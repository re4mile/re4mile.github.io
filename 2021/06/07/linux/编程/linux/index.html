<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>LinuxC语言 - re4mile</title>

  
    <meta name="description" content="文件系统ext文件描述符对应的file结构体 123456789101112131415161718192021222324565 struct file &amp;#123;566         struct list_head        f_list;&#x2F;&#x2F;打开的文件形成的链表,链表作用不多说567         struct dentry           *f_dentry;568">
<meta property="og:type" content="article">
<meta property="og:title" content="LinuxC语言">
<meta property="og:url" content="https://gitee.com/re4mile/re4mile.git/2021/06/07/linux/%E7%BC%96%E7%A8%8B/linux/index.html">
<meta property="og:site_name" content="re4mile">
<meta property="og:description" content="文件系统ext文件描述符对应的file结构体 123456789101112131415161718192021222324565 struct file &amp;#123;566         struct list_head        f_list;&#x2F;&#x2F;打开的文件形成的链表,链表作用不多说567         struct dentry           *f_dentry;568">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115405728.png">
<meta property="og:image" content="https://re4mile.gitee.io/res/photo/linux/image-20221110115434107.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115508570.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115529954.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115551419.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115612782.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110123208787.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110123233392.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110123356105.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110123621887.png">
<meta property="og:image" content="https://resmile.gitee.io/blog/sysC/image-20221110123704235.png">
<meta property="og:image" content="https://gitee.com/blog/sysC/image-20221128233335349.png">
<meta property="article:published_time" content="2021-06-07T01:00:00.000Z">
<meta property="article:modified_time" content="2022-12-29T09:46:24.076Z">
<meta property="article:author" content="邓渠香">
<meta property="article:tag" content="ELF">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://resmile.gitee.io/blog/sysC/image-20221110115405728.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/re4mile/css/main.css">

  

  
    <link rel="shortcut icon" href="https://s1.ax1x.com/2023/01/03/pSip2aF.png">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/re4mile/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://s1.ax1x.com/2022/12/21/zOXq9s.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/re4mile/"><div class="main" ff="title">re4mile</div><div class="sub cap">好记性不如烂笔头</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/re4mile/">文章</a><a class="nav-item" href="/re4mile/wiki/">项目</a><a class="nav-item" target="_blank" rel="noopener" href="https://re4mile.gitee.io/re4mile/wiki/关于我/">关于</a><a class="nav-item" target="_blank" rel="noopener" href="https://re4mile.gitee.io/re4mile/wiki/博客链接/">友链</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">LinuxC语言</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ext"><span class="toc-text">ext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-text">dup和dup2函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-text">导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-text">fork函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0"><span class="toc-text">exec函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%92%8Cwaitpid"><span class="toc-text">wait和waitpid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83IPC%E6%9C%BA%E5%88%B6"><span class="toc-text">其它IPC机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO"><span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B"><span class="toc-text">总结如下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">信号的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-text">产生信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="toc-text">阻塞信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-1"><span class="toc-text">导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">信号集操作函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7"><span class="toc-text">捕捉信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sa-handler"><span class="toc-text">sa_handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pause"><span class="toc-text">pause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sig-atomic-t%E7%B1%BB%E5%9E%8B%E4%B8%8Evolatile%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">sig_atomic_t类型与volatile限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8Esigsuspend%E5%87%BD%E6%95%B0"><span class="toc-text">竞态条件与sigsuspend函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ESIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-text">关于SIGCHLD信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-text">终端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Job%E6%8E%A7%E5%88%B6"><span class="toc-text">Job控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-2"><span class="toc-text">导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="toc-text">线程间同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-text">Mutex互斥体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition-Variable-%E6%9D%A1%E4%BB%B6%E4%BA%92%E6%96%A5"><span class="toc-text">Condition Variable 条件互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">Semaphore 信号量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%8A%82"><span class="toc-text">小节</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/re4mile/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/re4mile/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/re4mile/categories/Reverse/">Reverse</a></div><div id="post-meta">发布于&nbsp;<time datetime="2021-06-07T01:00:00.000Z">2021-06-07</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>LinuxC语言</span></h1>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="ext"><a href="#ext" class="headerlink" title="ext"></a>ext</h2><p>文件描述符对应的file结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">565</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="number">566</span>         <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">f_list</span>;</span><span class="comment">//打开的文件形成的链表,链表作用不多说</span></span><br><span class="line"><span class="number">567</span>         <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>           *<span class="title">f_dentry</span>;</span></span><br><span class="line"><span class="number">568</span>         <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>         *<span class="title">f_vfsmnt</span>;</span></span><br><span class="line"><span class="number">569</span>         <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>  *<span class="title">f_op</span>;</span></span><br><span class="line"><span class="number">570</span>         <span class="type">atomic_t</span>                f_count;<span class="comment">//引用计数</span></span><br><span class="line"><span class="number">571</span>         <span class="type">unsigned</span> <span class="type">int</span>            f_flags;<span class="comment">//打开文件时候指定的标识</span></span><br><span class="line"><span class="number">572</span>         <span class="type">mode_t</span>                  f_mode;<span class="comment">//文件的访问模式</span></span><br><span class="line"><span class="number">573</span>         <span class="type">loff_t</span>                  f_pos;<span class="comment">//目前文件的相对开头的偏移</span></span><br><span class="line"><span class="number">574</span>         <span class="type">unsigned</span> <span class="type">long</span>           f_reada, f_ramax, f_raend, f_ralen, f_rawin;</span><br><span class="line"><span class="number">575</span>         <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>      <span class="title">f_owner</span>;</span><span class="comment">//：记录一个进程ID</span></span><br><span class="line"><span class="number">576</span>         <span class="type">unsigned</span> <span class="type">int</span>            f_uid, f_gid;<span class="comment">//：记录用户ID,组ID</span></span><br><span class="line"><span class="number">577</span>         <span class="type">int</span>                     f_error;</span><br><span class="line"><span class="number">578</span> </span><br><span class="line"><span class="number">579</span>         <span class="type">size_t</span>                  f_maxcount;</span><br><span class="line"><span class="number">580</span>         <span class="type">unsigned</span> <span class="type">long</span>           f_version;</span><br><span class="line"><span class="number">581</span> </span><br><span class="line"><span class="number">582</span>         <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line"><span class="number">583</span>         <span class="type">void</span>                    *private_data;</span><br><span class="line"><span class="number">584</span> </span><br><span class="line"><span class="number">585</span>         <span class="comment">/* preallocated helper kiobuf to speedup O_DIRECT */</span></span><br><span class="line"><span class="number">586</span>         <span class="class"><span class="keyword">struct</span> <span class="title">kiobuf</span>           *<span class="title">f_iobuf</span>;</span></span><br><span class="line"><span class="number">587</span>         <span class="type">long</span>                    f_iobuf_lock;</span><br><span class="line"><span class="number">588</span> &#125;;</span><br></pre></td></tr></table></figure>



<p>在file结构体中维护文件状态 Flag（file结构体的成员f_flags）</p>
<p>当前读写位置（file结构体的成员f_pos)</p>
<p>比较重要的成员还有f_count，表示引用计数（Reference Count）</p>
<p>后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体</p>
<p>例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，</p>
<p>当close(fd1)时并不会释放file结构体，而只是把引用计数减到1</p>
<p>如果再close(fd2)，引用计数就会减到0同时释放file结构体，</p>
<p>这才真的关闭了文件</p>
<p>每个file结构体都指向一个file_operations结构体</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110115405728.png" alt="image-20221110115405728"></p>
<p>这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数</p>
<p>比如在用户程序中read一个文件描述符，read通过系统调用进入内核，</p>
<p>然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，</p>
<p>调用它的read成员所指向的内核函数以完成用户请求。</p>
<p>在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的</p>
<p>各成员所指向的内核函数完成用户请求。</p>
<p>file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close</p>
<p>是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件</p>
<p>每个file结构体都有一个指向dentry结构体的指针dentry是directory entry（目录项）的缩写</p>
<p>我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PATH 1024</span></span><br><span class="line"><span class="comment">/* dirwalk: apply fcn to all files in dir */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dirwalk</span><span class="params">(<span class="type">char</span> *dir, <span class="type">void</span> (*fcn)(<span class="type">char</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[MAX_PATH];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">	DIR *dfd;</span><br><span class="line">	<span class="keyword">if</span> ((dfd = opendir(dir)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: can&#x27;t open%s\n&quot;</span>, dir);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((dp = readdir(dfd)) != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>|| <span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* skip self and parent */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strlen</span>(dir)+<span class="built_in">strlen</span>(dp-&gt;d_name)+<span class="number">2</span> &gt;<span class="keyword">sizeof</span>(name))</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: name %s %s too long\n&quot;</span>,dir, dp-&gt;d_name);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(name, <span class="string">&quot;%s/%s&quot;</span>, dir, dp-&gt;d_name);(*fcn)(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fsize: print the size and name of file &quot;name&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fsize</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (stat(name, &amp;stbuf) == <span class="number">-1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fsize: can&#x27;t access%s\n&quot;</span>, name);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">		dirwalk(name, fsize);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%8ld %s\n&quot;</span>, stbuf.st_size, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>a</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">1</span>) <span class="comment">/* default: current directory*/</span></span><br><span class="line">		fsize(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span> (--argc &gt; <span class="number">0</span>)</span><br><span class="line">			fsize(*++argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dqx@resmile<span class="number">-2</span>:/mnt/f/<span class="number">0xC0de</span>/elf/C$ ./q.elf</span><br><span class="line">   <span class="number">12288</span> ./.q.c.swp</span><br><span class="line">     <span class="number">122</span> ./makefile</span><br><span class="line">    <span class="number">1223</span> ./q.c</span><br><span class="line">   <span class="number">17168</span> ./q.elf</span><br><span class="line">    <span class="number">3256</span> ./q.o</span><br><span class="line">       <span class="number">0</span> ./q.txt</span><br><span class="line">     <span class="number">512</span> .</span><br><span class="line">dqx@resmile<span class="number">-2</span>:/mnt/f/<span class="number">0xC0de</span>/elf/C$</span><br></pre></td></tr></table></figure>



<h2 id="dup和dup2函数"><a href="#dup和dup2函数" class="headerlink" title="dup和dup2函数"></a>dup和dup2函数</h2><p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/1337e6e77d2f402b851f86795b32b0ad">https://blog.nowcoder.net/n/1337e6e77d2f402b851f86795b32b0ad</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/silent123go/article/details/71108501">https://blog.csdn.net/silent123go/article/details/71108501</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line">oldfd: 原来的文件描述符</span><br><span class="line">newfd：复制成的新的文件描述符</span><br><span class="line"></span><br><span class="line">成功：将oldfd复制一份然后给newfd, 两个文件描述符指向oldfd</span><br><span class="line">失败：返回<span class="number">-1</span>, 设置errno值</span><br><span class="line">它的意思是将oldfd重定向至newfd</span><br></pre></td></tr></table></figure>

<p>dup和dup2都可用来复制一个现存的文件描述符，使两个文件描述符指向同一个file结构体。</p>
<p>如果两个文件描述符指向同一个file结构体，读写位置只保存一份在file结构体中，并且file结构体的引用计数是2</p>
<p>当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。<br>dup2和dup的区别就是可以用newfd参数指定新描述符的数值，</p>
<p>如果newfd已经打开，则先将其关闭。</p>
<p>如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。</p>
<p>dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> fd, fd_tmp;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;This is a test\n&quot;</span>;</span><br><span class="line">        fd = open(<span class="string">&quot;somefile&quot;</span>, O_RDWR|O_CREAT,S_IRUSR|S_IWUSR);</span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fd_tmp = dup(STDOUT_FILENO); 				<span class="comment">//stdout=&#123;tmp,1&#125; ,file=&#123;fd&#125;</span></span><br><span class="line">        dup2(fd, STDOUT_FILENO); 					<span class="comment">//stdout=&#123;tmp&#125; ,file=&#123;fd,1&#125;</span></span><br><span class="line">        close(fd); 									<span class="comment">//stdout=&#123;tmp&#125; ,file=&#123;1&#125;</span></span><br><span class="line">        write(STDOUT_FILENO, msg, <span class="built_in">strlen</span>(msg)); 	<span class="comment">//往1==文件里面写入</span></span><br><span class="line">        dup2(fd_tmp, STDOUT_FILENO); 				<span class="comment">//stdout=&#123;tmp,1&#125; ,file=&#123;&#125;</span></span><br><span class="line">        write(STDOUT_FILENO, msg, <span class="built_in">strlen</span>(msg));		<span class="comment">//往终端输出</span></span><br><span class="line">        close(fd_tmp);								<span class="comment">//stdout=&#123;1&#125; ,file=&#123;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ext文件系统主要介绍了的文件描述符对应的file结构体,然后简单提及类其中几个重要的成员</p>
<p>dup&#x2F;dup2主要讲了一个文件描述符号的复制,也就是备份了一个,file结构体的引用计数++</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息</p>
<p>Linux内核的进程控制块是task_struct结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;  <span class="comment">//说明了该进程是否可以执行,还是可中断等信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;  <span class="comment">//Flage 是进程号,在调用fork()时给出</span></span><br><span class="line">    <span class="type">int</span> sigpending;    <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit; <span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">                            <span class="comment">//0-0xBFFFFFFF for user-thead</span></span><br><span class="line">                            <span class="comment">//0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line">    <span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> need_resched;</span><br><span class="line">    <span class="type">int</span> lock_depth;  <span class="comment">//锁深度</span></span><br><span class="line">    <span class="type">long</span> nice;       <span class="comment">//进程的基本时间片</span></span><br><span class="line">    <span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> policy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">//进程内存管理信息</span></span><br><span class="line">    <span class="type">int</span> processor;</span><br><span class="line">    <span class="comment">//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpus_runnable, cpus_allowed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span> <span class="comment">//指向运行队列的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sleep_time;  <span class="comment">//进程的睡眠时间</span></span><br><span class="line">    <span class="comment">//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span>       <span class="comment">//指向本地页面      </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocation_order, nr_local_pages;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span>  <span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">    <span class="type">int</span> pdeath_signal;     <span class="comment">//父进程终止时向子进程发送的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">    <span class="comment">//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序</span></span><br><span class="line">    <span class="type">int</span> did_exec:<span class="number">1</span>; </span><br><span class="line">    <span class="type">pid_t</span> pid;    <span class="comment">//进程标识符,用来代表一个进程,一个非负整数</span></span><br><span class="line">    <span class="type">pid_t</span> pgrp;   <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">    <span class="type">pid_t</span> tty_old_pgrp;  <span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">    <span class="type">pid_t</span> session;  <span class="comment">//进程的会话标识</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;</span><br><span class="line">    <span class="type">int</span> leader;     <span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>,*<span class="title">p_pptr</span>,*<span class="title">p_cptr</span>,*<span class="title">p_ysptr</span>,*<span class="title">p_osptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span>   <span class="comment">//线程链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span> <span class="comment">//用于将进程链入HASH表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">pidhash_pprev</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait_chldexit;  <span class="comment">//供wait4()使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>  <span class="comment">//供vfork() 使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rt_priority; <span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value</span></span><br><span class="line">    <span class="comment">//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line">    <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line">    <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送</span></span><br><span class="line">    <span class="comment">//信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">    <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line">    <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据</span></span><br><span class="line">    <span class="comment">//it_virt_incr重置初值。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span>   <span class="comment">//指向实时定时器的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span>      <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;  <span class="comment">//进程创建的时间</span></span><br><span class="line">    <span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">    <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; </span><br><span class="line">    <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line">    <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line">    <span class="comment">//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">    <span class="comment">//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line">    <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">    <span class="type">int</span> swappable:<span class="number">1</span>; <span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">    <span class="comment">//进程认证信息</span></span><br><span class="line">    <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid</span></span><br><span class="line">    <span class="comment">//euid，egid为有效uid,gid</span></span><br><span class="line">    <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件</span></span><br><span class="line">    <span class="comment">//系统的访问权限时使用他们。</span></span><br><span class="line">    <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">    <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">    <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">    <span class="type">int</span> ngroups; <span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">    <span class="type">gid_t</span> groups[NGROUPS]; <span class="comment">//记录进程所在的组</span></span><br><span class="line">    <span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line">    <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>  <span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math;   <span class="comment">//是否使用FPU</span></span><br><span class="line">    <span class="type">char</span> comm[<span class="number">16</span>];   <span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">     <span class="comment">//文件系统信息</span></span><br><span class="line">    <span class="type">int</span> link_count, total_link_count;</span><br><span class="line">    <span class="comment">//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> locks;</span><br><span class="line">    <span class="comment">//进程间通信信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span>  <span class="comment">//进程在信号灯上的所有undo操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span> <span class="comment">//当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">    <span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">      <span class="comment">//文件系统信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line">      <span class="comment">//打开文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">      <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">spinlock_t</span> sigmask_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span> <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;  <span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span>  <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">    <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">    <span class="type">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">    <span class="type">void</span> *notifier_data;</span><br><span class="line">    <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">    u32 parent_exec_id;</span><br><span class="line">    u32 self_exec_id;</span><br><span class="line">     </span><br><span class="line">    <span class="type">spinlock_t</span> alloc_lock;</span><br><span class="line">    <span class="type">void</span> *journal_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>fork的作用是根据一个现有的进程复制出一个新进程，</p>
<p>原来的进程称为父进程（Parent Process），</p>
<p>新进程称为子进程（ChildProcess)</p>
<p>在Shell下输入命令可以运行一个程序，是因为Shell进程在读取用户输入的命令之后会</p>
<p>调用fork复制出一个新的Shell进程，然后新的Shell进程调用exec执行新的程序</p>
<p>exec系统调用执行新程序时会把命令行参数和环境变量表传递给main函数</p>
<p>和命令行参数argv类似，环境变量表也是一组字符串</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://re4mile.gitee.io/res/photo/linux/image-20221110115434107.png" alt="image-20221110115434107"></p>
<p>打印环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; environ[i]!=<span class="literal">NULL</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父进程在调用fork创建子进程时会把自己的环境变量表也复制给子进程，</p>
<p>所以a.out打印的环境变量和Shell进程的环境变量是相同的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dqx@dqx:/mnt/f/<span class="number">0xC0de</span>/elf/C$ ./q.elf</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">WSL_DISTRO_NAME=Debian</span><br><span class="line">WT_SESSION=<span class="number">8546</span>ea82<span class="number">-2f</span>08<span class="number">-4619</span><span class="number">-955</span>e-ad9e217bac0e</span><br><span class="line">NAME=resmile<span class="number">-2</span></span><br><span class="line">PWD=/mnt/f/<span class="number">0xC0de</span>/elf/C</span><br><span class="line">LOGNAME=dqx</span><br><span class="line">HOME=/home/dqx</span><br><span class="line">LANG=en_US.UTF<span class="number">-8</span></span><br><span class="line">WSL_INTEROP=/run/WSL/<span class="number">14</span>_interop</span><br></pre></td></tr></table></figure>





<p>getenv函数查看环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>getenv的返回值是指向value的指针，若未找到则为NULL</p>
<p>修改环境变量可以用以下函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> rewrite)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>putenv和setenv函数若成功则返回为0，若出错则返回非0</p>
<p>etenv将环境变量name的值设置为value。如果已存在环境变量name，</p>
<p>那么</p>
<p>若rewrite非0，则覆盖原来的定义；</p>
<p>若rewrite为0，则不覆盖原来的定义，也不返回错误。</p>
<p>unsetenv删除name的定义。即使name没有定义也不返回错误</p>
<p>修改环境变量,运行不是很成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH=%s\n&quot;</span>, getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    setenv(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH=%s\n&quot;</span>, getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shell进程的环境变量PATH传给了a.out，</p>
<p>然后a.out修改了PATH的值，在a.out中能打印出修改后的值，</p>
<p>但在Shell进程中PATH的值没变。</p>
<p>父进程在创建子进程时会复制一份环境变量给子进程，</p>
<p>但此后二者的环境变量互不影响</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>fork调用失败则返回-1，调用成功的返回值见下面的解释。我们通过一个例子来理解fork是怎样创建新进程的</p>
<p>fork会产生一个进程</p>
<p>复制一份自己,产生一份新的自己.原来的自己依然存在</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> *message=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">//child</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;C-0 %08X\n&quot;</span>,getpid());</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;C-0 %08X\n&quot;</span>,getpid());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//0</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;C-C %08X\n&quot;</span>,getpid());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// pid&gt;0 father</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;F-0 %08X\n&quot;</span>,getpid());</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;F-0 %08X\n&quot;</span>,getpid());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;F-C %08X\n&quot;</span>,getpid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dqx@resmile-<span class="number">2</span>:/mnt/f/<span class="number">0</span>xC0de/elf/C$ ./q</span><br><span class="line">F-<span class="number">0</span> <span class="number">00000090</span></span><br><span class="line">C-<span class="number">0</span> <span class="number">00000091</span></span><br><span class="line">F-<span class="number">0</span> <span class="number">00000090</span></span><br><span class="line">F-C <span class="number">00000092</span></span><br><span class="line">C-<span class="number">0</span> <span class="number">00000091</span></span><br><span class="line">C-C <span class="number">00000093</span></span><br><span class="line">dqx@resmile-<span class="number">2</span>:/mnt/f/<span class="number">0</span>xC0de/elf/C$</span><br></pre></td></tr></table></figure>



<p>这个程序是在Shell下运行的，因此Shell进程是父进程的父进程。</p>
<p>父进程运行时Shell进程处于等待状态，当父进程终止时Shell进程认为命令执行结束了，于是打印Shell提示符，</p>
<p>而事实上子进程这时还没结束，所以子进程的消息打印到了Shell提示符后面。</p>
<p>最后光标停在This is the child的下一行，这时用户仍然可以敲命令，</p>
<p>即使命令不是紧跟在提示符后面，Shell也能正确读取</p>
<p>子进程中fork的返回值是0，而父进程中fork的返回值则是子进程的id</p>
<p>这样当fork函数返回后，程序员可以根据返回值的不同让父进程和子进程执行不同的代码</p>
<p>调用getppid函数得到父进程的id</p>
<p>用getpid可以得到自己的进程id</p>
<h3 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h3><p>fork创建子进程 相当于复制,但有可能执行不同的代码分支</p>
<p>exec可能类似于创造一个不同的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> ps_argv[] =&#123;<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-o&quot;</span>,<span class="string">&quot;pid,ppid,pgrp,session,tpgid,comm&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> ps_envp[] =&#123;<span class="string">&quot;PATH=/bin:/usr/bin&quot;</span>, <span class="string">&quot;TERM=console&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;pid,ppid,pgrp,session,tpgid,comm&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">execle(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;pid,ppid,pgrp,session,tpgid,comm&quot;</span>,<span class="literal">NULL</span>, ps_envp);</span><br><span class="line"></span><br><span class="line">execv(<span class="string">&quot;/bin/ps&quot;</span>, ps_argv);</span><br><span class="line">execve(<span class="string">&quot;/bin/ps&quot;</span>, ps_argv, ps_envp);</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;pid,ppid,pgrp,session,tpgid,comm&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">execvp(<span class="string">&quot;ps&quot;</span>, ps_argv);</span><br></pre></td></tr></table></figure>

<p>这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回</p>
<p>如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值</p>
<p>不带字母p（表示path）的exec函数第一个参数必须是程序的相对路径或绝对路径</p>
<p>对于带字母p的函数,</p>
<p>如果参数中包含&#x2F;，则将其视为路径名</p>
<p>否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。</p>
<p>带有字母l（表示list）的exec函数要求将新程序的每个命令行参数都当作一个参数传给它，</p>
<p>命令行参数的个数是可变的，因此函数原型中有…,最后一个可变参数应该是NULL</p>
<p>对于带有字母v（表示vector）的函数，则应该先构造一个指向各参数的指针数组，</p>
<p>然后将该数组的首地址当作参数传给它，数组中的最后一个指针也应该是NULL，</p>
<p>就像main函数的argv参数或者环境变量表一样</p>
<p>对于以e（表示environment）结尾的exec函数，可以把一份新的环境变量表传给它，</p>
<p>其他exec函数仍使用当前的环境变量表执行新程序</p>
<p>只有execve是真正的系统调用，其它五个函数最终都调用execve</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110115508570.png" alt="image-20221110115508570"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-o&quot;</span>,<span class="string">&quot;pid,ppid,pgrp,session,tpgid,comm&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	perror(<span class="string">&quot;exec ps&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>显示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  PID    PPID    PGRP    SESS   TPGID COMMAND</span><br><span class="line"><span class="number">19205</span>   <span class="number">17176</span>   <span class="number">19205</span>   <span class="number">19205</span>   <span class="number">20817</span> bash</span><br><span class="line"><span class="number">20817</span>   <span class="number">19205</span>   <span class="number">20817</span>   <span class="number">19205</span>   <span class="number">20817</span> ps</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* wrapper.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">&quot;usage: wrapper file\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	dup2(fd, STDIN_FILENO);</span><br><span class="line">	close(fd);</span><br><span class="line">	execl(<span class="string">&quot;./upper.elf&quot;</span>, <span class="string">&quot;upper.elf&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	perror(<span class="string">&quot;exec ./upper.elf&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入 .&#x2F;q.elf hello.txt</p>
<p>显示 DQX IS A GOD BOY,但是文本内容不变</p>
<h3 id="wait和waitpid"><a href="#wait和waitpid" class="headerlink" title="wait和waitpid"></a>wait和waitpid</h3><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，</p>
<p>但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，</p>
<p>如果是异常终止则保存着导致该进程终止的信号是哪个。</p>
<p>这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p>
<p>我们知道一个进程的退出状态可以在Shell中用特殊变量$?</p>
<p>查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态</p>
<p>同时彻底清除掉这个进程。</p>
<p>如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理</p>
<p>这时的进程状态称为僵尸（Zombie）进程。</p>
<p>任何进程在刚终止时都是僵尸进程，正常情况下，</p>
<p>僵尸进程都立刻被父进程清理了，为了观察到僵尸进程，</p>
<p>我们自己写一个不正常的程序，父进程fork出子进程，子进程终止，而父进程既不终止也不调用wait清理子进程</p>
<p>僵尸进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;	</span><br><span class="line">	<span class="type">pid_t</span> pid=fork();</span><br><span class="line">	x=getpid();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;F %08d\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;S %08d&quot;</span>,x);</span><br><span class="line">	<span class="comment">/* child */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./q.elf &amp; 表示elf在后台执行,不显示到前台</span><br><span class="line">ps u 显示执行的程序</span><br></pre></td></tr></table></figure>



<p>前台运行一下</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110115529954.png" alt="image-20221110115529954"></p>
<p>开放另外一个终端,</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110115551419.png" alt="image-20221110115551419"></p>
<p>父进程存在,子进程死亡,父进程没有清理子进程,子进程此刻叫僵尸进程ps:僵尸进程就是没有死透彻的进程</p>
<p>也就是子进程先死,未做特殊处理,父进程不会清理子进程</p>
<p>在父进程未退出的情况下,始终会有父进程和僵尸子进程存在</p>
<p>利用ps u 查看僵尸进程.他的STAT是Z状态</p>
<p>如果父进程先死(进程号消失的那种死亡), 子进程还存在(可能是僵尸进程), </p>
<p>即使父进程没有清理子进程,父进程也会变为init进程,进程id是1,然后父进程等待子进程结束,然后清理</p>
<p>僵尸进程是不能用kill命令清除掉的，因为kill命令只是用来终止进程的，</p>
<p>而僵尸进程已经终止了</p>
<p>接下来避免僵尸进程</p>
<p>wait和waitpid函数的原型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>



<p>父进程调用wait或waitpid时可能会：</p>
<ul>
<li>阻塞（如果它的所有子进程都还在运行）</li>
<li>带子进程的终止信息立即返回（如果一个子进程已终止，正等待父进程读取其终止信息)</li>
<li>出错立即返回（如果它没有任何子进程）</li>
</ul>
<p>这两个函数的区别是：</p>
<ul>
<li>如果父进程的所有子进程都还在运行，调用wait将使父进程阻塞，而调用waitpid时如果在options参数中</li>
</ul>
<p>指定WNOHANG可以使父进程不阻塞而立即返回0。</p>
<ul>
<li>wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程</li>
</ul>
<p>可见，调用wait和waitpid不仅可以获得子进程的终止信息，还可以使父进程阻塞等待子进程终</p>
<p>止，起到进程间同步的作用。如果参数status不是空指针，则子进程的终止信息通过这个参数</p>
<p>传出，如果只是为了同步而不关心子进程的终止信息，可以将status参数指定为NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">//son</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;This is the child\n&quot;</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//father</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> stat_val;</span><br><span class="line">		waitpid(pid, &amp;stat_val, <span class="number">0</span>);<span class="comment">//父进程等待子进程,输出信息到stat_val</span></span><br><span class="line">		<span class="keyword">if</span> (WIFEXITED(stat_val))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Child exited with code%d\n&quot;</span>, WEXITSTATUS(stat_val));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(stat_val))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Child terminated abnormally, signal %d\n&quot;</span>, WTERMSIG(stat_val));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dqx@dqx-virtual-machine:~/桌面/C/q1$ ./q.elf </span><br><span class="line">This is the child</span><br><span class="line">This is the child</span><br><span class="line">This is the child</span><br><span class="line">Child exited with code3</span><br><span class="line">dqx@dqx-virtual-machine:~/桌面/C/q1$ </span><br></pre></td></tr></table></figure>

<p>可以看到,main函数被阻塞了</p>
<p>子进程的终止信息在一个int中包含了多个字段，用宏定义可以取出其中的每个字段：</p>
<p>如果子进程是正常终止的，</p>
<p>WIFEXITED取出的字段值非零，WEXITSTATUS取出的字段值就是子进程的退出状态；</p>
<p>如果子进程是收到信号而异常终止的，</p>
<p>WIFSIGNALED取出的字段值非零，WTERMSIG取出的字段值就是信号的编号</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>（IPC:InterProcess Communication）</p>
<p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，</p>
<p>所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，</p>
<p>进程1把数据从用户空间拷到内核缓冲区，</p>
<p>进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110115612782.png" alt="image-20221110115612782"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>



<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，</p>
<p>它有一个读端一个写端，</p>
<p>然后通过filedes参数传出给用户程序两个文件描述符，</p>
<p>filedes[0]指向管道的读端，</p>
<p>filedes[1]指向管道的写端</p>
<p>记忆方式就是读取和写入</p>
<p>所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);</p>
<p>向这个文件读写数据其实是在读写内核缓冲区。</p>
<p>pipe函数调用成功返回0，调用失败返回-1。</p>
<p>开辟了管道之后如何实现两个进程间的通信呢？</p>
<p>比如可以按下面的步骤通信</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110123208787.png" alt="image-20221110123208787"></p>
<ol>
<li>父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道<br>里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信</li>
</ol>
<p>ps: 我读的时候,你只能写?我写,你只能读取?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) <span class="comment">// open pipe</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) <span class="comment">//begin fork</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">	&#123; </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Father Begin Read&quot;</span>);</span><br><span class="line">		close(fd[<span class="number">1</span>]);<span class="comment">//close write begin read</span></span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);<span class="comment">//貌似这里会有阻塞 </span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Father Read Down&quot;</span>);</span><br><span class="line">		write(STDOUT_FILENO, line, n);<span class="comment">//write to stdout</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* child */</span></span><br><span class="line">	&#123; </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Child Begin Write&quot;</span>);</span><br><span class="line">		close(fd[<span class="number">0</span>]);<span class="comment">//clsoe read,begin write</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Child Write Down&quot;</span>);</span><br><span class="line">		<span class="comment">//wait(NULL);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用管道有一些限制</p>
<p>1). 	两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读</p>
<p>2). 	管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖</p>
<p>先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程</p>
<p>之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间</p>
<p>通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。</p>
<p>不是随随便便一个fd就可以,fd必须来自相同的pipe(fd)经过注册</p>
<p>下面这个子进程之间的管道访问，不知道有没有写对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) <span class="comment">// open pipe</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="comment">//  fork wrong</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">	&#123; </span><br><span class="line">		pid=fork();<span class="comment">//又创建一个??</span></span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//child-2</span></span><br><span class="line">		&#123;</span><br><span class="line">			close(fd[<span class="number">0</span>]);<span class="comment">//clsoe read,begin write</span></span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Write Down&quot;</span>); </span><br><span class="line">			write(fd[<span class="number">1</span>], <span class="string">&quot;pipe:hello world\n&quot;</span>, <span class="number">17</span>);			</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//father </span></span><br><span class="line">		&#123;		</span><br><span class="line">			wait(<span class="literal">NULL</span>);<span class="comment">//得等待另外一个写进程完毕吗? </span></span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Last over&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* child-1 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		close(fd[<span class="number">1</span>]);<span class="comment">//close write begin read</span></span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Read Down&quot;</span>); </span><br><span class="line">		write(STDOUT_FILENO, line, n);<span class="comment">//write to stdout</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dqx@D0g3:~/桌面/C$ ./q.elf</span><br><span class="line">Write Down</span><br><span class="line">Read Down</span><br><span class="line">pipe:hello world</span><br><span class="line">Last over</span><br><span class="line">dqx@D0g3:~/桌面/C$ </span><br></pre></td></tr></table></figure>

<p>感觉还行</p>
<p>使用管道需要注意以下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</p>
<ol>
<li>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有<br>进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像<br>读到文件末尾一样。</li>
<li>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写<br>端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据<br>都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进<br>程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。<br>在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。</li>
<li>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读<br>端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再<br>次write会阻塞，直到管道中有空位置了才写入数据并返回。<br>管道的这四种特殊情况具有普遍意义。在第 37 章 socket编程要讲的TCP socket也具有管道的<br>这些特性</li>
</ol>
<h3 id="其它IPC机制"><a href="#其它IPC机制" class="headerlink" title="其它IPC机制"></a>其它IPC机制</h3><p>进程间通信必须通过内核提供的通道，如果要互相通信的几个进程没有从公共祖先那里继承文件描述符，</p>
<p>它们怎么通信呢？</p>
<p>内核提供一条通道简单，问题是如何标识这条通道才能使各进程都可以访问它？</p>
<p>文件系统中的路径名是全局的，各进程都可以访问，</p>
<p>因此可以用文件系统中的路径名来标识一个IPC通道。</p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>可以用mkfifo命令创建一个FIFO文件</p>
<p>各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道实现了进程间通信，实现了进程间通信</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Socket是目前最广泛,使用的IPC机制，到后面讲socket编程时再详细介绍</p>
<p>Socket和FIFO的原理类似，也需要一个特殊的socket文件来标识内核中的通道，</p>
<p>例如&#x2F;var&#x2F;run目录下有很多系统服务的socket文件</p>
<h2 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h2><p>导入部分,主要讲了进程块结构体的东西</p>
<p>进程控制主要讲了fork和exec,fork是继承形的复制进程,exec是完全新的开辟一个进程</p>
<p>进程之间的通信主要讲了pipi的管道,其它的没有过多的去讲</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>Ctrl-C产生SIGINT终止信号</p>
<p>Ctrl-\产生SIGQUIT信号,终止进程并且CoreDump</p>
<p>Ctrl-Z产生SIGTSTP信号,可使前台进程停止</p>
<h2 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110123233392.png" alt="image-20221110123233392"></p>
<p>每个信号都有一个编号和一个宏定义名称，这些宏定义可以在signal.h中找到</p>
<p>编号34以上的是实时信号，本章只讨论编号34以下的信号，不讨论实时信号</p>
<p>产生信号的条件主要有</p>
<ul>
<li>用户在终端按下某些键时(人为物理发送)</li>
<li>比如除以0的指令,访问了非法内存地址(内部异常)</li>
<li>一个进程调用kill函数可以发送信号给另一个进程(函数调用)</li>
<li>可以用kill命令发送信号给某个进程，如果不明确指定信号则发送SIGTERM信号，默认处理动作是终止进程。</li>
</ul>
<p>指令调用</p>
<ul>
<li>例如闹钟超时产生SIGALRM信号，向读端已关闭的管道写数据时产生SIGPIPE信号(函数浅调用)</li>
</ul>
<p>如果不想按默认动作处理信号，用户程序可以调用sigaction函数告诉内核如何处理某种信号</p>
<p>可选的处理动作有以下三种：</p>
<ol>
<li>忽略此信号。</li>
<li>执行该信号的默认处理动作。</li>
<li>提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种<br>方式称为捕捉（Catch）一个信号。</li>
</ol>
<h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><p>1).通过终端按键产生信号</p>
<p>2). 调用系统函数向进程发信号</p>
<p>kill命令是调用kill函数实现的。</p>
<p>kill函数可以给一个指定的进程发送指定的信号。raise函数可以给当前进程发送指定的信号</p>
<p>(自己给自己发信号)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）<span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">　　功能：信号发送</span><br><span class="line">　　参数：pid：指定进程</span><br><span class="line">　　sig：要发送的信号</span><br><span class="line">　　返回值：成功 <span class="number">0</span>；失败 <span class="number">-1</span></span><br><span class="line">      </span><br><span class="line"><span class="number">2</span>）<span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">　　功能：进程向自己发送信号</span><br><span class="line">　　参数：sig：信号</span><br><span class="line">　　返回值：成功 <span class="number">0</span>；失败 <span class="number">-1</span>  </span><br><span class="line">      </span><br><span class="line"><span class="number">3</span>）<span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">　　功能：在进程中设置一个定时器</span><br><span class="line">　　参数：seconds：定时时间，单位为秒</span><br><span class="line">　　返回值：如果调用此<span class="title function_">alarm</span><span class="params">()</span>前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</span><br><span class="line">	注意：一个进程只能有一个闹钟时间。如果在调用alarm时已设置过闹钟时间，则之前的闹钟时间被新值所代替   </span><br><span class="line">      </span><br><span class="line">4）<span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">　　功能：用于将调用进程挂起直到收到信号为止。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）<span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line">　　或者：</span><br><span class="line">　　<span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">　　<span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">　　功能：信号处理函数</span><br><span class="line">　　参数：signum：要处理的信号<span class="comment">//不能是SIGKILL和SIGSTOP</span></span><br><span class="line">　　　　handler：SIG_IGN：忽略该信号。</span><br><span class="line">　　　　SIG_DFL：采用系统默认方式处理信号。</span><br><span class="line">　　　　自定义的信号处理函数指针</span><br><span class="line">　　返回值：成功：设置之前的信号处理方式；失败：SIG_ERR</span><br><span class="line"></span><br><span class="line"> <span class="number">6</span>）<span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">　　给自己发送异常终止信号，（<span class="number">6.</span>SIGABRO）终止并产生core文件。      </span><br></pre></td></tr></table></figure>

<p>这两个函数都是成功返回0，错误返回-1。</p>
<p>abort函数使当前进程接收到SIGABRT信号而异常终止</p>
<p>就像exit函数一样，abort函数总是会成功的，所以没有返回值。</p>
<p>3).函数的浅调用</p>
<p>SIGPIPE是一种由软件条件产生的信号， </p>
<p>本节主要介绍alarm函数和SIGALRM信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>调用alarm函数可以设定一个闹钟，也就是告诉内核在seconds秒之后给当前进程发SIGALRM信号，</p>
<p>该信号的默认处理动作是终止当前进程。</p>
<p>这个函数的返回值是0或者是以前设定的闹钟时间还余下的秒数。</p>
<p>打个比方，某人要小睡一觉，设定闹钟为30分钟之后响</p>
<p>20分钟后被人吵醒了，还想多睡一会儿，于是重新设定闹钟为15分钟之后响，</p>
<p>以前设定的闹钟时间还余下的时间就是10分钟。</p>
<p>如果seconds值为0，表示取消以前设定的闹钟</p>
<p>函数的返回值仍然是以前设定的闹钟时间还余下的秒数</p>
<p>下面这个例子看elf在1s种可以数数多少下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">	alarm(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(counter=<span class="number">0</span>; <span class="number">1</span>; counter++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;counter=%d\n&quot;</span>, counter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><p>以上我们讨论了信号产生（Generation）的各种原因，</p>
<p>而实际执行信号的处理动作称为信号递达（Delivery），</p>
<p>信号从产生到递达之间的传递状态称为信号未决（Pending）。</p>
<p>进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态，</p>
<p>直到进程解除对此信号的阻塞，才执行递达的动作。</p>
<p>注意，阻塞和忽略是不同的，</p>
<p>只要信号被阻塞就不会递达，</p>
<p>而忽略是在递达之后可选的一种处理动作。</p>
<p>每个信号都有两个标志位分别表示阻塞和未决，还有一个函数指针表示处理动作。</p>
<p>信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110123356105.png" alt="image-20221110123356105"></p>
<ol>
<li>SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。</li>
<li>SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在<br>没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。</li>
<li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函<br>数sighandler</li>
</ol>
<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>未决和阻塞标志可以用相同的数据类型sigset_t来存储sigset_t称为信号集，</p>
<p>这个类型可以表示每个信号的“有效”或“无效”状态，</p>
<p>在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞，</p>
<p>而在未决信号集中“有效”和“无效”的含义是该信号是否处于未决状态。</p>
<p>gset_t类型对于每种信号用一个bit表示“有效”或“无效”状态，</p>
<p>至于这个类型内部如何存储这些bit则依赖于系统实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure>



<p>函数sigemptyset初始化set所指向的信号集，使其中所有信号的对应bit清零，</p>
<p>表示该信号集不包含任何有效信号。</p>
<p>函数sigfillset初始化set所指向的信号集，使其中所有信号的对应bit置位，</p>
<p>表示该信号集的有效信号包括系统支持的所有信号。</p>
<p>注意，在使用sigset_t类型的变量之前，一定要调用sigemptyset或sigfillset做初始化，</p>
<p>使信号集处于确定的状态。</p>
<p>初始化sigset_t变量之后就可以在调用sigaddset和sigdelset在该信号集中</p>
<p>添加或删除某种有效信号。这四个函数都是成功返回0，出错返回-1。</p>
<p>sigismember是一个布尔函数，用于判断一个信号集的有效信号中是否包含某种信号，</p>
<p>若包含则返回1，不包含则返回0，出错返回-1。</p>
<p>sigpending</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>sigpending读取当前进程的未决信号集，通过set参数传出。调用成功则返回0，出错则返回-1</p>
<p>.</p>
<p>调用函数sigprocmask可以读取或更改进程的信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oset)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：若成功则为0，若出错则为-1</p>
<p>如果oset是非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。</p>
<p>如果set是非空指针，则更改进程的信号屏蔽字，set,指向来一系列的00101010的集合</p>
<p>参数how指示如何更改。如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset里，</p>
<p>然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask，</p>
<p>下表说明了how参数的可选值</p>
<p>mask就是那个信号的01集合</p>
<p>set是我们往空信号集里面添加的信号</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110123621887.png" alt="image-20221110123621887"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printsigset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (sigismember(<span class="built_in">set</span>, i) == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);<span class="comment">//当前位有效，返回1</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//当前位无效，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span> s, p;<span class="comment">//变量的创建</span></span><br><span class="line">	sigemptyset(&amp;s);<span class="comment">//置空</span></span><br><span class="line">	sigaddset(&amp;s, SIGINT);<span class="comment">//添加一个信号</span></span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;s, <span class="literal">NULL</span>);<span class="comment">//把信号做成集合</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sigpending(&amp;p);<span class="comment">//读取当前进程未决信号集，通过p参数传出</span></span><br><span class="line">		printsigset(&amp;p);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行时，每秒钟把各信号的未决状态打印一遍，</p>
<p>由于我们阻塞了SIGINT信号，按Ctrl-C将会使SIGINT信号处于未决状态，</p>
<p>按Ctrl-\仍然可以终止程序，因为SIGQUIT信号没有阻塞</p>
<h2 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h2><p>内核如何实现信号的捕捉?</p>
<p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号</p>
<p>1).  用户程序注册了SIGQUIT信号的处理函数sighandler</p>
<p>2). 在执行main函数时，发生中断或异常切换到内核态</p>
<p>3). 在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达</p>
<p>4). 内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函</p>
<p>数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，</p>
<p>是两个独立的控制流程</p>
<p>5). sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态</p>
<p>6). 如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行</p>
<p>就上面的流程,首先不是很懂,但是其中有些点需要注意</p>
<p>内核决定返回用户态后不是恢复main函数的上下文继续执行</p>
<p>sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系</p>
<p>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行</p>
<h3 id="sa-handler"><a href="#sa-handler" class="headerlink" title="sa_handler"></a>sa_handler</h3><p>main函数和信号处理函数是同一个进程地址空间中的多个控制流程</p>
<p>主要是修改对应的的消息处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    _in_ <span class="type">int</span> signo, </span></span><br><span class="line"><span class="params">    _in_ <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, </span></span><br><span class="line"><span class="params">    _out_ <span class="keyword">struct</span> sigaction *oact</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p>sigaction函数可以读取和修改与指定信号相关联的处理函数。</p>
<p>调用成功则返回0，出错则返回-1</p>
<p>signo是指定信号的编号。</p>
<p>若act指针非空，则根据act修改该信号的处理函数。</p>
<p>若oact指针非空，则通过oact接受该信号原来的处理函数。act和oact指向sigaction结构体：</p>
<p>与内核消息有关的结构体处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>); </span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);<span class="comment">//实时信号的处理函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数1</p>
<p>sa_handler,消息处理函数的指针,可以是自己写的函数</p>
<p>也可以是一下一些值</p>
<p>常数SIG_IGN传给sigaction表示忽略信号，怎么才算忽略?</p>
<p>常数SIG_DFL表示执行系统默认动作，指针</p>
<p>如果在调用信号处理函数时，除了当前信号被自动屏蔽之外(也就是忽略再次传来的相同信号)</p>
<p>还希望自动屏蔽另外一些信号，则用sa_mask字段说明这些需要额外屏蔽的信号，</p>
<p>当信号处理函数返回时自动恢复原来的信号屏蔽字。(也就是,可以再次屏蔽传来的信号)</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pause函数使调用进程挂起直到有信号递达。</p>
<p>如果信号的处理动作是终止进程，则进程终&#x3D;止，pause函数没有机会返回；</p>
<p>如果信号的处理动作是忽略，则进程继续处于挂起状态，pause不返回；</p>
<p>如果信号的处理动作是捕捉，则调用了信号处理函数之后pause返回-1，</p>
<p>errno设置为EINTR，所以pause只有出错的返回值。错误码EINTR表示“被信号中断”。</p>
<p>下面我们用alarm和pause实现sleep(3)函数，称为mysleep。</p>
<p>ps:pause的处理函数本身就是挂起进程吗?如果我们修改了对应的处理函数,那它的挂起还起作用吗?</p>
<p>下面这个函数,直接无法返回.为什么?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先,他和Windwos的Pause函数不同,不是说你按下pause就立马返回</p>
<p>无论你怎么按下空格,woc,我们可以注册一个函数,但是这个函数还是容易被发现的,woc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* nothing to do */</span></span><br><span class="line">	<span class="comment">//我们分配一个啥也不干的函数</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time_sleep)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="comment">//创建了2个结构体,其中一个用于传入,其中一个用于传出</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unslept=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">	newact.sa_handler = sig_alrm;<span class="comment">//添加消息处理函数,函数的动作是啥也不干</span></span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);<span class="comment">//把掩码置空,也就是谁也不屏蔽</span></span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;<span class="comment">//设置信号为是0</span></span><br><span class="line">	sigaction(SIGALRM, &amp;newact, &amp;oldact);<span class="comment">//把结构体传入,old接受原来的结构体</span></span><br><span class="line">	alarm(time_sleep);<span class="comment">//开始计时,时间一到,发送信号</span></span><br><span class="line">	x=pause();<span class="comment">//程序处于挂起状态.等待信号,信号采用的是捕捉的方式,所以pause会错误返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d\n&quot;</span>,x);</span><br><span class="line">    unslept = alarm(<span class="number">0</span>);<span class="comment">//取消之前的闹钟,而不是重复定义一个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复以前的处理函数</span></span><br><span class="line">	<span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		ret=mysleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面那个程序</p>
<p>有些地方需要注意</p>
<p>alarm是注册一个闹钟</p>
<p>pause是等待信号,不管你是什么信号</p>
<h3 id="sig-atomic-t类型与volatile限定符"><a href="#sig-atomic-t类型与volatile限定符" class="headerlink" title="sig_atomic_t类型与volatile限定符"></a>sig_atomic_t类型与volatile限定符</h3><p>之前提到,过,信号处理函数和main函数之间不存在调用和被调用的关系</p>
<p>两者是相互独立的线程</p>
<p>既然是相互独立的,就会存在一个多线程的资源访问问题</p>
<p>sig_atomic_t  好比int之类的</p>
<p>它修饰变量后,变量的读写会经过编译器的优化,从而避免资源访问冲突</p>
<p>volatile限定符，如果将上述变量定义为volatile sig_atomic_t a&#x3D;0;那么即使指定了</p>
<p>优化选项，编译器也不会优化掉对变量a内存单元的读写</p>
<p>sig_atomic_t类型的变量应该总是加上volatile限定符，因为要使用sig_atomic_t类型的理由也</p>
<p>正是要加volatile限定符的理由</p>
<h3 id="竞态条件与sigsuspend函数"><a href="#竞态条件与sigsuspend函数" class="headerlink" title="竞态条件与sigsuspend函数"></a>竞态条件与sigsuspend函数</h3><p>之前写了那个sleep函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alarm(time_sleep); </span><br><span class="line">x=pause();/</span><br></pre></td></tr></table></figure>

<p>现在我们考虑了一些问题</p>
<p>alarm注册闹钟后,可能会有闹钟信号的提取到达,对后面的处理</p>
<p>解除信号屏蔽”和“挂起等待信号”这两步能合并成一个原子操作就好了</p>
<p>这正是sigsuspend函数的功能。sigsuspend包含了pause的挂起等待功能，</p>
<p>同时解决了竞态条件的问题，</p>
<p>在对时序要求严格的场合下都应该调用sigsuspend而不是pause</p>
<p>pause一样，sigsuspend没有成功返回值，只有执行了一个信号处理函数之后sigsuspend才返回，\返回值为-1，errno设置为EINTR</p>
<p>用sigsuspend时，进程的信号屏蔽字由sigmask参数指定，</p>
<p>可以通过指定sigmask来临时解除对某个信号的屏蔽，然后挂起等待，</p>
<p>当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值，</p>
<p>如果原来对该信号是屏蔽的，从sigsuspend返回后仍然是屏蔽的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* nothing to do */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newAction</span>, <span class="title">oldAction</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span> newMask, oldMask, suspMask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unslept;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册信号处理函数 </span></span><br><span class="line">	newAction.sa_handler = sig_alrm;</span><br><span class="line">	sigemptyset(&amp;newAction.sa_mask);</span><br><span class="line">	newAction.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGALRM, &amp;newAction, &amp;oldAction);<span class="comment">//修改 SIGALRM 的处理函数 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//屏蔽  SIGALRM </span></span><br><span class="line">	sigemptyset(&amp;newMask);</span><br><span class="line">	sigaddset(&amp;newMask, SIGALRM);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newMask, &amp;oldMask);</span><br><span class="line">	</span><br><span class="line">	alarm(nsecs);<span class="comment">//注册闹钟 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂起等待</span></span><br><span class="line">	suspMask = oldMask;</span><br><span class="line">	sigdelset(&amp;suspMask, SIGALRM); </span><br><span class="line">	sigsuspend(&amp;suspMask); <span class="comment">//单独监听SIGALRM，然后挂起等待待</span></span><br><span class="line">            </span><br><span class="line">	</span><br><span class="line">	unslept = alarm(<span class="number">0</span>);<span class="comment">//取消闹钟 </span></span><br><span class="line">	sigaction(SIGALRM, &amp;oldAction, <span class="literal">NULL</span>); <span class="comment">//恢复SIGALRM的处理函数 </span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;oldMask, <span class="literal">NULL</span>);<span class="comment">//不再屏蔽 </span></span><br><span class="line">	<span class="keyword">return</span> (unslept);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Two seconds passed\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关于SIGCHLD信号"><a href="#关于SIGCHLD信号" class="headerlink" title="关于SIGCHLD信号"></a>关于SIGCHLD信号</h3><p>子进程在终止时会给父进程发SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以</p>
<p>自定义SIGCHLD信号的处理函数，这样父进程只需专心处理自己的工作，不必关心子进程了，子</p>
<p>进程终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可</p>
<p>ps:</p>
<p>请编写一个程序完成以下功能：父进程fork出子进程，子进程调用exit(2)终止，父进程自定</p>
<p>义SIGCHLD信号的处理函数，在其中调用wait获得子进程的退出状态并打印</p>
<p>用sigaction将SIGCHLD的处理动作置为SIG_IGN，这样fork出来的子进程在终止时会自动清理</p>
<p>掉，不会产生僵尸进程，也不会通知父进程。系统默认的忽略动作和用户用sigaction函数自定</p>
<p>义的忽略通常是没有区别的，但这是一个特例。此方法对于Linux可用，但不保证在其它UNIX系</p>
<p>统上都可用。请编写程序验证这样做不会产生僵尸进程</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>sa_handler主要讲了一些和消息处理函数有关的东西</p>
<p>pause没太多的讲</p>
<p>然后就是扯类一下多线程的资源访问问题(说到不是很清楚)</p>
<p>竞态条件和siguspend主要讲了由pause引发的问题,然后sigsuspend可以处理</p>
<p>SIGCHILD信号常和僵尸进程的处理相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_MY_DEFINE_TEST    __SIGRTMIN+10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数的构建</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigactionProcess</span><span class="params">(<span class="type">int</span> nsig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;S GetMsg :%08X\n&quot;</span>, getpid()) ;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号处理函数的注册</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MegReg</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">NewAct</span>,<span class="title">OldAct</span>;</span></span><br><span class="line">	NewAct.sa_handler  = sigactionProcess;</span><br><span class="line">	NewAct.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIG_MY_DEFINE_TEST,&amp;NewAct,&amp;OldAct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret ;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//C</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;S:%08X Begin\n&quot;</span>,getpid());</span><br><span class="line">		<span class="comment">//信号处理函数注册</span></span><br><span class="line">		MegReg();</span><br><span class="line">		<span class="comment">//raise(SIGSTOP) ;//子进程暂停</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;S:%08X End\n&quot;</span>,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//F</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;F:%08X Begin\n&quot;</span>,getpid());</span><br><span class="line">		usleep(<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//获取到pid子进程没有退出,指定WNOHANG不会阻塞，没有退出会返回0</span></span><br><span class="line">		<span class="keyword">if</span> ((waitpid(pid, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//if ((ret = kill(pid, SIGINT)) == 0)//向子进程发出SIGKILL信号</span></span><br><span class="line">			<span class="keyword">if</span> ((ret = kill(pid, SIG_MY_DEFINE_TEST)) == <span class="number">0</span>)<span class="comment">//向子进程发出SIG_MY_DEFINE_TEST信号</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;F kill %08X down\n&quot;</span>, pid) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="comment">/*等待子进程退出*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork() error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="终端、Job控制与守护进程"><a href="#终端、Job控制与守护进程" class="headerlink" title="终端、Job控制与守护进程"></a>终端、Job控制与守护进程</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>每个进程都可以通过一个特殊的设备文件&#x2F;dev&#x2F;tty访问它的控制终端</p>
<p>事实上每个终端设备都对应一个不同的设备文件，</p>
<p>&#x2F;dev&#x2F;tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过&#x2F;dev&#x2F;tty</p>
<p>也可以通过该终端设备所对应的设备文件来访问</p>
<p>ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备</p>
<p>而不能是任意文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 0: %s\n&quot;</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 1: %s\n&quot;</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 2: %s\n&quot;</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>终端登录过程</p>
<p>一台PC通常只有一套键盘和显示器</p>
<p>但是可以通过Ctrl-Alt-F1~Ctrl-Alt-F6切换到6个字符终端，</p>
<p>相当于有6套虚拟的终端设备，它们共用同一套物理终端设备，</p>
<p>对应的设备文件分别是&#x2F;dev&#x2F;tty1~&#x2F;dev&#x2F;tty6</p>
<p>&#x2F;dev&#x2F;tty一样也是一个通用的接口，但它不能表示图形终端窗口所对应的终端</p>
<h2 id="Job控制"><a href="#Job控制" class="headerlink" title="Job控制"></a>Job控制</h2><p>我说过“Shell可以同时运行一个前台进程和任意多个后台进程”其实是不全面的，</p>
<p>现在我们来研究更复杂的情况。事实上，Shell分前后台来控制的不是进程而是（Job）或者进程组（Process Group）。一个前台Job可以由多个进程组成，一个后台Job也可以由多个进程组成，</p>
<p>Shell可以同时运行一个前台Job和任意多个后台Job，这称为作业控制（Job Control）。</p>
<p>例如用以下命令启动5个进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc1 | proc2 &amp;</span><br><span class="line">proc3 | proc4 | proc5</span><br></pre></td></tr></table></figure>

<p>proc1和proc2属于同一个后台进程组</p>
<p>proc3、proc4、proc5属于同一个前台进程组</p>
<p>Shell进程本身属于一个单独的进程组</p>
<p>这些进程组的控制终端相同，它们属于同一个Session</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://resmile.gitee.io/blog/sysC/image-20221110123704235.png" alt="image-20221110123704235"></p>
<p>setsid函数创建一个新的Session,该进程称为Session Leader,该进程的id也可以看作Session的id</p>
<p>在创建新Session的同时也创建了一个新的进程组，</p>
<p>该进程是这个进程组的Process Group Leader，该进程的id也是进程组的id。</p>
<p>在上面的例子中，proc3、proc4、proc5被Shell放到同一个前台进程组，</p>
<p>其中有一个进程是该进程组的Leader，Shell调用wait等待它们运行结束。</p>
<p>一旦它们全部运行结束，Shell就调用tcsetpgrp函数将自己提到前台继续接受命令</p>
<p>但是注意，如果proc3、proc4、proc5中的某个进程又fork出子进程，</p>
<p>子进程也属于同一进程组，但是Shell并不知道子进程的存在，也不会调用wait等待它结束。</p>
<p>这是作业和进程组在概念上的区别。一旦作业运行结束，Shell就把自己提到前台，</p>
<p>如果原来的前台进程组还存在（如果这个子进程还没终止），则它自动变成后台进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat</span><br><span class="line">  PID  PPID  PGRP  SESS TPGID COMMAND</span><br><span class="line">  <span class="number">191</span>   <span class="number">190</span>   <span class="number">191</span>   <span class="number">191</span>   <span class="number">200</span> bash</span><br><span class="line">  <span class="number">200</span>   <span class="number">191</span>   <span class="number">200</span>   <span class="number">191</span>   <span class="number">200</span> ps</span><br><span class="line">  <span class="number">201</span>   <span class="number">191</span>   <span class="number">200</span>   <span class="number">191</span>   <span class="number">200</span> cat</span><br></pre></td></tr></table></figure>

<p>这个作业由ps和cat两个进程组成，在前台运行</p>
<p>从PPID(父亲ID)列可以看出这两个进程的父进程是bash</p>
<p>从PGRP列可以看出，bash在id为191的进程组,这个id等于bash的进程id,所以它是组的Leader</p>
<p>而两个子进程在id为200的进程组中，ps是这个进程组的Leader</p>
<p>从SESS可以看出三个进程都在同一Session中，bash是Session Leader</p>
<p>从TPGID可以看出，前台进程组的id是200，也就是两个子进程所在的进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">208</span></span><br><span class="line">PID  PPID  PGRP  SESS TPGID COMMAND</span><br><span class="line"><span class="number">191</span>   <span class="number">190</span>   <span class="number">191</span>   <span class="number">191</span>   <span class="number">191</span> bash</span><br><span class="line"><span class="number">207</span>   <span class="number">191</span>   <span class="number">207</span>   <span class="number">191</span>   <span class="number">191</span> ps</span><br><span class="line"><span class="number">208</span>   <span class="number">191</span>   <span class="number">207</span>   <span class="number">191</span>   <span class="number">191</span> cat</span><br></pre></td></tr></table></figure>







<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程."></a>守护进程.</h2><p>inux系统启动时会启动很多系统服务进程 ,这些服务进程没有控制终端，不能直接和用户交互。</p>
<p>其它进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，</p>
<p>但系统服务进程不受用户登录注销的影响，它们一直在运行着。这种进程有一个名称叫守护进程（Daemon）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br><span class="line">PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span> ?           <span class="number">-1</span> Sl       <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line">   <span class="number">1</span>    <span class="number">16</span>    <span class="number">16</span>    <span class="number">16</span> ?           <span class="number">-1</span> Ss       <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line">  <span class="number">16</span>    <span class="number">17</span>    <span class="number">16</span>    <span class="number">16</span> ?           <span class="number">-1</span> S        <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line">  <span class="number">17</span>    <span class="number">18</span>    <span class="number">18</span>    <span class="number">18</span> pts/<span class="number">1</span>       <span class="number">21</span> Ss    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line">  <span class="number">18</span>    <span class="number">21</span>    <span class="number">21</span>    <span class="number">18</span> pts/<span class="number">1</span>       <span class="number">21</span> S+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">01</span> vim q.c</span><br><span class="line">   <span class="number">1</span>   <span class="number">190</span>   <span class="number">189</span>   <span class="number">189</span> ?           <span class="number">-1</span> S        <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line"> <span class="number">190</span>   <span class="number">250</span>   <span class="number">250</span>   <span class="number">250</span> ?           <span class="number">-1</span> Rs    <span class="number">1000</span>   <span class="number">8</span>:<span class="number">21</span> ./q</span><br><span class="line">   <span class="number">1</span>   <span class="number">254</span>   <span class="number">254</span>   <span class="number">254</span> ?           <span class="number">-1</span> Ss       <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line"> <span class="number">254</span>   <span class="number">255</span>   <span class="number">254</span>   <span class="number">254</span> ?           <span class="number">-1</span> R        <span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span> /init</span><br><span class="line"> <span class="number">255</span>   <span class="number">256</span>   <span class="number">256</span>   <span class="number">256</span> pts/<span class="number">0</span>      <span class="number">259</span> Ss    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line"> <span class="number">256</span>   <span class="number">259</span>   <span class="number">259</span>   <span class="number">256</span> pts/<span class="number">0</span>      <span class="number">259</span> R+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ps ajx</span><br></pre></td></tr></table></figure>

<p>凡是TPGID一栏写着-1的都是没有控制终端的进程，也就是守护进程。</p>
<p>在COMMAND一列用[]括起来的名字表示内核线程，这些线程在内核里创建，没有用户空间代码，因此没有程序文件名和命令行，通常采用以k开头的名字，表示Kernel。</p>
<p>init进程我们已经很熟悉了，udevd负责维护&#x2F;dev目录下的设备文件</p>
<p>acpid负责电源管理，</p>
<p>syslogd负责维护&#x2F;var&#x2F;log下的日志文件，</p>
<p>创建守护进程最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数调用成功时返回新创建的Session的id（其实也就是当前进程的id），出错返回-1。</p>
<p>注意，调用这个函数之前，当前进程不允许是进程组的Leader，否则该函数返回-1</p>
<p>要保证当前进程不是进程组的Leader也很容易，只要先fork再调用setsid就行了。</p>
<p>fork创建的子进程和父进程在同一个进程组中，进程组的Leader必然是该组的第一个进程</p>
<p>所以子进程不可能是该组的第一个进程，在子进程中调用setsid就不会有问题了</p>
<p> 成功调用该函数的结果是</p>
<p>创建一个新的Session，当前进程成为Session Leader，当前进程的id就是Session的id</p>
<p>创建一个新的进程组，当前进程成为进程组的Leader，当前进程的id就是进程组的idid</p>
<p>如果当前进程原本有一个控制终端，则它失去这个控制终端，成为一个没有控制终端的进程。</p>
<p>所谓失去控制终端是指，原来的控制终端仍然是打开的，仍然可以读写，</p>
<p>但只是一个普通的打开文件而不是控制终端了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">daemonize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出</span></span><br><span class="line">        setsid();<span class="comment">//子进程成为section leader,成为group leader</span></span><br><span class="line">        <span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(<span class="number">0</span>);<span class="comment">//关闭输入流</span></span><br><span class="line">        open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">        dup2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dup2(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">//把1/2作为输入流</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        daemonize();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>终端:只是简单的介绍类一下终端</p>
<p>Job控制:只是简单的说了一下Job的概念,Job类似于进程组,但是小于进程组</p>
<p>守护进程:简单提及了一下概念,和简单的创建一个守护进程</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="导入-2"><a href="#导入-2" class="headerlink" title="导入"></a>导入</h2><p>进程在各自独立的地址空间中运行，进程之间共享数据需要用mmap或者进程间通信机制</p>
<p>在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，</p>
<p>除此之外，各线程还共享以下进程资源和环境：</p>
<ul>
<li>文件描述符表</li>
<li>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）</li>
<li>当前工作目录</li>
<li>用户id和组id</li>
</ul>
<p>然后是线程私有的</p>
<ul>
<li>线程id</li>
<li>上下文，包括各种寄存器的值、程序计数器和栈指针</li>
<li>栈空间</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<p>在Linux上线程函数位于libpthread共享库中，因此在编译时要加上-lpthread选项</p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    _out_ <span class="type">pthread_t</span> *<span class="keyword">restrict</span> thread,<span class="comment">//接收线程返回的ID</span></span></span><br><span class="line"><span class="params">	_in_ <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,<span class="comment">//线程的属性</span></span></span><br><span class="line"><span class="params">	_in_ <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="comment">//线程函数指针</span></span></span><br><span class="line"><span class="params">    _in_ <span class="type">void</span> *<span class="keyword">restrict</span> arg <span class="comment">//线程函数的参数指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回自定义的错误号int值。 </p>
<p>exit或_exit是退出进程,而不是u退出线程</p>
<p>获取线程的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc q.c -o q -lpthread</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printids</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pid = getpid();<span class="comment">//获取进程</span></span><br><span class="line">        tid = pthread_self();<span class="comment">//获取线程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s pid %08X tid %08X\n&quot;</span>, s, (<span class="type">unsigned</span> <span class="type">int</span>)pid, (<span class="type">unsigned</span> <span class="type">int</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span><span class="comment">//现场处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">        printids(arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        err = pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="string">&quot;new thread: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t create thread: %s\n&quot;</span>,strerror(err));<span class="comment">//pthread_create的错误码不保存在errno</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//用strerror(3)把错误码转换成错误信息再打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        printids(<span class="string">&quot;main thread:&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">//为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">main thread: pid <span class="number">000000000000018B</span> tid <span class="number">00000000061E4740</span></span><br><span class="line">new thread:  pid <span class="number">000000000000018B</span> tid <span class="number">00000000061E3700</span></span><br></pre></td></tr></table></figure>

<p>.</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>如果需要只终止某个线程而不终止整个进程，可以有三种方法：</p>
<ul>
<li>从线程函数return。这种方法对主线程不适用，从main函数return相当于调用exit。</li>
<li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li>
<li>线程可以调用pthread_exit终止自己</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(_in_ <span class="type">void</span> *value_ptr)</span>;<span class="comment">//常用于自杀</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">pthread_join</span><span class="params">( _in_ <span class="type">pthread_t</span> thread_ID, _ out_ <span class="type">void</span> **value_ptr)</span>;<span class="comment">//用于接收线程返回参数</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">pthread_cancel</span><span class="params">(_in_ <span class="type">pthread_t</span> tid)</span>;<span class="comment">//常用语异常退出其它线程</span></span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回错误号</p>
<p>调用pthread_join( ID, value_ptr);的线程将挂起等待，直到id为的线程终止。</p>
<p>加入A创建了线程B,A调用pthread_join( ID_B, value_ptr);函数pthread_join会阻塞A,直到线程B结束</p>
<p>才会结束</p>
<p>thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下</p>
<ul>
<li>(正常死亡)如果thread线程通过return返回，value_ptr所指向的单元里存放的是thread线程函数的返</li>
</ul>
<p>回值。</p>
<ul>
<li>(谋杀)如果thread线程被别的线程调用pthread_cancel异常终止掉，value_ptr所指向的单元里存</li>
</ul>
<p>放的是常数PTHREAD_CANCELED&#x3D;-1。</p>
<ul>
<li>(自杀)如果thread线程是自己调用pthread_exit终止的，value_ptr所指向的单元存放的是传</li>
</ul>
<p>给pthread_exit的退出码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;T1 Die Normally\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;T2 Kill Self\n&quot;</span>);</span><br><span class="line">	pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn3</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;T2\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">void</span> *tret;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tret);<span class="comment">//自然退出,返回值是跳过ret返回 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;T1 Return %d\n&quot;</span>, (<span class="type">int</span>)tret);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tret);<span class="comment">//退出码 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;T2 Exit With %d\n&quot;</span>, (<span class="type">int</span>)tret);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn3, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	pthread_cancel(tid);</span><br><span class="line">	pthread_join(tid, &amp;tret);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;T3 Exit With %d\n&quot;</span>, (<span class="type">int</span>)tret);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在linux下正常退出,在windwos的gcc下,就是不退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dqx@resmile<span class="number">-2</span>:/mnt/f/<span class="number">0xC0de</span>/elf/C$ ./q</span><br><span class="line">T1 Die Normally</span><br><span class="line">T1 Return <span class="number">1</span></span><br><span class="line">T2 Kill Self</span><br><span class="line">T2 Exit With <span class="number">2</span></span><br><span class="line">T2</span><br><span class="line">T2</span><br><span class="line">T2</span><br><span class="line">T3 Exit With <span class="number">-1</span></span><br><span class="line">dqx@resmile<span class="number">-2</span>:/mnt/f/<span class="number">0xC0de</span>/elf/C$</span><br></pre></td></tr></table></figure>



<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为</p>
<p>止。</p>
<p>但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL。</p>
<p>对一个尚未detach的线程调用pthread_join或pthread_detach都可以把该线程置为detach状态，</p>
<p>也就是说，不能对同一线程调用两次pthread_join，</p>
<p>或者如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回错误号</p>
<h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><h4 id="Mutex互斥体"><a href="#Mutex互斥体" class="headerlink" title="Mutex互斥体"></a>Mutex互斥体</h4><p>主要和多线程的资源访问有关系</p>
<p>Mutex用pthread_mutex_t类型的变量表示，可以这样初始化和销毁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;<span class="comment">//销毁互斥体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr<span class="comment">//互斥体属性,NULL表示默认属性</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//用宏定义初始化全局|静态的互斥体</span></span><br><span class="line">                                         <span class="comment">//用pthread_mutex_init初始化并且attr参数为NULL</span></span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回错误号</p>
<p>Mutex的加锁和解锁操作可以用下列函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;<span class="comment">//等待的方式获取互斥体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">	<span class="comment">//不等待的方式获取互斥体,</span></span><br><span class="line">	<span class="comment">//如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;<span class="comment">//释放互斥体</span></span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回错误号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLOOP 5000</span></span><br><span class="line"><span class="type">int</span> counter; </span><br><span class="line"><span class="type">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">doit</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tidA, tidB;</span><br><span class="line">	pthread_create(&amp;tidA, <span class="literal">NULL</span>, doit, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;tidB, <span class="literal">NULL</span>, doit, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	pthread_join(tidA, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tidB, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">doit</span><span class="params">(<span class="type">void</span> *vptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, val;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOP ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">		val = counter;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x: %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self(),val + <span class="number">1</span>);</span><br><span class="line">		counter = val + <span class="number">1</span>;</span><br><span class="line">		pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>lock和unlock的原理</strong></p>
<p>Mutex变量的值为1表示互斥锁空闲</p>
<p>Mutex的值为0,表示互斥锁已经被某个线程获得</p>
<p>下面是一个互斥体原理的雏形,但是仍然不能够互斥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mutex &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mutex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	挂起等待;</span><br><span class="line">    <span class="keyword">goto</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock()</span><br><span class="line">&#123;   </span><br><span class="line">    mutex = <span class="number">1</span>;</span><br><span class="line">    唤醒等待Mutex的线程;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，</p>
<p>也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，</p>
<p>竞争失败的线程继续挂起等待</p>
<p>如果两个线程同时调用lock，这时Mutex是1，两个线程先后都判断mutex&gt;0成立，然后其中一个线程</p>
<p>置mutex&#x3D;0，而另一个线程并不知道这一情况，也置mutex&#x3D;0，于是两个线程都以为自己获得了</p>
<p>锁。为了实现互斥锁操作，大多数体系结构都提供了swap或exchange指令，该指令的作用是把寄存</p>
<p>器和内存单元的数据相交换，由于只有一条指令，保证了原子性，即使是多处理器平台，访问</p>
<p>内存的总线周期也有先后，一个处理器上的交换指令执行时另一个处理器的交换指令只能等待</p>
<p>总线周期。现在我们把lock和unlock的伪代码改一下（以x86的xchg指令为例）</p>
<p>下面才是比较完整的原理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lock()</span><br><span class="line">&#123;</span><br><span class="line">    al=<span class="number">0</span>;</span><br><span class="line">    swapt(al, mutex)</span><br><span class="line">    <span class="keyword">if</span>(al寄存器的内容 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	挂起等待;</span><br><span class="line">	<span class="keyword">goto</span> lock;</span><br><span class="line">&#125;</span><br><span class="line">unlock()</span><br><span class="line">&#123;</span><br><span class="line">    mutex=<span class="number">1</span>   	</span><br><span class="line">    唤醒等待Mutex的线程;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU一次只干一件事情</p>
<p>一定有一个人先 swapt(al, mutex)</p>
<p>然后另外一个人后 swapt(al, mutex)</p>
<p>下的那个人获取奥al&#x3D;1,后的那个人只能al&#x3D;0</p>
<p>或者2个人获取的都是0.</p>
<p><strong>挂起等待”和“唤醒等待线程”的操作如何实现？</strong></p>
<p>每个Mutex有一个等待队列，一个线程要在Mutex上挂起等待，</p>
<p>首先在把自己加入等待队列中(最后一位乘客)，然后置线程状态为睡眠，</p>
<p>然后调用调度器函数切换到别的线程。</p>
<p>一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一项(第一位乘客)</p>
<p>把它的状态从睡眠改为就绪，加入就绪队列，那么下次调度器函数执行时就有可能切换到被唤醒的线程</p>
<p>(主要讲了一个等待队列和就绪队列,是调度器函数从队列的第一个拿出来执行)</p>
<p>死锁</p>
<p>eg1</p>
<p>假如有2个线程,线程A抓取了lock1,线程B抓取了lock2,</p>
<p>然后A又抓取lock2的信号,但是lock2的信号已经被占用了</p>
<p>然后B又抓取lock1的信号,但是lock2的信号已经被占用了</p>
<p>于是A&#x2F;B都会处于等待状态,2者的信号都不不释放</p>
<p>eg:死锁1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建2个互斥体 </span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ThreadA</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置进程属性为结束后自动释放进程空间 </span></span><br><span class="line">	pthread_detach(pthread_self());<span class="comment">//自己在返回的时候,立即释放 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取互斥锁1 </span></span><br><span class="line">	pthread_mutex_lock(&amp;lock1);<span class="comment">// </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;A抓取lock1信号&quot;</span>); </span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//获取互斥锁2 </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;A请求B释放lock2信号......&quot;</span>);</span><br><span class="line">	pthread_mutex_lock(&amp;lock2);<span class="comment">//执行到这里,等待对方B放锁 , .结果是2个人都不互相谦让 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解锁 </span></span><br><span class="line">	pthread_mutex_unlock(&amp;lock1);</span><br><span class="line">	pthread_mutex_unlock(&amp;lock2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;信号释放完毕&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ThreadB</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	<span class="comment">//获取互斥锁2 </span></span><br><span class="line">	pthread_mutex_lock(&amp;lock2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;B抓取lock2信号&quot;</span>); </span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;B请求A释放lock1信号......&quot;</span>);</span><br><span class="line">	<span class="comment">//获取互斥锁1 </span></span><br><span class="line">	pthread_mutex_lock(&amp;lock1);<span class="comment">//执行到这里,等待对方A放锁 .结果是2个人都不互相谦让 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解锁 ,解不开锁,因为正常情况下无法执行到这里来 </span></span><br><span class="line">	pthread_mutex_unlock(&amp;lock2);</span><br><span class="line">	pthread_mutex_unlock(&amp;lock1);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;信号释放完毕&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//互斥锁初始化 </span></span><br><span class="line">  pthread_mutex_init(&amp;lock1,<span class="literal">NULL</span>);<span class="comment">//属性采用默认值 </span></span><br><span class="line">  pthread_mutex_init(&amp;lock2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">pthread_t</span> tid[<span class="number">2</span>];<span class="comment">//模拟两个执行流 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建两个线程 ,线程的ID放入了 tid[2]</span></span><br><span class="line">  <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = pthread_create(&amp;tid[<span class="number">0</span>],<span class="literal">NULL</span>,ThreadA,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    perror(<span class="string">&quot;pthread_create A error&quot;</span>);</span><br><span class="line">  ret = pthread_create(&amp;tid[<span class="number">1</span>],<span class="literal">NULL</span>,ThreadB,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    perror(<span class="string">&quot;pthread_create B error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//主线程进行等待 </span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;......&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//互斥锁销毁 </span></span><br><span class="line">  pthread_mutex_destroy(&amp;lock1);</span><br><span class="line">  pthread_mutex_destroy(&amp;lock2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dqx@resmile<span class="number">-1</span>:/mnt/e/<span class="number">0xC0de</span>/elf/C$ ./q</span><br><span class="line">A抓取lock1信号</span><br><span class="line">B抓取lock2信号</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">A请求B释放lock2信号......</span><br><span class="line">B请求A释放lock1信号......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">^C</span><br><span class="line">dqx@resmile<span class="number">-1</span>:/mnt/e/<span class="number">0xC0de</span>/elf/C$</span><br></pre></td></tr></table></figure>



<h4 id="Condition-Variable-条件互斥"><a href="#Condition-Variable-条件互斥" class="headerlink" title="Condition Variable 条件互斥"></a>Condition Variable 条件互斥</h4><p>线程间的同步还有这样一种情况：</p>
<p>线程A需要等某个条件成立才能继续往下执行，现在这个条件不成立，</p>
<p>线程A就阻塞等待，而线程B在执行过程中使这个条件成立了，</p>
<p>就唤醒线程A继续执行。在pthread库中通过条件变量（Condition Variable）来阻塞等待一个条件，或者唤醒等待这个条件的线程。Condition Variable用pthread_cond_t类型的变量表示，可以这样初始化和销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回错误号</p>
<p>和Mutex的初始化和销毁类似，</p>
<p>pthread_cond_init函数初始化一个Condition Variable，</p>
<p>attr参数为NULL则表示缺省属性，</p>
<p>pthread_cond_destroy函数销毁一个Condition Variable。</p>
<p>如果Condition Variable是静态分配的，也可以用宏定义PTHEAD_COND_INITIALIZER初始化，相当于</p>
<p>用pthread_cond_init函数初始化并且attr参数为NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p>可见，一个Condition Variable总是和一个Mutex搭配使用的。</p>
<p>一个线程可以调用pthread_cond_wait在一个Condition Variable上阻塞等待，</p>
<p>这个函数做以下三步操作：</p>
<p>1 释放Mutex信号</p>
<p>2 阻塞等待</p>
<p>3 当被唤醒时，重新获得Mutex并返回</p>
<p>pthread_cond_timedwait函数还有一个额外的参数可以设定等待超时，</p>
<p>如果到达了abstime所指定的时刻仍然没有别的线程来唤醒当前线程，就返回ETIMEDOUT。</p>
<p>一个线程可以调用pthread_cond_signal唤醒在某个Condition Variable上等待的另一个线程，</p>
<p>也可以调用pthread_cond_broadcast唤醒在这个Condition Variable上等待的所有线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> MsgKey2;</span><br><span class="line"><span class="type">pthread_cond_t</span> FoodExit = PTHREAD_COND_INITIALIZER;<span class="comment">//初始化条件体</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> Lock = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//初始化互斥体</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">PeopleOpenDoor</span><span class="params">(<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;Lock);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;E Receive Key1:0x40&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (MsgKey2 == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;E No Key2&quot;</span>);</span><br><span class="line">                        pthread_cond_wait(&amp;FoodExit, &amp;Lock);<span class="comment">//等待第二把钥匙</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;E Receive Key2 : %X \n&quot;</span>, MsgKey2);</span><br><span class="line">                MsgKey2 = <span class="number">0</span>;</span><br><span class="line">                pthread_mutex_unlock(&amp;Lock);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;E SendBack All Key&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">KeyReleasae</span><span class="params">(<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> KeyCode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                pthread_mutex_lock(&amp;Lock);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;C Receive All Key&quot;</span>);</span><br><span class="line">                MsgKey2 = rand() % <span class="number">100</span> + <span class="number">20</span>;</span><br><span class="line">                pthread_mutex_unlock(&amp;Lock);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;C Send Key1&quot;</span>);</span><br><span class="line">                pthread_cond_signal(&amp;FoodExit);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;C Send Key2&quot;</span>);</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> CookerID, EaterID;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        pthread_create(&amp;CookerID, <span class="literal">NULL</span>, KeyReleasae, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;EaterID, <span class="literal">NULL</span>, PeopleOpenDoor, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(CookerID, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(EaterID, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实,相当于多了一个互斥体,说</p>
<p>说是什么条件控制,让人大小的是,那个条件竟然是DIY的if</p>
<p>这个和if+互斥体没啥区别</p>
<h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h4><p>一次性释放后多个信号</p>
<p>Mutex变量是非0即1的，可看作一种资源的可用数量，初始化时Mutex是1，表示有一个可用资源，</p>
<p>加锁时获得该资源，将Mutex减到0，表示不再有可用资源，</p>
<p>解锁时释放该资源，将Mutex重新加到1，表示又有了一个可用资源</p>
<p>信号量（Semaphore）和Mutex类似，表示可用资源的数量，和Mutex不同的是这个数量可以大于1</p>
<p><strong>这种信号量不仅可用于同一进程的多线程间同步，也可用于不同进程间的同步</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">( <span class="comment">//初始化信号量</span></span></span><br><span class="line"><span class="params">    <span class="type">sem_t</span> *sem, <span class="comment">//semaphore变量的类型</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> pshared, <span class="comment">//参数为0表示信号量用于同一进程的线程间同步</span></span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> value<span class="comment">//初始信号数量</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//获得信号，使信号量的值减1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">	<span class="comment">//如果调用sem_wait()时信号量的值已经是0，则挂起等待</span></span><br><span class="line">	<span class="comment">//如果不希望挂起等待，可以调用sem_trywait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> * sem)</span>;<span class="comment">//调用sem_post()可以释放资源,使信号量的值加1，同时唤醒挂起等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> * sem)</span>;</span><br></pre></td></tr></table></figure>

<p>semaphore变量的类型为sem_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 3</span></span><br><span class="line"><span class="type">int</span> Food[NUM];</span><br><span class="line"><span class="type">sem_t</span> EatDone, MakeDone;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sem_wait(&amp;EatDone);</span><br><span class="line">                Food[p] = rand() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;P %08X\n&quot;</span>, Food[p]);</span><br><span class="line">                sem_post(&amp;MakeDone);<span class="comment">//信号量++</span></span><br><span class="line">                p = (p + <span class="number">1</span>) % NUM;<span class="comment">//随机释放食物</span></span><br><span class="line">                sleep(rand() % NUM);<span class="comment">//随机睡眠</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sem_wait(&amp;MakeDone);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;C %08X\n&quot;</span>, Food[c]);</span><br><span class="line">                Food[c] = <span class="number">0</span>;</span><br><span class="line">                sem_post(&amp;EatDone);<span class="comment">//信号量++MakeDone</span></span><br><span class="line">                c = (c + <span class="number">1</span>) % NUM;</span><br><span class="line">                sleep(rand() % NUM);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        sem_init(&amp;EatDone, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//初始化,有NUM个信号</span></span><br><span class="line">        sem_init(&amp;MakeDone, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//初始化,有0个信号</span></span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;EatDone);</span><br><span class="line">        sem_destroy(&amp;MakeDone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>主要讲了线程的创建,挂起</p>
<p>然后是多线程的资源访问问题</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/re4mile/../../../blog/sysC/image-20221128233335349.png" alt="image-20221128233335349"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">sub_404E40</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v9; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v15; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v16; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v18; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// er9</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v20; <span class="comment">// er11</span></span><br><span class="line">  __int64 v21; <span class="comment">// r10</span></span><br><span class="line">  __int64 v22; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v24; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v25; <span class="comment">// er15</span></span><br><span class="line">  __int64 v26; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v27; <span class="comment">// rdx</span></span><br><span class="line">  __m128i v28; <span class="comment">// xmm2</span></span><br><span class="line">  __m128i v29; <span class="comment">// xmm4</span></span><br><span class="line">  __m128i v30; <span class="comment">// xmm1</span></span><br><span class="line">  __m128i v31; <span class="comment">// xmm0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *v33; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">signed</span> __int64 v34; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v35; <span class="comment">// edx</span></span><br><span class="line">  __int64 (__fastcall ***i)(); <span class="comment">// rbx</span></span><br><span class="line">  __int64 v37; <span class="comment">// rax</span></span><br><span class="line">  __int64 *v38; <span class="comment">// r14</span></span><br><span class="line">  __int64 v44; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v54; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v55; <span class="comment">// eax</span></span><br><span class="line">  __int64 v56; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v57; <span class="comment">// r15</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v58; <span class="comment">// rax</span></span><br><span class="line">  __int64 v64; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v74; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v75; <span class="comment">// eax</span></span><br><span class="line">  __int64 v76; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">signed</span> __int64 v77; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v78; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *v79; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">signed</span> __int64 v80; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v81; <span class="comment">// eax</span></span><br><span class="line">  __int64 v82; <span class="comment">// rax</span></span><br><span class="line">  __int64 v83; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v84; <span class="comment">// er11</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v95; <span class="comment">// eax</span></span><br><span class="line">  __int64 v106; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v116; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v122; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v123; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v124; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v125; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v126; <span class="comment">// rax</span></span><br><span class="line">  __m128i v127; <span class="comment">// [rsp+8h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v128; <span class="comment">// [rsp+18h] [rbp-100h] BYREF</span></span><br><span class="line">  __m128i v129; <span class="comment">// [rsp+20h] [rbp-F8h] BYREF</span></span><br><span class="line">  __int64 v130; <span class="comment">// [rsp+30h] [rbp-E8h] BYREF</span></span><br><span class="line">  __int64 v131; <span class="comment">// [rsp+38h] [rbp-E0h]</span></span><br><span class="line">  __int64 v132; <span class="comment">// [rsp+40h] [rbp-D8h] BYREF</span></span><br><span class="line">  __int64 v133; <span class="comment">// [rsp+48h] [rbp-D0h]</span></span><br><span class="line">  __int64 v134; <span class="comment">// [rsp+50h] [rbp-C8h] BYREF</span></span><br><span class="line">  __int64 v135; <span class="comment">// [rsp+58h] [rbp-C0h] BYREF</span></span><br><span class="line">  __int64 v136; <span class="comment">// [rsp+60h] [rbp-B8h]</span></span><br><span class="line">  __int64 v137; <span class="comment">// [rsp+68h] [rbp-B0h] BYREF</span></span><br><span class="line">  __int64 v138; <span class="comment">// [rsp+70h] [rbp-A8h]</span></span><br><span class="line">  __int64 v139; <span class="comment">// [rsp+78h] [rbp-A0h]</span></span><br><span class="line">  __int64 v140; <span class="comment">// [rsp+80h] [rbp-98h]</span></span><br><span class="line">  <span class="type">int</span> v141; <span class="comment">// [rsp+8Ch] [rbp-8Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v142; <span class="comment">// [rsp+98h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v143; <span class="comment">// [rsp+9Ch] [rbp-7Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v144; <span class="comment">// [rsp+A0h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v145; <span class="comment">// [rsp+A4h] [rbp-74h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v146; <span class="comment">// [rsp+A8h] [rbp-70h] BYREF</span></span><br><span class="line">  __int64 v147; <span class="comment">// [rsp+B0h] [rbp-68h] BYREF</span></span><br><span class="line">  __int64 v148; <span class="comment">// [rsp+B8h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 code[<span class="number">11</span>]; <span class="comment">// [rsp+C0h] [rbp-58h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v138 = a1;</span><br><span class="line">  v9 = a3 + <span class="number">8LL</span> * (<span class="type">int</span>)a2 + <span class="number">8</span>;</span><br><span class="line">  v139 = a6;</span><br><span class="line">  qword_4F64A8 = v9;</span><br><span class="line">  qword_4EEA80 = a7;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v9 += <span class="number">8LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(_QWORD *)(v9 - <span class="number">8</span>) );</span><br><span class="line">  sub_467490();</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4F65D0 )</span><br><span class="line">  &#123;</span><br><span class="line">    qword_4F65D0 = (__int64)(&amp;dword_400000 + <span class="number">16</span>);</span><br><span class="line">    qword_4F65C8 = <span class="number">10LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_4696D0();</span><br><span class="line">  sub_466450(qword_4F64A8);</span><br><span class="line">  _RAX = <span class="number">0LL</span>;</span><br><span class="line">  v142 = <span class="number">0</span>;</span><br><span class="line">  v143 = <span class="number">0</span>;</span><br><span class="line">  v144 = <span class="number">0</span>;</span><br><span class="line">  __asm &#123; cpuid &#125;</span><br><span class="line">  dword_4F6624 = _RAX;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)_RBX == <span class="number">1970169159</span> &amp;&amp; (_DWORD)_RCX == <span class="number">1818588270</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)_RDX != <span class="number">1231384169</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_8:</span><br><span class="line">      sub_404000(<span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">      sub_404990(<span class="number">0LL</span>, <span class="number">0LL</span>, v15, v16);</span><br><span class="line">      v17 = v143;</span><br><span class="line">      v18 = v144;</span><br><span class="line">      v19 = <span class="number">4</span>;</span><br><span class="line">      v20 = v142;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_404000(&amp;v142, &amp;v143, code, &amp;v144);</span><br><span class="line">    _RAX = <span class="number">0x80000000</span>LL;</span><br><span class="line">    __asm &#123; cpuid &#125;</span><br><span class="line">    v106 = (<span class="type">unsigned</span> <span class="type">int</span>)_RAX;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)_RAX &gt; <span class="number">0x80000000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _RAX = <span class="number">2147483649LL</span>;</span><br><span class="line">      __asm &#123; cpuid &#125;</span><br><span class="line">      dword_4F6674 = _RAX;</span><br><span class="line">      dword_4F6678 = _RBX;</span><br><span class="line">      dword_4F667C = _RCX;</span><br><span class="line">      dword_4F6680 = _RDX;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v106 &gt; <span class="number">0x80000006</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _RAX = <span class="number">2147483655LL</span>;</span><br><span class="line">        __asm &#123; cpuid &#125;</span><br><span class="line">        dword_4F66B4 = _RAX;</span><br><span class="line">        dword_4F66B8 = _RBX;</span><br><span class="line">        dword_4F66BC = _RCX;</span><br><span class="line">        dword_4F66C0 = _RDX;</span><br><span class="line">        <span class="keyword">if</span> ( (_DWORD)v106 != <span class="number">-2147483641</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          _RAX = <span class="number">2147483656LL</span>;</span><br><span class="line">          __asm &#123; cpuid &#125;</span><br><span class="line">          dword_4F66D4 = _RAX;</span><br><span class="line">          dword_4F66D8 = _RBX;</span><br><span class="line">          dword_4F66DC = _RCX;</span><br><span class="line">          dword_4F66E0 = _RDX;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_404990(&amp;v142, v106, _RDX, _RCX);</span><br><span class="line">    v17 = v143;</span><br><span class="line">    <span class="keyword">if</span> ( v142 != <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_141;</span><br><span class="line">    v122 = LODWORD(code[<span class="number">0</span>]) + v143;</span><br><span class="line">    v143 = v122;</span><br><span class="line">    v123 = v122;</span><br><span class="line">    <span class="keyword">if</span> ( v122 &gt; <span class="number">0x5D</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v124 = v122 - <span class="number">95</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v124 &gt; <span class="number">0x3D</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F663C &amp; <span class="number">0x10000000</span>) != <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_180;</span><br><span class="line">LABEL_181:</span><br><span class="line">        v18 = v144;</span><br><span class="line">        <span class="keyword">if</span> ( v123 &lt;= <span class="number">0x5E</span> )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_182:</span><br><span class="line">          <span class="keyword">if</span> ( v123 &gt; <span class="number">0x3B</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v125 = v123 - <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v125 &lt;= <span class="number">0x22</span> )</span><br><span class="line">              __asm &#123; jmp     rdx &#125;</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_178:</span><br><span class="line">          v17 = v143;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_142;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_175:</span><br><span class="line">        <span class="keyword">if</span> ( (v123 &amp; <span class="number">0xFFFFFFEF</span>) == <span class="number">142</span> &amp;&amp; v18 &lt;= <span class="number">0xC</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(qword_4F6668) = qword_4F6668 &amp; <span class="number">0xFFFFF7EF</span>;</span><br><span class="line">          v17 = v143;</span><br><span class="line">          dword_4F6670 |= <span class="number">0x800</span>u;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_142;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_178;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( ((((_QWORD)&amp;loc_40FFFE + <span class="number">3</span>) &lt;&lt; <span class="number">39</span>) &amp; (<span class="number">1LL</span> &lt;&lt; v124)) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_4F6754 |= <span class="number">0x139</span>u;</span><br><span class="line">        v18 = v144;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_175;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( ((<span class="number">1LL</span> &lt;&lt; v124) &amp; <span class="number">0x8400001</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F663C &amp; <span class="number">0x10000000</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v18 = v144;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_175;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_180;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v122 &lt;= <span class="number">0x24</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v122 != <span class="number">28</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v122 &lt;= <span class="number">0x1C</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v122 != <span class="number">26</span> )</span><br><span class="line">            &#123;</span><br><span class="line">LABEL_168:</span><br><span class="line">              <span class="keyword">if</span> ( (dword_4F663C &amp; <span class="number">0x10000000</span>) == <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v17 = v143;</span><br><span class="line">LABEL_141:</span><br><span class="line">                v18 = v144;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_142;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( v122 - <span class="number">30</span> &gt; <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_168;</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_180:</span><br><span class="line">          dword_4F6754 |= <span class="number">0x39</span>u;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_181;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_193:</span><br><span class="line">        dword_4F6754 |= <span class="number">4u</span>;</span><br><span class="line">        v17 = v143;</span><br><span class="line">        v18 = v144;</span><br><span class="line">LABEL_142:</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F6658 &amp; <span class="number">0x8000000</span>) != <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_146;</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F66F4 &amp; <span class="number">0x10</span>) == <span class="number">0</span> )</span><br><span class="line">          dword_4F6754 |= <span class="number">0x1000</span>u;</span><br><span class="line">        <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x800</span>) != <span class="number">0</span> )</span><br><span class="line">LABEL_146:</span><br><span class="line">          dword_4F6754 |= <span class="number">0x400</span>u;</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F6660 &amp; <span class="number">0x10</span>) != <span class="number">0</span> )</span><br><span class="line">          dword_4F6754 |= <span class="number">0x8000</span>u;</span><br><span class="line">        v20 = v142;</span><br><span class="line">        v19 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">      &#125;</span><br><span class="line">      v126 = <span class="number">1LL</span> &lt;&lt; ((<span class="type">unsigned</span> __int8)v122 - <span class="number">37</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (v126 &amp; <span class="number">0x1A401A000040000</span>LL) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v126 &amp; <span class="number">0x681</span>) != <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_180;</span><br><span class="line">        <span class="keyword">if</span> ( v122 != <span class="number">38</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (dword_4F663C &amp; <span class="number">0x10000000</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = v144;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_182;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_180;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_193;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dword_4F6754 |= <span class="number">0x138</span>u;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_181;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)_RBX == <span class="number">1752462657</span> &amp;&amp; (_DWORD)_RCX == <span class="number">1145913699</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)_RDX != <span class="number">1769238117</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)_RBX == <span class="number">1869052232</span> &amp;&amp; (_DWORD)_RCX == <span class="number">1701734773</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)_RDX != <span class="number">1852131182</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">LABEL_57:</span><br><span class="line">    sub_404000(&amp;v142, &amp;v143, code, &amp;v144);</span><br><span class="line">    _RAX = <span class="number">0x80000000</span>LL;</span><br><span class="line">    __asm &#123; cpuid &#125;</span><br><span class="line">    v44 = (<span class="type">unsigned</span> <span class="type">int</span>)_RAX;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)_RAX &gt; <span class="number">0x80000000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _RAX = <span class="number">2147483649LL</span>;</span><br><span class="line">      __asm &#123; cpuid &#125;</span><br><span class="line">      dword_4F6674 = _RAX;</span><br><span class="line">      dword_4F6678 = _RBX;</span><br><span class="line">      dword_4F667C = _RCX;</span><br><span class="line">      dword_4F6680 = _RDX;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v44 &gt; <span class="number">0x80000006</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _RAX = <span class="number">2147483655LL</span>;</span><br><span class="line">        __asm &#123; cpuid &#125;</span><br><span class="line">        dword_4F66B4 = _RAX;</span><br><span class="line">        dword_4F66B8 = _RBX;</span><br><span class="line">        dword_4F66BC = _RCX;</span><br><span class="line">        dword_4F66C0 = _RDX;</span><br><span class="line">        <span class="keyword">if</span> ( (_DWORD)v44 != <span class="number">-2147483641</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          _RAX = <span class="number">2147483656LL</span>;</span><br><span class="line">          __asm &#123; cpuid &#125;</span><br><span class="line">          dword_4F66D4 = _RAX;</span><br><span class="line">          dword_4F66D8 = _RBX;</span><br><span class="line">          dword_4F66DC = _RCX;</span><br><span class="line">          dword_4F66E0 = _RDX;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_404990(&amp;v142, v44, _RDX, _RCX);</span><br><span class="line">    <span class="keyword">if</span> ( (dword_4F664C &amp; <span class="number">0x10000000</span>) != <span class="number">0</span> )</span><br><span class="line">      LODWORD(qword_4F668C) = dword_4F667C &amp; <span class="number">0x10000</span> | qword_4F668C;</span><br><span class="line">    v17 = v143;</span><br><span class="line">    <span class="keyword">if</span> ( v142 == <span class="number">21</span> &amp;&amp; v143 - <span class="number">96</span> &lt;= <span class="number">0x1F</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v81 = dword_4F6754;</span><br><span class="line">      BYTE1(v81) = BYTE1(dword_4F6754) &amp; <span class="number">0xFD</span>;</span><br><span class="line">      dword_4F6754 = v81 | <span class="number">0xA</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = v144;</span><br><span class="line">    v20 = v142;</span><br><span class="line">    v19 = <span class="number">2</span>;</span><br><span class="line">LABEL_9:</span><br><span class="line">    <span class="keyword">if</span> ( (dword_4F6640 &amp; <span class="number">0x100</span>) != <span class="number">0</span> )</span><br><span class="line">      dword_4F6754 |= <span class="number">0x40</span>u;</span><br><span class="line">    <span class="keyword">if</span> ( (dword_4F6640 &amp; <span class="number">0x8000</span>) != <span class="number">0</span> )</span><br><span class="line">      dword_4F6754 |= <span class="number">0x80</span>u;</span><br><span class="line">    dword_4F6620 = v19;</span><br><span class="line">    dword_4F6630 = v18;</span><br><span class="line">    v146 = <span class="number">-1LL</span>;</span><br><span class="line">    v145 = <span class="number">0</span>;</span><br><span class="line">    qword_4F6628 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v20), _mm_cvtsi32_si128(v17)).m128i_u64[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        v141 = <span class="number">1</span>;</span><br><span class="line">        v127.m128i_i64[<span class="number">0</span>] = sub_4048A0(<span class="number">188LL</span>);</span><br><span class="line">        v132 = sub_4048A0(<span class="number">191LL</span>);</span><br><span class="line">        v146 = sub_4048A0(<span class="number">194LL</span>);</span><br><span class="line">        v127.m128i_i64[<span class="number">1</span>] = sub_4048A0(<span class="number">185LL</span>);</span><br><span class="line">        v129.m128i_i64[<span class="number">0</span>] = v127.m128i_i64[<span class="number">0</span>];</span><br><span class="line">        v128 = sub_4048A0(<span class="number">187LL</span>);</span><br><span class="line">        v130 = sub_4048A0(<span class="number">189LL</span>);</span><br><span class="line">        v131 = sub_4048A0(<span class="number">190LL</span>);</span><br><span class="line">        v140 = v132;</span><br><span class="line">        v133 = sub_4048A0(<span class="number">192LL</span>);</span><br><span class="line">        v134 = sub_4048A0(<span class="number">193LL</span>);</span><br><span class="line">        v135 = sub_4048A0(<span class="number">195LL</span>);</span><br><span class="line">        v136 = sub_4048A0(<span class="number">196LL</span>);</span><br><span class="line">        v137 = sub_4048A0(<span class="number">197LL</span>);</span><br><span class="line">        sub_404190(&amp;v146, &amp;v145, v132);</span><br><span class="line">        v21 = v132;</span><br><span class="line">        v19 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v141 = <span class="number">3</span>;</span><br><span class="line">        v127.m128i_i64[<span class="number">0</span>] = sub_403BA0(<span class="number">188LL</span>);</span><br><span class="line">        v132 = sub_403BA0(<span class="number">191LL</span>);</span><br><span class="line">        v146 = sub_403BA0(<span class="number">194LL</span>);</span><br><span class="line">        v127.m128i_i64[<span class="number">1</span>] = sub_403BA0(<span class="number">185LL</span>);</span><br><span class="line">        v129.m128i_i64[<span class="number">0</span>] = v127.m128i_i64[<span class="number">0</span>];</span><br><span class="line">        v128 = sub_403BA0(<span class="number">187LL</span>);</span><br><span class="line">        v130 = sub_403BA0(<span class="number">189LL</span>);</span><br><span class="line">        v131 = sub_403BA0(<span class="number">190LL</span>);</span><br><span class="line">        v133 = sub_403BA0(<span class="number">192LL</span>);</span><br><span class="line">        v134 = sub_403BA0(<span class="number">193LL</span>);</span><br><span class="line">        v135 = sub_403BA0(<span class="number">195LL</span>);</span><br><span class="line">        v136 = sub_403BA0(<span class="number">196LL</span>);</span><br><span class="line">        v140 = v132;</span><br><span class="line">        sub_404190(&amp;v146, &amp;v145, v132);</span><br><span class="line">        v21 = v132;</span><br><span class="line">        v137 = <span class="number">-1LL</span>;</span><br><span class="line">        v19 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v127.m128i_i64[<span class="number">0</span>] = sub_403D70(<span class="number">188LL</span>);</span><br><span class="line">        sub_403D70(<span class="number">191LL</span>);</span><br><span class="line">        v137 = sub_403D70(<span class="number">194LL</span>);</span><br><span class="line">        v146 = v137;</span><br><span class="line">        v127.m128i_i64[<span class="number">1</span>] = sub_403D70(<span class="number">185LL</span>);</span><br><span class="line">        v129.m128i_i64[<span class="number">0</span>] = v127.m128i_i64[<span class="number">0</span>];</span><br><span class="line">        v128 = sub_403D70(<span class="number">187LL</span>);</span><br><span class="line">        v130 = sub_403D70(<span class="number">189LL</span>);</span><br><span class="line">        v82 = sub_403D70(<span class="number">190LL</span>);</span><br><span class="line">        v132 = v83;</span><br><span class="line">        v131 = v82;</span><br><span class="line">        v133 = sub_403D70(<span class="number">192LL</span>);</span><br><span class="line">        v134 = sub_403D70(<span class="number">193LL</span>);</span><br><span class="line">        v135 = sub_403D70(<span class="number">195LL</span>);</span><br><span class="line">        v136 = sub_403D70(<span class="number">196LL</span>);</span><br><span class="line">        _RAX = <span class="number">0x80000000</span>LL;</span><br><span class="line">        __asm &#123; cpuid &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v137 &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v146 = v21;</span><br><span class="line">          v137 = <span class="number">-1LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)_RAX &gt; <span class="number">0x80000007</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            _RAX = <span class="number">2147483656LL</span>;</span><br><span class="line">            __asm &#123; cpuid &#125;</span><br><span class="line">            v95 = <span class="number">1</span> &lt;&lt; ((<span class="type">unsigned</span> __int16)_RCX &gt;&gt; <span class="number">12</span>);</span><br><span class="line">            v145 = v95;</span><br><span class="line">            <span class="keyword">if</span> ( v84 &lt;= <span class="number">0x16</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_128;</span><br><span class="line">          &#125;</span><br><span class="line">          _RAX = <span class="number">1LL</span>;</span><br><span class="line">          __asm &#123; cpuid &#125;</span><br><span class="line">          <span class="keyword">if</span> ( (_RDX &amp; <span class="number">0x10000000</span>) != <span class="number">0</span> )</span><br><span class="line">            v145 = BYTE2(_RBX);</span><br><span class="line">          v95 = v145;</span><br><span class="line">          <span class="keyword">if</span> ( v145 )</span><br><span class="line">LABEL_128:</span><br><span class="line">            v146 = v137 / v95;</span><br><span class="line">          <span class="keyword">if</span> ( v84 &lt;= <span class="number">0x16</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v137 = <span class="number">-1LL</span>;</span><br><span class="line">            v146 += v21;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            _RAX = <span class="number">2147483677LL</span>;</span><br><span class="line">            __asm &#123; cpuid &#125;</span><br><span class="line">            v137 = <span class="number">-1LL</span>;</span><br><span class="line">            v146 *= (((<span class="type">unsigned</span> <span class="type">int</span>)_RAX &gt;&gt; <span class="number">14</span>) &amp; <span class="number">0xFFF</span>) + <span class="number">1LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v137 = <span class="number">-1LL</span>;</span><br><span class="line">        v21 = <span class="number">-1LL</span>;</span><br><span class="line">        v136 = <span class="number">-1LL</span>;</span><br><span class="line">        v135 = <span class="number">-1LL</span>;</span><br><span class="line">        v134 = <span class="number">-1LL</span>;</span><br><span class="line">        v133 = <span class="number">-1LL</span>;</span><br><span class="line">        v132 = <span class="number">-1LL</span>;</span><br><span class="line">        v131 = <span class="number">-1LL</span>;</span><br><span class="line">        v130 = <span class="number">-1LL</span>;</span><br><span class="line">        v129.m128i_i64[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">        v128 = <span class="number">-1LL</span>;</span><br><span class="line">        v127.m128i_i64[<span class="number">1</span>] = <span class="number">-1LL</span>;</span><br><span class="line">        v127.m128i_i64[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xmmword_4F67A0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v128);</span><br><span class="line">    v22 = <span class="number">3</span> * v146 + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="number">3</span> * v146) &amp; <span class="number">0x8000000000000000</span>LL) == <span class="number">0LL</span> )</span><br><span class="line">      v22 = <span class="number">3</span> * v146;</span><br><span class="line">    xmmword_4F67B0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v130);</span><br><span class="line">    v127.m128i_i64[<span class="number">1</span>] = v22 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    xmmword_4F67C0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v132);</span><br><span class="line">    xmmword_4F67D0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v134);</span><br><span class="line">    xmmword_4F67E0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v135);</span><br><span class="line">    xmmword_4F67F0 = (__int128)_mm_loadh_ps((<span class="type">const</span> <span class="type">double</span> *)&amp;v137);</span><br><span class="line">    <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x10000</span>) != <span class="number">0</span> &amp;&amp; (dword_4F6754 &amp; <span class="number">0x1000</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v24 = <span class="number">0x4000</span>;</span><br><span class="line">      v25 = <span class="number">512</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v23 = dword_4F6754 &amp; <span class="number">0x200</span>;</span><br><span class="line">      v24 = v23 == <span class="number">0</span> ? <span class="number">2048</span> : <span class="number">0x2000</span>;</span><br><span class="line">      v25 = v23 == <span class="number">0</span> ? <span class="number">128</span> : <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (dword_4F6670 &amp; <span class="number">0x10</span>) != <span class="number">0</span> )</span><br><span class="line">      v24 = <span class="number">2112</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v19 != <span class="number">2</span> )</span><br><span class="line">      v21 = v127.m128i_i64[<span class="number">1</span>];</span><br><span class="line">    v128 = v21;</span><br><span class="line">    sub_466CC0(<span class="number">28LL</span>, code, <span class="number">0LL</span>);</span><br><span class="line">    v26 = code[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( !code[<span class="number">0</span>] )</span><br><span class="line">      v26 = v127.m128i_i64[<span class="number">0</span>];</span><br><span class="line">    v127.m128i_i64[<span class="number">0</span>] = v26;</span><br><span class="line">    sub_466CC0(<span class="number">4LL</span>, code, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( code[<span class="number">0</span>] )</span><br><span class="line">      v146 = code[<span class="number">0</span>];</span><br><span class="line">    sub_466CC0(<span class="number">16LL</span>, code, <span class="number">0LL</span>);</span><br><span class="line">    v27 = code[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( !code[<span class="number">0</span>] )</span><br><span class="line">      v27 = v127.m128i_i64[<span class="number">1</span>];</span><br><span class="line">    v127.m128i_i64[<span class="number">1</span>] = v27;</span><br><span class="line">    sub_466CC0(<span class="number">10LL</span>, code, <span class="number">0LL</span>);</span><br><span class="line">    v131 = v25;</span><br><span class="line">    <span class="keyword">if</span> ( (__int64)code[<span class="number">0</span>] &gt; v25 )</span><br><span class="line">      v24 = code[<span class="number">0</span>];</span><br><span class="line">    sub_466CC0(<span class="number">15LL</span>, code, <span class="number">0LL</span>);</span><br><span class="line">    v28 = _mm_loadl_epi64((<span class="type">const</span> __m128i *)&amp;v128);</span><br><span class="line">    v147 = v127.m128i_i64[<span class="number">0</span>];</span><br><span class="line">    v29 = (__m128i)code[<span class="number">0</span>];</span><br><span class="line">    v130 = code[<span class="number">0</span>];</span><br><span class="line">    code[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">    v129 = _mm_unpacklo_epi64(v28, v29);</span><br><span class="line">    v148 = <span class="number">0LL</span>;</span><br><span class="line">    sub_466300(<span class="number">28LL</span>, &amp;v147, &amp;v148, code);</span><br><span class="line">    code[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">    v148 = <span class="number">0LL</span>;</span><br><span class="line">    v147 = v146;</span><br><span class="line">    v128 = v146;</span><br><span class="line">    sub_466300(<span class="number">4LL</span>, &amp;v147, &amp;v148, code);</span><br><span class="line">    code[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">    v147 = v127.m128i_i64[<span class="number">1</span>];</span><br><span class="line">    v148 = <span class="number">0LL</span>;</span><br><span class="line">    sub_466300(<span class="number">16LL</span>, &amp;v147, &amp;v148, code);</span><br><span class="line">    v147 = v24;</span><br><span class="line">    v148 = v131;</span><br><span class="line">    code[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">    sub_466300(<span class="number">10LL</span>, &amp;v147, &amp;v148, code);</span><br><span class="line">    code[<span class="number">0</span>] = <span class="number">-1LL</span>;</span><br><span class="line">    v147 = v130;</span><br><span class="line">    v148 = <span class="number">1LL</span>;</span><br><span class="line">    sub_466300(<span class="number">15LL</span>, &amp;v147, &amp;v148, code);</span><br><span class="line">    v30 = _mm_loadl_epi64((<span class="type">const</span> __m128i *)&amp;v127.m128i_i8[<span class="number">8</span>]);</span><br><span class="line">    v31 = _mm_unpacklo_epi64(_mm_loadl_epi64(&amp;v127), (__m128i)v128);</span><br><span class="line">    xmmword_4F6790 = (__int128)_mm_load_si128(&amp;v129);</span><br><span class="line">    xmmword_4F6770 = (__int128)v31;</span><br><span class="line">    xmmword_4F6780 = (__int128)_mm_unpacklo_epi64(v30, _mm_cvtsi32_si128(v24));</span><br><span class="line">    sub_466CC0(<span class="number">24LL</span>, code, sub_4689E0);</span><br><span class="line">    v32 = dword_4F664C;</span><br><span class="line">    <span class="keyword">if</span> ( (dword_4F664C &amp; <span class="number">0x8000000</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( dword_4F664C &amp; <span class="number">0x4000000</span> | dword_4F66A4 &amp; <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      dword_4F66A4 &amp;= <span class="number">0xFFFFFFE8</span>;</span><br><span class="line">      v32 = dword_4F664C &amp; <span class="number">0xFBFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v32 &amp;= <span class="number">0xCFFFEFFF</span>;</span><br><span class="line">    qword_4F6760 = <span class="number">0LL</span>;</span><br><span class="line">    dword_4F6704 &amp;= <span class="number">0xFFFFFFCF</span>;</span><br><span class="line">    dword_4F664C = v32;</span><br><span class="line">    dword_4F6670 &amp;= <span class="number">0xFC3FFEF3</span>;</span><br><span class="line">    LODWORD(qword_4F668C) = qword_4F668C &amp; <span class="number">0xFFFEF7FF</span>;</span><br><span class="line">    qword_4F6668 = _mm_and_si128(</span><br><span class="line">                     _mm_loadl_epi64((<span class="type">const</span> __m128i *)&amp;qword_4F6668),</span><br><span class="line">                     _mm_loadl_epi64((<span class="type">const</span> __m128i *)&amp;qword_4BF6E8)).m128i_u64[<span class="number">0</span>];</span><br><span class="line">LABEL_36:</span><br><span class="line">    qword_4F65C0 = <span class="number">2LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_4F6620 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">    <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x10000000</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x8000000</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x4000000</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v58 = <span class="string">&quot;xeon_phi&quot;</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_90;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x40020000</span>) == <span class="number">1073872896</span> &amp;&amp; (<span class="type">int</span>)qword_4F6668 &lt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qword_4F65C0 = <span class="number">6LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x20</span>) == <span class="number">0</span></span><br><span class="line">      || (v32 &amp; <span class="number">0x1000</span>) == <span class="number">0</span></span><br><span class="line">      || (qword_4F6668 &amp; <span class="number">0x108</span>) != <span class="number">264</span></span><br><span class="line">      || (qword_4F668C &amp; <span class="number">0x20</span>) == <span class="number">0</span></span><br><span class="line">      || (v32 &amp; <span class="number">0xC00000</span>) != <span class="number">12582912</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_37:</span><br><span class="line">      sub_466CC0(<span class="number">23LL</span>, code, sub_4694A0);</span><br><span class="line">      sub_466CC0(<span class="number">17LL</span>, code, sub_469530);</span><br><span class="line">      v34 = sys_arch_prctl((<span class="keyword">struct</span> task_struct *)<span class="number">0x3001</span>, (<span class="type">int</span>)code, v33);</span><br><span class="line">      v35 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v34 || (v35 = code[<span class="number">0</span>], (code[<span class="number">0</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>) )</span><br><span class="line">        dword_4F6670 &amp;= ~<span class="number">0x100000</span>u;</span><br><span class="line">      <span class="keyword">if</span> ( (v35 &amp; <span class="number">2</span>) == <span class="number">0</span> &amp;&amp; (HIDWORD(qword_4F6668) &amp;= ~<span class="number">0x80</span>u, !v35) || (dword_4F6804 = v35, (v35 &amp; <span class="number">3</span>) == <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_41:</span><br><span class="line">        <span class="keyword">if</span> ( (__int64)xmmword_4F6770 &gt;= <span class="number">0</span> &amp;&amp; (xmmword_4F6770 &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          qword_4EF130 = xmmword_4F6770 &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL;</span><br><span class="line">          qword_4EF138 = (__int64)(xmmword_4F6770 &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( xmmword_4F6770 &gt;= <span class="number">0</span> &amp;&amp; (*((_QWORD *)&amp;xmmword_4F6770 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          qword_4EF120 = *((_QWORD *)&amp;xmmword_4F6770 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL;</span><br><span class="line">          qword_4EF128 = (__int64)(*((_QWORD *)&amp;xmmword_4F6770 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFF00</span>LL) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qword_4EF118 = *((_QWORD *)&amp;xmmword_4F6780 + <span class="number">1</span>);</span><br><span class="line">        qword_4F13E0 = xmmword_4F6780;</span><br><span class="line">        qword_4EF110 = *((_QWORD *)&amp;xmmword_4F6790 + <span class="number">1</span>);</span><br><span class="line">        qword_4F13D8 = xmmword_4F6790;</span><br><span class="line">        <span class="keyword">if</span> ( (dword_4F6754 &amp; <span class="number">0x8000</span>) != <span class="number">0</span> )</span><br><span class="line">          dword_4F13D0 |= <span class="number">1u</span>;</span><br><span class="line">        sub_401A60();</span><br><span class="line">        <span class="keyword">for</span> ( i = &amp;off_4002E8; (<span class="type">unsigned</span> __int64)i &lt; <span class="number">0x400570</span>; *v38 = v37 )</span><br><span class="line">        &#123;</span><br><span class="line">          v38 = (__int64 *)*i;</span><br><span class="line">          <span class="keyword">if</span> ( *((_DWORD *)i + <span class="number">2</span>) != <span class="number">37</span> )</span><br><span class="line">            sub_419770(<span class="string">&quot;Unexpected reloc type in static binary.\n&quot;</span>);</span><br><span class="line">          v37 = ((__int64 (*)(<span class="type">void</span>))i[<span class="number">2</span>])();</span><br><span class="line">          i += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sub_4063D0();</span><br><span class="line">        __writefsdword(<span class="number">0x48</span>u, dword_4F6804);</span><br><span class="line">        v54 = *(_QWORD *)qword_4EEA70;</span><br><span class="line">        LOBYTE(v54) = <span class="number">0</span>;</span><br><span class="line">        __writefsqword(<span class="number">0x28</span>u, v54);</span><br><span class="line">        v55 = sub_4695C0();</span><br><span class="line">        <span class="keyword">if</span> ( v55 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !dword_4F65F8 || dword_4F65F8 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)v55 )</span><br><span class="line">            dword_4F65F8 = v55;</span><br><span class="line">          <span class="keyword">if</span> ( v55 &gt; <span class="number">197119</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( qword_4EEF98 )</span><br><span class="line">              MEMORY[<span class="number">0</span>]();</span><br><span class="line">            __writefsqword(<span class="number">0x30</span>u, *(_QWORD *)(qword_4EEA70 + <span class="number">8</span>));</span><br><span class="line">            <span class="keyword">if</span> ( v139 )</span><br><span class="line">              sub_40D0A0(v139, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">            sub_469720(<span class="number">1LL</span>);</span><br><span class="line">            sub_4698E0(a2, a3, qword_4F64A8);</span><br><span class="line">            sub_40D0A0(sub_403F20, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( dword_4EEAB0 )</span><br><span class="line">              sub_406230();</span><br><span class="line">            v56 = qword_4F64A8;</span><br><span class="line">            sub_401000();</span><br><span class="line">            v57 = <span class="number">0LL</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ((<span class="type">char</span> *)&amp;off_4EB798 - (<span class="type">char</span> *)&amp;off_4EB788) &gt;&gt; <span class="number">3</span> )</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//**********************************************************************************</span></span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                ((<span class="type">void</span> (__fastcall *)(_QWORD, __int64, __int64))*(&amp;off_4EB788 + v57++))(a2, a3, v56);</span><br><span class="line">            <span class="comment">//**********************************************************************************    </span></span><br><span class="line">              <span class="keyword">while</span> ( ((<span class="type">char</span> *)&amp;off_4EB798 - (<span class="type">char</span> *)&amp;off_4EB788) &gt;&gt; <span class="number">3</span> != v57 );</span><br><span class="line">            &#125;</span><br><span class="line">            sub_45DC80(<span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">            sub_403F60(v138, a2, a3);</span><br><span class="line">          &#125;</span><br><span class="line">          sub_419770(<span class="string">&quot;FATAL: kernel too old\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sub_419770(<span class="string">&quot;FATAL: cannot determine kernel version\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v75 = BYTE4(qword_4F6668) &amp; <span class="number">0x80</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (dword_4F6670 &amp; <span class="number">0x100000</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x8000000000</span>LL) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_114:</span><br><span class="line">          v79 = (<span class="type">unsigned</span> __int64 *)(byte_4F6800 &amp; <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">if</span> ( (_BYTE)v79 != <span class="number">3</span> &amp;&amp; (byte_4F6800 &amp; <span class="number">0xC</span>) != <span class="number">12</span> )</span><br><span class="line">            v80 = sys_arch_prctl((<span class="keyword">struct</span> task_struct *)<span class="number">0x3003</span>, <span class="number">0</span>, v79);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_41;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v76 = <span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (qword_4F6668 &amp; <span class="number">0x8000000000</span>LL) != <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_112;</span><br><span class="line">        v75 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v76 = v75 | <span class="number">2u</span>;</span><br><span class="line">LABEL_112:</span><br><span class="line">      v77 = sys_arch_prctl((<span class="keyword">struct</span> task_struct *)<span class="number">0x3002</span>, v76, (<span class="type">unsigned</span> __int64 *)v76);</span><br><span class="line">      <span class="keyword">if</span> ( !(_DWORD)v77 )</span><br><span class="line">        dword_4F6804 &amp;= ~v78;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_114;</span><br><span class="line">    &#125;</span><br><span class="line">    v58 = <span class="string">&quot;haswell&quot;</span>;</span><br><span class="line">LABEL_90:</span><br><span class="line">    qword_4F6850 = (__int64)v58;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)_RBX == <span class="number">1953391939</span> &amp;&amp; (_DWORD)_RCX == <span class="number">1936487777</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)_RDX != <span class="number">1215460705</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)_RCX != <span class="number">538995041</span> || (_DWORD)_RBX != <span class="number">1750278176</span> || (_DWORD)_RDX != <span class="number">1751608929</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_404000(&amp;v142, &amp;v143, &amp;v148, code);</span><br><span class="line">  _RAX = <span class="number">0x80000000</span>LL;</span><br><span class="line">  __asm &#123; cpuid &#125;</span><br><span class="line">  v64 = (<span class="type">unsigned</span> <span class="type">int</span>)_RAX;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)_RAX &gt; <span class="number">0x80000000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _RAX = <span class="number">2147483649LL</span>;</span><br><span class="line">    __asm &#123; cpuid &#125;</span><br><span class="line">    dword_4F6674 = _RAX;</span><br><span class="line">    dword_4F6678 = _RBX;</span><br><span class="line">    dword_4F667C = _RCX;</span><br><span class="line">    dword_4F6680 = _RDX;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v64 &gt; <span class="number">0x80000006</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _RAX = <span class="number">2147483655LL</span>;</span><br><span class="line">      __asm &#123; cpuid &#125;</span><br><span class="line">      dword_4F66B4 = _RAX;</span><br><span class="line">      dword_4F66B8 = _RBX;</span><br><span class="line">      dword_4F66BC = _RCX;</span><br><span class="line">      dword_4F66C0 = _RDX;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v64 != <span class="number">-2147483641</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _RAX = <span class="number">2147483656LL</span>;</span><br><span class="line">        __asm &#123; cpuid &#125;</span><br><span class="line">        dword_4F66D4 = _RAX;</span><br><span class="line">        dword_4F66D8 = _RBX;</span><br><span class="line">        dword_4F66DC = _RCX;</span><br><span class="line">        dword_4F66E0 = _RDX;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_404990(&amp;v142, v64, _RDX, _RCX);</span><br><span class="line">  v20 = v142;</span><br><span class="line">  v74 = v143 + v148;</span><br><span class="line">  v143 += v148;</span><br><span class="line">  <span class="keyword">if</span> ( v142 == <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v74 != <span class="number">15</span> &amp;&amp; v74 != <span class="number">25</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_107;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v142 != <span class="number">7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_107:</span><br><span class="line">      v17 = v143;</span><br><span class="line">      v18 = v144;</span><br><span class="line">      v19 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v74 != <span class="number">27</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v74 == <span class="number">59</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_4F664C &amp;= ~<span class="number">0x10000000</span>u;</span><br><span class="line">        LODWORD(qword_4F6668) = qword_4F6668 &amp; <span class="number">0xFFFFFFDF</span>;</span><br><span class="line">        dword_4F6754 &amp;= ~<span class="number">0x200</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_107;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v116 = dword_4F6754;</span><br><span class="line">  LODWORD(qword_4F6668) = qword_4F6668 &amp; <span class="number">0xFFFFFFDF</span>;</span><br><span class="line">  dword_4F664C &amp;= ~<span class="number">0x10000000</span>u;</span><br><span class="line">  BYTE1(v116) = BYTE1(dword_4F6754) &amp; <span class="number">0xFC</span> | <span class="number">1</span>;</span><br><span class="line">  dword_4F6754 = v116;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_107;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/re4mile/2022/06/07/linux/syscall/%E4%B8%AD%E6%96%AD%E8%AF%A6%E8%AE%B2/048-063/linux/">Linux syscall 048-063</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/re4mile/2021/06/07/ctf/%E5%81%9A%E9%A2%98%E5%8F%8D%E6%80%9D/ctf/">CTF习题有感</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="re4mile/wp" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/re4mile/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
