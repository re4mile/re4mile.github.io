<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>x86汇编语言实践部分 | ❄️</title><meta name="author" content="re4mile"><meta name="copyright" content="re4mile"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="常用指令系统x64 汇编网 https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;index.html 伪指令伪指令在编译阶段起作用 没有对应的机器码 \ 换行符 连接上一句如 123456invoke	MessageBox,	\NULL,				\offset A_Text,		\offset A_Title,		\MB_OKinvoke	ExitProcess,NULL  \它的">
<meta property="og:type" content="article">
<meta property="og:title" content="x86汇编语言实践部分">
<meta property="og:url" content="https://gitee.com/re4mile/re4mile.git/2021/06/07/language/Asm/windwos/%E6%8C%87%E4%BB%A4/language/index.html">
<meta property="og:site_name" content="❄️">
<meta property="og:description" content="常用指令系统x64 汇编网 https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;index.html 伪指令伪指令在编译阶段起作用 没有对应的机器码 \ 换行符 连接上一句如 123456invoke	MessageBox,	\NULL,				\offset A_Text,		\offset A_Title,		\MB_OKinvoke	ExitProcess,NULL  \它的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/re4mile/re4mile.git/img/bk5.jpg">
<meta property="article:published_time" content="2021-06-07T01:00:00.000Z">
<meta property="article:modified_time" content="2022-12-29T03:48:17.836Z">
<meta property="article:author" content="re4mile">
<meta property="article:tag" content="Assembly">
<meta property="article:tag" content="x86">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/re4mile/re4mile.git/img/bk5.jpg"><link rel="shortcut icon" href="/re4mile/img/favicon.jpg"><link rel="canonical" href="https://gitee.com/re4mile/re4mile.git/2021/06/07/language/Asm/windwos/%E6%8C%87%E4%BB%A4/language/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/re4mile/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/re4mile/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'x86汇编语言实践部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-29 11:48:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/re4mile/img/wlq.jpg" onerror="onerror=null;src='img/banner.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/re4mile/archives/"><div class="headline">Articles</div><div class="length-num">65</div></a><a href="/re4mile/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a><a href="/re4mile/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/re4mile/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/archives/"><i class="fa-fw fas fa-archive"></i><span> 一路走来</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas  fa-bed"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://re4mile.gitee.io/re4mile/2022/11/30/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/"><i class="fa-fw fas fa-list-alt"></i><span> 任务清单</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://re4mile.notion.site/Recording-128f15b4906c43f19c64e7be1b6011cc"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/re4mile/img/bk5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/re4mile/">❄️</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/re4mile/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/archives/"><i class="fa-fw fas fa-archive"></i><span> 一路走来</span></a></div><div class="menus_item"><a class="site-page" href="/re4mile/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas  fa-bed"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://re4mile.gitee.io/re4mile/2022/11/30/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/"><i class="fa-fw fas fa-list-alt"></i><span> 任务清单</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://re4mile.notion.site/Recording-128f15b4906c43f19c64e7be1b6011cc"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">x86汇编语言实践部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-06-07T01:00:00.000Z" title="Created 2021-06-07 09:00:00">2021-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-29T03:48:17.836Z" title="Updated 2022-12-29 11:48:17">2022-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/re4mile/categories/Language/">Language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="x86汇编语言实践部分"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="常用指令系统"><a href="#常用指令系统" class="headerlink" title="常用指令系统"></a>常用指令系统</h1><p>x64 汇编网 <a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/index.html">https://www.felixcloutier.com/x86/index.html</a></p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令在编译阶段起作用</p>
<p>没有对应的机器码</p>
<h3 id="换行符-连接上一句"><a href="#换行符-连接上一句" class="headerlink" title="\ 换行符 连接上一句"></a>\ 换行符 连接上一句</h3><p>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke	MessageBox,	\</span><br><span class="line">NULL,				\</span><br><span class="line">offset A_Text,		\</span><br><span class="line">offset A_Title,		\</span><br><span class="line">MB_OK</span><br><span class="line">invoke	ExitProcess,NULL</span><br></pre></td></tr></table></figure>

<p><code>\</code>它的作用是连接上一句,使之成为一个整体</p>
<p>等效于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br></pre></td></tr></table></figure>



<h3 id="段指令"><a href="#段指令" class="headerlink" title="段指令"></a>段指令</h3><p>.code .data .data? .const .code这些事分段的伪指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat ,stdcall</span><br><span class="line">option casemap :none</span><br><span class="line">&lt;一些include指令&gt;</span><br><span class="line">.stack</span><br><span class="line">&lt;堆栈的大小&gt;</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有被初始化过的变量定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;一些常量的定义&gt;</span><br><span class="line">.code</span><br><span class="line">&lt;代码&gt;</span><br><span class="line">&lt;开始标号&gt;</span><br><span class="line">其它语句</span><br><span class="line">end&lt;开始标号&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>就书上的东西而言</p>
<p>x86下</p>
<p>.data .data? .const</p>
<h3 id="data"><a href="#data" class="headerlink" title=".data?"></a>.data?</h3><p>&lt;一些没有被初始化过的变量定义&gt;</p>
<p>在内存分配时,他们不占空间,编译器只是会记录这个位置区域的大小,而真正的使用它会在另外一个空间空间开辟</p>
<h3 id="const"><a href="#const" class="headerlink" title=".const"></a>.const</h3><p>&lt;一些常量,好比字符串,整形数据&gt;</p>
<p>可读不可写的常量区,如果写到这里来就会报错然后退出</p>
<p>x64下</p>
<h3 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h3><p>存放一些没有没有初始化的变量,不包含任何数值,</p>
<p>在编译阶段不会占据内存,在执行时像操作系统请求所需的内存,并初始化为0</p>
<p>如果执行时,没有足够的内存分配,程序会崩溃</p>
<p>一个例子,不是很理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">section .bss</span><br><span class="line">flist	resb 11</span><br></pre></td></tr></table></figure>

<p>于是就表示了filst是一个11字节的字符串</p>
<p>有一些这些类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resb 8位</span><br><span class="line">resw 16位</span><br><span class="line">resd 32位</span><br><span class="line">resq 64位</span><br></pre></td></tr></table></figure>

<p>声明一个数组</p>
<blockquote>
<p>arr resd 20</p>
</blockquote>
<p>还有一个例子就是</p>
<p>scanf的缓冲区与是放在.bss区域</p>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>放在了text节区</p>
<p>一般代码段时不可读不可写的,但是修改一些属性就可以</p>
<h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>书上说斩断时可读可写<code>可执行的</code>,woc???所以黑客攻击栈段?????</p>
<h3 id="equ-相等"><a href="#equ-相等" class="headerlink" title="equ 相等"></a>equ 相等</h3><p>EQU可以与C语言的define做一个比较</p>
<p>EQU相关的数据,内存不会给他分配空间</p>
<p>凡是遇到EQU定义的数据,系统就给你自动替换为了相应的字面量</p>
<p>3种情况</p>
<table>
<thead>
<tr>
<th align="center">左值</th>
<th align="center">EQU</th>
<th align="center">右值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dqx</td>
<td align="center">EQU</td>
<td align="center">&lt;“I am Dqx_Gh0st”,0&gt;或者&lt;1024*2&gt;</td>
<td align="center">凡是遇到Dqx就用相应的字符串或者数值替代</td>
</tr>
<tr>
<td align="center">xx</td>
<td align="center">EQU</td>
<td align="center">symble</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">xxx</td>
<td align="center">EQU</td>
<td align="center">表达式</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>既然与Define做了一个比较,那么的话define定义的都是常量,是不可以再次赋值的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">Just_A_Ejd  EQU &lt;&quot;Pess and key to continue...&quot;,0&gt;</span><br><span class="line">Just_A_Var EQU &lt;100*100&gt;</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	len					dd $-Arr</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,Just_A_Var</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>在IDA里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, 10000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>

<p>Just_A_Var被替换为了100*100</p>
<p>其实也不是这样</p>
<p>Just_A_Var会被替换位100*100,而不是100000</p>
<p>毕竟是一个字符串的替换,而不是u直接算出结果</p>
<h3 id="textequ-文本相等"><a href="#textequ-文本相等" class="headerlink" title="textequ 文本相等"></a>textequ 文本相等</h3><p>与EQU类似</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">&lt;指令表达式或者带“”的字符串&gt;</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">已经被创建的EQU宏</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">%数值</td>
</tr>
</tbody></table>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=20</span><br><span class="line">num  TEXTEQU %(x*10)</span><br><span class="line">move TEXTEQU &lt;mov&gt;</span><br><span class="line">init_ax  TEXTEQU &lt;move ax,num&gt;</span><br><span class="line"></span><br><span class="line">(略)</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	init_ax</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>在IDA里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     ax, 200</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我用EQU</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=20</span><br><span class="line">num TEXTEQU %(x*10)</span><br><span class="line">move EQU &lt;mov&gt;</span><br><span class="line">init_ax  EQU &lt;move ax,num&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在IDA里面可以得到一样的结果</p>
<h3 id="地址标号"><a href="#地址标号" class="headerlink" title="@@ 地址标号"></a>@@ 地址标号</h3><p>@@ 是当前的地址</p>
<p>@F会指向下一个最近的@@</p>
<p>@B会指向下上一个最近的@@</p>
<p>遵循就近原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	jmp @F</span><br><span class="line"></span><br><span class="line">@@:</span><br><span class="line">	invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br><span class="line"></span><br><span class="line">	jmp @B</span><br></pre></td></tr></table></figure>

<p>实现一个死循环</p>
<h3 id="type-获取数据类型的大小"><a href="#type-获取数据类型的大小" class="headerlink" title="type 获取数据类型的大小"></a>type 获取数据类型的大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">var dword ?</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	</span><br><span class="line">	mov eax,type var</span><br><span class="line">	mov eax,type start</span><br><span class="line">	mov eax,type near</span><br><span class="line">	mov eax,type far</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 0FF04h</span><br><span class="line">mov     eax, 0FF04h</span><br><span class="line">mov     eax, 0FF06h</span><br><span class="line">mov     eax, 4</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关于,start与near,far的标号值是固定的</p>
<h3 id="lengthof-计算数组元素的个数"><a href="#lengthof-计算数组元素的个数" class="headerlink" title="lengthof 计算数组元素的个数"></a>lengthof 计算数组元素的个数</h3><p>相比于C语言,</p>
<p>如果是整数数组,它的功能就是<code>sizeof(arr)/sizeof(arr[0])</code></p>
<p>如果是字符串数组,它的功能就是<code>strlen(str)</code></p>
<p>它会返回一个32位的数值</p>
<p>关于细节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	arr1 db 1,2,3,4</span><br><span class="line">			db 5,6,7,8</span><br><span class="line">	ptr_arr dd arr1</span><br><span class="line"></span><br><span class="line">	arr2 dw 1,2,3,4,</span><br><span class="line">				5,6,7,8</span><br><span class="line">	ptr_arr2 dd arr2</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,lengthof arr1;我感觉offset的就像C语言的取地址运算符&amp;</span><br><span class="line"></span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,lengthof arr2</span><br><span class="line">	;mov eax,lengthof ptr_arr2</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>IDA源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 4</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 8</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>①.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 	db 1,2,3,4</span><br><span class="line">		db 5,6,7,8</span><br><span class="line">ptr_arr dd arr1</span><br></pre></td></tr></table></figure>

<p>第2行与第1行没有关系</p>
<p>lengthof&#x3D;4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 db 1,2,3,4,</span><br><span class="line">	 db 5,6,7,8</span><br><span class="line">ptr_arr dd arr1</span><br></pre></td></tr></table></figure>

<p>这样写会报错</p>
<p><code>,</code>逗号的意思…..你可以看作第一行与第二行之间有很多的空格,那个逗号就是连接的</p>
<p>报错的原有?</p>
<p>这么看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 db 1,2,3,4 ,db 5,6,7,8</span><br></pre></td></tr></table></figure>

<p>这样当然会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 db 1,2,3,4 db 5,6,7,8</span><br></pre></td></tr></table></figure>

<p>这样就不会报错</p>
<p>但是第二个db和第一个db就不不再有联系了(对于lengthof)的话</p>
<h3 id="sizeof-x2F-size-返回数组的总字节数"><a href="#sizeof-x2F-size-返回数组的总字节数" class="headerlink" title="sizeof&#x2F;size 返回数组的总字节数"></a>sizeof&#x2F;size 返回数组的总字节数</h3><p>可以形象的比喻它为</p>
<p>type x lengthof</p>
<p>数组单元个数x每个单元的字节数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">var dword ?</span><br><span class="line">arr word 4 dup(0)</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	</span><br><span class="line">	mov eax,size var</span><br><span class="line">	mov eax,sizeof var</span><br><span class="line">	mov eax,size arr</span><br><span class="line">	mov eax,sizeof arr</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 4</span><br><span class="line">mov     eax, 4</span><br><span class="line">mov     eax, 8</span><br><span class="line">mov     eax, 8</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>

<p>使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1		db  &quot;hello,I am dqx_Gh0st&quot;,0</span><br><span class="line">arr2		db   sizeof arr1 dup(0)</span><br></pre></td></tr></table></figure>

<p>返回的结果是21,字符串长度+1,那个1是0的占位</p>
<h3 id="typedef-定义新的类型"><a href="#typedef-定义新的类型" class="headerlink" title="typedef 定义新的类型"></a>typedef 定义新的类型</h3><p>可以与C语言联想</p>
<p>但是不同于C语言</p>
<p>C语言</p>
<p>typedef+原来的类型+新的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *ptr B_ptr</span><br></pre></td></tr></table></figure>

<p>x86汇编</p>
<p>新的类型+typedef+老的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B_ptr typedef  ptr byte</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title Dqx_Gh0st</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD	</span><br><span class="line"></span><br><span class="line">db_ptr typedef ptr byte</span><br><span class="line">dw_ptr typedef ptr word</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	arr1		db 9,8,7,6,5,4,3,2</span><br><span class="line">	arr2		dw 9,8,7,6,5,4,3,2,1</span><br><span class="line">	ptr1		dd arr1	</span><br><span class="line">	ptr2     dd arr2</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	......................</span><br></pre></td></tr></table></figure>

<h3 id="地址计数器"><a href="#地址计数器" class="headerlink" title="$ 地址计数器"></a>$ 地址计数器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	temp dd $	;偏移地址的长度data:00405000,可见它是一个4字节的长度,我们要用dd来获取</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,temp;eax就获取了temp的偏移地址</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>于是你在IDA里面看到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, off_405000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>

<p>temp直接就转化为了一个地址的变量名称</p>
<p>以前的变量名称是temp</p>
<p>写在变为了off_405000</p>
<p>40500就是偏移地址</p>
<p>源代码的data</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	temp 			dd $</span><br></pre></td></tr></table></figure>

<p>IDA里面是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	off_405000      dd offset off_405000    </span><br></pre></td></tr></table></figure>



<h4 id="获取当前位置的偏移地址"><a href="#获取当前位置的偏移地址" class="headerlink" title="获取当前位置的偏移地址"></a>获取当前位置的偏移地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end				dd $</span><br></pre></td></tr></table></figure>

<p>Arr_end就是它的当前的偏移地址</p>
<p>就是获取一个偏移地址,至于后面怎么样再说</p>
<h4 id="计算数组长度"><a href="#计算数组长度" class="headerlink" title="计算数组长度"></a>计算数组长度</h4><h5 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h5><p>计算数组的长度</p>
<p>数组的第一个元素会有一个偏移量</p>
<p>数组的最后一个元素也会有一个偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end				dd $</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data:00405000 unk_405000      db    1                 ; Arr</span><br><span class="line">.data:00405001                 db    2</span><br><span class="line">.data:00405002                 db    3</span><br><span class="line">.data:00405003                 db    4</span><br><span class="line">.data:00405004                 db    5</span><br><span class="line">.data:00405005                 db    6</span><br><span class="line">.data:00405006                 db    7</span><br><span class="line">.data:00405007                 db    8</span><br><span class="line">.data:00405008                 db    9</span><br><span class="line">.data:00405009                 db  14h</span><br><span class="line">.data:0040500A                 dd offset unk_405000;Arr_end不太理解IDA里面为什是offset unk_405000,而不是offset unk_40500A</span><br></pre></td></tr></table></figure>

<p>Arr		-&gt;xxxx5000</p>
<p>Arr_end-&gt;xxxx500A</p>
<p>0xA-0x0&#x3D;10</p>
<p>于是就有10个数据</p>
<p>你可能会想到10个元素</p>
<p>最后一个元素index&#x3D;9,</p>
<p>第一个元素    index&#x3D;0</p>
<p>9-0&#x3D;9</p>
<p>得到数字9</p>
<p>你也知道这样得到的数据是不对的,9只是[0]和[9]的差量</p>
<p>len&#x3D;10是[10]和[0]的差量</p>
<p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end			dd $</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov ax,Arr_end-Arr</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     ax, 10</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>



<h5 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h5><p>更加常见的的计算方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	len					dd $-Arr</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,len</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<p>data</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data:00405000                 db    1</span><br><span class="line">.data:00405001                 db    2</span><br><span class="line">.data:00405002                 db    3</span><br><span class="line">.data:00405003                 db    4</span><br><span class="line">.data:00405004                 db    5</span><br><span class="line">.data:00405005                 db    6</span><br><span class="line">.data:00405006                 db    7</span><br><span class="line">.data:00405007                 db    8</span><br><span class="line">.data:00405008                 db    9</span><br><span class="line">.data:00405009                 db  0Ah</span><br><span class="line">.data:0040500A dword_40500A    dd 10</span><br></pre></td></tr></table></figure>

<p>code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, dword_40500A;也就是10</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>



<h5 id="其它类型数组"><a href="#其它类型数组" class="headerlink" title="其它类型数组"></a>其它类型数组</h5><table>
<thead>
<tr>
<th>db</th>
<th>len&#x3D;($-Arr)</th>
</tr>
</thead>
<tbody><tr>
<td>dw</td>
<td>len&#x3D;($-Arr)&#x2F;2</td>
</tr>
<tr>
<td>dd</td>
<td>len&#x3D;($-Arr)&#x2F;4</td>
</tr>
</tbody></table>
<p>….</p>
<h3 id="x3D-等号指令"><a href="#x3D-等号指令" class="headerlink" title="&#x3D;  等号指令"></a>&#x3D;  等号指令</h3><p>&#x3D;指令的对象是一个32位长度的数据</p>
<p>它的优点….利于代码的维护与修改</p>
<p>在我对C语言或者C++不明白的情况下</p>
<p>我觉得<code>=指令</code>给我的感觉就是一个全局的变量</p>
<p>无论你在后面赋值还是前面赋值,系统都可以为你找到数据然后赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">	x=100</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>无论怎么样.在IDA里面都是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc near               ; CODE XREF: start↑j</span><br><span class="line">mov     eax, 100</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>



<p>加深一下理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=1</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		xor eax,eax	</span><br><span class="line">		x=100</span><br><span class="line">		mov eax,x</span><br><span class="line">		x=1000</span><br><span class="line">		mov eax,x</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>在DIA里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proc near               ; CODE XREF: start↑j</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 100</span><br><span class="line">mov     eax, 1000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028      endp</span><br></pre></td></tr></table></figure>





<h3 id="high-x2F-low-x2F-highword-x2F-lowword"><a href="#high-x2F-low-x2F-highword-x2F-lowword" class="headerlink" title="high&#x2F;low&#x2F;highword&#x2F;lowword"></a>high&#x2F;low&#x2F;highword&#x2F;lowword</h3><p>他可以取出高8位,低8位,高16位,低16位的数据</p>
<p>他的操作数是立即数,不是变量,不是寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	mov ah,high 1234h</span><br><span class="line">	mov al,low  1234h</span><br><span class="line"></span><br><span class="line">	mov ax,highword 12345678h</span><br><span class="line">	mov ax,lowword  12345678h</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     ah, 12h</span><br><span class="line">mov     al, 34h ; &#x27;4&#x27;</span><br><span class="line">mov     ax, 1234h</span><br><span class="line">mov     ax, 5678h</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>



<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>（1）LENGTH,SIZE,WIDTH,MASK. (),[],(结构体),&lt;&gt;。<br>（2）PTR,OFFSET,TYPE,SEG,THIS,冒号。冒号用于表示段超越前缀。<br>（3）*，&#x2F;，MOD，SHL,SHR<br>（4）HIGH,LOW<br>（5）+，-<br>（6）EQ,NE,LT,LE,GT,GE<br>（7）NOT<br>（8）AND<br>（9）OR,XOR<br>（10）SHORT</p>
<h2 id="非伪指令"><a href="#非伪指令" class="headerlink" title="非伪指令"></a>非伪指令</h2><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>在C语言下,字节对齐可以自己规定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line">struct str</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#pragma pack()</span><br></pre></td></tr></table></figure>

<p>每个成员所占空间是字节对齐的倍数,不足就补0</p>
<h4 id="align"><a href="#align" class="headerlink" title="align"></a>align</h4><p>可以联想一下<code>nop</code>,这里的<code>algin</code>会填充空字节,也就是填充0</p>
<p>然后algin的原理是个啥</p>
<p>最后的结果就是让下一个数据的地址是1&#x2F;2&#x2F;4&#x2F;8&#x2F;16的倍数</p>
<p>好比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db1		byte	1</span><br><span class="line">db2		byte	2</span><br><span class="line">align	4		;让dw1的地址是4的倍数  </span><br><span class="line">dw1		word    3 </span><br><span class="line">align	2		;让dd1的地址是2的倍数</span><br><span class="line">dd1		dword	4</span><br><span class="line">dd2		dword	5</span><br><span class="line">align	4  		;让db3的地址是4的倍数</span><br><span class="line">db3		byte	6</span><br></pre></td></tr></table></figure>



<p>为了得到这些倍数,他就通过在前面补充0来填充字节</p>
<p>另外之一下</p>
<p>align 4 不是说真的填充4字节</p>
<p>align 16 也不是说填充16字节</p>
<p>可能还是填充2字节,4字节,,看地址情况而定</p>
<p>algin的主要功能之一</p>
<p>16&#x2F;32位 字节对齐</p>
<p>这对寻址很有帮助</p>
<h4 id="alignb"><a href="#alignb" class="headerlink" title="alignb"></a>alignb</h4><h3 id="BCD码指令-gt-fld-fbstp"><a href="#BCD码指令-gt-fld-fbstp" class="headerlink" title="BCD码指令-&gt;fld,fbstp"></a>BCD码指令-&gt;fld,fbstp</h3><p>见&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page-60</p>
<h3 id="inc-x2F-dec-x2F-add-x2F-sub"><a href="#inc-x2F-dec-x2F-add-x2F-sub" class="headerlink" title="inc&#x2F;dec&#x2F;add&#x2F;sub"></a>inc&#x2F;dec&#x2F;add&#x2F;sub</h3><p>自己百度</p>
<h3 id="dup-数据重复"><a href="#dup-数据重复" class="headerlink" title="dup 数据重复"></a>dup 数据重复</h3><p>db 128 dup(0)表示重复128个1,单位字节</p>
<p>db 128 dup(‘1’)表示重复128个字符’1’,单位字节</p>
<p>db 128 dup(?) 表示没有初始化</p>
<h3 id="offset-就取处偏移地址"><a href="#offset-就取处偏移地址" class="headerlink" title="offset 就取处偏移地址"></a>offset 就取处偏移地址</h3><p>他的对象是一个常数地址,不会发生变化,编译器遇到offset就会寻找那个偏移地址,然后<code>ofset xxx = 地址常量</code></p>
<blockquote>
<p>为什么?</p>
<p>offset 用于全局变量</p>
<p>全局变量是不会消失的</p>
<p>所以offset的操作数是一个全局的常量</p>
<p>在编译阶段直接由编译器赋值</p>
</blockquote>
<p>在之前我们有这样的写法</p>
<p>8086中,只能把数组写到代码段寻址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">start:</span><br><span class="line">	....</span><br><span class="line">	mov si,Arr1</span><br></pre></td></tr></table></figure>

<p>于是我们就可以获取偏移地址</p>
<p>在x86中,可以把数组写进data段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">.code</span><br><span class="line">	mov ax,[Arr1+1]</span><br></pre></td></tr></table></figure>

<p>于是我,们就可以直接把数组名当中地址来用</p>
<p>为了更加的严谨.利于代码的阅读性与维护性</p>
<p>我们用offset</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">	ptr_arr dd Arr1</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	mov esi,offset Arr1;我感觉offset的就像C语言的取地址运算符&amp;</span><br><span class="line">	mov edi,ptr_arr;一个指针,</span><br><span class="line">	mov al,[esi]</span><br><span class="line">	mov ah,[edi]</span><br></pre></td></tr></table></figure>

<p>offset返回的数据是一个对应位数的偏移地址</p>
<p>8086的offset返回2字节</p>
<p>x86的offset返回4字节</p>
<h3 id="lea-取地址"><a href="#lea-取地址" class="headerlink" title="lea 取地址"></a>lea 取地址</h3><p>不同于offset,offset是编译是直接获取的常量地址</p>
<p>lea是运行时动态的算出每一次地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea Des,Src</span><br></pre></td></tr></table></figure>



<p>lea eax,dword ptr ds:[ebx]</p>
<p>其中eax&#x3D;ebx</p>
<h3 id="ptr-重写操作数大小类型"><a href="#ptr-重写操作数大小类型" class="headerlink" title="ptr 重写操作数大小类型"></a>ptr 重写操作数大小类型</h3><p>8686下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,arr[1*2]</span><br></pre></td></tr></table></figure>

<p>ax就决定了数组的数据长度</p>
<p>x86下就离谱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, byte ptr ptr1[1*(type arr1)]</span><br><span class="line">mov ax, word ptr ptr2[1*(type arr2)]</span><br></pre></td></tr></table></figure>

<p>非要这样写,否者就报错</p>
<p>对于一个好比4字节的数据</p>
<p>你可以对它的2个字节2个字节的访问</p>
<p>或者8个字节8个字节的访问,这就会访问4字节后面的4字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	x dw 4321h</span><br><span class="line">	y dw 8765h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,dword ptr x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Attributes: noreturn</span><br><span class="line"></span><br><span class="line">sub_652028 proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, dword_654000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_652028 endp</span><br></pre></td></tr></table></figure>

<p>最后EAX&#x3D;87654321h</p>
<h3 id="xchg-交换指令"><a href="#xchg-交换指令" class="headerlink" title="xchg 交换指令"></a>xchg 交换指令</h3><p><code>xchg x,y</code>那么x,y的数据会交换</p>
<p>如何交换2个数?还是要用到第3者</p>
<p>对于操作数,必须2个必须是可读可写的变量</p>
<p>way1-我自己想的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xchg x,eax		</span><br><span class="line">xchg y,eax		</span><br><span class="line">xchg x,eax		</span><br></pre></td></tr></table></figure>

<p>way-2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,x</span><br><span class="line">xchg y,eax</span><br><span class="line">mov x,eax</span><br></pre></td></tr></table></figure>

<p>way-3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov temp,x</span><br><span class="line">mov x,y</span><br><span class="line">mov y,temp</span><br></pre></td></tr></table></figure>









<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>本质是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push next_IP</span><br><span class="line">jmp call_func_location</span><br></pre></td></tr></table></figure>

<p>回归到CPU执行指令的原理</p>
<p>读取当前指令到BUFF</p>
<p>IP&#x3D;下一个IP</p>
<p>CPU执行BUFF</p>
<p>那么的话,当我们执行了Call会,IP&#x3D;下一个IP</p>
<p>那么的话call会就会push下一个指令的ip</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">call s </span><br><span class="line">然后会push ip</span><br><span class="line"></span><br><span class="line">ret </span><br><span class="line">然后会</span><br><span class="line">pop ip</span><br><span class="line"></span><br><span class="line">call far ptr </span><br><span class="line">然后会</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line">然后会</span><br><span class="line">pop ip, pop cs</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>对一般的call</p>
<p>它就是push一些东西</p>
<p>然后再 jmp 到 call 的那个地址</p>
<p>再次说一遍,我们是push 地址,不是push一个指令</p>
<p>对far ptr</p>
<p>push cs</p>
<p>push ip</p>
<p>对于数据,肯定还要pop</p>
<p>就是</p>
<p>pop ip</p>
<p>pop cs</p>
<p>call word ptr ds:[xx]    会 push ip</p>
<p>call dword ptr ds:[xx]  会push cs, push ip</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><blockquote>
<p>loop的代码执行效率会比jmp慢,所以在实际的调试时,很少出现loop,都是一些条件跳转</p>
</blockquote>
<p>loop也有很多的形式</p>
<p>他们对计数器的要求会不同</p>
<p>他们对程序的指令的兼容性也会不同</p>
<p>遇到就查吧</p>
<p>add会偷偷修改标志寄存器</p>
<p>所以在使用寄存器的时候你要注意那些寄存器的变化</p>
<p>判断是否循环的原则</p>
<p>先对ecx&#x2F;cx作运算</p>
<p>然后看是否为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">	   	mov ax,0</span><br><span class="line">       	mov cx,4</span><br><span class="line"></span><br><span class="line">func:   add ax,2</span><br><span class="line">        loop func</span><br><span class="line">	  	mov ax,4c00h</span><br><span class="line">	   	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>对于嵌套的LOOP循环,要记住push cx和pop cx,并且注意中途少用cx</p>
<p>对于这种机制,要注意的是</p>
<p>高级语言往往是先检验是否为0,再执行cx-1</p>
<p>Loop是先执行cx-1,再去判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,0</span><br><span class="line">add_sum:</span><br><span class="line">	add eax,arr[esi]</span><br><span class="line">	inc esi</span><br><span class="line">	loop add_sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它会是一个很大的循环</p>
<p>一直到ecx发生溢出或者进位,他就为0了</p>
<h3 id="cmpxchg"><a href="#cmpxchg" class="headerlink" title="cmpxchg"></a>cmpxchg</h3><p>他有2个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmpxchg x,y</span><br></pre></td></tr></table></figure>

<p>用高级语言解释一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(eax==x)</span><br><span class="line">&#123;</span><br><span class="line">    x=y;</span><br><span class="line">    ZF=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    eax=x;</span><br><span class="line">    ZF=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>在我的电脑上无法运行该指令</p>
<h3 id="bsr-x2F-bsf-位扫描"><a href="#bsr-x2F-bsf-位扫描" class="headerlink" title="bsr&#x2F;bsf 位扫描"></a>bsr&#x2F;bsf 位扫描</h3><blockquote>
<p> 数值的下标是这样安排的</p>
<p> 最右边是index&#x3D;0</p>
<p> 最左边是index&#x3D;xx</p>
<p> 字符串的下标</p>
<p> 做左边是index&#x3D;0</p>
<p> 最右边是index&#x3D;xx</p>
</blockquote>
<p>bsf :Bit Scan Forward</p>
<p>bsr :Bit Scanf Reverse</p>
<p>反汇编会被翻译为函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_BitScanReverse()</span><br></pre></td></tr></table></figure>

<p>bsf指令的功能: 从右往左扫描,正向寻取 二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值</p>
<p>bsr指令的功能: 从左往右扫描 逆向寻取 寻取二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值</p>
<p>如果找到1,说明value!&#x3D;0,那么ZF&#x3D;0</p>
<p>如果找不到1,,说明value&#x3D;&#x3D;0,那么ZF&#x3D;1</p>
<p>好比1101,</p>
<p>用bsr寻取到index&#x3D;3,最左边是[3]&#x3D;1</p>
<p>用bsf寻取到index&#x3D;0,最右边是[0]&#x3D;1</p>
<p>这不同于字符串的index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsr ecx ,vale</span><br></pre></td></tr></table></figure>

<p>那么他就把value的1值最高位返回给ecx</p>
<p>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>
<h3 id="bswap-字节反向存储"><a href="#bswap-字节反向存储" class="headerlink" title="bswap 字节反向存储"></a>bswap 字节反向存储</h3><p>好比</p>
<p>mov eax,12345678h</p>
<p>bswap eax</p>
<p>eax&#x3D;78563412h</p>
<h3 id="return返回"><a href="#return返回" class="headerlink" title="return返回"></a>return返回</h3><p>虽然本质是pop ip</p>
<p>其实我们可以在栈里面修改它那个ip,然后在pop出去</p>
<p>这就很妙</p>
<h4 id="ret近转移"><a href="#ret近转移" class="headerlink" title="ret近转移"></a>ret近转移</h4><p><code>本质</code>是<code>pop ip</code></p>
<p>他是近转移</p>
<p>ret 后面也可以带参数</p>
<p>ret 8</p>
<p>masm32下表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip </span><br><span class="line">add esp+8</span><br></pre></td></tr></table></figure>

<h4 id="retn-近转移"><a href="#retn-近转移" class="headerlink" title="retn 近转移"></a>retn 近转移</h4><p>意思是ret near</p>
<p>retn操作：pop eip</p>
<p>retn N操作：先pop eip，然后add esp,N</p>
<p>retn 其实等价于 ret</p>
<h4 id="retf-远转移"><a href="#retf-远转移" class="headerlink" title="retf 远转移"></a>retf 远转移</h4><p>他是段间转移</p>
<p>可以修改CS:IP</p>
<blockquote>
<p>  先pop IP</p>
<p>  后pop CS</p>
<p>  因为之前有push cs,push ip</p>
</blockquote>
<p>把栈顶的word数据给IP</p>
<p>又把下一个栈顶word数据给CS</p>
<h4 id="iret-中断返回"><a href="#iret-中断返回" class="headerlink" title="iret 中断返回"></a>iret 中断返回</h4><p>中断过程中的iret</p>
<p>他会实现</p>
<p>pop ip</p>
<p>pop cs</p>
<p>popf</p>
<h3 id="二进制第i位操作"><a href="#二进制第i位操作" class="headerlink" title="二进制第i位操作"></a>二进制第i位操作</h3><p>从右往左寻找二进制的1</p>
<h4 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位传递给CF,然后,[2]位不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_bittest()</span><br></pre></td></tr></table></figure>



<h4 id="btc"><a href="#btc" class="headerlink" title="btc"></a>btc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btc eax,2</span><br></pre></td></tr></table></figure>

<p>将eax的第[2]传递给CF,把[2]取反</p>
<h4 id="btr"><a href="#btr" class="headerlink" title="btr"></a>btr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btr eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位给CF,然后置[2]位为0</p>
<h4 id="bts"><a href="#bts" class="headerlink" title="bts"></a>bts</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bts eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位给CF,然后置[2]位为1</p>
<h3 id="CPU控制指令"><a href="#CPU控制指令" class="headerlink" title="CPU控制指令"></a>CPU控制指令</h3><h4 id="nop"><a href="#nop" class="headerlink" title="nop"></a>nop</h4><p>该指令的执行不会影响任何标志寄存器</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>让CPU处于等待状态,直到协处理器完成运算</p>
<p>问题来了,什么叫协处理器</p>
<h4 id="hlt-暂停指令"><a href="#hlt-暂停指令" class="headerlink" title="hlt 暂停指令"></a>hlt 暂停指令</h4><p>执行了hlt后,CPU处于暂停的工作状态,</p>
<p>EIP指向HLT的下一条指令</p>
<p>把EIP入栈</p>
<p>当产生了reset信号或者中断请求信号时,才会eip出栈,CPU继续执行</p>
<p>关于中断的产生,CPU强制去执行中断</p>
<p>CPU转去处理中断程序后,中断结束,iret弹出EIP,并唤醒HLT的下一条指令,这样CPU退出了暂停</p>
<p>所以这个IRET还是强大呀</p>
<h4 id="lock-封锁数据"><a href="#lock-封锁数据" class="headerlink" title="lock 封锁数据"></a>lock 封锁数据</h4><p>它是一个前缀指令</p>
<p>就像rep movsb指令套</p>
<p>lock会跟一个操作指令</p>
<p>lock可以保证在其后指令的执行过程中,禁止协处理器修改数据总线</p>
<p>起到单独占线的占用,该指令不会影响寄存器</p>
<h4 id="cpuid-获取CPU信息"><a href="#cpuid-获取CPU信息" class="headerlink" title="cpuid 获取CPU信息"></a>cpuid 获取CPU信息</h4><p>这应该与端口相关吧….</p>
<p>x86模式下</p>
<p>初始化eax,然后调用cpuid在最后在ebx&#x2F;edx&#x2F;ecx检查该值</p>
<p>x64模式下</p>
<p>初始化eax,然后调用cpuid在最后在ecx&#x2F;edx中检查该值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getcpu</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> b_str[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ret=getcpu(b_str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ID:%u %s&quot;</span>,ret,b_str);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getcpu</span><span class="params">(<span class="type">char</span>* b_str)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		mov eax,<span class="number">0</span></span><br><span class="line">		cpuid</span><br><span class="line">		mov eax,b_str</span><br><span class="line">		mov [eax],ebx</span><br><span class="line">		mov [eax+<span class="number">4</span>],edx</span><br><span class="line">		mov [eax+<span class="number">8</span>],ecx</span><br><span class="line">		mov eax,<span class="number">1</span></span><br><span class="line">		cpuid</span><br><span class="line">		mov eax,edx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>一般汇编语言的跳转判断是根据指定条件的相反条件</p>
<p>若满足相反条件就就指向else</p>
<p>否则顺序执行后面的语句</p>
<p>浮点数的比较</p>
<p>fcomp会影响FPU的寄存器</p>
<p>fcomi指令字节影响CPU的eflag</p>
<h4 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>CPU如何指令命令?</p>
<ol>
<li><p>CPU从CS:IP读取指令到buff</p>
</li>
<li><p>IP&#x3D;IP+刚才读取的指令长度</p>
<p>于是IP指向了下一条指令</p>
</li>
<li><p>CPU执行buff的指令</p>
</li>
</ol>
<p>CPU又开始读取IP,循环操作上面的操作</p>
<h5 id="机器码剖析"><a href="#机器码剖析" class="headerlink" title="机器码剖析"></a>机器码剖析</h5><p><img src="D:\JGY\P0st\Pho\Asm-指令\image-20220804220620675.png" alt="image-20220804220620675"></p>
<p>那么jmp的话</p>
<p>就是 <code>EB xx</code></p>
<p>那个<code>xx</code>就是一个偏移地址,这个偏移地址的基地址是jmp后面那个指令的开始字节,从字节数0开始数</p>
<p>然后,偏移到jmp的地方</p>
<p><code>xx</code>快速计算的方法就是</p>
<p>跳到那里的地址-jmp后的那个IP&#x3D;xx</p>
<p>xx是一个有符号的数值</p>
<p>比如0x00-0xFF</p>
<p>其中0x00-0x7F是往前跳</p>
<p>0x7F-0xFF是往后面跳</p>
<h5 id="其它jmp"><a href="#其它jmp" class="headerlink" title="其它jmp"></a>其它jmp</h5><p> jmp far ptr   段间转移   跳转范围 -32768~32767</p>
<p> jmp short ptr 段转移     跳转的范围小于128字节</p>
<p> jmp  word ptr ds:[0]	会取ds: [0] [1] 位ip地址</p>
<p> jmp  dword ptr ds:[1]   取[0] [1]为ip,[2] [3]为cs</p>
<p> jmp  byte ptr ds:[1]</p>
<h4 id="cmp-有符号-x2F-无符号"><a href="#cmp-有符号-x2F-无符号" class="headerlink" title="cmp-有符号&#x2F;无符号"></a>cmp-有符号&#x2F;无符号</h4><p>对于数值的cmp</p>
<p>&#x3D;&#x3D;你若看作是无符号比较,就只看ZF&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;你若看作有符号的比较,就看SF&#x2F;OF,或者ZF&#x3D;&#x3D;</p>
<p>CPU将cmp指令得到的结果记录在flag的相关标志位中，我们可以根据指令执行后，相关标志位的值来判断比较的结果。单纯的考察SF的值不可能知道结果的正负</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmp al,bl</span><br><span class="line"></span><br><span class="line">SF=1,OF=0 al&lt;bl</span><br><span class="line">SF=1,OF=1 al&gt;bl	 SF=OF</span><br><span class="line">如果因为溢出导致的实际结果为负数,那么真正的结果为正数</span><br><span class="line"></span><br><span class="line">SF=0,OF=1 al&lt;bl</span><br><span class="line">SF=0,OF=0 al&gt;nl SF==OF</span><br><span class="line">如果因为溢出导致的实际结果为正数,那么真正的结果为负数</span><br><span class="line"></span><br><span class="line">OF==SF 才会有大于</span><br></pre></td></tr></table></figure>



<p>je 相等就跳转</p>
<p>jne 不相等就跳转</p>
<p>jb      jmp blow 小于就跳转</p>
<p>jnb     jmp not blow 大于等于就跳转</p>
<p>ja      jmp above 大于就跳转</p>
<p>jna     jmp not above 小于等于就跳转</p>
<h4 id="eflag跳转"><a href="#eflag跳转" class="headerlink" title="eflag跳转"></a>eflag跳转</h4><table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th>标志位&#x2F;寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>JZ</td>
<td>为零跳转</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>JNZ</td>
<td>非零跳转</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>JC</td>
<td>进位跳转</td>
<td>CF&#x3D;1</td>
</tr>
<tr>
<td>JNC</td>
<td>无进位跳转</td>
<td>CF&#x3D;0</td>
</tr>
<tr>
<td>JO</td>
<td>溢出跳转</td>
<td>OF&#x3D;1</td>
</tr>
<tr>
<td>JNO</td>
<td>无溢出跳转</td>
<td>OF&#x3D;0</td>
</tr>
<tr>
<td>JS</td>
<td>有符号跳转</td>
<td>SF&#x3D;1</td>
</tr>
<tr>
<td>JNS</td>
<td>无符号跳转</td>
<td>SF&#x3D;0</td>
</tr>
<tr>
<td>JP</td>
<td>偶校验跳转</td>
<td>PF&#x3D;1</td>
</tr>
<tr>
<td>JNP</td>
<td>奇校验跳转</td>
<td>PF&#x3D;0</td>
</tr>
</tbody></table>
<p>STC 让CF&#x3D;1</p>
<p>CLC 让CF&#x3D;0</p>
<p>CMC 让CF取反</p>
<h4 id="相等跳转"><a href="#相等跳转" class="headerlink" title="相等跳转"></a>相等跳转</h4><p>用cmp判断</p>
<table>
<thead>
<tr>
<th align="center">助记符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JE&#x2F;JZ</td>
<td>相等跳转 (leftOp&#x3D;rightOp)</td>
</tr>
<tr>
<td align="center">JNE&#x2F;JNZ</td>
<td>不相等跳转 (leftOp M rightOp)</td>
</tr>
<tr>
<td align="center">JCXZ</td>
<td>CX&#x3D;0 跳转</td>
</tr>
<tr>
<td align="center">JECXZ</td>
<td>ECX&#x3D;0 跳转,你在8086用的比较多</td>
</tr>
<tr>
<td align="center">JRCXZ</td>
<td>RCX&#x3D;0 跳转（64 位模式）</td>
</tr>
</tbody></table>
<h4 id="无符号跳转"><a href="#无符号跳转" class="headerlink" title="无符号跳转"></a>无符号跳转</h4><p>above&#x2F;below</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>JA&#x3D;JNBE</td>
<td>&gt;</td>
<td>CF|ZF&#x3D;0</td>
<td></td>
</tr>
<tr>
<td>JB&#x3D;JNAE</td>
<td>&lt;</td>
<td>CF&#x3D;1</td>
<td></td>
</tr>
<tr>
<td>JAE&#x3D;JNB</td>
<td>&gt;&#x3D;</td>
<td>CF&#x3D;0</td>
<td></td>
</tr>
<tr>
<td>JNA&#x3D;JBE</td>
<td>&lt;&#x3D;</td>
<td>CF|ZF&#x3D;1</td>
<td></td>
</tr>
</tbody></table>
<h4 id="有符号的跳转"><a href="#有符号的跳转" class="headerlink" title="有符号的跳转"></a>有符号的跳转</h4><p>greate&#x2F;little</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>JG&#x3D;JNLE</td>
<td>&gt;</td>
<td align="center">(SF ^OF)|ZF&#x3D;0</td>
</tr>
<tr>
<td>JL&#x3D;JNGE</td>
<td>&lt;</td>
<td align="center">SF^OF&#x3D;1,意思SF &#x3D; OF</td>
</tr>
<tr>
<td>JGE&#x3D;JNL</td>
<td>&gt;&#x3D;</td>
<td align="center">SF ^ OF&#x3D;0,意思是SF! &#x3D; OF</td>
</tr>
<tr>
<td>JLE&#x3D;JNG</td>
<td>&lt;&#x3D;</td>
<td align="center">(SF^OF)|ZF&#x3D;1</td>
</tr>
</tbody></table>
<h4 id="测试条件转存指令"><a href="#测试条件转存指令" class="headerlink" title="测试条件转存指令"></a>测试条件转存指令</h4><h4 id="条件跳转的应用"><a href="#条件跳转的应用" class="headerlink" title="条件跳转的应用"></a>条件跳转的应用</h4><p>举个例子al是8位</p>
<p>把8位当作开关,于是我们来检测</p>
<h5 id="某一位是否开启"><a href="#某一位是否开启" class="headerlink" title="某一位是否开启"></a>某一位是否开启</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test al,10000000b</span><br><span class="line">jnz	xxx</span><br><span class="line">//开启了就ZF!=0,</span><br><span class="line">//没开启,ZF==1</span><br></pre></td></tr></table></figure>

<p>对于<code>10001000b</code></p>
<p>0位数据不管,检测那个1位,如果他也为1,那么最后ZF&#x3D;0.否则为1</p>
<h5 id="某几位当中是否有任意一位开启"><a href="#某几位当中是否有任意一位开启" class="headerlink" title="某几位当中是否有任意一位开启"></a>某几位当中是否有任意一位开启</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test al,10010001b</span><br><span class="line">jnz	xxx</span><br></pre></td></tr></table></figure>

<p>只要开启了一位,最后的ZF&#x3D;0,都没有开启就会ZF&#x3D;1</p>
<h5 id="某几位都开启"><a href="#某几位都开启" class="headerlink" title="某几位都开启"></a>某几位都开启</h5><p>要用减法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,10010001b</span><br><span class="line">cmp al,10010001b</span><br><span class="line">jz	xxx</span><br></pre></td></tr></table></figure>

<p>and把无关的位数都屏蔽了,留下了要检测的</p>
<p>然后一个cmp,如果都开启,最后结果就是0,ZF&#x3D;&#x3D;1</p>
<h5 id="求3个数的最小值"><a href="#求3个数的最小值" class="headerlink" title="求3个数的最小值"></a>求3个数的最小值</h5><p>假设x,y,z</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov eax,x</span><br><span class="line">cmp eax,y</span><br><span class="line">jbe next</span><br><span class="line">mov eax,y</span><br><span class="line">next:</span><br><span class="line">cmp	eax,z</span><br><span class="line">jbe	end</span><br><span class="line">mov	result,z</span><br><span class="line">end:</span><br><span class="line">mov	result,eax</span><br></pre></td></tr></table></figure>



<h5 id="数的比较"><a href="#数的比较" class="headerlink" title="数的比较"></a>数的比较</h5><p>char x&#x3D;0xff<br>char y&#x3D;0x1<br>比较x&#x2F;y    x&lt;y</p>
<p>unsigned char x&#x3D;0xff<br>unsigned char y&#x3D;0x1<br>比较x&#x2F;y    x&gt;y</p>
<p>在数的比较中,我们会对其进行扩展</p>
<p>好比8位的比较变化位32位了</p>
<p>无符号的比较也可能用来有符号的跳转,可能涉及了符号的扩展</p>
<h3 id="条件测试-与循环语句"><a href="#条件测试-与循环语句" class="headerlink" title="条件测试+与循环语句"></a>条件测试+与循环语句</h3><h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><h5 id="if-x2F-elseif-x2F-endif-x2F-else"><a href="#if-x2F-elseif-x2F-endif-x2F-else" class="headerlink" title=".if&#x2F;.elseif&#x2F;.endif&#x2F;.else"></a>.if&#x2F;.elseif&#x2F;.endif&#x2F;.else</h5><p>一个基本的条件循环是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>

<p>2面性判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.else</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>



<p>多面性判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.elseif</span><br><span class="line"></span><br><span class="line">.elseif</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>



<p>这些if语句会与跳转指令相挂钩</p>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>条件测试语句?</p>
<p>就是逻辑条件的判断…</p>
<p>masm条件测试的几个限制</p>
<p>表达式左边只能是常量&#x2F;寄存器</p>
<p>表达式2边不能同时是变量,可以是寄存器</p>
<p>另外表达式中不能是算术表达式,好比x*y&gt;0</p>
<p>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>一些标志寄存器的伪指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.if carry</span><br><span class="line">.if overflow</span><br><span class="line">.if parity</span><br><span class="line">.if sign</span><br><span class="line">.if zero</span><br></pre></td></tr></table></figure>





<p>条件的测试语句的伪指令见后面的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx);</span><br></pre></td></tr></table></figure>

<p>这句话实现有很多个跳转</p>
<p>这句判断的判断是一个顺序的结构</p>
<p>eax&#x3D;0,跑去判断var!&#x3D;ecx,</p>
<p>eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果是,就直接跳过后面的判断,直接执行</p>
<p>eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果不是,就去判断var!&#x3D;ecx,然后看是否要执行</p>
<p>所以这个判断还是有很多的jmp&#x2F;jnz&#x2F;jz的</p>
<p>很头疼</p>
<h5 id="天坑"><a href="#天坑" class="headerlink" title="天坑"></a>天坑</h5><p>1️⃣</p>
<p>关于那些条件条件跳转</p>
<p>他们也有sign与unsigned之分,</p>
<p>好比无符号的jb&#x2F;jnb</p>
<p>mov eax,1</p>
<p>jb eax,-1</p>
<p>那么的话-1是一个很大的值</p>
<p>对于无符号的比较指令好像书上写了</p>
<p>见cmp指令的跳转指令\</p>
<p>怎么在源代码里面避免这些情况???</p>
<p>办法一是把数据类型改为有符号的数,好比sword</p>
<p>办法二,强制类型转化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.if sword ptr eax &gt;0</span><br><span class="line">.if eax &gt; sword ptr 0</span><br></pre></td></tr></table></figure>





<p>2️⃣</p>
<p>条件指令就那几个</p>
<p>注意在前面加上点<code>.</code>,否则他就成为了宏指令</p>
<h5 id="代码示意"><a href="#代码示意" class="headerlink" title="代码示意"></a>代码示意</h5><p>可以调试一下它!!!!巨离谱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib		user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib		kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">var	dd	20</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		xor eax,eax</span><br><span class="line">		.if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx);把前面看作一个部分,如果前面2个返回1,那么后面就不在判断</span><br><span class="line">			mov esi,1</span><br><span class="line">		.elseif edx</span><br><span class="line">			mov esi,2</span><br><span class="line">		.elseif	esi &amp; 1</span><br><span class="line">			mov esi,3</span><br><span class="line">		.elseif	ZERO? &amp;&amp; CARRY?</span><br><span class="line">			mov esi,4</span><br><span class="line">		.endif</span><br><span class="line">			</span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>





<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>while&#x2F;endw&#x2F;repeat&#x2F;until&#x2F;untilcxz&#x2F;continue&#x2F;break</p>
<p>搭配</p>
<p>while-endw</p>
<p>repeat-until</p>
<p>repeat-untilcxz</p>
<p>while+表达式</p>
<p>表示一个循环执行的条件</p>
<p>一次循环结束就jmp到while那里再次判断是否执行</p>
<p>break&#x2F;continue就类别C语言就可以了,用于中途的跳出…</p>
<p>break到哪里去?while循环外的第一条语句</p>
<p>continue不会执行后面的代码,会jmp到循环开始的while</p>
<p>until+一个表达式</p>
<p>这个表达式是结束的表达式,也就是循环到什么时候结束</p>
<p>untilcxz是一个loop的盗版,他会ecx-&#x3D;1,判断ecx是否为0,然后执行loop一样的操作</p>
<p>它也可以接上一个表达式,那么的话,循环🔚的条件就变为了2个</p>
<p>loop指令不会影响标志寄存器的,是一个很好的选择</p>
<p>关于循环语句的伪指令见指令那一章节</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib		user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib		kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">szCaption	db	&#x27;Dqx-Gh0st&#x27;,0</span><br><span class="line">szText1		db	&#x27;I&#x27;,0</span><br><span class="line">szText2		db	&#x27;Love&#x27;,0</span><br><span class="line">szText3		db	&#x27;You&#x27;,0</span><br><span class="line">szText4		db	&#x27;Deeply&#x27;,0</span><br><span class="line">fuck		db	&#x27;fuck&#x27;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">var	dd	20</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">		</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		mov eax,5</span><br><span class="line">		.while	eax&gt;0</span><br><span class="line"></span><br><span class="line">			.if eax==4</span><br><span class="line">				dec eax</span><br><span class="line">				.continue</span><br><span class="line">				;continue后面的代码是不会执行的,可以对比一下C语言</span><br><span class="line">				push eax</span><br><span class="line">				invoke	MessageBox,NULL,offset fuck,offset szCaption,MB_OK</span><br><span class="line">				pop eax	</span><br><span class="line">				;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变</span><br><span class="line">				</span><br><span class="line">			.elseif eax==3</span><br><span class="line">				push eax</span><br><span class="line">				invoke	MessageBox,NULL,offset szText1,offset szCaption,MB_OK</span><br><span class="line">				pop eax</span><br><span class="line">				dec eax</span><br><span class="line"></span><br><span class="line">			.elseif eax==2</span><br><span class="line">				.break</span><br><span class="line">			.else</span><br><span class="line">				dec eax</span><br><span class="line">			.endif</span><br><span class="line">		.endw</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		;do &#123;&#125;while(eax&gt;0)</span><br><span class="line">		mov eax,2</span><br><span class="line">		.repeat	</span><br><span class="line">			push eax</span><br><span class="line">			invoke	MessageBox,NULL,offset szText2,offset szCaption,MB_OK</span><br><span class="line">			pop eax</span><br><span class="line">			dec eax</span><br><span class="line">		.until	eax == 0</span><br><span class="line">		</span><br><span class="line">		mov ecx,2</span><br><span class="line">		.repeat</span><br><span class="line">			pushad</span><br><span class="line">			invoke	MessageBox,NULL,offset szText3,offset szCaption,MB_OK</span><br><span class="line">			popad</span><br><span class="line">		.untilcxz</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>​               </p>
<p>把上面的代码转化一下</p>
<p>​			           </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2</span><br><span class="line">.repeat	</span><br><span class="line">	push eax</span><br><span class="line">	invoke	MessageBox,NULL,offset szText2,offset szCaption,MB_OK</span><br><span class="line">	pop eax</span><br><span class="line">	dec eax</span><br><span class="line">.until	eax == 0</span><br><span class="line"></span><br><span class="line">i=0;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line">while(i!=0)</span><br></pre></td></tr></table></figure>



<p>​         </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;汇编</span><br><span class="line">mov eax,5</span><br><span class="line">.while	eax&gt;0</span><br><span class="line"></span><br><span class="line">	.if eax==4</span><br><span class="line">		dec eax</span><br><span class="line">		.continue</span><br><span class="line">		;continue后面的代码是不会执行的,可以对比一下C语言</span><br><span class="line">		push eax</span><br><span class="line">		invoke	MessageBox,NULL,offset fuck,offset szCaption,MB_OK</span><br><span class="line">		pop eax	</span><br><span class="line">		;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变</span><br><span class="line">		</span><br><span class="line">	.elseif eax==3</span><br><span class="line">		push eax</span><br><span class="line">		invoke	MessageBox,NULL,offset szText1,offset szCaption,MB_OK</span><br><span class="line">		pop eax</span><br><span class="line">		dec eax</span><br><span class="line"></span><br><span class="line">	.elseif eax==2</span><br><span class="line">		.break</span><br><span class="line">	.else</span><br><span class="line">		dec eax</span><br><span class="line">	.endif</span><br><span class="line">.endw</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;C语言</span><br><span class="line">i=5;</span><br><span class="line">for(i=5;i&gt;0;)</span><br><span class="line">&#123;</span><br><span class="line">	if(i==4)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">		continue;</span><br><span class="line">		sub();</span><br><span class="line">	&#125;</span><br><span class="line">	else if(i==3)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;xxx&quot;);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	elseif(i==2)</span><br><span class="line">		breakl;</span><br><span class="line">	else</span><br><span class="line">		i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="movsx-x2F-movzx-符号扩展"><a href="#movsx-x2F-movzx-符号扩展" class="headerlink" title="movsx&#x2F;movzx 符号扩展"></a>movsx&#x2F;movzx 符号扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cl,66</span><br><span class="line">mov ax,0</span><br><span class="line">mov al,cl</span><br></pre></td></tr></table></figure>

<p>这样就实现了cl到ax的变化</p>
<p>但是有个问题,如果cl是负数呢?我们</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cl,0xf0</span><br><span class="line">mov ax,0xffff</span><br><span class="line">mov al,cl</span><br></pre></td></tr></table></figure>

<p>这会很麻烦</p>
<p>movsx eax,cl</p>
<p>无论cl是正是负.eax都会跟着cl的符号</p>
<p>movzx eax,cl 就不会有符号的跟随</p>
<h4 id="零扩展-x2F-符号扩展"><a href="#零扩展-x2F-符号扩展" class="headerlink" title="零扩展&#x2F;符号扩展"></a>零扩展&#x2F;符号扩展</h4><p>如果你是正数,就把你的二进制高位全部置为<code>0</code></p>
<p>如果你是负数,就把你的二进制高位全部置为<code>1</code>,</p>
<p>这样扩展不会改变原来的值</p>
<p>它不会要求你的长度怎么怎么样</p>
<p>只要长度<code>左边&gt;=右边</code>就可以,它会把右边的数据自动的长度扩展</p>
<p>movzx只用于无符号的数据,但是这句话不太明白</p>
<p>书上的例子<code>mov bx,0A69B</code>,也没有指明后者是正数还是负数</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="AND-x2F-OR-x2F-NOT-x2F-XOR-x2F-TEST"><a href="#AND-x2F-OR-x2F-NOT-x2F-XOR-x2F-TEST" class="headerlink" title="AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST"></a>AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST</h4><p>在移位的时候,你的左移和右移是和有无符号相关的</p>
<p>所以这回是一个细节</p>
<h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>AND 对1没影响,对0会得0</p>
<p>所以AND可以</p>
<p>用1去AND,那个数,可用于检测,如果对方是1那么结果是1,如果不是就为0</p>
<p>用0去AND,结果只会是0,</p>
<p>用0去or那个数,那个数不会发生任何改变,用于保存某些位的数</p>
<p>用1去or,结果只能是1</p>
<p>NOT 是取反</p>
<p>XOR 异或</p>
<p>如果2个数相同就不相异,结果为0</p>
<p>如果2个数不相同就相异,结果为1</p>
<p>TEST </p>
<p>不会修改操作数,相当于AND</p>
<p>会影响ZF&#x2F;SF&#x2F;PF</p>
<h5 id="映射集"><a href="#映射集" class="headerlink" title="映射集"></a>映射集</h5><p>补集用<code>NOT</code></p>
<p>交集用AND,对于2个操作数,如果有都有1,那就1,否则就是0</p>
<p>并集用OR,只要有一个人有就可以了</p>
<h4 id="neg"><a href="#neg" class="headerlink" title="neg"></a>neg</h4><p>求补码</p>
<p>neg求的是有符号的数据</p>
<p>如果结果无法放入寄存器,就补码无效,也就是OF&#x3D;1,就neg无效</p>
<p>好比数据-128</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">mov al,-128</span><br><span class="line">neg al</span><br><span class="line">mov al,-60</span><br><span class="line">neg al</span><br></pre></td></tr></table></figure>

<p>第一次neg</p>
<p><code>al=128,of=1,neg无效</code>,al不发生变化,al还是原来的<code>-128</code></p>
<p>第二次neg</p>
<p>al&#x3D;-60,neg后al&#x3D;60,of&#x3D;0,neg成功</p>
<p>&#x3D;&#x3D;neg&#x3D;&#x3D;可以用来取相反数</p>
<h4 id="shl-x2F-shr"><a href="#shl-x2F-shr" class="headerlink" title="shl&#x2F;shr"></a>shl&#x2F;shr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov al,11001100b</span><br><span class="line">mov cl,1</span><br><span class="line">shl al,cl//</span><br></pre></td></tr></table></figure>

<p>shl实际左移的位数是n%32</p>
<p>如果左移1位,  可以<code>shl al,1</code></p>
<p>如果左移&gt;1位,必须用cl保存左移的位数,cl也可以是1[^这是8086的说法]</p>
<p>左移会存在数据的进位,进位的保存会在CF中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov al,11000001b</span><br><span class="line">mov cl,1</span><br><span class="line">shr al,cl</span><br></pre></td></tr></table></figure>



<p>如果右移1位,  可以<code>shl al,1</code></p>
<p>如果右移&gt;1位,必须用cl保存左移的位数,cl也可以是,[^8086的说法]</p>
<p>右移会存在数据的移除,消失的最后一位会在CF中-</p>
<p>计算100*36</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	eax,100</span><br><span class="line">mov	ebx,eax</span><br><span class="line">shl	eax,5</span><br><span class="line">shl	ebx,2</span><br><span class="line">add	eax,ebx</span><br></pre></td></tr></table></figure>

<p>它的原理分配法</p>
<p>100x36&#x3D;100x(32+4)</p>
<h4 id="sal-x2F-sar"><a href="#sal-x2F-sar" class="headerlink" title="sal&#x2F;sar"></a>sal&#x2F;sar</h4><p>就算数左移的话,与逻辑左移没有什么区别,都是填充0</p>
<p>就是右移就有些不同</p>
<p>10001000b是负数,逻辑右移后01000100b是正数,符号的性质发生了改变</p>
<p>于是我们就要用到算数右移了</p>
<p>10001000b用sar后11000100b,结果还是负数</p>
<p>sar 右移&gt;32位的话,实际右移的位数是n%32</p>
<h4 id="ROL-x2F-ROR-后进位循环移动"><a href="#ROL-x2F-ROR-后进位循环移动" class="headerlink" title="ROL&#x2F;ROR 后进位循环移动"></a>ROL&#x2F;ROR 后进位循环移动</h4><p>什么意思?</p>
<p>好比10101111b用指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,1010 1111b</span><br><span class="line">rol al,4</span><br><span class="line">al= 1111 1010b</span><br></pre></td></tr></table></figure>

<p>左移动4位,每移动一位,CF就记录那个值,然后在右边补上</p>
<p>它的用处?</p>
<p>①.位组交换</p>
<p>它可以交换一个8bit的前4位和后4位</p>
<p>②.坑</p>
<p>我们都知道一位的16进制对应了4位的二进制</p>
<p>于是左移一位16进制就是左移4位二进制</p>
<p>于是把数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,6A4Bh</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br></pre></td></tr></table></figure>

<p>于是到了最后ax的值没有发生变化</p>
<h4 id="RCL-x2F-RCR-先进位循环移动"><a href="#RCL-x2F-RCR-先进位循环移动" class="headerlink" title="RCL&#x2F;RCR 先进位循环移动"></a>RCL&#x2F;RCR 先进位循环移动</h4><p>与上面的原理一样</p>
<p>不一样的地方在于</p>
<p>它有CF的初始化值,移动后,先用已经初始化的CF取填充,再去记录那个移动的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STC	;CF=1</span><br><span class="line">mov	cl,4</span><br><span class="line">mov	al,10010010b</span><br><span class="line">rcl	al,4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后AL=00101100</span><br></pre></td></tr></table></figure>

<p>为了做一个对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STC</span><br><span class="line">mov	cl,4</span><br><span class="line">mov	al,10010010b</span><br><span class="line">rol	al,4</span><br></pre></td></tr></table></figure>

<p>于是最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al= 00101001</span><br></pre></td></tr></table></figure>



<h4 id="SHLD-x2F-SHRD"><a href="#SHLD-x2F-SHRD" class="headerlink" title="SHLD&#x2F;SHRD"></a>SHLD&#x2F;SHRD</h4><p>第一个操作数是16位&#x2F;32位的寄存器或者内存单元</p>
<p>第二个操作数只能是寄存器</p>
<p>第三个操作数可以使CL或者立即数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHLD D,S,count</span><br><span class="line">SHRD D,S,count</span><br></pre></td></tr></table></figure>

<p>count啥意思?<br>就是移多少位</p>
<p>SHLD D,S,count</p>
<p>把D左移coutn位,用S的高coutn位填充D的低count位</p>
<p>好比</p>
<p>shld 0x9BA6,0xAC36,4</p>
<blockquote>
<p>4位就是16进制的一个数字</p>
</blockquote>
<p>最后的0x9BA6-&gt;0xBA60-&gt;0xBA6A</p>
<hr>
<p>SHRD D,S,count</p>
<p>把D右移count位</p>
<p>用S的低count为去填充D的高count为</p>
<p>好比</p>
<p>shrd 0x234B,0x7654,4</p>
<p>0x2345-&gt;0x0234-&gt;0x4234</p>
<h4 id="mul-乘法指令"><a href="#mul-乘法指令" class="headerlink" title="mul 乘法指令"></a>mul 乘法指令</h4><p>由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。</p>
<blockquote>
<p>   8bit类型</p>
</blockquote>
<p>AL*1Byte</p>
<p>因数1是AL</p>
<p>因数2是一个8位的数据</p>
<p>其结果默认存放在AX中</p>
<blockquote>
<p>   16bit类型</p>
</blockquote>
<p>AX*1word</p>
<p>因数1是AX</p>
<p>因数2是一个16位的数据</p>
<p>其结果默认存放</p>
<p>低16位 AX</p>
<p>高16位 DX</p>
<p>上面是8086机学到的,可以兼容32位</p>
<blockquote>
<p>32bit</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据长度</th>
<th>因数1</th>
<th>因数2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>al</td>
<td>bl&#x2F;byte ptr ds:[si]</td>
<td>AX</td>
</tr>
<tr>
<td>16位</td>
<td>ax</td>
<td>bx&#x2F;word ptr ds:[si]</td>
<td>DX:AX</td>
</tr>
<tr>
<td>32位</td>
<td>eax</td>
<td></td>
<td>EDX:EAX</td>
</tr>
</tbody></table>
<p>什么时候高位会产生数据?<br>对于无符号的数据来说,数据太大就进位</p>
<p>所以才会有高位的寄存器,当高位寄存器!&#x3D;0,那么CF&#x3D;1,表示进位了</p>
<p>好比这一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">     db 5,4,3,2,1,0 </span><br><span class="line">data ends  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mov ax,0</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov al,2</span><br><span class="line">    mov bl,3</span><br><span class="line">    mul bl</span><br><span class="line">    mul byte ptr ds:[1]</span><br><span class="line"></span><br><span class="line">    mov ax,2</span><br><span class="line">    mov bx,10</span><br><span class="line">    mul bx</span><br><span class="line">    mul word ptr ds:[0]</span><br></pre></td></tr></table></figure>





<h4 id="IMUL-指令-有符号的乘法"><a href="#IMUL-指令-有符号的乘法" class="headerlink" title="IMUL 指令 有符号的乘法"></a>IMUL 指令 有符号的乘法</h4><p>IMUL有3种语法</p>
<p>1个操作数&#x2F;2个操作数&#x2F;3个操作数</p>
<p>对于无符号的数据,好比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,48</span><br><span class="line">mov	bl,4</span><br><span class="line">imul	bl</span><br></pre></td></tr></table></figure>

<p> 48*4&#x3D;192</p>
<p>192&gt;127溢出</p>
<p>192&lt;255不会进位,但是就离谱的CF&#x3D;1</p>
<p>其实我还是没有分清IMUL与MUL到底有什么区别….</p>
<p>难道说他会有一个mul的有符号填充???</p>
<p>一个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,10</span><br><span class="line">mov bl,20</span><br><span class="line">IMUL bl</span><br><span class="line">ax=al*bl</span><br></pre></td></tr></table></figure>

<p>两个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,10</span><br><span class="line">IMUL ax,20</span><br><span class="line">ax=ax*20</span><br></pre></td></tr></table></figure>

<p>三个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imul cx,ax,bx</span><br><span class="line">//cx=ax*bx</span><br></pre></td></tr></table></figure>





<h4 id="DIV-除法指令"><a href="#DIV-除法指令" class="headerlink" title="DIV 除法指令"></a>DIV 除法指令</h4><p>24&#x2F;9&#x3D;2…6</p>
<p>被除数24</p>
<p>除数9</p>
<p>商2</p>
<p>余数6</p>
<table>
<thead>
<tr>
<th align="center">被除数</th>
<th>被除数位置</th>
<th>除数</th>
<th>除数位置</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">16bti</td>
<td>AX</td>
<td>8位</td>
<td>8bit的内存单元&#x2F;寄存器</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td align="center">32bit</td>
<td>DX:AX</td>
<td>16位</td>
<td>16bit的内存单元&#x2F;寄存器</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td align="center">64bit</td>
<td>EDX:EAX</td>
<td>32位</td>
<td>32bit的内存单元&#x2F;寄存器</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody></table>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><p>与DIV的区别在于,IDIV要进行符号的扩张</p>
<p>也就是DX&#x2F;EDX会根据AX&#x2F;EAX的正负进行有无符号的填写</p>
<p>其余无区别了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">x	sword	-101</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	dx,0</span><br><span class="line">		mov	ax,x</span><br><span class="line">		mov	bx,2</span><br><span class="line">		idiv	bx</span><br><span class="line">		;用DIV是一样的</span><br><span class="line">		;=-51...1</span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	dx,0</span><br><span class="line">		mov	ax,x</span><br><span class="line">		cwd</span><br><span class="line">		mov	bx,2</span><br><span class="line">		idiv	bx</span><br><span class="line">		;=-50...-1</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<p>很奇怪</p>
<h4 id="cbw-x2F-cwd-x2F-cdq-x2F-cdqe-x2F-cwde符号扩展"><a href="#cbw-x2F-cwd-x2F-cdq-x2F-cdqe-x2F-cwde符号扩展" class="headerlink" title="cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展"></a>cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展</h4><p>cbw	;扩展到了AH,用AL的符号填充AH,AH的值会被覆盖</p>
<blockquote>
<p> 若al&#x3D;78h,cbw后ax&#x3D;78h</p>
<p> 若al&#x3D;87h,cbw后ax&#x3D;ff87h</p>
</blockquote>
<p>cwd	;扩展到了DX,用AX的符号填充DX,   DX的值会被覆盖</p>
<p>cwde AX-&gt;EAX</p>
<p>cdq	;扩展到了EDX,用EAX的符号填充EDX,EDX的值会被覆盖</p>
<p>cdqe   EAX-&gt;RAX</p>
<p>为什么要符号扩展????</p>
<p>做8位除法,被除数必须16位AX</p>
<p>做16位除法,被除数必须32位DX|AX</p>
<p>做32位除法,被除数必须64位EDX|EAX</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,-48</span><br><span class="line">		mov	bl,5</span><br><span class="line">		idiv	bl</span><br><span class="line">		;-48(208)/5=40..3</span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,-48</span><br><span class="line">		cbw		;让ah=FF</span><br><span class="line">		mov	bl,5</span><br><span class="line">		idiv	bl</span><br><span class="line">		;-48/5=-9..-3;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<p>不用就会产生错误的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">x	sword	-101	;=0x9b,-101一定是负数,但是0x9b却不是</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		;mov	al,9bh,al一定是负数</span><br><span class="line">		mov	al,-101		</span><br><span class="line">		cbw	;扩展到了AH</span><br><span class="line">		</span><br><span class="line">		;mov	ax,9bh,ax不是负数,cwd失效</span><br><span class="line">		mov	ax,-101</span><br><span class="line">		cwd	;扩展到了dx</span><br><span class="line"></span><br><span class="line">		;mov	eax,9bh,eax不是是负数,cdq失效</span><br><span class="line">		mov	eax,-101</span><br><span class="line">		cdq	;扩展到了edx</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<h4 id="adc-进位加法"><a href="#adc-进位加法" class="headerlink" title="adc 进位加法"></a>adc 进位加法</h4><p>adc实现了带有符号位的加法,建立在二进制位的那个符号</p>
<p><code>adc eax,dword ptr [esi]</code></p>
<p>等价于</p>
<p><code> eax=eax+dword ptr [esi]+CF</code></p>
<p> adc的优势体现在哪????</p>
<p>好比1234+4567</p>
<p>我们可以这样算</p>
<p>34+67&#x3D;01,本来是101,但是进位了1</p>
<p>然后</p>
<p>12+45&#x3D;57,于是加上进位,就是58</p>
<p>最后的结果就是5801</p>
<p>通过这种分割的形式我们可以算很长的数据</p>
<p>下面是一个8字节程度的数据,实现加法</p>
<p>好比0x1234567890102345+0x1234567890102345</p>
<p>这个代码你还还是多看一下,很妙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">arr1	dw	12h,34h,56h,78h,9h</span><br><span class="line">arr2	dw	9h,87h,65h,43h,21h</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		mov esi,offset arr1</span><br><span class="line">		mov edi,offset arr2</span><br><span class="line"></span><br><span class="line">		mov ecx,5</span><br><span class="line">		xor eax,eax</span><br><span class="line">		clc</span><br><span class="line">		;clc指令把CF寄存器初始化为0,给首位adc使用</span><br><span class="line">	ok:	</span><br><span class="line">		mov ax,[esi]</span><br><span class="line">		adc [edi],ax</span><br><span class="line">		pushfd</span><br><span class="line">		add esi,2</span><br><span class="line">		add edi,2</span><br><span class="line">		popfd</span><br><span class="line">		;为什么把寄存器入栈?因为add会修改CF寄存器的值</span><br><span class="line">		loop ok</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<h4 id="sbb-借位减法"><a href="#sbb-借位减法" class="headerlink" title="sbb 借位减法"></a>sbb 借位减法</h4><p> 就是一个借位的过程,做一些记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xor	eax,eax</span><br><span class="line"></span><br><span class="line">mov	edx,7</span><br><span class="line">mov	eax,1</span><br><span class="line">sub	eax,2</span><br><span class="line">sbb	edx,0</span><br></pre></td></tr></table></figure>







<h4 id="xadd-很sb的加法"><a href="#xadd-很sb的加法" class="headerlink" title="xadd 很sb的加法"></a>xadd 很sb的加法</h4><p>z&#x3D;x+y</p>
<p>xadd的效果就是</p>
<p>z&#x3D;y+x</p>
<p>在我的电脑上,这个指令无法用</p>
<h3 id="非压缩10进制算法原理"><a href="#非压缩10进制算法原理" class="headerlink" title="非压缩10进制算法原理"></a>非压缩10进制算法原理</h3><h4 id="aaa-加法"><a href="#aaa-加法" class="headerlink" title="aaa 加法"></a>aaa 加法</h4><p>会影响AF&#x2F;CF</p>
<h5 id="通俗介绍"><a href="#通俗介绍" class="headerlink" title="通俗介绍"></a>通俗介绍</h5><blockquote>
<p>aaa 操作的对象16进制的个位数,也就是4个bit位</p>
<p>好比0x2F,他会把F拿出来,然后把F分解为1和5,因为F是15</p>
<p>好比0x39,ASCII是9,然后把9分解为0和9,也就是9</p>
</blockquote>
<p>于是下面这些例子</p>
<p>3+’6’&#x3D;0x39,然后对个位数可以转化为0和9,依次放在ah,al</p>
<p>‘3’+’6’&#x3D;0x69,然后对个位数可以转化为0和9</p>
<p>因为它只看个位数,同时请保证AH&#x3D;0,再进行操作</p>
<p>16进制个位数满足0-15,对于10进制绰绰有余,</p>
<p>AH代表了进位,会传递给一个进位者</p>
<h5 id="书上说"><a href="#书上说" class="headerlink" title="书上说"></a>书上说</h5><blockquote>
<p>如果AL的低4位&gt;9,也就数10进制进位了AL+&#x3D;6,AH+&#x3D;1…..是吗?????&#x2F;</p>
</blockquote>
<blockquote>
<p>会有CF&#x3D;1,AF&#x3D;1</p>
</blockquote>
<blockquote>
<p>否则CF&#x3D;0.AF&#x3D;0.</p>
</blockquote>
<p>难道会有置空?</p>
<h5 id="关于计算过程"><a href="#关于计算过程" class="headerlink" title="关于计算过程"></a>关于计算过程</h5><p>好比0x37&#x3D;0x39</p>
<p>也就是7+9&#x3D;0x70</p>
<p>你可以看到低4字节为0</p>
<p>但是他有一个进位</p>
<p>CF&#x3D;1,AF&#x3D;1</p>
<p>就相当于0x10&#x3D;16了</p>
<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">x		db &quot;96543&quot;			</span><br><span class="line">y		db &quot;53279&quot;		</span><br><span class="line">sum		db (sizeof x + 1) dup(&#x27;0&#x27;),0</span><br><span class="line">format		db &quot;%s&quot;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">		xor	ecx,ecx</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		;为什么esi-1</span><br><span class="line">		;因为从0开始计数,所以最后一位的index=len-1</span><br><span class="line">		;为什么edi不-1?</span><br><span class="line">		;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,会有进位</span><br><span class="line">		mov	esi,sizeof x -1</span><br><span class="line">		mov	edi,sizeof x</span><br><span class="line">		mov	ecx,sizeof x</span><br><span class="line">		;数值的填充由字符串最高位开始==数值最低位开始</span><br><span class="line"></span><br><span class="line">		;让进位值由bh来装,最先的进位还是0</span><br><span class="line">		mov	bh,0					</span><br><span class="line"></span><br><span class="line">L1:		;aaa指令要求ah=0</span><br><span class="line">		mov	ah,0					</span><br><span class="line">		mov	al,x[esi]	</span><br><span class="line">		;al每一次先加上进位值,再加上数值</span><br><span class="line">		add	al,bh					</span><br><span class="line">		aaa					</span><br><span class="line">		add	al,y[esi]		</span><br><span class="line">		aaa</span><br><span class="line">		;+了后,bh还要保持新的进位</span><br><span class="line">		</span><br><span class="line">		mov	bh,ah</span><br><span class="line">		or	al,30h</span><br><span class="line">		;转ascii然后放入sum</span><br><span class="line">		mov	sum[edi],al			</span><br><span class="line">		dec	esi 					</span><br><span class="line">		dec	edi</span><br><span class="line">		loop	L1</span><br><span class="line">		</span><br><span class="line">		;最后一个也可能有进位</span><br><span class="line">		or	bh,30h</span><br><span class="line">		mov	sum[edi],bh			</span><br><span class="line">		invoke	printf,addr format,addr sum</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>又写了一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">x		db &quot;96543&quot;,0			</span><br><span class="line">y		db &quot;53279&quot;,0		</span><br><span class="line">sum		db  sizeof x dup(0),0</span><br><span class="line">format		db &quot;%s&quot;,13,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">		xor	ecx,ecx</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		;为什么esi-1</span><br><span class="line">		;因为从0开始计数,所以最后一位的index=len-1</span><br><span class="line">		;为什么edi不-1?</span><br><span class="line">		;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,可能会有进位</span><br><span class="line">		mov	esi,sizeof x - 2</span><br><span class="line">		mov	edi,sizeof x - 1</span><br><span class="line">		mov	ecx,sizeof x - 1</span><br><span class="line">		;数值的填充由字符串最高位开始==数值最低位开始</span><br><span class="line"></span><br><span class="line">		clc					</span><br><span class="line">L1:		</span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,x[esi]</span><br><span class="line">		adc	al,y[esi]</span><br><span class="line">		aaa</span><br><span class="line"></span><br><span class="line">		pushfd</span><br><span class="line">		or	al,30h</span><br><span class="line">		popfd</span><br><span class="line">		mov	sum[edi],al	</span><br><span class="line">        </span><br><span class="line">		dec	esi 					</span><br><span class="line">		dec	edi</span><br><span class="line">		loop	L1</span><br><span class="line">		</span><br><span class="line">		cmp     ah,1</span><br><span class="line">		jnz     over</span><br><span class="line">		or	    ah,30h</span><br><span class="line">		mov	sum[edi],ah</span><br><span class="line">		over:</span><br><span class="line">		invoke	printf,addr format,addr sum</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>or,add,会影响CF</p>
<p>inc&#x2F;dex不会</p>
<h4 id="daa-加法"><a href="#daa-加法" class="headerlink" title="daa 加法"></a>daa 加法</h4><p>影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF</p>
<h5 id="书上说-1"><a href="#书上说-1" class="headerlink" title="书上说"></a>书上说</h5><p>其调整规则</p>
<p>若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6,</p>
<p>若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h,</p>
<p>都不成立就AF&#x3D;CF&#x3D;0</p>
<p>他把16进制的0x12</p>
<p>可以转化为10进制的0x12</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xor	eax,eax</span><br><span class="line"></span><br><span class="line">mov	al,12h</span><br><span class="line">add	al,28h</span><br><span class="line">daa</span><br></pre></td></tr></table></figure>

<p>12+28&#x3D;40,</p>
<p>最后的结果是16进制的40</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">Num1 WORD 4536h</span><br><span class="line">Num2 WORD 7207h</span><br><span class="line">sum DWORD ?</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	xor	eax,eax</span><br><span class="line">	mov	sum,0</span><br><span class="line">	mov	esi,0</span><br><span class="line">	mov	ecx,type Num1</span><br><span class="line"></span><br><span class="line">	CLC</span><br><span class="line">	</span><br><span class="line">	ok:</span><br><span class="line">	mov	al,byte ptr Num1[esi]</span><br><span class="line">	add	al,byte ptr Num2[esi]</span><br><span class="line">	daa	</span><br><span class="line">	mov	byte ptr sum[esi],al</span><br><span class="line">	inc	esi</span><br><span class="line">	loop	ok</span><br><span class="line"></span><br><span class="line">	adc	byte ptr sum[esi],0</span><br><span class="line">	mov	eax,sum</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">	end	start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关于进位的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov	al,56h</span><br><span class="line">add	al,92h</span><br><span class="line">daa</span><br></pre></td></tr></table></figure>

<p>56+92&#x3D;148</p>
<p>al装不下148,只能装48</p>
<p>所以就进位了</p>
<h4 id="aas-减法"><a href="#aas-减法" class="headerlink" title="aas 减法"></a>aas 减法</h4><p>影响AC&#x2F;CF</p>
<p>它操作的对象也是16进制</p>
<p>好比操作0xF,就是操作15</p>
<p>然后得到10进制意义的数值</p>
<p>可以类比aaa</p>
<h5 id="书上说-2"><a href="#书上说-2" class="headerlink" title="书上说"></a>书上说</h5><blockquote>
<p>如果AL的低4位&gt;9,也就数10进制借位了AL-&#x3D;6,AH-&#x3D;1…..是吗?????&#x2F;</p>
</blockquote>
<blockquote>
<p>会有CF&#x3D;1,AF&#x3D;1</p>
</blockquote>
<blockquote>
<p>否则CF&#x3D;0.AF&#x3D;0.</p>
</blockquote>
<p>难道会有置空?</p>
<h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov	ah,0</span><br><span class="line">mov	al,5</span><br><span class="line">sub	al,10</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">add	al,30h</span><br><span class="line">popf</span><br><span class="line">;or会影响CF</span><br><span class="line"></span><br><span class="line">aas</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>0-5&#x3D;FB</p>
<p>然后aas后</p>
<p>AH&#x3D;0xFF,AL&#x3D;5</p>
<p>可能AH代表了符号,AL代表了值</p>
<p>其中产生的借位留在了CF中</p>
<h4 id="das-减法"><a href="#das-减法" class="headerlink" title="das 减法"></a>das 减法</h4><p>影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF\</p>
<h5 id="书上说-3"><a href="#书上说-3" class="headerlink" title="书上说"></a>书上说</h5><p>其调整规则</p>
<p>若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6,</p>
<p>若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h,</p>
<p>都不成立就AF&#x3D;CF&#x3D;0</p>
<h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><p>对16进制形式操作</p>
<p>结果也是10进制意义的16进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">	xor	eax,eax</span><br><span class="line">	xor	ebx,ebx</span><br><span class="line">	mov	al,85h</span><br><span class="line">	mov	bl,48h</span><br><span class="line">	sub	al,bl</span><br><span class="line">	das</span><br></pre></td></tr></table></figure>

<p>结果是10进制意义16进制的85-48&#x3D;37</p>
<p>对于负数的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov	al,50h</span><br><span class="line">sub	al,90h</span><br><span class="line">das</span><br></pre></td></tr></table></figure>

<p>其实这里的借位我算是见过了</p>
<p>诸如的结果60h</p>
<p>怎么来的</p>
<p>150-90&#x3D;60</p>
<p>所以就60h</p>
<h4 id="aam-乘法"><a href="#aam-乘法" class="headerlink" title="aam 乘法"></a>aam 乘法</h4><p>会影响PF&#x2F;SF&#x2F;ZF</p>
<p>ascii adjust after mul</p>
<p>操作的对象是16进制</p>
<p>得到结果是10进制,分别放在AH,AL</p>
<p>AH&#x3D;AL&#x2F;10</p>
<p>AL&#x3D;AL%10</p>
<p>话不多说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	ah,0</span><br><span class="line">mov	al,5</span><br><span class="line">mov	bl,6	</span><br><span class="line">mul	bl</span><br><span class="line">aam</span><br></pre></td></tr></table></figure>

<p>然后结果就是30</p>
<p>ah&#x3D;03,al&#x3D;00</p>
<p>如果结果是98.AH&#x3D;09h.AL&#x3D;08h</p>
<p>如果结果是125.AH&#x3D;12h.AL&#x3D;05h</p>
<p>就像aaa的那个程序一样</p>
<h4 id="aad-除法"><a href="#aad-除法" class="headerlink" title="aad 除法"></a>aad 除法</h4><p>会影响PF&#x2F;SF&#x2F;ZF</p>
<p>它很不一样</p>
<p>操作的是10进制,从AH,Al当中取数据</p>
<p>AL&#x3D;AH*10+AL</p>
<p>AH&#x3D;0</p>
<p>好比0x0207</p>
<p>就是操作10进制的27</p>
<p>在Al中生成商,在AH中生存余数</p>
<p>,可是数据太多怎么办?????</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	ax,0307h</span><br><span class="line">aad</span><br><span class="line">;合成了数值37=0x某某</span><br><span class="line">mov	bl,5</span><br><span class="line">div	bl</span><br></pre></td></tr></table></figure>

<p>他可以识别ax&#x3D;0x307位10进制的的37</p>
<p>于是想要使用aad的话,你得是10进制的形式然后被识别为16进制</p>
<p>好比你把一串ASCII-0x30,然后放在AH,AL中</p>
<p>“1234”</p>
<p>识别为,1,2,3,4然后除法?????woc????&#x2F;貌似不行的</p>
<h3 id="字符串基本指令"><a href="#字符串基本指令" class="headerlink" title="字符串基本指令"></a>字符串基本指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MOVSB、MOVSW、MOVSD</td>
<td>传送字符串数据： ESI的内存数据—&gt; EDI 的内存位置</td>
</tr>
<tr>
<td>CMPSB、CMPSW、CMPSD</td>
<td>比较字符串：比较分别由 ESI 和 EDI 寻址的内存数据</td>
</tr>
<tr>
<td>SCASB、SCASW、SCASD</td>
<td>扫描字符串：比较累加器 (AL、AX 或 EAX) 与 EDI 寻址的内存数据</td>
</tr>
<tr>
<td>STOSB、STOSW、STOSD</td>
<td>保存字符串数据：将累加器内容保存到 EDI 寻址的内存位置</td>
</tr>
<tr>
<td>LODSB、LODSW、LODSD</td>
<td>从字符串加载到累加器：将 ESI 寻址的内存数据加载到累加器</td>
</tr>
</tbody></table>
<h4 id="方向标志位指令"><a href="#方向标志位指令" class="headerlink" title="方向标志位指令"></a>方向标志位指令</h4><p>STD 让DF&#x3D;1 表示方向</p>
<p>CLD 让DF&#x3D;0 表示正向</p>
<table>
<thead>
<tr>
<th>DF</th>
<th>对ESI和EDI的影响</th>
<th>esi&#x2F;edi位置</th>
<th>地址顺序</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>每一次增加type 个大小</td>
<td>指向首位</td>
<td>小-&gt;大,正序</td>
</tr>
<tr>
<td>1</td>
<td>每一次减少type 个大小</td>
<td>指向末尾</td>
<td>大-&gt;小,逆序</td>
</tr>
</tbody></table>
<h4 id="字符串循环的退出条件之一"><a href="#字符串循环的退出条件之一" class="headerlink" title="字符串循环的退出条件之一"></a>字符串循环的退出条件之一</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rep</td>
<td>ECX &gt; 0 时循环</td>
</tr>
<tr>
<td>repz,repe</td>
<td>ZF&#x3D; 1 且 ECX &gt; 0 时循环</td>
</tr>
<tr>
<td>repnz,repne</td>
<td>ZF&#x3D;0 且 ECX &gt; 0 时循环</td>
</tr>
</tbody></table>
<h4 id="movs-b-x2F-w-x2F-d-数据复制"><a href="#movs-b-x2F-w-x2F-d-数据复制" class="headerlink" title="movs b&#x2F;w&#x2F;d  数据复制"></a>movs b&#x2F;w&#x2F;d  数据复制</h4><p>MoVS BYTE PTR ES:[EDI], BYTE PTR DS: [ESI] 简写为:MOVSB<br>Movs WORD PTR ES:[EDI], WORD PTR DS:[ESI]   简写为:MOvsw<br>MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  简写为:MOVSD</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">数据类型</th>
<th align="center">ESI 和 EDI 增加或减少的数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MOVSB</td>
<td align="center">传送（复制）byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">MOVSW</td>
<td align="center">传送（复制）word</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">MOVSD</td>
<td align="center">传送（复制）dword</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>从esi到edi</p>
<p>一个从尾巴到头部的复制制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A_str	db	&quot;I love you deeply&quot;,0</span><br><span class="line">len	=	lengthof A_str</span><br><span class="line">B_str	db	len dup (&#x27;C&#x27;)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A_str +len - 1 ;+len指向了0后面</span><br><span class="line">	mov	edi,offset B_str +len - 1 ;指向了最后一个C</span><br><span class="line">	mov	ecx,len	;表示循环次数0也复制进去</span><br><span class="line">	std</span><br><span class="line">	rep	movsb</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="cmpsb-x2F-sw-x2F-sd-数据比较"><a href="#cmpsb-x2F-sw-x2F-sd-数据比较" class="headerlink" title="cmpsb&#x2F;sw&#x2F;sd 数据比较"></a>cmpsb&#x2F;sw&#x2F;sd 数据比较</h4><table>
<thead>
<tr>
<th>CMPSB</th>
<th>比较字节</th>
</tr>
</thead>
<tbody><tr>
<td>CMPSW</td>
<td>比较字</td>
</tr>
<tr>
<td>CMPSD</td>
<td>比较双字</td>
</tr>
</tbody></table>
<p>通过循环可以比较字符串,与strcmp可以相当</p>
<p>比较esi与edi指向的数据串,循环ecx次</p>
<p>cmpsb 是字节比较</p>
<p>cmpsw 是字比较</p>
<p>cmpsd 是双值比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">B1	db	&quot;I l0ve You&quot;,0</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A1 </span><br><span class="line">	mov	edi,offset B1 </span><br><span class="line">	mov	ecx,lengthof A1 - 1</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	repe	cmpsb</span><br><span class="line">	;repe	如果zf=1,ecx&gt;0就继续循环</span><br><span class="line">	;故循环继续的条件是ecx&gt;0&amp;&amp;ZF==1</span><br><span class="line">	jnz	show1</span><br><span class="line">	jz	show2	</span><br><span class="line">	</span><br><span class="line">	show1:  mov	eax,1</span><br><span class="line">		jmp	over</span><br><span class="line">	show2:	mov	eax,2</span><br><span class="line">		jmp	over</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>对于cmpsw&#x2F;sd的比较,我就不多说了</p>
<h4 id="scasb-x2F-sw-x2F-sd-数据遍历"><a href="#scasb-x2F-sw-x2F-sd-数据遍历" class="headerlink" title="scasb&#x2F;sw&#x2F;sd 数据遍历"></a>scasb&#x2F;sw&#x2F;sd 数据遍历</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>scasb</td>
<td>扫描字节</td>
</tr>
<tr>
<td>scasw</td>
<td>扫描字</td>
</tr>
<tr>
<td>scasd</td>
<td>扫描双字</td>
</tr>
</tbody></table>
<p>通过循环,可以逐个遍历字符串然后获取其中的index</p>
<p>这个指令是拿al&#x2F;ax&#x2F;eax与edi指向的数据串进行遍历比较</p>
<p>scan-xx指令有什么要注意的</p>
<p>1️⃣.它是拿al&#x2F;ax&#x2F;eax与[edi]作比较,而不是[esi]</p>
<p>2️⃣.每比较一个就dec edi,这是一个连在一起的过程</p>
<p>3️⃣.他的用处到底是啥?寻找一个数据串当中有没有对应的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	edi,offset A1 </span><br><span class="line">	mov	ecx,lengthof A1 - 1</span><br><span class="line">	mov	al,&#x27;Y&#x27;</span><br><span class="line">	cld</span><br><span class="line">	repne	scasb</span><br><span class="line">	;相等就退出循环</span><br><span class="line">	;不相等就一直遍历,一直到ecx=0||ZF=1才退出</span><br><span class="line"></span><br><span class="line">	jnz	show1	;最后都还是没有找到相等的值</span><br><span class="line">	jz	show2	;最后找到了相等的值</span><br><span class="line">	</span><br><span class="line">	show1:  mov	eax,0</span><br><span class="line">		jmp	over</span><br><span class="line">	show2:	</span><br><span class="line">		dec	edi		;把edi再一次指向&#x27;Y&#x27;</span><br><span class="line">		mov	ah,byte ptr [edi]</span><br><span class="line">		jmp	over</span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="stos-b-x2F-w-x2F-d-数据存入"><a href="#stos-b-x2F-w-x2F-d-数据存入" class="headerlink" title="stos b&#x2F;w&#x2F;d 数据存入"></a>stos b&#x2F;w&#x2F;d 数据存入</h4><p>把Al&#x2F;AX&#x2F;EAX的值存储到[EDI]指定的内存单元</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>stosb</td>
<td>存储字节</td>
</tr>
<tr>
<td>stosw</td>
<td>存储字</td>
</tr>
<tr>
<td>stosd</td>
<td>存储双字</td>
</tr>
</tbody></table>
<p>STOS BYTE PTR ES:[EDI] 简写为STOSB<br>STos WORD PTR ES:[EDI] 简写为STOSw<br>STOS DWORD PTR ES:[EDI] 简写为STOSD</p>
<p>循环ecx次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">len	=	lengthof A1 - 1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	edi,offset A1 </span><br><span class="line">	mov	ecx,len</span><br><span class="line">	mov	al,&#x27;D&#x27;</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	rep	stosb</span><br><span class="line">	;他会把&#x27;D&#x27;依次填满字符串A1</span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>





<h4 id="losb-x2F-sw-x2F-sd-数据拿出"><a href="#losb-x2F-sw-x2F-sd-数据拿出" class="headerlink" title="losb&#x2F;sw&#x2F;sd 数据拿出"></a>losb&#x2F;sw&#x2F;sd 数据拿出</h4><p>把[esi]指向的数据串依次给了al&#x2F;ax&#x2F;eax</p>
<p>这个代码的功能</p>
<p>将数据串[esi]的每一位拿出来放在al</p>
<p>然后乘以10,</p>
<p>然后把al放进[edi]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	1,2,3,4,5</span><br><span class="line">len	dd	lengthof A1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A1 </span><br><span class="line">	mov	edi,esi</span><br><span class="line">	mov	ecx,len</span><br><span class="line">	mov	bh,10</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">	lodsb</span><br><span class="line">	mul	bh</span><br><span class="line">	stosb</span><br><span class="line"></span><br><span class="line">	loop ok</span><br><span class="line"></span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>





<h4 id="xlat-x2F-xlatb"><a href="#xlat-x2F-xlatb" class="headerlink" title="xlat&#x2F;xlatb"></a>xlat&#x2F;xlatb</h4><p>他会用2个寄存器</p>
<p>ebx存放加密表的table的地址</p>
<p>al存放待加密的数据,和已经加密好的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al, byte ptr [esi]</span><br><span class="line">sub al,&#x27;+&#x27;</span><br><span class="line">xlat table</span><br><span class="line">mov byte ptr [edi],al</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后一个例子</p>
<p>加密字符串”Dqx_Gh0st”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">table	byte	&quot;+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;,0</span><br><span class="line">ming	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">len	=	sizeof	ming</span><br><span class="line">mi	byte	len-1 dup(&#x27;@&#x27;),0</span><br><span class="line">format	byte	&quot;%c %c&quot;,10,0</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	xor eax,eax </span><br><span class="line">	mov ebx,offset table</span><br><span class="line">	mov esi,offset ming</span><br><span class="line">	mov edi,offset mi</span><br><span class="line">	mov ecx,len</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	flag:</span><br><span class="line">	mov al, byte ptr [esi]</span><br><span class="line">	sub al,&#x27;+&#x27;</span><br><span class="line">	xlat table</span><br><span class="line">	mov byte ptr [edi],al</span><br><span class="line"></span><br><span class="line">	pushad</span><br><span class="line">	movzx eax,byte ptr [esi]</span><br><span class="line">	movzx ebx,byte ptr [edi]</span><br><span class="line">	invoke printf ,addr format,eax,ebx</span><br><span class="line">	popad</span><br><span class="line"></span><br><span class="line">	inc esi</span><br><span class="line">	inc edi</span><br><span class="line">	loop flag</span><br><span class="line">	</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>IDA的分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">start</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 *_esi; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 *_edi; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-20h] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp-1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// [esp-18h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  _EAX = <span class="number">0</span>;</span><br><span class="line">  _EBX = aAbcdefghijklmn;</span><br><span class="line">  _esi = (<span class="type">unsigned</span> __int8 *)aDqxGh0st;</span><br><span class="line">  _edi = (<span class="type">unsigned</span> __int8 *)asc_40304B;</span><br><span class="line">  len = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOBYTE(_EAX) = *_esi - <span class="number">43</span>;</span><br><span class="line">    __asm &#123; xlat &#125;</span><br><span class="line">    *_edi = _EAX;</span><br><span class="line">    count = len;</span><br><span class="line">    v8 = a2;</span><br><span class="line">    v7 = _EAX;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>, *_esi, *_edi);</span><br><span class="line">    _EAX = v7;</span><br><span class="line">    a2 = v8;</span><br><span class="line">    ++_esi;</span><br><span class="line">    ++_edi;</span><br><span class="line">    len = count - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( count != <span class="number">1</span> );</span><br><span class="line">  ExitProcess(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的v7&#x2F;v8应该就是源码的一个pushad和popad操作</p>
<h4 id="insb-x2F-w-x2F-d-输入串指令"><a href="#insb-x2F-w-x2F-d-输入串指令" class="headerlink" title="insb&#x2F;w&#x2F;d 输入串指令"></a>insb&#x2F;w&#x2F;d 输入串指令</h4><p>输入串操作从DX指定端口接受一个byte&#x2F;word&#x2F;dword</p>
<p>并存入以EDI为起始地址的的存储单元,DF决定了写入的方向,然后EDI根据单位值进行自增与自减</p>
<p>书上没有例子,这可能与终端有关</p>
<h4 id="outsb-x2F-w-x2F-d输出串指令"><a href="#outsb-x2F-w-x2F-d输出串指令" class="headerlink" title="outsb&#x2F;w&#x2F;d输出串指令"></a>outsb&#x2F;w&#x2F;d输出串指令</h4><p>从EDI指向内存单元输出到指定的端口</p>
<h1 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h1><p>遇到的指令</p>
<p>没有对齐的加法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movupd  xmm0, dpvector1</span><br><span class="line">movupd  xmm1, dpvector2</span><br><span class="line">addpd   xmm0, xmm1</span><br><span class="line">movupd  ds:dpvector_res, xmm0</span><br></pre></td></tr></table></figure>

<p>对齐的加法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movapd  xmm0, dpvector1</span><br><span class="line">addpd   xmm0, dpvector2</span><br><span class="line">movapd  ds:dpvector_res, xmm0</span><br></pre></td></tr></table></figure>





<h3 id="movups"><a href="#movups" class="headerlink" title="movups"></a>movups</h3><p>移动&#x3D;&#x3D;未对齐&#x3D;&#x3D;的打包单精度</p>
<p>会得到4个精度值的向量</p>
<h3 id="movaps"><a href="#movaps" class="headerlink" title="movaps"></a>movaps</h3><h3 id="movaps-1"><a href="#movaps-1" class="headerlink" title="movaps"></a>movaps</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVAPS xmm1, xmm2 / m128</span><br></pre></td></tr></table></figure>

<p>把对齐的<code>xmm2/8字节mem</code>给xmm1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVAPS xmm2 / m128.xmm1</span><br></pre></td></tr></table></figure>

<p>把对齐的xmm1给<code>xmm2/8字节mem</code></p>
<h3 id="movapd"><a href="#movapd" class="headerlink" title="movapd"></a>movapd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVAPD xmm1, xmm2/m128</span><br></pre></td></tr></table></figure>

<p>把对齐的<code>xmm2或者8字节mem</code>的double类型给xmm1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVAPD xmm2/m128, xmm1</span><br></pre></td></tr></table></figure>

<p>把对齐的xmm1给<code>xmm2/8字节mem</code></p>
<h3 id="movss"><a href="#movss" class="headerlink" title="movss"></a>movss</h3><p>把float送到目的地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVSS xmm1, xmm2</span><br><span class="line">MOVSS xmm1, m32</span><br></pre></td></tr></table></figure>



<h3 id="movdqa"><a href="#movdqa" class="headerlink" title="movdqa"></a>movdqa</h3><p>将对齐的压缩整数值从 16字节长度 移动到 16字节</p>
<h3 id="movd"><a href="#movd" class="headerlink" title="movd"></a>movd</h3><p>4字节的mov</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVD xmm , r/m32</span><br><span class="line">MOVD r/m32 , xmm</span><br></pre></td></tr></table></figure>



<h3 id="movq"><a href="#movq" class="headerlink" title="movq"></a>movq</h3><p>8字节的mov</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVQ xmm , r/m64</span><br><span class="line">MOVQ r/m64 , xmm</span><br></pre></td></tr></table></figure>



<h3 id="movsd"><a href="#movsd" class="headerlink" title="movsd"></a>movsd</h3><p>在8字节基础上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVSD xmm1, xmm2</span><br><span class="line">MOVSD xmm1, m64</span><br><span class="line">MOVSD xmm1/m64, xmm2</span><br></pre></td></tr></table></figure>

<p>处理的数据类型是double</p>
<h3 id="addps"><a href="#addps" class="headerlink" title="addps"></a>addps</h3><p>将压缩的单精度浮点值从 16字节 数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器 中。</p>
<p>打包单精度数据相加</p>
<p>也就是每4字节相加….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401166 movaps  xmm0, spvector1</span><br><span class="line">.text:000000000040116E addps   xmm0, spvector2</span><br></pre></td></tr></table></figure>



<h3 id="appad"><a href="#appad" class="headerlink" title="appad"></a>appad</h3><p>  将压缩双精度浮点值从128位的数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器中。</p>
<p>每8字节8字节的相加</p>
<h3 id="cvtss2sd"><a href="#cvtss2sd" class="headerlink" title="cvtss2sd"></a>cvtss2sd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVTSS2SD xmm1, xmm2/m32</span><br></pre></td></tr></table></figure>

<p>double&lt;–flaot</p>
<h3 id="cvtsd2ss"><a href="#cvtsd2ss" class="headerlink" title="cvtsd2ss"></a>cvtsd2ss</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVTSD2SS xmm1, xmm2/m64</span><br></pre></td></tr></table></figure>

<p>float&lt;–double</p>
<h3 id="paddb-x2F-w-x2F-d-x2F-q"><a href="#paddb-x2F-w-x2F-d-x2F-q" class="headerlink" title="paddb&#x2F;w&#x2F;d&#x2F;q"></a>paddb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401166 movdqa  xmm0, pdivector1</span><br><span class="line">.text:000000000040116F paddd   xmm0, pdivector2</span><br><span class="line">//xmm0= pdivector1+ pdivector2</span><br></pre></td></tr></table></figure>



<p>加法运算…</p>
<h3 id="pextrb-x2F-w-x2F-d-x2F-q"><a href="#pextrb-x2F-w-x2F-d-x2F-q" class="headerlink" title="pextrb&#x2F;w&#x2F;d&#x2F;q"></a>pextrb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011A3 pextrd  eax, xmm3, 0</span><br><span class="line">.text:00000000004011A9 pextrd  ebx, xmm3, 1</span><br><span class="line">.text:00000000004011AF pextrd  ecx, xmm3, 2</span><br><span class="line">.text:00000000004011B5 pextrd  edx, xmm3, 3</span><br><span class="line"></span><br><span class="line">.text:00000000004011BB pinsrd  xmm0, eax, 3</span><br><span class="line">.text:00000000004011C1 pinsrd  xmm0, ebx, 2</span><br><span class="line">.text:00000000004011C7 pinsrd  xmm0, ecx, 1</span><br><span class="line">.text:00000000004011CD pinsrd  xmm0, edx, 0</span><br></pre></td></tr></table></figure>



<p>pextrb</p>
<p>参数1&#x3D;byte 参数2[参数3]</p>
<p> pextrw</p>
<p>参数1&#x3D;word 参数2[参数3]</p>
<p> pextrd</p>
<p>参数1&#x3D;dword 参数2[参数3]</p>
<p> pextrq</p>
<p>参数1&#x3D;qword 参数2[参数3]</p>
<h3 id="pinsrb-x2F-w-x2F-d-x2F-q"><a href="#pinsrb-x2F-w-x2F-d-x2F-q" class="headerlink" title="pinsrb&#x2F;w&#x2F;d&#x2F;q"></a>pinsrb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011A3 pextrd  eax, xmm3, 0</span><br><span class="line">.text:00000000004011A9 pextrd  ebx, xmm3, 1</span><br><span class="line">.text:00000000004011AF pextrd  ecx, xmm3, 2</span><br><span class="line">.text:00000000004011B5 pextrd  edx, xmm3, 3</span><br><span class="line">.text:00000000004011BB pinsrd  xmm0, eax, 3</span><br><span class="line">.text:00000000004011C1 pinsrd  xmm0, ebx, 2</span><br><span class="line">.text:00000000004011C7 pinsrd  xmm0, ecx, 1</span><br><span class="line">.text:00000000004011CD pinsrd  xmm0, edx, 0</span><br></pre></td></tr></table></figure>



<p>pinsrb</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>pinsrw</p>
<p>pinsrd</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>参数2是4字节</p>
<p>参数1是xmm寄存器</p>
<p>参数3是index</p>
<p>pinsrq</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>参数2是8字节</p>
<p>参数1是xmm寄存器</p>
<p>参数3是index</p>
<h3 id="pcmpistri"><a href="#pcmpistri" class="headerlink" title="pcmpistri"></a>pcmpistri</h3><p>打包比较隐式的字符串,返回索引</p>
<h3 id="pcmpistrm"><a href="#pcmpistrm" class="headerlink" title="pcmpistrm"></a>pcmpistrm</h3><p>打包比较隐式的字符串,返回索引,返回掩码</p>
<h3 id="pcmpestri"><a href="#pcmpestri" class="headerlink" title="pcmpestri"></a>pcmpestri</h3><p>打包比较显式的字符串,返回索引</p>
<h3 id="pcmpestrm"><a href="#pcmpestrm" class="headerlink" title="pcmpestrm"></a>pcmpestrm</h3><p>打包比较显</p>
<p>式的字符串,返回掩码</p>
<h3 id="pxor"><a href="#pxor" class="headerlink" title="pxor"></a>pxor</h3><p>16字节与16字节异或</p>
<h3 id="mulsd"><a href="#mulsd" class="headerlink" title="mulsd"></a>mulsd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MULSD xmm1,xmm2/m64</span><br></pre></td></tr></table></figure>

<p>double低位之间的乘法</p>
<h1 id="FPU指令系统"><a href="#FPU指令系统" class="headerlink" title="FPU指令系统"></a>FPU指令系统</h1><p>里面的基础知识很多很杂,用到的地方也很少</p>
<p>遇到一个有用的指令就记录一下</p>
<p>FPU 不使用通用寄存器 (EAX、EBX 等等)。</p>
<p>反之，它有自己的一组寄存器，称为寄存器栈 (register stack)。</p>
<p>数值从内存加载到寄存器栈，然后执行计算，再将堆栈数值保存到内存。</p>
<p>他的没有esp,但是有top指针</p>
<h2 id="IEE-规范-存储小数"><a href="#IEE-规范-存储小数" class="headerlink" title="IEE 规范 存储小数"></a>IEE 规范 存储小数</h2><h3 id="化为二进制科学计算法"><a href="#化为二进制科学计算法" class="headerlink" title="化为二进制科学计算法"></a>化为二进制科学计算法</h3><p>用IEE规范转8.25</p>
<p>(1), 8转二进制0000 1000</p>
<p>(2).  0.25转二进制</p>
<p>​	0.25*2&#x3D;0.5   个位是0</p>
<p>​	0.5*2  &#x3D;1.0   个位是1</p>
<p>​	因为小数点第一位是0,所以结束</p>
<p>​	0.25&#x3D;0b01,不是0b10</p>
<p>​     这里0b10只有2位,有的可能是无限不循环,或者说是无限循环的,于是就有一个精确位的取舍</p>
<p>科学计数法</p>
<p> 8.25是1000.01,转科学计算法,1.00001*2的3次方</p>
<h3 id="分解二进制位"><a href="#分解二进制位" class="headerlink" title="分解二进制位"></a>分解二进制位</h3><p>(1)</p>
<p> 小数点后,数23位放到结果的二进制[9,31]位</p>
<p>00001-&gt;<code>00001000000000000000000 </code>没有就补0</p>
<p>(2)</p>
<p>之前的科学计算法,</p>
<p>小数点左移n位,n是正的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;1</p>
<p>小数点右移n位,n是负的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;0</p>
<p>或者直接127+n,结果后8位,填充[1,8]</p>
<p>左移n为正,右移,n位负</p>
<p>(3)</p>
<p> [0]位是符号位</p>
<blockquote>
<p>如果是8.25,[0]&#x3D;0</p>
<p>如果是-8.25,[0]&#x3D;1</p>
</blockquote>
<p>最后整合</p>
<p>01000001000001000000000000000000</p>
<p>转16进制,然后存储</p>
<p>0.25转</p>
<p>0转二进制-&gt;0b0</p>
<p>0.25转二进制-&gt;0.01</p>
<p>0.25-&gt;0b0.01-&gt;1.0*2的负二次方</p>
<p>符号位[0]&#x3D;0</p>
<p>[1]&#x3D;0 右移</p>
<p>-2-1&#x3D;-3&#x3D;1111 1101</p>
<p>取111 1101放入[2,8]</p>
<p>[1,8]&#x3D;0111 1101</p>
<p>数1.0*2的负二次方小数点后23位00000000000000000000000</p>
<p>整合</p>
<p>0    01111101   00000000000000000000000</p>
<p>最后再转16进制</p>
<h2 id="FPU-栈"><a href="#FPU-栈" class="headerlink" title="FPU 栈"></a>FPU 栈</h2><p>入栈是fld</p>
<p>出栈是fstp</p>
<p>他有栈有8个空间,st0~st7</p>
<p>这8个空间循环使用</p>
<p>栈顶指针始终指向st0</p>
<p>st只是一个标号</p>
<p>具体细节遇到后再完善</p>
<h2 id="舍入原则"><a href="#舍入原则" class="headerlink" title="舍入原则"></a>舍入原则</h2><h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p>对于0.5这种类型</p>
<p>如果整数部分是偶数,就保留整数,舍去小数部分</p>
<p>如果整数部分是奇数,就整数+1,舍去小数部分</p>
<p>对于0.1,0.2这种,直接舍去,然后整数不变</p>
<p>对于0.6,0.8这种,就直接舍去,整数+1</p>
<p>2.5&#x3D;2</p>
<p>3.5&#x3D;4</p>
<p>2.6&#x3D;3</p>
<p>2.1&#x3D;2</p>
<h3 id="向下舍入"><a href="#向下舍入" class="headerlink" title="向下舍入"></a>向下舍入</h3><p>就是小于它的最大整数</p>
<p>102.3&#x3D;102</p>
<p>-103.2&#x3D;-104</p>
<h3 id="向上舍入"><a href="#向上舍入" class="headerlink" title="向上舍入"></a>向上舍入</h3><p>就是大于它的最小整数</p>
<p>100.101&#x3D;101</p>
<p>-100.101&#x3D;-100</p>
<h3 id="向0舍入"><a href="#向0舍入" class="headerlink" title="向0舍入"></a>向0舍入</h3><p>数据向0靠齐,舍去小数部分</p>
<p>100,101&#x3D;100</p>
<p>-103.89&#x3D;-103</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>浮点指令名用字母 F 开头，以区别于 CPU 指令。</p>
<p>指令助记符的第二个字母（通常为 B 或 I）指明如何解释内存操作数：B 表示 BCD 操作数，I 表示二进制整数操作数。</p>
<p>末尾带P,表示要出栈</p>
<h3 id="实数传输指令"><a href="#实数传输指令" class="headerlink" title="实数传输指令"></a>实数传输指令</h3><h4 id="FLD-浮点数入栈"><a href="#FLD-浮点数入栈" class="headerlink" title="FLD  浮点数入栈"></a>FLD  浮点数入栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fld x</span><br></pre></td></tr></table></figure>

<p>可以把x入FPU栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">array REAL8 10 DUP (?)</span><br><span class="line">.code</span><br><span class="line">fld array                         ;直接寻址</span><br><span class="line">fld [array+16 ]                    ;直接偏移</span><br><span class="line">fld REAL8 PTR[esi]                 ;间接寻址</span><br><span class="line">fld array[esi]                      ;变址寻址</span><br><span class="line">fld array[esi*8]                    ;带比例因子的变址</span><br><span class="line">fld array[esi*TYPE array]             ;带比例因子的变址</span><br><span class="line">fld REAL8 PTR[ebx+esi]             ;基址-变址</span><br><span class="line">fld array[ebx+esi]                  ;基址-变址-偏移量</span><br><span class="line">fld aray[ebx+esi*TYPE array]         ;带比例因子的基址-变址-偏移量</span><br></pre></td></tr></table></figure>



<p>关于栈中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dblOne REAL8 234.56</span><br><span class="line">dblTwo REAL8 10.1</span><br><span class="line">.code</span><br><span class="line">fld dblOne      ; ST(0) = dblOne</span><br><span class="line">fld dblTwo      ; ST(0) = dblTwo, ST(1) = dblOne</span><br></pre></td></tr></table></figure>

<p>st(0)&#x3D;10.1</p>
<p>st(1)&#x3D;234.56</p>
<h4 id="FLD-xxx加载常数"><a href="#FLD-xxx加载常数" class="headerlink" title="FLD-xxx加载常数"></a>FLD-xxx加载常数</h4><p>下面的指令将特定常数加载到堆栈。这些指令没有操作数：</p>
<ul>
<li>FLD1 指令将 1.0 压入寄存器堆栈。</li>
<li>FLDL2T 指令将 log210 压入寄存器堆栈。</li>
<li>FLDL2E 指令将 log2e 压入寄存器堆栈。</li>
<li>FLDPI 指令将 π  压入寄存器堆栈。</li>
<li>FLDLG2 指令将 log102 压入寄存器堆栈。</li>
<li>FLDLN2 指令将 loge2压入寄存器堆栈。</li>
<li>FLDZ（加载零）指令将 0.0 压入 FPU 堆栈。</li>
</ul>
<h4 id="FILD-将整数入栈"><a href="#FILD-将整数入栈" class="headerlink" title="FILD 将整数入栈"></a>FILD 将整数入栈</h4><p>FILD（加载整数）指令将 16 位、32 位或 64 位&#x3D;&#x3D;有符号整数源操作数转换为双精度浮点数&#x3D;&#x3D;，并加载到 ST(0)。源操作数符号保留。</p>
<p>FILD 支持的内存操作数类型与 MOV 指令一致（间接、变址、基址-变址等）</p>
<h4 id="FBLD-bcd码入栈"><a href="#FBLD-bcd码入栈" class="headerlink" title="FBLD bcd码入栈"></a>FBLD bcd码入栈</h4><h4 id="FST-栈顶数据导出"><a href="#FST-栈顶数据导出" class="headerlink" title="FST  栈顶数据导出"></a>FST  栈顶数据导出</h4><p>FST（保存浮点数值）指令将浮点操作数从 FPU 栈顶复制到内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstp x</span><br></pre></td></tr></table></figure>

<p>把栈顶的数据给了x</p>
<p>不涉及TOP的变化</p>
<p>为什么说不涉及top变化</p>
<p>FST 不是弹出堆栈。下面的指令将 ST(0) 保存到内存。</p>
<p>假设</p>
<p>ST(0) 等于 10.1，</p>
<p>ST(1) 等于 234.56：</p>
<p>我们的栈顶指针一直是st(0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fst dblThree  ; fst取出了栈顶的数据10.1</span><br><span class="line">fst dblFour   ; fst还是取出了栈顶的数据10.1</span><br></pre></td></tr></table></figure>

<p>直观地说，代码段期望 dblFour 等于 234.56。</p>
<p>但是第一条 FST 指令把 10.1 留在 ST(0) 中。</p>
<p>如果代码段的意图是把 ST(1) 复制到 dblFour，那么就要用 FSTP 指令。</p>
<h4 id="FSTP-栈顶数据弹出栈"><a href="#FSTP-栈顶数据弹出栈" class="headerlink" title="FSTP 栈顶数据弹出栈"></a>FSTP 栈顶数据弹出栈</h4><p>FSTP（保存浮点值到Dest并将st0出栈）</p>
<p>假设执行下述指令前 </p>
<p>ST(0) 等于 10.1，</p>
<p>ST(1) 等于 234.56：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstp dblThree ; 10.1</span><br><span class="line">fstp dblFour ; 234.56</span><br></pre></td></tr></table></figure>

<p>指令执行后，这两个数值会从堆栈中逻辑移除。从物理上看，每次执行 FSTP，TOP 指针都会减 1，修改 ST(0) 的位置。</p>
<h4 id="FIST-栈顶数据四舍五入后导出"><a href="#FIST-栈顶数据四舍五入后导出" class="headerlink" title="FIST  栈顶数据四舍五入后导出"></a>FIST  栈顶数据四舍五入后导出</h4><p>首先栈顶得有数据</p>
<p>然后把栈顶的数据四舍五入后导出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fitp x</span><br></pre></td></tr></table></figure>

<p>出栈的数据给了x</p>
<p>不涉及top的变化</p>
<h4 id="FISTP-栈顶数据四舍五入后出栈"><a href="#FISTP-栈顶数据四舍五入后出栈" class="headerlink" title="FISTP 栈顶数据四舍五入后出栈"></a>FISTP 栈顶数据四舍五入后出栈</h4><p>原理和上面一样,不过会设计top的变化</p>
<h4 id="FBSTP-栈顶数据四舍五入后以bcd码出栈"><a href="#FBSTP-栈顶数据四舍五入后以bcd码出栈" class="headerlink" title="FBSTP 栈顶数据四舍五入后以bcd码出栈"></a>FBSTP 栈顶数据四舍五入后以bcd码出栈</h4><p>它不仅会对栈顶数据四舍五入还会对原地址的数据四舍五入</p>
<p>真的吗?</p>
<h4 id="fxch-实数交换"><a href="#fxch-实数交换" class="headerlink" title="fxch 实数交换"></a>fxch 实数交换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fxch </span><br><span class="line">fxch st(i)</span><br></pre></td></tr></table></figure>

<p>fxch实现了str[0]和st[1]的交换</p>
<p>fxch st[i]实现了st[i]与st[0]的交换</p>
<h3 id="实数比较"><a href="#实数比较" class="headerlink" title="实数比较"></a>实数比较</h3><p>浮点数不能使用 CMP 指令进行比较，因为后者是通过整数减法来执行比较的。取而代之，必须使用 FCOM 指令。</p>
<p>执行 FCOM 指令后，还需要采取特殊步骤，然后再使用逻辑 IF 语句中的条件跳转指令（JA、JB、JE 等）。</p>
<p>由于所有的浮点数都为隐含的有符号数，因此，FCOM 执行的是有符号比较。</p>
<h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><p>他们都是和st0比较</p>
<h5 id="fcom-x2F-fcomp-x2F-fcompp"><a href="#fcom-x2F-fcomp-x2F-fcompp" class="headerlink" title="fcom&#x2F;fcomp&#x2F;fcompp"></a>fcom&#x2F;fcomp&#x2F;fcompp</h5><p>FCOM（比较浮点数）指令将其源操作数与 ST(0) 进行比较,我们要把比较的数据入栈。</p>
<p>源操作数可以为内存操作数或 FPU 寄存器。其语法如下表所示：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FCOM</td>
<td>比较 ST(0) 与 ST(1)</td>
</tr>
<tr>
<td>FCOM m32fp</td>
<td>比较 ST(0) 与 m32fp</td>
</tr>
<tr>
<td>FCOM m64fp</td>
<td>比较 ST(0) 与 m64fp</td>
</tr>
<tr>
<td>FCOM ST(i)</td>
<td>比较 ST(0) 与 ST(i)</td>
</tr>
</tbody></table>
<p>FCOMP 指令的操作数类型和执行的操作与 FCOM 指令相同，但是它要将 ST(0) 弹岀堆栈。</p>
<p>FCOMPP 指令与 FCOMP 相同，但是它有两次出栈操作。</p>
<h5 id="fucom-x2F-fucomp-x2F-fucompp"><a href="#fucom-x2F-fucomp-x2F-fucompp" class="headerlink" title="fucom&#x2F;fucomp&#x2F;fucompp"></a>fucom&#x2F;fucomp&#x2F;fucompp</h5><p>他和前面讲的fcom是一样的货色</p>
<h5 id="fcomi-x2F-FCOMIP-x2F-FUCOMI-x2F-FUCOMIP"><a href="#fcomi-x2F-FCOMIP-x2F-FUCOMI-x2F-FUCOMIP" class="headerlink" title="fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP"></a>fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP</h5><p>它是<code>.686</code>的指令</p>
<p>在下面我们会讲一下条件码,于是会说到</p>
<p>把条件码怎么和eflag联系在一起</p>
<p>要用到fnstsw和sahf指令,这里的开销比较大</p>
<p>于是就进入了fcomi</p>
<p>跳过”把条件码怎么和eflag联系在一起”,直接把状态位给了eflag</p>
<p>FCOMI 指令代替了之前代码段中的三条指令，但是增加了一条 FLD 指令。也就是把要比较的数据都压入栈中</p>
<p>FCOMI 指令不使用内存操作数。</p>
<p>关于后面的3条指令也不多说</p>
<h5 id="FICOM-x2F-FICOMP"><a href="#FICOM-x2F-FICOMP" class="headerlink" title="FICOM&#x2F;FICOMP"></a>FICOM&#x2F;FICOMP</h5><p>就是把st0与操作数比较,初始化c3c2c0</p>
<p>ficomph会出栈</p>
<h5 id="FTST"><a href="#FTST" class="headerlink" title="FTST"></a>FTST</h5><p>将实数与0作比较,初始化c3c2c0</p>
<h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>FPU 条件码标识有 3 个，C3、C2 和 C0，用以说明浮点数比较的结果，</p>
<p>如下表所示。由于 C3、C2 和 C0 的功能分别与零标志位 (ZF)、奇偶标志位 (PF) 和进位标志位 (CF) 相同，</p>
<p>因此表中列标题给出了与之等价的 CPU 状态标识</p>
<table>
<thead>
<tr>
<th>条件 st0-操作数</th>
<th>C3&#x3D;&#x3D;ZF</th>
<th>C2&#x3D;&#x3D;PF</th>
<th>C0&#x3D;&#x3D;CF</th>
<th>使用的条件跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>ST(0) &gt; SPC</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>JA. JNBE</td>
</tr>
<tr>
<td>ST(0) &lt; SPC</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>JB. JNAE</td>
</tr>
<tr>
<td>ST(0) &#x3D; SPC</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>JE. JZ</td>
</tr>
<tr>
<td>无序</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>（无）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>JAE</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>JBE</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>JBE</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>JNE</td>
</tr>
</tbody></table>
<p>如果出现&#x3D;&#x3D;无效算术运算操作数&#x3D;&#x3D;异常（无效操作数,无穷大,无穷小,格式不正常,非实数），且该异常被屏蔽，则 C3、C2 和 C0 按照标记为“无序”的行来设置。</p>
<p>在比较了两个数值并设置了 FPU 条件码之后，遇到的主要挑战就是怎样根据条件分支到相应标号。这包括了两个步骤：</p>
<ul>
<li>用 FNSTSW 指令把 FPU 状态字送入 AX。</li>
<li>用 SAHF 指令把 AH 复制到 EFLAGS 寄存器。</li>
</ul>
<p>条件码送入 EFLAGS 之后，就可以根据 ZF、PF 和 CF 进行条件跳转。</p>
<p>问题是:为什么要送入eflag?</p>
<p>因为你的用的是FPU系统的条件码,和EFLAG无法直接联系在一起,毕竟你的跳转指令是和eflag联系的</p>
<p>所以我们才用fnstsw和sahf指令吧&#x3D;把条件码送入ax,再把ah送入eflag</p>
<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>所有算术运算指令支持的内存操作数类型与 FLD （加载）和 FST（保存）一致，’</p>
<p>因此，操作数可以是间接操作数、变址操作数和基址-变址操作数等等</p>
<table>
<thead>
<tr>
<th>FCHS</th>
<th>修改符号</th>
</tr>
</thead>
<tbody><tr>
<td>FADD</td>
<td>源操作数与目的操作数相加</td>
</tr>
<tr>
<td>FSUB</td>
<td>从目的操作数中减去源操作数</td>
</tr>
<tr>
<td>FSUBR</td>
<td>从源操作数中减去目的操作数</td>
</tr>
<tr>
<td>FMUL</td>
<td>源操作数与目的操作数相乘</td>
</tr>
<tr>
<td>FDIV</td>
<td>目的操作数除以源操作数</td>
</tr>
<tr>
<td>FDIVR</td>
<td>源操作数除以目的操作数</td>
</tr>
</tbody></table>
<h4 id="FADD-x2F-FADDP-x2F-FIADD"><a href="#FADD-x2F-FADDP-x2F-FIADD" class="headerlink" title="FADD&#x2F;FADDP&#x2F;FIADD"></a>FADD&#x2F;FADDP&#x2F;FIADD</h4><h5 id="fadd"><a href="#fadd" class="headerlink" title="fadd"></a>fadd</h5><p>FADD（加法）指令格式如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FADD</span><br><span class="line">FADD m32fp				;st0+=m32fp</span><br><span class="line">FADD m64fp				;st0+=m64fp</span><br><span class="line">FADD ST(0), ST(i)		;st0+=sti</span><br><span class="line">FADD ST(i) , ST(0)		;sti+=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣.如果 FADD 没有操作数，则 ST(0)与 ST(1)相加，结果暂存在 ST(1)。</p>
<p>然后 ST(0) 弹出堆栈，把加法结果保留在栈顶。假设堆栈已经包含了两个数值，</p>
<p>执行前</p>
<p>st0&#x3D;10.5</p>
<p>st1&#x3D;2.4</p>
<p>执行后</p>
<p>st0&#x3D;12.9</p>
<p>st1&#x3D;2.4</p>
<p>2️⃣如果参数是寄存器操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FADD ST(0), ST(1)</span><br></pre></td></tr></table></figure>

<p>同上</p>
<p>3️⃣如果使用的是内存操作数，FADD 将操作数与 ST(0) 相加。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fadd mySingle    	  ; ST(0) += mySingle</span><br><span class="line">fadd REAL8 PTR [esi]  ; ST(0) += [esi]</span><br></pre></td></tr></table></figure>



<h5 id="faddp"><a href="#faddp" class="headerlink" title="faddp"></a>faddp</h5><p>FADDP（相加并出栈）指令先执行加法操作，再将 ST(0) 弹出堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FADDP ST(i),ST(0)</span><br></pre></td></tr></table></figure>

<p>原理同上</p>
<h5 id="FIADD（整数加法）"><a href="#FIADD（整数加法）" class="headerlink" title="FIADD（整数加法）"></a>FIADD（整数加法）</h5><p>FIADD（整数加法）指令先将源操作数转换为扩展双精度浮点数，再与 ST(0) 相加。指令语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">myInteger DWORD 1</span><br><span class="line">.code</span><br><span class="line">fiadd myInteger          ; ST(0) += myInteger</span><br></pre></td></tr></table></figure>



<h4 id="FSUB-x2F-FSUBP-x2F-FISUB-x2F-FSUBR"><a href="#FSUB-x2F-FSUBP-x2F-FISUB-x2F-FSUBR" class="headerlink" title="FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBR"></a>FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBR</h4><h5 id="fsub"><a href="#fsub" class="headerlink" title="fsub"></a>fsub</h5><p>FSUB 指令从Dest中减去Source，并把result保存在Dest中。</p>
<p>Dest总是一个 FPU 寄存器，Source可以是 FPU 寄存器或者内存操作数。</p>
<p>该指令操作数类型与 FADD 指令一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSUB				;st0=st1-st0	;这里的顺序别错的</span><br><span class="line">FSUB m32fp			;st0=st0-m32fp</span><br><span class="line">FSUB m64fp			;st0=sto-m64fp</span><br><span class="line">FSUB ST(0), ST(i)	;st0=st0-sti</span><br><span class="line">FSUB ST(i), ST(0)	;sti=sti-st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FSUB 实现 ST(1) - ST(0)，结果暂存于 ST(1)。然后 ST(0) 弹出堆栈，将减法结果留在栈顶。</p>
<p>2️⃣若 FSUB 使用内存操作数，则从 ST(0) 中减去内存操作数，且不再弹出堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsub mySingle       ; ST(0) -= mySingle</span><br><span class="line">fsub array[edi*8]   ; ST(0) -= array[edi*8]</span><br></pre></td></tr></table></figure>



<h5 id="fsubp"><a href="#fsubp" class="headerlink" title="fsubp"></a>fsubp</h5><p>FSUBP（相减并出栈）指令先执行减法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FSUBP ST(i),ST(0)</span><br></pre></td></tr></table></figure>



<h5 id="FISUB（整数减法）"><a href="#FISUB（整数减法）" class="headerlink" title="FISUB（整数减法）"></a>FISUB（整数减法）</h5><p>FISUB（整数减法）指令先把源操作数转换为扩展双精度浮点数，再从 ST(0) 中减去该操作数：</p>
<h5 id="FSUBR"><a href="#FSUBR" class="headerlink" title="FSUBR"></a>FSUBR</h5><p>方向相减</p>
<p>之前的减法顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSUB				;st0=st1-st0	;这里的顺序别错的</span><br><span class="line">FSUB m32fp			;st0=st0-m32fp</span><br><span class="line">FSUB m64fp			;st0=sto-m64fp</span><br><span class="line">FSUB ST(0), ST(i)	;st0=st0-sti</span><br><span class="line">FSUB ST(i), ST(0)	;sti=sti-st0</span><br></pre></td></tr></table></figure>

<p>​	用一下fubr,减法的顺序就反了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSUBR				;st0=st1-st0	</span><br><span class="line">FSUBR m32fp			;st0=m32fp-st0</span><br><span class="line">FSUBR m64fp			;st0=m64fp-st0</span><br><span class="line">FSUBR ST(0), ST(i)	;st0=sti-st0</span><br><span class="line">FSUBR ST(i), ST(0)	;sti=st0-sti</span><br></pre></td></tr></table></figure>



<h4 id="FMUL-x2F-FMULP-x2F-FIMUl"><a href="#FMUL-x2F-FMULP-x2F-FIMUl" class="headerlink" title="FMUL &#x2F;FMULP&#x2F;FIMUl"></a>FMUL &#x2F;FMULP&#x2F;FIMUl</h4><h5 id="FMUL"><a href="#FMUL" class="headerlink" title="FMUL"></a>FMUL</h5><p>FMUL 指令将Source与Dest相乘，乘积保存在Dest中。</p>
<p>Dest总是一个 FPU 寄存器，Source可以为寄存器或者内存操作数。</p>
<p>其语法与 FADD 和 FSUB 相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FMUL				;st0*=st1</span><br><span class="line">FMUL m32fp			;st0*=m32fp</span><br><span class="line">FMUL m64fp			;st0*=m64fp</span><br><span class="line">FMUL ST(0), ST(i)	;st0*=sti</span><br><span class="line">FMUL ST(i), ST(0)	;sti*=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FMUL 将 ST(O) 与 ST(1) 相乘，乘积暂存于 ST(1)。然后 ST(0) 弹出堆栈，将乘积留在栈顶</p>
<p>2️⃣使用内存操作数的 FMUL 则将内存操作数与 ST(0) 相乘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmul mySingle    ; ST(0) *= mySingle</span><br></pre></td></tr></table></figure>

<h5 id="fmulp"><a href="#fmulp" class="headerlink" title="fmulp"></a>fmulp</h5><p>FMULP（相乘并出栈）指令先执行乘法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMULP ST(i),ST(O)</span><br></pre></td></tr></table></figure>

<h5 id="FIMUL-整数相乘"><a href="#FIMUL-整数相乘" class="headerlink" title="FIMUL 整数相乘"></a>FIMUL 整数相乘</h5><h4 id="FDIV-x2F-FDIVP-x2F-FIDIV-x2F-FDIVR"><a href="#FDIV-x2F-FDIVP-x2F-FIDIV-x2F-FDIVR" class="headerlink" title="FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVR"></a>FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVR</h4><h5 id="FDIV"><a href="#FDIV" class="headerlink" title="FDIV"></a>FDIV</h5><p>FDIV 指令执行Dest除以Source，被除数保存在Dest中。</p>
<p>Dest总是一个寄存器，Sourc可以为寄存器或者内存操作数。</p>
<p>其语法与 FADD 和 FSUB 相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FDIV					;st0=st1/st0</span><br><span class="line">FDIV m32fp				;st0/=m32fp</span><br><span class="line">FDIV m64fp				;st0/=m64fp</span><br><span class="line">FDIV ST(O), ST(i)		;st0/=sti</span><br><span class="line">FDIV ST(i), ST(O)		;sti/=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FDIV 执行 ST(1) 除以 ST(0)。然后 ST(0) 弹出堆栈，将被除数留在栈顶</p>
<p>2️⃣使用内存操作数的 FDIV 将 ST(0) 除以内存操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dblOne REAL8 1234.56</span><br><span class="line">dblTwo REAL8 10.0</span><br><span class="line">dblQuot REAL8 ?</span><br><span class="line">.code</span><br><span class="line">fid dblOne      ; 加载到 ST (0)</span><br><span class="line">fdiv dblTwo     ; ST(0) 除以 dblTwo</span><br><span class="line">fstp dblQuot    ; 将 ST(0) 保存到 dblQuot</span><br></pre></td></tr></table></figure>

<p>若源操作数为 0，则产生除零异常。若源操作数等于正、负无穷，零或 NaN，则使用一些特殊情况。</p>
<h5 id="fdivp"><a href="#fdivp" class="headerlink" title="fdivp"></a>fdivp</h5><p>多了一个出栈的操作</p>
<h5 id="fdivp-1"><a href="#fdivp-1" class="headerlink" title="fdivp"></a>fdivp</h5><p>FIDIV 指令先将整数源操作数转换为扩展双精度浮点数，再执行与 ST(0) 的除法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIDIV ml6int</span><br><span class="line">FIDIV m32int</span><br></pre></td></tr></table></figure>



<h5 id="FDIVR"><a href="#FDIVR" class="headerlink" title="FDIVR"></a>FDIVR</h5><p>把原来的除数当做被除数,被除数当做除数</p>
<p>但是结果还是放在Dest中</p>
<h3 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h3><h4 id="FCHS-x2F-FABS-求绝对值-st0-求相反数"><a href="#FCHS-x2F-FABS-求绝对值-st0-求相反数" class="headerlink" title="FCHS&#x2F;FABS  求绝对值|st0|,求相反数"></a>FCHS&#x2F;FABS  求绝对值|st0|,求相反数</h4><p>FCHS( 修改符号 ) 指令将 ST(0) 中浮点数值的符号取反</p>
<p>FABS ( 绝对值 ) 指令清除 ST(0) 中数值的符号，以得到它的绝对值。</p>
<p>这两条指令都没有操作数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FCHS</span><br><span class="line">FABS</span><br></pre></td></tr></table></figure>



<h4 id="fsqrt-求-sqrt-st0"><a href="#fsqrt-求-sqrt-st0" class="headerlink" title="fsqrt 求 $\sqrt{st0}$"></a>fsqrt 求 $\sqrt{st0}$</h4><p>用于求st0的平方根</p>
<h4 id="fxtract-求阶码与尾数"><a href="#fxtract-求阶码与尾数" class="headerlink" title="fxtract  求阶码与尾数"></a>fxtract  求阶码与尾数</h4><p>阶码不多说</p>
<p>尾数就是小数+整数吧</p>
<p>(10进制)12&#x3D;1.1x2^3(二进制)</p>
<p>于是</p>
<p>阶码3</p>
<p>尾数1.1(二进制)&#x3D;1.5(10进制)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flad xx</span><br><span class="line">fxtract</span><br><span class="line">fstp weishu</span><br><span class="line">fstp jeima</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;使用fxtrcat,他会把阶码压入栈st1,尾数压入栈st0&#x3D;&#x3D;</p>
<p>然后获取的话就是尾数出栈,阶码出栈</p>
<h4 id="fprem-x2F-fprem1-取余数"><a href="#fprem-x2F-fprem1-取余数" class="headerlink" title="fprem&#x2F;fprem1 取余数"></a>fprem&#x2F;fprem1 取余数</h4><p>取余数的原理是什么?</p>
<p>对于fprem</p>
<p>就是x&#x2F;y&#x3D;z</p>
<p>余数&#x3D;x-y*z</p>
<p>就是这个道理</p>
<p>对于fprem1</p>
<p>他的x&#x2F;y&#x3D;z会有一个四舍五入,这样的求余数当然会有误差</p>
<h4 id="frndint-四舍五入"><a href="#frndint-四舍五入" class="headerlink" title="frndint 四舍五入"></a>frndint 四舍五入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fld x</span><br><span class="line">frndint</span><br><span class="line">fstp y</span><br></pre></td></tr></table></figure>



<p>x&#x3D;2.5</p>
<p>那么y&#x3D;2</p>
<h4 id="fscale-求st0x2-st1"><a href="#fscale-求st0x2-st1" class="headerlink" title="fscale 求st0x2^st1^"></a>fscale 求st0x2^st1^</h4><p>fscale是求st0x2^st1^</p>
<p>st0乘以2的st1次方,结果返回st0</p>
<p>比如计数x*y^2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fld y			;入栈</span><br><span class="line">fld x			;入栈</span><br><span class="line">fscale</span><br><span class="line">fstp result		;出栈</span><br><span class="line">fstp buff		;出栈	</span><br></pre></td></tr></table></figure>



<h4 id="f2xm1-求2-st0-1"><a href="#f2xm1-求2-st0-1" class="headerlink" title="f2xm1 求2^st0^  -1"></a>f2xm1 求2^st0^  -1</h4><p>f2xm1 是求2^st0^  -1</p>
<p>计算2^x^-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fld x</span><br><span class="line">f2xm1</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h4 id="fyl2x-求-st1-times-log-2-st0"><a href="#fyl2x-求-st1-times-log-2-st0" class="headerlink" title="fyl2x 求  st1$\times$$log_2$st0"></a>fyl2x 求  st1$\times$$log_2$st0</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fld x</span><br><span class="line">fld y</span><br><span class="line">fyl2x</span><br><span class="line">fstp result </span><br></pre></td></tr></table></figure>



<p>结果存st1,st0出栈</p>
<h4 id="fyl2xp1-求-st1-times-log-2-st0-1"><a href="#fyl2xp1-求-st1-times-log-2-st0-1" class="headerlink" title="fyl2xp1 求 st1$\times$$log_2$(st0+1)"></a>fyl2xp1 求 st1$\times$$log_2$(st0+1)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fld x</span><br><span class="line">fld y</span><br><span class="line">fyl2xp1</span><br><span class="line">fstp result </span><br></pre></td></tr></table></figure>

<p>结果存st1,st0出栈</p>
<h4 id="三角函数-用弧度代入"><a href="#三角函数-用弧度代入" class="headerlink" title="三角函数 用弧度代入"></a>三角函数 用弧度代入</h4><h6 id="fsin-求-sin-st0"><a href="#fsin-求-sin-st0" class="headerlink" title="fsin 求$sin$(st0)"></a>fsin 求$sin$(st0)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fld jiaodu</span><br><span class="line">fmul PI</span><br><span class="line">fidiv Num_180</span><br><span class="line">fsin</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>

<p>你也可以直接算出弧度,再直接入栈</p>
<h6 id="fcos-求-cos-st0"><a href="#fcos-求-cos-st0" class="headerlink" title="fcos 求$cos$(st0)"></a>fcos 求$cos$(st0)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">st0弧度已经转化</span><br><span class="line">fld hudu&#x27;</span><br><span class="line">fcos</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h6 id="fsincos-求sin-st0-和-cos-st0"><a href="#fsincos-求sin-st0-和-cos-st0" class="headerlink" title="fsincos 求sin$(st0)和$cos(st0)"></a>fsincos 求sin$(st0)和$cos(st0)</h6><p>先计算sin入栈</p>
<p>再计算cos,入栈</p>
<p>于是</p>
<p>st1是sin</p>
<p>st0是cos</p>
<h6 id="fptan-求-tan-st0"><a href="#fptan-求-tan-st0" class="headerlink" title="fptan 求 $tan$(st0)"></a>fptan 求 $tan$(st0)</h6><p>st0还是弧度</p>
<p>不知道为什么.</p>
<p>st0会自动压入1</p>
<p>st1才是计算的结果</p>
<p>于是出栈的时候</p>
<p>先把st0弹出</p>
<p>再把结果弹出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fld hudu</span><br><span class="line">fptan</span><br><span class="line">fstp buff</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h6 id="fpatan-坐标轴下的有符号角度"><a href="#fpatan-坐标轴下的有符号角度" class="headerlink" title="fpatan 坐标轴下的有符号角度"></a>fpatan 坐标轴下的有符号角度</h6><p>好比</p>
<p>(1,1)&#x3D;45^0^</p>
<p>(-1,0)&#x3D;180^0^</p>
<p>st0是x坐标</p>
<p>st1是y坐标</p>
<p>返回的是一个弧度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fld y</span><br><span class="line">fld x</span><br><span class="line">fpatan</span><br><span class="line">fimul 180</span><br><span class="line">fstp  result</span><br></pre></td></tr></table></figure>

<p>余数结果就是度数</p>
<h3 id="FPU-控制指令"><a href="#FPU-控制指令" class="headerlink" title="FPU 控制指令"></a>FPU 控制指令</h3><h4 id="finit-x2F-fninit-初始化FPU"><a href="#finit-x2F-fninit-初始化FPU" class="headerlink" title="finit&#x2F;fninit 初始化FPU"></a>finit&#x2F;fninit 初始化FPU</h4><p>控制字是什么?就那几个判断异常的东西….</p>
<p>状态字是什么?就是C3C2C0</p>
<p>标记字是什么&gt;?</p>
<p>上面可能说错的……</p>
<p>反正他们会初始化一下FPU里的东西</p>
<p>然后</p>
<p>finit初始化前会检测没有处理的异常</p>
<p>fuinit初始化前并不会取检测</p>
<h4 id="fstsw-x2F-fntstw-导出状态字"><a href="#fstsw-x2F-fntstw-导出状态字" class="headerlink" title="fstsw&#x2F;fntstw 导出状态字"></a>fstsw&#x2F;fntstw 导出状态字</h4><p>针对于状态字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftstw ax		;检测并且处理异常,再状态字传递给ax,</span><br><span class="line">ftstw m16		;检测并且处理异常,再状态字传递给内存m16,</span><br><span class="line">fnstsw ax		;不检测并且处理异常,再状态字传递给ax,</span><br><span class="line">fnstsw m16		;不检测并且处理异常,再状态字传递给内存m16,</span><br></pre></td></tr></table></figure>



<h4 id="fstcw-x2F-fnstcw-导出控制字"><a href="#fstcw-x2F-fnstcw-导出控制字" class="headerlink" title="fstcw&#x2F;fnstcw 导出控制字"></a>fstcw&#x2F;fnstcw 导出控制字</h4><p>针对于控制字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstcw m16	;检测并且处理异常,再控制字传递给m16,</span><br><span class="line">fnstcw m16	;不检测并且处理异常,再控制字传递给m16,</span><br></pre></td></tr></table></figure>





<h4 id="fldcw-导入控制字"><a href="#fldcw-导入控制字" class="headerlink" title="fldcw  导入控制字"></a>fldcw  导入控制字</h4><p>把16位变量的值加载到控制字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fldcw m16</span><br></pre></td></tr></table></figure>

<h4 id="fldenv-导入环境"><a href="#fldenv-导入环境" class="headerlink" title="fldenv 导入环境"></a>fldenv 导入环境</h4><p>将src的数据加载到FPU</p>
<h4 id="fstenv-x2F-fnstenv-导出小环境"><a href="#fstenv-x2F-fnstenv-导出小环境" class="headerlink" title="fstenv&#x2F;fnstenv 导出小环境"></a>fstenv&#x2F;fnstenv 导出小环境</h4><p>保存FPU当前操作环境到Dest内存变量指定的14或者28字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstenv dest 	;检测并且处理异常后保存到dext,再屏蔽异常</span><br><span class="line">fnstenv Dest	:不检测并且处理异常,直接保存到dext,再屏蔽异常</span><br></pre></td></tr></table></figure>

<h4 id="fsave-x2F-fnsave-导出大环境"><a href="#fsave-x2F-fnsave-导出大环境" class="headerlink" title="fsave&#x2F;fnsave 导出大环境"></a>fsave&#x2F;fnsave 导出大环境</h4><p>把fpu当前状态导出到94或者108字节的内存,然后自动初始化FPU</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsave dest		;检测/处理异常,然后导出到dext,然后初始化FPU</span><br><span class="line">fnsave	dest	;不检测/处理异常,然后导出到dest,然后出释怀fpu</span><br></pre></td></tr></table></figure>





<h4 id="fclex-x2F-fncles-清除异常"><a href="#fclex-x2F-fncles-清除异常" class="headerlink" title="fclex&#x2F;fncles  清除异常"></a>fclex&#x2F;fncles  清除异常</h4><p>清除浮点异常标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclex		;检测并且处理异常,然后清除异常标志位</span><br><span class="line">fnclex		;不检测并且处理异常,直接清除异常标志位</span><br></pre></td></tr></table></figure>

<p>除了像fstenv那样,他还会保存浮点数数据寄存器,按照st0-st7的顺序紧随其后</p>
<h4 id="frstor导入环境"><a href="#frstor导入环境" class="headerlink" title="frstor导入环境"></a>frstor导入环境</h4><p>把src的94或者108个字节导入到fpu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frstor src</span><br></pre></td></tr></table></figure>



<h4 id="fincstp-x2F-fdecstp-top的自增自减"><a href="#fincstp-x2F-fdecstp-top的自增自减" class="headerlink" title="fincstp &#x2F;fdecstp top的自增自减"></a>fincstp &#x2F;fdecstp top的自增自减</h4><p>Inc top 会让st0的数据转移到st7,(st0去部st7的位)</p>
<p>dec top会让st7的数据转移到st0,(st7去补st0的位)</p>
<p>可以对应一下栈图,因为他只有8个空间,要循环使用,所以的话才会有这种奇奇怪怪的转移</p>
<p>inc之前&#x2F;dec之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br></pre></td></tr></table></figure>

<p>inc之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>dec之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.#IND</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br></pre></td></tr></table></figure>



<h4 id="ffree-sti"><a href="#ffree-sti" class="headerlink" title="ffree sti"></a>ffree sti</h4><p>free后sti就是<code>-1/#IND</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffree st(0)</span><br></pre></td></tr></table></figure>



<h4 id="fnop"><a href="#fnop" class="headerlink" title="fnop"></a>fnop</h4><p>同CPU的nop</p>
<h4 id="fwait-x2F-wait"><a href="#fwait-x2F-wait" class="headerlink" title="fwait&#x2F;wait"></a>fwait&#x2F;wait</h4><p>他们是同一个东西</p>
<p>功能是检查并且处理没有屏蔽的浮点异常</p>
<p>在浮点指令后加一条wait指令确保任何未被处理的异常在下一条IP执行前被处理</p>
<h2 id="异常同步fwait-x2F-wait"><a href="#异常同步fwait-x2F-wait" class="headerlink" title="异常同步fwait&#x2F;wait"></a>异常同步fwait&#x2F;wait</h2><p>整数 (CPU) 和 FPU 是相互独立的单元，因此，在执行整数和系统指令的同时可以执行浮点指令。这个功能被称为并行性 (concurrency)，</p>
<p>我认为这是一个很好的隐藏手段,IDA都调试不了中间过程</p>
<p>当发生未屏蔽的浮点异常时，它可能是个潜在的问题。反之，已屏蔽异常则不成问题，因为，FPU 总是可以完成当前操作并保存结果。</p>
<h2 id="FXAM"><a href="#FXAM" class="headerlink" title="FXAM"></a>FXAM</h2><p>检测st0是否是0,正无穷,负无穷,非实数,或者正常数,然后会初始化c3c2c0</p>
<p>具体遇到再说</p>
<h2 id="异常的屏蔽与未屏蔽简述"><a href="#异常的屏蔽与未屏蔽简述" class="headerlink" title="异常的屏蔽与未屏蔽简述"></a>异常的屏蔽与未屏蔽简述</h2><h3 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h3><h4 id="fstcw"><a href="#fstcw" class="headerlink" title="fstcw"></a>fstcw</h4><p> ;获取控制字</p>
<h4 id="fldcw"><a href="#fldcw" class="headerlink" title="fldcw"></a>fldcw</h4><p>;结果加载到 FPU</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>默认情况下，异常是被屏蔽的，因此，当出现浮点异常时，处理器分配一个默认值为结果，并继续平稳地工作。</p>
<p>例如，一个浮点数除以 0 生成结果为无穷，但不会中断程序,是吗?????哦????</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">.code</span><br><span class="line">fild val1        ;整数加载到ST(0)</span><br><span class="line">fdiv val2       ;ST(0) =正无穷</span><br></pre></td></tr></table></figure>

<p>如果 FPU 控制字没有屏蔽异常，那么处理器就会试着执行合适的异常处理程序。</p>
<p>清除 FPU 控制字中的相应位就可以实现异常的未屏蔽操作，如下表所示。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>无效操作异常屏蔽位</td>
<td>5</td>
<td>精度异常屏蔽位</td>
</tr>
<tr>
<td>1</td>
<td>非规格化操作数异常屏蔽位</td>
<td>8〜9</td>
<td>精度控制位</td>
</tr>
<tr>
<td>2</td>
<td>除零异常屏蔽位</td>
<td>10〜11</td>
<td>舍入控制位</td>
</tr>
<tr>
<td>3</td>
<td>上溢异常屏蔽位</td>
<td>12</td>
<td>无穷控制位</td>
</tr>
<tr>
<td>4</td>
<td>下溢异常屏蔽位</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>于是对于除0异常,我们就去看2位,把它置0</p>
<ol>
<li><p>将 FPU 控制字保存到 16 位变量。</p>
</li>
<li><p>清除位 2（除零标志位）。</p>
</li>
<li><p>将变量加载回控制字。</p>
</li>
</ol>
<p>一个自动被屏蔽的异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">hello	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">fmt	byte	&quot;%s&quot;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fild val1        ;整数加载到ST(0)</span><br><span class="line">		fdiv val2       ;ST(0) =正无穷</span><br><span class="line">		invoke  printf,offset fmt,offset hello</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后我们</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">ctrlWord WORD ?</span><br><span class="line">.code</span><br><span class="line">fstcw ctrlWord                   ;获取控制字</span><br><span class="line">and ctrlWord, 1111111111111011b  ;不屏蔽除零异常</span><br><span class="line">fldcw ctrlWord                   ;结果加载回 FPU</span><br></pre></td></tr></table></figure>

<p>然后我们也没发生啥呀….woc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">ctrlWord WORD ?</span><br><span class="line"></span><br><span class="line">hello	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">fmt	byte	&quot;%s&quot;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		fstcw ctrlWord</span><br><span class="line">		and ctrlWord, 1111111111111011b</span><br><span class="line">		fldcw ctrlWord</span><br><span class="line"></span><br><span class="line">		fild val1        ;整数加载到ST(0)</span><br><span class="line">		fdiv val2       ;ST(0) =正无穷</span><br><span class="line">		invoke  printf,offset fmt,offset hello</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="x64的浮点数四则运算"><a href="#x64的浮点数四则运算" class="headerlink" title="x64的浮点数四则运算"></a>x64的浮点数四则运算</h2><p>假设我们用的双精度浮点运算</p>
<h3 id="addsd-加法"><a href="#addsd-加法" class="headerlink" title="addsd 加法"></a>addsd 加法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">addsd xmm2, [number2]	; add into to xmm</span><br></pre></td></tr></table></figure>



<h3 id="subsd-减法"><a href="#subsd-减法" class="headerlink" title="subsd 减法"></a>subsd 减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">subsd xmm2, [number2]	; subtract from xmm</span><br></pre></td></tr></table></figure>



<h3 id="mulsd-乘法"><a href="#mulsd-乘法" class="headerlink" title="mulsd 乘法"></a>mulsd 乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">mulsd xmm2, [number2]	; multiply with xmm </span><br></pre></td></tr></table></figure>



<h3 id="divsd-除法"><a href="#divsd-除法" class="headerlink" title="divsd 除法"></a>divsd 除法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">divsd xmm2, [number2]	; divide xmm0 </span><br></pre></td></tr></table></figure>



<h3 id="sqrtsd-开方"><a href="#sqrtsd-开方" class="headerlink" title="sqrtsd 开方"></a>sqrtsd 开方</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqrtsd xmm1, [number1]</span><br><span class="line">//结果保持在xmm1中</span><br></pre></td></tr></table></figure>



<h2 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h2><h3 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h3><p>valD&#x3D;-valA+(valB*valC)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">valA REAL8 1.5</span><br><span class="line">valB REAL8 2.5</span><br><span class="line">valC REAL8 3.0</span><br><span class="line">valD REAL8 ? ; +6.0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fld valA    ; ST(0) = valA</span><br><span class="line">		fchs        ;修改 ST(0) 的符号</span><br><span class="line">		fld valB    ; 将 valB 加载到 ST(0)</span><br><span class="line">		fmul valC   ; ST(0) *= valC</span><br><span class="line">		fadd        ; ST(0) += ST(1)</span><br><span class="line">		fstp valD   ; 将 ST(0) 保存到 valD</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		;invoke	printf,addr out_fmt,edi</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">ARRAY_SIZE = 20</span><br><span class="line">sngArray REAL8 1.2,2.3,3.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		    mov		esi, 0            ;数组索引</span><br><span class="line">		    fldz			  ; 0.0 入栈</span><br><span class="line">		    mov		ecx,ARRAY_SIZE</span><br><span class="line">		L1: fld		sngArray[esi]     ;将内存操作数加载到ST(0)</span><br><span class="line">		    fadd			  ; ST(0) 加 ST(1),出栈</span><br><span class="line">		    add		esi,TYPE REAL8    ;移至!I 下一个元素</span><br><span class="line">		    loop	L1</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="开方求和"><a href="#开方求和" class="headerlink" title="开方求和"></a>开方求和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">valA REAL8 25.0</span><br><span class="line">valB REAL8 36.0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fld valA        ; valA 入栈</span><br><span class="line">		fsqrt           ; ST(0) = sqrt(valA)</span><br><span class="line">		fld valB        ; valB 入栈</span><br><span class="line">		fsqrt           ; ST(0) = sqrt(valB)</span><br><span class="line">		fadd            ; ST (0)+ST(1)</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="C语言的强制类型转换"><a href="#C语言的强制类型转换" class="headerlink" title="C语言的强制类型转换"></a>C语言的强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> X = <span class="number">3.5</span>;</span><br><span class="line"><span class="type">double</span> Z = N + X;</span><br><span class="line"><span class="comment">//asm</span></span><br><span class="line">.data</span><br><span class="line">N SDWORD <span class="number">20</span></span><br><span class="line">X REAL8 <span class="number">3.5</span></span><br><span class="line">Z REAL8 ?</span><br><span class="line">.code</span><br><span class="line">fild n         ;整数加载到ST(<span class="number">0</span>)</span><br><span class="line">fadd X       ;将内存操作数与ST(<span class="number">0</span>)相加</span><br><span class="line">fstp z        ;将ST(<span class="number">0</span>)保存到内存操作数</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> X = <span class="number">3.5</span>;</span><br><span class="line"><span class="type">int</span> Z = (<span class="type">int</span>)(N + X);</span><br><span class="line"><span class="comment">//Asm</span></span><br><span class="line">fild N   	;整数加载到ST(<span class="number">0</span>)</span><br><span class="line">fadd X  	;将内存操作数与ST(<span class="number">0</span>)相加</span><br><span class="line">fist Z    	;将ST(<span class="number">0</span>)保存为整型内存操作数,这里就是一个转化</span><br></pre></td></tr></table></figure>



<h3 id="修改舍入模式-什么鬼"><a href="#修改舍入模式-什么鬼" class="headerlink" title="修改舍入模式,什么鬼"></a>修改舍入模式,什么鬼</h3><p>FPU 控制字的 RC 字段指定使用的舍入类型。可以先用 FSTCW 把控制字保存为一个变量，再修改 RC 字段（位 10 和 11）,最后用 FLDCW 指令把这个变量加载回控制字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fstew ctrlWord             ;保存控制字</span><br><span class="line">or ctrlWord, 110000000000b ;设置眈=截断</span><br><span class="line">fldcw ctrlWord             ;加载控制字</span><br></pre></td></tr></table></figure>

<p>之后采用截断执行计算，生成结果为 Z&#x3D;23：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fild N  ;整数加载到ST(0)</span><br><span class="line">fadd X ;将内存整数与ST(0)相加</span><br><span class="line">fist Z   ;将ST(0)保存为整型内存操作数</span><br></pre></td></tr></table></figure>

<p>或者，把舍入模式重新设置为默认选项（舍入到最接近的偶数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fstcw ctrlWord               ;保存控制字</span><br><span class="line">and ctrlWord, 001111111111b  ;重置舍入模式为默认</span><br><span class="line">fldcw ctrlWord               ;加载控制字 </span><br></pre></td></tr></table></figure>











</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://gitee.com/re4mile/re4mile.git">re4mile</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://gitee.com/re4mile/re4mile.git/2021/06/07/language/Asm/windwos/%E6%8C%87%E4%BB%A4/language/">https://gitee.com/re4mile/re4mile.git/2021/06/07/language/Asm/windwos/%E6%8C%87%E4%BB%A4/language/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/re4mile/tags/Assembly/">Assembly</a><a class="post-meta__tags" href="/re4mile/tags/x86/">x86</a></div><div class="post_share"><div class="social-share" data-image="/re4mile/img/bk5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/re4mile/2021/06/07/language/Asm/windwos/%E5%AE%9E%E8%B7%B5/language/" title="x86汇编语言实践部分"><img class="cover" src="/re4mile/img/bk5.jpg" onerror="onerror=null;src='/re4mile/img/banner.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">x86汇编语言实践部分</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/re4mile/2021/06/07/language/Asm/windwos/%E5%9F%BA%E7%A1%80/language/" title="x86汇编语言基础部分"><img class="cover" src="/re4mile/img/bk5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-07</div><div class="title">x86汇编语言基础部分</div></div></a></div><div><a href="/re4mile/2021/06/07/language/Asm/windwos/%E5%AE%9E%E8%B7%B5/language/" title="x86汇编语言实践部分"><img class="cover" src="/re4mile/img/bk5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-07</div><div class="title">x86汇编语言实践部分</div></div></a></div><div><a href="/re4mile/2021/06/07/language/Asm/linux/language/" title="Linux汇编语言基础部分"><img class="cover" src="/re4mile/img/bk5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-07</div><div class="title">Linux汇编语言基础部分</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/re4mile/img/wlq.jpg" onerror="this.onerror=null;this.src='/re4mile/img/banner.jpg'" alt="avatar"/></div><div class="author-info__name">re4mile</div><div class="author-info__description">an ordinary people</div></div><div class="card-info-data site-data is-center"><a href="/re4mile/archives/"><div class="headline">Articles</div><div class="length-num">65</div></a><a href="/re4mile/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a><a href="/re4mile/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.cnblogs.com/re4mile/"><i class="fab fa-linux"></i><span>我的另外一个博客</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/re4mile" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/re4mile" target="_blank" title="Gitee"><i class="fab fa-google"></i></a><a class="social-icon" href="mailto:935797872@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">路漫漫其修远兮,吾将上下而求索. ——屈原·离骚</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">常用指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E7%AC%A6-%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%B8%80%E5%8F%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">\ 换行符 连接上一句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">段指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data"><span class="toc-number">1.1.3.</span> <span class="toc-text">.data?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">1.1.4.</span> <span class="toc-text">.const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bss"><span class="toc-number">1.1.5.</span> <span class="toc-text">.bss</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">栈段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equ-%E7%9B%B8%E7%AD%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">equ 相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#textequ-%E6%96%87%E6%9C%AC%E7%9B%B8%E7%AD%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">textequ 文本相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%87%E5%8F%B7"><span class="toc-number">1.1.8.</span> <span class="toc-text">@@ 地址标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.9.</span> <span class="toc-text">type 获取数据类型的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lengthof-%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.10.</span> <span class="toc-text">lengthof 计算数组元素的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-x2F-size-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%BB%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">1.1.11.</span> <span class="toc-text">sizeof&#x2F;size 返回数组的总字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef-%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.12.</span> <span class="toc-text">typedef 定义新的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.13.</span> <span class="toc-text">$ 地址计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.13.1.</span> <span class="toc-text">获取当前位置的偏移地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.1.13.2.</span> <span class="toc-text">计算数组长度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.13.2.1.</span> <span class="toc-text">简要介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5"><span class="toc-number">1.1.13.2.2.</span> <span class="toc-text">一般情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.13.2.3.</span> <span class="toc-text">其它类型数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-%E7%AD%89%E5%8F%B7%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.14.</span> <span class="toc-text">&#x3D;  等号指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#high-x2F-low-x2F-highword-x2F-lowword"><span class="toc-number">1.1.15.</span> <span class="toc-text">high&#x2F;low&#x2F;highword&#x2F;lowword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.16.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">非伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">字节对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#align"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">align</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alignb"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">alignb</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCD%E7%A0%81%E6%8C%87%E4%BB%A4-gt-fld-fbstp"><span class="toc-number">1.2.2.</span> <span class="toc-text">BCD码指令-&gt;fld,fbstp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inc-x2F-dec-x2F-add-x2F-sub"><span class="toc-number">1.2.3.</span> <span class="toc-text">inc&#x2F;dec&#x2F;add&#x2F;sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">dup 数据重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offset-%E5%B0%B1%E5%8F%96%E5%A4%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.5.</span> <span class="toc-text">offset 就取处偏移地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lea-%E5%8F%96%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.6.</span> <span class="toc-text">lea 取地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptr-%E9%87%8D%E5%86%99%E6%93%8D%E4%BD%9C%E6%95%B0%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">ptr 重写操作数大小类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xchg-%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.8.</span> <span class="toc-text">xchg 交换指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">1.2.9.</span> <span class="toc-text">call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop"><span class="toc-number">1.2.10.</span> <span class="toc-text">loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmpxchg"><span class="toc-number">1.2.11.</span> <span class="toc-text">cmpxchg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bsr-x2F-bsf-%E4%BD%8D%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.12.</span> <span class="toc-text">bsr&#x2F;bsf 位扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bswap-%E5%AD%97%E8%8A%82%E5%8F%8D%E5%90%91%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.13.</span> <span class="toc-text">bswap 字节反向存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return%E8%BF%94%E5%9B%9E"><span class="toc-number">1.2.14.</span> <span class="toc-text">return返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ret%E8%BF%91%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.2.14.1.</span> <span class="toc-text">ret近转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retn-%E8%BF%91%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.2.14.2.</span> <span class="toc-text">retn 近转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retf-%E8%BF%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.2.14.3.</span> <span class="toc-text">retf 远转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iret-%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E"><span class="toc-number">1.2.14.4.</span> <span class="toc-text">iret 中断返回</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AC%ACi%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.15.</span> <span class="toc-text">二进制第i位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bt"><span class="toc-number">1.2.15.1.</span> <span class="toc-text">bt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#btc"><span class="toc-number">1.2.15.2.</span> <span class="toc-text">btc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#btr"><span class="toc-number">1.2.15.3.</span> <span class="toc-text">btr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bts"><span class="toc-number">1.2.15.4.</span> <span class="toc-text">bts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.16.</span> <span class="toc-text">CPU控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nop"><span class="toc-number">1.2.16.1.</span> <span class="toc-text">nop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait"><span class="toc-number">1.2.16.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hlt-%E6%9A%82%E5%81%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.16.3.</span> <span class="toc-text">hlt 暂停指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E5%B0%81%E9%94%81%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.16.4.</span> <span class="toc-text">lock 封锁数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpuid-%E8%8E%B7%E5%8F%96CPU%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.16.5.</span> <span class="toc-text">cpuid 获取CPU信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.17.</span> <span class="toc-text">条件跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jmp"><span class="toc-number">1.2.17.1.</span> <span class="toc-text">jmp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.17.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.2.17.1.2.</span> <span class="toc-text">机器码剖析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83jmp"><span class="toc-number">1.2.17.1.3.</span> <span class="toc-text">其它jmp</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmp-%E6%9C%89%E7%AC%A6%E5%8F%B7-x2F-%E6%97%A0%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.2.17.2.</span> <span class="toc-text">cmp-有符号&#x2F;无符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eflag%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.17.3.</span> <span class="toc-text">eflag跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.17.4.</span> <span class="toc-text">相等跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.17.5.</span> <span class="toc-text">无符号跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.17.6.</span> <span class="toc-text">有符号的跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6%E8%BD%AC%E5%AD%98%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.17.7.</span> <span class="toc-text">测试条件转存指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.17.8.</span> <span class="toc-text">条件跳转的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E4%B8%80%E4%BD%8D%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF"><span class="toc-number">1.2.17.8.1.</span> <span class="toc-text">某一位是否开启</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E5%87%A0%E4%BD%8D%E5%BD%93%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E4%BB%BB%E6%84%8F%E4%B8%80%E4%BD%8D%E5%BC%80%E5%90%AF"><span class="toc-number">1.2.17.8.2.</span> <span class="toc-text">某几位当中是否有任意一位开启</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E5%87%A0%E4%BD%8D%E9%83%BD%E5%BC%80%E5%90%AF"><span class="toc-number">1.2.17.8.3.</span> <span class="toc-text">某几位都开启</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%823%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.2.17.8.4.</span> <span class="toc-text">求3个数的最小值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.17.8.5.</span> <span class="toc-text">数的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.18.</span> <span class="toc-text">条件测试+与循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.18.1.</span> <span class="toc-text">条件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#if-x2F-elseif-x2F-endif-x2F-else"><span class="toc-number">1.2.18.1.1.</span> <span class="toc-text">.if&#x2F;.elseif&#x2F;.endif&#x2F;.else</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.18.1.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A9%E5%9D%91"><span class="toc-number">1.2.18.1.3.</span> <span class="toc-text">天坑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F"><span class="toc-number">1.2.18.1.4.</span> <span class="toc-text">代码示意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.18.2.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.18.3.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movsx-x2F-movzx-%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.19.</span> <span class="toc-text">movsx&#x2F;movzx 符号扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%89%A9%E5%B1%95-x2F-%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.19.1.</span> <span class="toc-text">零扩展&#x2F;符号扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.20.</span> <span class="toc-text">整数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AND-x2F-OR-x2F-NOT-x2F-XOR-x2F-TEST"><span class="toc-number">1.2.20.1.</span> <span class="toc-text">AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.2.20.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E9%9B%86"><span class="toc-number">1.2.20.1.2.</span> <span class="toc-text">映射集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#neg"><span class="toc-number">1.2.20.2.</span> <span class="toc-text">neg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shl-x2F-shr"><span class="toc-number">1.2.20.3.</span> <span class="toc-text">shl&#x2F;shr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sal-x2F-sar"><span class="toc-number">1.2.20.4.</span> <span class="toc-text">sal&#x2F;sar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ROL-x2F-ROR-%E5%90%8E%E8%BF%9B%E4%BD%8D%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.2.20.5.</span> <span class="toc-text">ROL&#x2F;ROR 后进位循环移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RCL-x2F-RCR-%E5%85%88%E8%BF%9B%E4%BD%8D%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.2.20.6.</span> <span class="toc-text">RCL&#x2F;RCR 先进位循环移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLD-x2F-SHRD"><span class="toc-number">1.2.20.7.</span> <span class="toc-text">SHLD&#x2F;SHRD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mul-%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.20.8.</span> <span class="toc-text">mul 乘法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMUL-%E6%8C%87%E4%BB%A4-%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.20.9.</span> <span class="toc-text">IMUL 指令 有符号的乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DIV-%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.20.10.</span> <span class="toc-text">DIV 除法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDIV-%E6%9C%89%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">1.2.20.11.</span> <span class="toc-text">IDIV 有符号除法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cbw-x2F-cwd-x2F-cdq-x2F-cdqe-x2F-cwde%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.20.12.</span> <span class="toc-text">cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adc-%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.20.13.</span> <span class="toc-text">adc 进位加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sbb-%E5%80%9F%E4%BD%8D%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.20.14.</span> <span class="toc-text">sbb 借位减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xadd-%E5%BE%88sb%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.20.15.</span> <span class="toc-text">xadd 很sb的加法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A910%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.21.</span> <span class="toc-text">非压缩10进制算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aaa-%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.21.1.</span> <span class="toc-text">aaa 加法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.21.1.1.</span> <span class="toc-text">通俗介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E8%AF%B4"><span class="toc-number">1.2.21.1.2.</span> <span class="toc-text">书上说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.21.1.3.</span> <span class="toc-text">关于计算过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.2.21.1.4.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#daa-%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.21.2.</span> <span class="toc-text">daa 加法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E8%AF%B4-1"><span class="toc-number">1.2.21.2.1.</span> <span class="toc-text">书上说</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aas-%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.21.3.</span> <span class="toc-text">aas 减法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E8%AF%B4-2"><span class="toc-number">1.2.21.3.1.</span> <span class="toc-text">书上说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">1.2.21.3.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#das-%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.21.4.</span> <span class="toc-text">das 减法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E8%AF%B4-3"><span class="toc-number">1.2.21.4.1.</span> <span class="toc-text">书上说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">1.2.21.4.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aam-%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.21.5.</span> <span class="toc-text">aam 乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aad-%E9%99%A4%E6%B3%95"><span class="toc-number">1.2.21.6.</span> <span class="toc-text">aad 除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.22.</span> <span class="toc-text">字符串基本指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E6%A0%87%E5%BF%97%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.22.1.</span> <span class="toc-text">方向标志位指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%80%80%E5%87%BA%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80"><span class="toc-number">1.2.22.2.</span> <span class="toc-text">字符串循环的退出条件之一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#movs-b-x2F-w-x2F-d-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.22.3.</span> <span class="toc-text">movs b&#x2F;w&#x2F;d  数据复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmpsb-x2F-sw-x2F-sd-%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.22.4.</span> <span class="toc-text">cmpsb&#x2F;sw&#x2F;sd 数据比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scasb-x2F-sw-x2F-sd-%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.22.5.</span> <span class="toc-text">scasb&#x2F;sw&#x2F;sd 数据遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stos-b-x2F-w-x2F-d-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5"><span class="toc-number">1.2.22.6.</span> <span class="toc-text">stos b&#x2F;w&#x2F;d 数据存入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#losb-x2F-sw-x2F-sd-%E6%95%B0%E6%8D%AE%E6%8B%BF%E5%87%BA"><span class="toc-number">1.2.22.7.</span> <span class="toc-text">losb&#x2F;sw&#x2F;sd 数据拿出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xlat-x2F-xlatb"><span class="toc-number">1.2.22.8.</span> <span class="toc-text">xlat&#x2F;xlatb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insb-x2F-w-x2F-d-%E8%BE%93%E5%85%A5%E4%B8%B2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.22.9.</span> <span class="toc-text">insb&#x2F;w&#x2F;d 输入串指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#outsb-x2F-w-x2F-d%E8%BE%93%E5%87%BA%E4%B8%B2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.22.10.</span> <span class="toc-text">outsb&#x2F;w&#x2F;d输出串指令</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x64"><span class="toc-number">2.</span> <span class="toc-text">x64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#movups"><span class="toc-number">2.0.1.</span> <span class="toc-text">movups</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movaps"><span class="toc-number">2.0.2.</span> <span class="toc-text">movaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movaps-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">movaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movapd"><span class="toc-number">2.0.4.</span> <span class="toc-text">movapd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movss"><span class="toc-number">2.0.5.</span> <span class="toc-text">movss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movdqa"><span class="toc-number">2.0.6.</span> <span class="toc-text">movdqa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movd"><span class="toc-number">2.0.7.</span> <span class="toc-text">movd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movq"><span class="toc-number">2.0.8.</span> <span class="toc-text">movq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movsd"><span class="toc-number">2.0.9.</span> <span class="toc-text">movsd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addps"><span class="toc-number">2.0.10.</span> <span class="toc-text">addps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appad"><span class="toc-number">2.0.11.</span> <span class="toc-text">appad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cvtss2sd"><span class="toc-number">2.0.12.</span> <span class="toc-text">cvtss2sd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cvtsd2ss"><span class="toc-number">2.0.13.</span> <span class="toc-text">cvtsd2ss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paddb-x2F-w-x2F-d-x2F-q"><span class="toc-number">2.0.14.</span> <span class="toc-text">paddb&#x2F;w&#x2F;d&#x2F;q</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pextrb-x2F-w-x2F-d-x2F-q"><span class="toc-number">2.0.15.</span> <span class="toc-text">pextrb&#x2F;w&#x2F;d&#x2F;q</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinsrb-x2F-w-x2F-d-x2F-q"><span class="toc-number">2.0.16.</span> <span class="toc-text">pinsrb&#x2F;w&#x2F;d&#x2F;q</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcmpistri"><span class="toc-number">2.0.17.</span> <span class="toc-text">pcmpistri</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcmpistrm"><span class="toc-number">2.0.18.</span> <span class="toc-text">pcmpistrm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcmpestri"><span class="toc-number">2.0.19.</span> <span class="toc-text">pcmpestri</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcmpestrm"><span class="toc-number">2.0.20.</span> <span class="toc-text">pcmpestrm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pxor"><span class="toc-number">2.0.21.</span> <span class="toc-text">pxor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mulsd"><span class="toc-number">2.0.22.</span> <span class="toc-text">mulsd</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FPU%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">FPU指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IEE-%E8%A7%84%E8%8C%83-%E5%AD%98%E5%82%A8%E5%B0%8F%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">IEE 规范 存储小数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%96%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">化为二进制科学计算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">分解二进制位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FPU-%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">FPU 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%88%8D%E5%85%A5%E5%8E%9F%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">舍入原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">四舍五入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%88%8D%E5%85%A5"><span class="toc-number">3.3.2.</span> <span class="toc-text">向下舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%88%8D%E5%85%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">向上舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%910%E8%88%8D%E5%85%A5"><span class="toc-number">3.3.4.</span> <span class="toc-text">向0舍入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%95%B0%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">实数传输指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FLD-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%85%A5%E6%A0%88"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">FLD  浮点数入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FLD-xxx%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">FLD-xxx加载常数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FILD-%E5%B0%86%E6%95%B4%E6%95%B0%E5%85%A5%E6%A0%88"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">FILD 将整数入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FBLD-bcd%E7%A0%81%E5%85%A5%E6%A0%88"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">FBLD bcd码入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FST-%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">FST  栈顶数据导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FSTP-%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%E5%BC%B9%E5%87%BA%E6%A0%88"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">FSTP 栈顶数据弹出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIST-%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%90%8E%E5%AF%BC%E5%87%BA"><span class="toc-number">3.4.1.7.</span> <span class="toc-text">FIST  栈顶数据四舍五入后导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FISTP-%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%90%8E%E5%87%BA%E6%A0%88"><span class="toc-number">3.4.1.8.</span> <span class="toc-text">FISTP 栈顶数据四舍五入后出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FBSTP-%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%90%8E%E4%BB%A5bcd%E7%A0%81%E5%87%BA%E6%A0%88"><span class="toc-number">3.4.1.9.</span> <span class="toc-text">FBSTP 栈顶数据四舍五入后以bcd码出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fxch-%E5%AE%9E%E6%95%B0%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.4.1.10.</span> <span class="toc-text">fxch 实数交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.2.</span> <span class="toc-text">实数比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fcom-x2F-fcomp-x2F-fcompp"><span class="toc-number">3.4.2.1.1.</span> <span class="toc-text">fcom&#x2F;fcomp&#x2F;fcompp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fucom-x2F-fucomp-x2F-fucompp"><span class="toc-number">3.4.2.1.2.</span> <span class="toc-text">fucom&#x2F;fucomp&#x2F;fucompp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fcomi-x2F-FCOMIP-x2F-FUCOMI-x2F-FUCOMIP"><span class="toc-number">3.4.2.1.3.</span> <span class="toc-text">fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FICOM-x2F-FICOMP"><span class="toc-number">3.4.2.1.4.</span> <span class="toc-text">FICOM&#x2F;FICOMP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FTST"><span class="toc-number">3.4.2.1.5.</span> <span class="toc-text">FTST</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">条件码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="toc-number">3.4.3.</span> <span class="toc-text">四则运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FADD-x2F-FADDP-x2F-FIADD"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">FADD&#x2F;FADDP&#x2F;FIADD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fadd"><span class="toc-number">3.4.3.1.1.</span> <span class="toc-text">fadd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#faddp"><span class="toc-number">3.4.3.1.2.</span> <span class="toc-text">faddp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FIADD%EF%BC%88%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%EF%BC%89"><span class="toc-number">3.4.3.1.3.</span> <span class="toc-text">FIADD（整数加法）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FSUB-x2F-FSUBP-x2F-FISUB-x2F-FSUBR"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fsub"><span class="toc-number">3.4.3.2.1.</span> <span class="toc-text">fsub</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fsubp"><span class="toc-number">3.4.3.2.2.</span> <span class="toc-text">fsubp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FISUB%EF%BC%88%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95%EF%BC%89"><span class="toc-number">3.4.3.2.3.</span> <span class="toc-text">FISUB（整数减法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FSUBR"><span class="toc-number">3.4.3.2.4.</span> <span class="toc-text">FSUBR</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FMUL-x2F-FMULP-x2F-FIMUl"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">FMUL &#x2F;FMULP&#x2F;FIMUl</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FMUL"><span class="toc-number">3.4.3.3.1.</span> <span class="toc-text">FMUL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fmulp"><span class="toc-number">3.4.3.3.2.</span> <span class="toc-text">fmulp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FIMUL-%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">3.4.3.3.3.</span> <span class="toc-text">FIMUL 整数相乘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FDIV-x2F-FDIVP-x2F-FIDIV-x2F-FDIVR"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FDIV"><span class="toc-number">3.4.3.4.1.</span> <span class="toc-text">FDIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fdivp"><span class="toc-number">3.4.3.4.2.</span> <span class="toc-text">fdivp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fdivp-1"><span class="toc-number">3.4.3.4.3.</span> <span class="toc-text">fdivp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FDIVR"><span class="toc-number">3.4.3.4.4.</span> <span class="toc-text">FDIVR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.4.</span> <span class="toc-text">算术指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCHS-x2F-FABS-%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC-st0-%E6%B1%82%E7%9B%B8%E5%8F%8D%E6%95%B0"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">FCHS&#x2F;FABS  求绝对值|st0|,求相反数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fsqrt-%E6%B1%82-sqrt-st0"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">fsqrt 求 $\sqrt{st0}$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fxtract-%E6%B1%82%E9%98%B6%E7%A0%81%E4%B8%8E%E5%B0%BE%E6%95%B0"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">fxtract  求阶码与尾数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fprem-x2F-fprem1-%E5%8F%96%E4%BD%99%E6%95%B0"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">fprem&#x2F;fprem1 取余数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#frndint-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">frndint 四舍五入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fscale-%E6%B1%82st0x2-st1"><span class="toc-number">3.4.4.6.</span> <span class="toc-text">fscale 求st0x2^st1^</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f2xm1-%E6%B1%822-st0-1"><span class="toc-number">3.4.4.7.</span> <span class="toc-text">f2xm1 求2^st0^  -1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fyl2x-%E6%B1%82-st1-times-log-2-st0"><span class="toc-number">3.4.4.8.</span> <span class="toc-text">fyl2x 求  st1$\times$$log_2$st0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fyl2xp1-%E6%B1%82-st1-times-log-2-st0-1"><span class="toc-number">3.4.4.9.</span> <span class="toc-text">fyl2xp1 求 st1$\times$$log_2$(st0+1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0-%E7%94%A8%E5%BC%A7%E5%BA%A6%E4%BB%A3%E5%85%A5"><span class="toc-number">3.4.4.10.</span> <span class="toc-text">三角函数 用弧度代入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#fsin-%E6%B1%82-sin-st0"><span class="toc-number">3.4.4.10.0.1.</span> <span class="toc-text">fsin 求$sin$(st0)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fcos-%E6%B1%82-cos-st0"><span class="toc-number">3.4.4.10.0.2.</span> <span class="toc-text">fcos 求$cos$(st0)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fsincos-%E6%B1%82sin-st0-%E5%92%8C-cos-st0"><span class="toc-number">3.4.4.10.0.3.</span> <span class="toc-text">fsincos 求sin$(st0)和$cos(st0)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fptan-%E6%B1%82-tan-st0"><span class="toc-number">3.4.4.10.0.4.</span> <span class="toc-text">fptan 求 $tan$(st0)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fpatan-%E5%9D%90%E6%A0%87%E8%BD%B4%E4%B8%8B%E7%9A%84%E6%9C%89%E7%AC%A6%E5%8F%B7%E8%A7%92%E5%BA%A6"><span class="toc-number">3.4.4.10.0.5.</span> <span class="toc-text">fpatan 坐标轴下的有符号角度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FPU-%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.5.</span> <span class="toc-text">FPU 控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#finit-x2F-fninit-%E5%88%9D%E5%A7%8B%E5%8C%96FPU"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">finit&#x2F;fninit 初始化FPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fstsw-x2F-fntstw-%E5%AF%BC%E5%87%BA%E7%8A%B6%E6%80%81%E5%AD%97"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">fstsw&#x2F;fntstw 导出状态字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fstcw-x2F-fnstcw-%E5%AF%BC%E5%87%BA%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">fstcw&#x2F;fnstcw 导出控制字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fldcw-%E5%AF%BC%E5%85%A5%E6%8E%A7%E5%88%B6%E5%AD%97"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">fldcw  导入控制字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fldenv-%E5%AF%BC%E5%85%A5%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.5.5.</span> <span class="toc-text">fldenv 导入环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fstenv-x2F-fnstenv-%E5%AF%BC%E5%87%BA%E5%B0%8F%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.5.6.</span> <span class="toc-text">fstenv&#x2F;fnstenv 导出小环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fsave-x2F-fnsave-%E5%AF%BC%E5%87%BA%E5%A4%A7%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.5.7.</span> <span class="toc-text">fsave&#x2F;fnsave 导出大环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fclex-x2F-fncles-%E6%B8%85%E9%99%A4%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.5.8.</span> <span class="toc-text">fclex&#x2F;fncles  清除异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#frstor%E5%AF%BC%E5%85%A5%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.5.9.</span> <span class="toc-text">frstor导入环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fincstp-x2F-fdecstp-top%E7%9A%84%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F"><span class="toc-number">3.4.5.10.</span> <span class="toc-text">fincstp &#x2F;fdecstp top的自增自减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ffree-sti"><span class="toc-number">3.4.5.11.</span> <span class="toc-text">ffree sti</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fnop"><span class="toc-number">3.4.5.12.</span> <span class="toc-text">fnop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwait-x2F-wait"><span class="toc-number">3.4.5.13.</span> <span class="toc-text">fwait&#x2F;wait</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%90%8C%E6%AD%A5fwait-x2F-wait"><span class="toc-number">3.5.</span> <span class="toc-text">异常同步fwait&#x2F;wait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FXAM"><span class="toc-number">3.6.</span> <span class="toc-text">FXAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%8F%E8%94%BD%E4%B8%8E%E6%9C%AA%E5%B1%8F%E8%94%BD%E7%AE%80%E8%BF%B0"><span class="toc-number">3.7.</span> <span class="toc-text">异常的屏蔽与未屏蔽简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4-2"><span class="toc-number">3.7.1.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fstcw"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">fstcw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fldcw"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">fldcw</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-number">3.7.2.</span> <span class="toc-text">导读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x64%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="toc-number">3.8.</span> <span class="toc-text">x64的浮点数四则运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addsd-%E5%8A%A0%E6%B3%95"><span class="toc-number">3.8.1.</span> <span class="toc-text">addsd 加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subsd-%E5%87%8F%E6%B3%95"><span class="toc-number">3.8.2.</span> <span class="toc-text">subsd 减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mulsd-%E4%B9%98%E6%B3%95"><span class="toc-number">3.8.3.</span> <span class="toc-text">mulsd 乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#divsd-%E9%99%A4%E6%B3%95"><span class="toc-number">3.8.4.</span> <span class="toc-text">divsd 除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sqrtsd-%E5%BC%80%E6%96%B9"><span class="toc-number">3.8.5.</span> <span class="toc-text">sqrtsd 开方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">3.9.</span> <span class="toc-text">应用例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">3.9.1.</span> <span class="toc-text">混合运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C"><span class="toc-number">3.9.2.</span> <span class="toc-text">数组求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%96%B9%E6%B1%82%E5%92%8C"><span class="toc-number">3.9.3.</span> <span class="toc-text">开方求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.9.4.</span> <span class="toc-text">C语言的强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%88%8D%E5%85%A5%E6%A8%A1%E5%BC%8F-%E4%BB%80%E4%B9%88%E9%AC%BC"><span class="toc-number">3.9.5.</span> <span class="toc-text">修改舍入模式,什么鬼</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By re4mile</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/re4mile/js/utils.js"></script><script src="/re4mile/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="my.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>