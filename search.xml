<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/re4mile/2023/01/11/%E6%80%9D%E8%80%83/%E9%94%99%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<h1 id="char和int比较"><a href="#char和int比较" class="headerlink" title="char和int比较"></a>char和int比较</h1><p>来源于南邮CTF whyvm1的数据比较,第一次看到就很疑惑</p>
<h1 id="记录一次字符串过滤"><a href="#记录一次字符串过滤" class="headerlink" title="记录一次字符串过滤"></a>记录一次字符串过滤</h1><p>下面我有几个操作,就是数据处理完后,不直接结束当前循环,而是从头再来判断一次</p>
<p>其实就怕数据监测的遗漏</p>
<p>…</p>
<p>比如你最后修改了某个内容,让指针移到新的节点,但是当前循环结束的时候也需要移动指针节点</p>
<p>所以就会导致一次多余的移动,同时你自己又不能少移动</p>
<p>所以你就不结束当前循环直接跳转到判断那里,再判断一次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ReadFileSize</span><span class="params">(<span class="type">char</span>* filename)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* fp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> fpname[] = <span class="string">&quot;F:\\src.txt&quot;</span>;</span><br><span class="line">	<span class="type">int</span> FileSize = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>* lp1 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>* lp2 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	FileSize = ReadFileSize(fpname);</span><br><span class="line">	fp = fopen(fpname, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;wrong open\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//每一次删除0x23个字节</span></span><br><span class="line">	<span class="comment">//开始标志是d,结束标志是;</span></span><br><span class="line"></span><br><span class="line">	lp1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(FileSize + <span class="number">0x10</span>);</span><br><span class="line">	lp2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(FileSize + <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">if</span> (lp1 == <span class="number">0</span> || lp2==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;wrong malloc\n&quot;</span>);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(lp1, <span class="number">0</span>, FileSize + <span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">memset</span>(lp2, <span class="number">0</span>, FileSize + <span class="number">0x10</span>);</span><br><span class="line">	fread(lp1, FileSize, <span class="number">1</span>,fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除多余项</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FileSize;i++ )</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	check_again:</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">memcmp</span>(&amp;lp1[i],<span class="string">&quot;dword&quot;</span>,<span class="number">5</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (lp1[i] == <span class="number">0xA</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					lp1[i] = <span class="number">0</span>;</span><br><span class="line">					i++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				lp1[i] = <span class="number">0</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> check_again;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;lp1[i], <span class="string">&quot;byte_6941&quot;</span>, <span class="number">9</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(&amp;lp1[i], <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;lp1[i], <span class="string">&quot;a[0x&quot;</span>, <span class="number">4</span>);</span><br><span class="line">			lp1[i + <span class="number">4</span> ] = lp1[i + <span class="number">9</span>];</span><br><span class="line">			lp1[i + <span class="number">5</span>] =  lp1[i + <span class="number">10</span>];</span><br><span class="line">			lp1[i + <span class="number">6</span>] = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">			lp1[i + <span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">			lp1[i + <span class="number">10</span>]=<span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;lp1[i], <span class="string">&quot;input&quot;</span>, <span class="number">5</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(&amp;lp1[i], <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;lp1[i], <span class="string">&quot;a[0]&quot;</span>, <span class="number">4</span>);</span><br><span class="line">			<span class="keyword">goto</span> check_again;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (lp1[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lp1[i] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">goto</span> check_again;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (lp1[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lp1[i] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">goto</span> check_again;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FileSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (lp1[i]!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lp2[j] = lp1[i];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//逆序读取</span></span><br><span class="line">	<span class="comment">//最后lp2以0xA结束</span></span><br><span class="line">	<span class="comment">//printf(&quot;%d %X&quot;, j, lp2[j]);</span></span><br><span class="line">	j--;</span><br><span class="line">	<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (lp2[j] == <span class="number">0xD</span> || lp2[j] == <span class="number">0xA</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lp2[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;lp2[j], <span class="string">&quot;--&quot;</span>, <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, &amp;lp2[j]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;lp2[j], <span class="string">&quot;++&quot;</span>, <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, &amp;lp2[j]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;lp2[j], <span class="string">&quot;a[&quot;</span>, <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, &amp;lp2[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ReadFileSize</span><span class="params">(<span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">	FILE* fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;wrong open\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">	size = ftell(fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>任务清单</title>
    <url>/re4mile/2023/01/11/other/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/other/</url>
    <content><![CDATA[<p>已完成✅</p>
<p>未完成❌</p>
<h1 id="信安数学"><a href="#信安数学" class="headerlink" title="信安数学"></a>信安数学</h1><p>✅欧几里得扩展算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/ash_zheng/article/details/44751697</span><br><span class="line">https://blog.csdn.net/AAMahone/article/details/79320635</span><br></pre></td></tr></table></figure>

<p>去百度的话,基本上都是ACM发的贴子,好像讲的很深奥,同时我自己基于原理,逆向出了一套算法</p>
<p>还有几个</p>
<p>❌还没有用C语言实现几个证明的推导</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p6:	引理1-1</span><br><span class="line">p7:	定理1-8,lcm(a,b)= |ab| / gcd(a,b)</span><br><span class="line">p8: 引理 1-2</span><br><span class="line">p8: 定i1-10</span><br></pre></td></tr></table></figure>



<h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><p>❌实现一个环形的迷宫,正式因为是环形,于是就可以走很多圈,所以得要求走一定的圈数,然后才会进入迷宫</p>
<p>❌你的地图为什么不可用用稀疏数组来压缩存储呢?</p>
<p>❌可以考虑用双向链表出一迷宫的圆形</p>
<p>❌我最近在Gitee上发现一个一个什么迷宫生成器或者什么迷宫来着,是汇编写的.你可以去看看,我已经下载了</p>
<p>在<code>E:\Code\Project\asm_for_all-master.zip</code></p>
<h2 id="记录一次使用free的失败"><a href="#记录一次使用free的失败" class="headerlink" title="记录一次使用free的失败"></a>记录一次使用free的失败</h2><p>可能是我的代码写的比较复杂,导致一些malloc存在越界写入,于是在free的时候就就很复杂</p>
<p>最后我没有知道我的代码哪里写错了</p>
<p>用了最垃圾的解决办法: 把代码写简单点</p>
<p>但是有个想法</p>
<p>我们可不可以让ctfer去走我们错误的代码?</p>
<p>比如我们写了函数A,在tls的时候,拿了一个基本一模一样的函数B其替换函数A,而且还写入了我们异常的free代码,让程序无法执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">怀疑free()为什么会失败,是作者的问题?</span><br><span class="line">其实ctfer本身就走了一个假的函数</span><br></pre></td></tr></table></figure>





<p>free()失败的原因</p>
<ol>
<li>对同一个地址free巨多次</li>
<li>内存越界访问</li>
<li>进程A去free进程B,比如我们用的当前模块的malloc,用另外一个dll模块的free来释放</li>
</ol>
<h2 id="Base58的欧拉函数"><a href="#Base58的欧拉函数" class="headerlink" title="Base58的欧拉函数"></a>Base58的欧拉函数</h2><p>其实就是复现一下Base58,去理解以前不理解的大数分解</p>
<h2 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h2><p>也就基于之前那个题目做一些修改</p>
<p>主要是它的那个扫雷会比较有趣</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>感觉他可以用于加密</p>
<h2 id="下棋"><a href="#下棋" class="headerlink" title="下棋"></a>下棋</h2><p>比如五子棋,</p>
<p>是不是就是用单链表实现的,用五子棋出一个题目</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>CTF: 用链表的存储数据,然后去ctf,会导致更加的难以读取,除非别人只看输入和输出,如果你在过程中做了一些手脚的话,会更加难以识别</p>
<h2 id="关于启动代码"><a href="#关于启动代码" class="headerlink" title="关于启动代码"></a>关于启动代码</h2><p>为什么你不写一些启动代码来加大寻找main函数的难度呢?</p>
<p>这是可以的,不过启动代码的设计也是比较难的,所以你应该参考一下cfree的</p>
<p>因为cfree5的IDA无法一下子跟到main</p>
<p>变相的思考一下:为什么你不可以把你的main函数封装为一个启动函数,然后塞一个关键代码进去</p>
<h2 id="正负数的概念"><a href="#正负数的概念" class="headerlink" title="正负数的概念"></a>正负数的概念</h2><p>也就是一个 数 + 正数 等价于一个数-负数</p>
<p>好比10+1&#x3D;&#x3D;19-(-1)</p>
<p>但是对于unsigned char 类型来说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x10 + 0x2E</span><br><span class="line">==</span><br><span class="line">0x10 - 0xD2</span><br></pre></td></tr></table></figure>

<p>注意1+100和1+99是有区别的,就像0xFF不是256那么大一样</p>
<p><code>2E + D2	==	0</code></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>可以修改栈里面的ip来达到一个循环的效果,这就明显的伪装了一个循环语句</p>
<h2 id="fputc的bug"><a href="#fputc的bug" class="headerlink" title="fputc的bug"></a>fputc的bug</h2><p>fputchar在写入文件时,对于0xA(回车符)写入的是0x0D0A,也就是写入了换行与回车,这就很g</p>
<p>所以在数据校验的时候,可以想办法利用这个固有的小bug</p>
<h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>❌SEH，还有就是那2篇文章</p>
<h2 id="PYC逆向"><a href="#PYC逆向" class="headerlink" title="PYC逆向"></a>PYC逆向</h2><p>❌pyc的那个什么流程图软件,很强大,但是基于Python2,你得学习一下,然后修改过度到Python3</p>
<p>❌自己定制一个pycdc,于是遇到nop后就可以很好的编译</p>
<p>❌这个师傅的博客还没有来得及学习</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://qiumingshanshangdexiaoning.gitee.io/2021/11/28/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8Dpython%E9%80%86%E5%90%91/#pyc%E6%96%87%E4%BB%B6</span><br></pre></td></tr></table></figure>

<p>❌把那个花指令总结一下</p>
<h2 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h2><p>❌ 学习一下&lt;&lt;windwos pe 权威指南&gt;&gt;</p>
<p>❌去学习upx项目的源码</p>
<p>❌ 学习如何去除upx特征码</p>
<p>❌ 学习如何去除upx关键信息,如何让upx混淆,让你的upx -d直接失败</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>❌ 关于before main那个函数到底在哪里寻找,它的出现标志到底是什么,这还是很重要的吧</p>
<h3 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h3><p>❌用它实现一个调试器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.myhack58.com/Article/html/3/92/2015/68568.htm</span><br><span class="line">https://www.cnblogs.com/tangr206/articles/3094358.html</span><br><span class="line">https://www.cnblogs.com/axiong/p/6184638.html</span><br></pre></td></tr></table></figure>



<h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>❌我记得有个花指令的arc.exe,我还没有再次学习和复现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学习IDC</span><br><span class="line">学习花指令种类</span><br></pre></td></tr></table></figure>



<p>❌smc多态解密也得学一下,我只是试过简单的原理,如何实现一个大的SMC,涉及一些静态地址该怎么办</p>
<h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Hipepper/anti_all_in_one/wiki</span><br></pre></td></tr></table></figure>



<p>至少对于我来说的话,如果反调试的代码比较多,</p>
<p>我就不会细看,而是仅仅看反调试在哪里异常或者卡住,</p>
<p>然后跳过那个地方,而不会去关注其它因为反调试而修改的地方,因为它没有影响到我反汇编甚至是F8&#x2F;7,</p>
<p>所以我就不会去关注</p>
<p>❌反IDA</p>
<p>之前反OD我见过钱老师演示过</p>
<p>这次南邮CTF [WxyVM 0.0.2],直接把IDA给卡住了</p>
<p>看上去很不错的文章</p>
<p>❌ <a href="https://bbs.pediy.com/thread-258353-1.html">https://bbs.pediy.com/thread-258353-1.html</a></p>
<p>❌ <a href="https://bbs.pediy.com/thread-224537.htm">https://bbs.pediy.com/thread-224537.htm</a></p>
<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><h2 id="技术书籍"><a href="#技术书籍" class="headerlink" title="技术书籍"></a>技术书籍</h2><p>❌《Linux 二进制分析》</p>
<p>❌《程序员的自我修养》</p>
<p>❌《编译原理》</p>
<p>❌ 龙书,那基本编译原理得学习一下</p>
<h1 id="CTF复现"><a href="#CTF复现" class="headerlink" title="CTF复现"></a>CTF复现</h1><p>❌ 2022-四川省-re</p>
<p>❌学习vm,到底是一个什么东西</p>
<p>❌ AES,XXTEA的加密,深入了解一下</p>
<p>❌ 关于重邮CTF的一些总结</p>
<p>关注CTF比赛</p>
<p>❌ 收集到这门一个网站</p>
<p>一个没有做的题目 <a href="https://qianfei11.github.io/MyOldBlog/2018/08/30/2017-CSAW-Quals-realism/">https://qianfei11.github.io/MyOldBlog/2018/08/30/2017-CSAW-Quals-realism/</a></p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>写一个C语言,清理一下你的Gitee图床,就是进入markdown,搜索关键字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https//resmile.gitee.io/---/xxx.png</span><br></pre></td></tr></table></figure>

<p>然后对比进入墓目录去清理删除,出现了不管,没出现就删除</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>三十六计</title>
    <url>/re4mile/2021/06/07/%E8%AF%BE%E5%A4%96%E4%B9%A6/%E4%B8%89%E5%8D%81%E5%85%AD%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="胜战"><a href="#胜战" class="headerlink" title="胜战"></a>胜战</h1><h2 id="瞒天过海"><a href="#瞒天过海" class="headerlink" title="瞒天过海"></a>瞒天过海</h2><blockquote>
<p>备周则意怠；常见则不疑。阴在阳之内，不在阳之对。太阳，太阴。</p>
</blockquote>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930160213407.png" alt="image-20220930160213407"></p>
<p>满是开始</p>
<p>走是终结</p>
<p>为什么要满? 因为知道敌人的弱点</p>
<p>如何满? 摸清对方的习惯,把握时机,乘虚示假以隐真,来掩盖某种行为,</p>
<p>在对方不知道的情况下蒙骗对方,骗不过别人的时候就一走了之</p>
<h2 id="围魏救赵"><a href="#围魏救赵" class="headerlink" title="围魏救赵"></a>围魏救赵</h2><p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930093243591.png" alt="image-20220930093243591"></p>
<p>魏国攻打赵国,赵国向邻国求救</p>
<p>齐国见状,想要攻打魏国,然后吞并,但是损失会比较惨重</p>
<p>于是齐国包围了魏国,魏国见状不妙,于是撤军回攻但是齐国并没有开战,只是威慑,但是赵国已经解围来</p>
<p>齐国撤军后,获取了帮助赵国的名誉,又没有损失一点点兵力</p>
<h2 id="借刀杀人"><a href="#借刀杀人" class="headerlink" title="借刀杀人"></a>借刀杀人</h2><blockquote>
<p>敌已明，友未定，引友杀敌，不自出力，以《损》推演。</p>
</blockquote>
<p>郑桓公举行祭祀,故意透露侩国的精锐士兵已经买通,到时攻打侩国直接里应外合</p>
<p>然后郑桓公故意把侩国精锐士兵的名单故意放在某个地方,侩国间谍看就候,拿着名单告诉侩国国王</p>
<p>侩国国王半信半疑,把侩国精锐士兵抓起来</p>
<p>郑桓公找到后,就故意说,必须放了侩国精锐士兵,否则就攻打</p>
<p>侩国国王于是立马信了,就杀掉了侩国的精锐士兵</p>
<p>郑桓公听闻了就立马攻打侩国,但是侩国已经没了精锐士兵</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930160619031.png" alt="image-20220930160619031"></p>
<h2 id="以逸待劳"><a href="#以逸待劳" class="headerlink" title="以逸待劳"></a>以逸待劳</h2><blockquote>
<p>困敌之势，不以战；损刚益柔。</p>
</blockquote>
<p>在敌强我弱时,成功时的策略</p>
<p>以近待远,以逸待劳,以饱待饥,此力者也</p>
<p>其核心在于”耗”</p>
<p>实力弱的可以原地不动,让敌人轻敌,</p>
<p>然后凭借自己的过人之处,养精蓄锐,抓住敌人的弱点,悄悄制订解决方案</p>
<p>对敌人进行不定期的骚扰,等到敌人精疲力尽,疲惫不堪的时候,乘其不备,搞突击</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930160728377.png" alt="image-20220930160728377"></p>
<p>此计强调：放敌方处于困难局面，不一定只用进攻之法。</p>
<p>关键在于掌握主动权，待机而动，以不变应万变，以静对动，积极调动敌人，创造战机，</p>
<p>不让敌人调动自已，而要努力牵着敌人的鼻子走。</p>
<p>所以，不可把以逸待劳的“待”字理解为消极被动的等待。</p>
<h2 id="趁火打劫"><a href="#趁火打劫" class="headerlink" title="趁火打劫"></a>趁火打劫</h2><blockquote>
<p>敌之害大，就势取利，刚决柔也。</p>
</blockquote>
<p>乱而取之,敌人混乱的时候,正是攻击的最好时机</p>
<p>核心思想:抓住对手犯错的时机,果断出击,谋求扩大自身利益,乃至把对手彻底击垮</p>
<p>所谓“火”，即对方的困难、麻烦。</p>
<p>敌方的困难不外有两个方面，即内忧、外患。</p>
<p>天灾人祸，经济凋敝，民不聊生，怨声载道，农民起义，内战连年，都是内患；外敌入侵，战事不断，都是外患</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930160818255.png" alt="image-20220930160818255"></p>
<h2 id="声东击西"><a href="#声东击西" class="headerlink" title="声东击西"></a>声东击西</h2><blockquote>
<p>敌志乱萃，不虞，坤下兑上之象。利其不自主而取之。</p>
</blockquote>
<p>故意声言击东,其实击西,造成敌人错觉</p>
<p>机动灵活地运用时东时西，似打似离，不攻而示它以攻，欲攻而又示之以不攻等战术，进一步造成敌人的错觉，出其不意地一举夺胜。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161034304.png" alt="image-20220930161034304"></p>
<h1 id="敌战"><a href="#敌战" class="headerlink" title="敌战"></a>敌战</h1><h2 id="无中生有"><a href="#无中生有" class="headerlink" title="无中生有"></a>无中生有</h2><blockquote>
<p>诳也，非诳也，实其所诳也。少阴、太阴、太阳。</p>
</blockquote>
<p>大多数计谋怕别人识破</p>
<p>无中生有故意让比人识破,被识破的假,却成功的掩护了暗藏了真</p>
<p>A国放稻草人借箭,B国以为是真人就射箭</p>
<p>后来B国知道了那是稻草人,就不再射箭</p>
<p>A国继续放稻草人.但是B国识破了,A国也知道他会识破</p>
<p>于是后面,A国一直放稻草人麻痹对方,也为那就是稻草人</p>
<p>最后,A国放士兵,直接偷袭</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161204237.png" alt="image-20220930161204237"></p>
<p>此计的关键在于真假要有变化，虚实必须结合，一假到底，易被敌人发觉，难以制敌。</p>
<p>先假后真，先虚后实，无中必须生有。指挥者必须抓住敌人已被迷惑的有利时机，迅速地以“真”、以“实”、以“有”，也就是以出奇制胜的速度，攻击</p>
<p>敌方，等敌人头脑还来不及清醒时，即被击溃。</p>
<p>无中生有，这个“无”，指的是“假”，是“虚”。这个“有”，指的是“真”，是“实”。无中生有，就是真真假假，虚虚实实，真中有假，假中有真。</p>
<p>虚实互变，扰乱敌人，使敌方造成判断失误，行动失误。此计可分解为三部曲：</p>
<ul>
<li>第一步，示敌以假，让敌人误以为真；</li>
<li>第二步，让敌方识破我方之假，掉以轻心；</li>
<li>第三步，我方变假为真，让敌方仍误以为假。这样，敌方思想已被扰乱，主动权就被我方掌握。<ul>
<li>使用此计有两点应予注意：<ul>
<li>第一、敌方指挥官性格多疑，过于谨慎的，此计特别奏效。</li>
<li>第二、要抓住敌方思想已乱迷惑不解之机，迅速变虚为实，变假为真，变无为有，出其不意地攻击敌方。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="暗渡陈仓"><a href="#暗渡陈仓" class="headerlink" title="暗渡陈仓"></a>暗渡陈仓</h2><blockquote>
<p>示之以动，利其静而有主，益动而巽。</p>
</blockquote>
<p>用假动作迷惑敌人</p>
<p>偷偷的声言击东,其实击西,造成敌人错觉</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161406995.png" alt="image-20220930161406995"></p>
<h2 id="隔岸观火"><a href="#隔岸观火" class="headerlink" title="隔岸观火"></a>隔岸观火</h2><blockquote>
<p>阳乖序乱，阴以待逆。暴戾恣睢，其势自毙。顺以动豫，豫顺以动</p>
</blockquote>
<p>隔岸红尘忙似火</p>
<p>当轩青嶂冷如冰</p>
<p>主动散风点火或者被动的等待火</p>
<p>然后观看地方内斗</p>
<p>自己再乘虚而入</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161510483.png" alt="image-20220930161510483"></p>
<h2 id="笑里藏刀"><a href="#笑里藏刀" class="headerlink" title="笑里藏刀"></a>笑里藏刀</h2><blockquote>
<p>信而安之， 阴以图之，备而后动，勿使有变。刚中柔外也</p>
</blockquote>
<p>用笑暗藏嘴里的刀,让敌人信</p>
<p>给对方示好</p>
<p>让对方相信自己的示好</p>
<p>站在对手的角度上思考问题,精心布局,一步步打破对方的心理防线</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161619083.png" alt="image-20220930161619083"></p>
<h2 id="李代桃僵"><a href="#李代桃僵" class="headerlink" title="李代桃僵"></a>李代桃僵</h2><blockquote>
<p>必有损，损阴以益阳</p>
</blockquote>
<p>在必有损失的时候,用最小的损失顾全大局,舍军保帅</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161841534.png" alt="image-20220930161841534"></p>
<h2 id="顺手牵羊"><a href="#顺手牵羊" class="headerlink" title="顺手牵羊"></a>顺手牵羊</h2><blockquote>
<p>微隙在所必乘；微利在所必得。少阴，少阳</p>
</blockquote>
<p>被动的利用敌方的bug</p>
<p>主动的给地方制造bug去利用</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930161922136.png" alt="image-20220930161922136"></p>
<h1 id="攻战"><a href="#攻战" class="headerlink" title="攻战"></a>攻战</h1><h2 id="打草惊蛇"><a href="#打草惊蛇" class="headerlink" title="打草惊蛇"></a>打草惊蛇</h2><blockquote>
<p>疑以叩实，察而后动；复者，阴之媒也。</p>
</blockquote>
<p>打草惊蛇作为一种侦查方式,投石问路</p>
<p>反复的试探去发现  的真相</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162036029.png" alt="image-20220930162036029"></p>
<h2 id="借尸还魂"><a href="#借尸还魂" class="headerlink" title="借尸还魂"></a>借尸还魂</h2><blockquote>
<p>有用者，不可借；不能用者，求借。借不能用者而用之，匪我求童蒙，童蒙求我。</p>
</blockquote>
<p>此言兵法，是说兵家要善于抓住一切机会，甚至是看去无什用处的东西，努力争取主动，壮大自己，即时利用而转不利为有利，乃至转败为胜。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162156523.png" alt="image-20220930162156523"></p>
<h2 id="调虎离山"><a href="#调虎离山" class="headerlink" title="调虎离山"></a>调虎离山</h2><blockquote>
<p>待天以困之，用人以诱之，往蹇来连。</p>
</blockquote>
<p>虎不离山就很厉害,离山就失去了优势</p>
<p>所以要调虎离山</p>
<p>用假象使敌人离开驻地，诱他就我之范，丧失他的优势，使他处处皆难，寸步难行，由主动变被动，而我则出其不意而致胜。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162445926.png" alt="image-20220930162445926"></p>
<h2 id="欲擒故纵"><a href="#欲擒故纵" class="headerlink" title="欲擒故纵"></a>欲擒故纵</h2><blockquote>
<p>逼则反兵；走则减势。紧随勿迫，累其气力，消其斗志，散而后擒，兵不血刃。需，有孚，光。</p>
</blockquote>
<p>攻心为上,攻城为下</p>
<p>逼迫敌入太紧，他可能因此拼死反扑，若让他逃跑则可减削他的气势。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162658878.png" alt="image-20220930162658878"></p>
<h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><blockquote>
<p>类以诱之，击蒙也。</p>
</blockquote>
<p>句意为：诱惑敌人，便可打击这种受我诱惑的愚蒙之人了。</p>
<p>战争中，迷惑敌人的方法多种多样，最妙的方法不是用似是而非的方法，而是应用极相类似的方法，以假乱真</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162816198.png" alt="image-20220930162816198"></p>
<h2 id="擒贼擒王"><a href="#擒贼擒王" class="headerlink" title="擒贼擒王"></a>擒贼擒王</h2><blockquote>
<p>摧其坚，夺其魁，以解其体。龙战于野，其道穷也</p>
</blockquote>
<p>射人先射马,擒贼先擒王</p>
<p>核心就是打进核心部分瓦解敌人</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930162903869.png" alt="image-20220930162903869"></p>
<h1 id="混战"><a href="#混战" class="headerlink" title="混战"></a>混战</h1><h2 id="釜底抽薪"><a href="#釜底抽薪" class="headerlink" title="釜底抽薪"></a>釜底抽薪</h2><blockquote>
<p>不敌其力，而消其势，兑下乾上之象</p>
</blockquote>
<p>适用于我方弱敌方强</p>
<p>还有人说，敌人再强大，也会有弱点，我方突然击败敌人的薄弱之处．再击败敌人主力，这也是釜底抽薪法的具体运用。</p>
<p>战争中也常使用袭击敌人后方基地、仓库，断其运输线等战术，也可以收到釜底抽薪的效果。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163016072.png" alt="image-20220930163016072"></p>
<h2 id="混水摸鱼"><a href="#混水摸鱼" class="headerlink" title="混水摸鱼"></a>混水摸鱼</h2><blockquote>
<p>乘其阴乱，利其弱而无主。随，以向晦入宴息</p>
</blockquote>
<p>主动给敌方制造混乱</p>
<p>从混乱中得利</p>
<p>此计用于军事，是指当敌人混乱无主时，乘机夺取胜利的谋略。</p>
<p>在混浊的水中，鱼儿辨不清方向，</p>
<p>在复杂的战争中，弱小的一方经常会动摇不定，这里就有可乘之机。</p>
<p>更多的时候，这个可乘之机不能只靠等待，而应主动去制造这种可乘之机。一方主动去把水搅浑，一切情况开始复杂起来，然后可借机行事。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163145703.png" alt="image-20220930163145703"></p>
<h2 id="金蝉脱壳"><a href="#金蝉脱壳" class="headerlink" title="金蝉脱壳"></a>金蝉脱壳</h2><blockquote>
<p>存其形，完其势；友不疑，敌不动。巽而止蛊。</p>
</blockquote>
<p><code>存其形，完其势；友不疑，敌不动 </code>就是在做一个壳,这个壳是用来迷惑敌人的</p>
<p> 其意是我暗中谨慎地实行主力转移，稳住敌人，我则乘敌不惊疑之际脱离险境，就可安然躲过战乱之危</p>
<p>此计用于军事，是指通过伪装摆脱敌人，撤退或转移，以实现我方的战略目标的谋略。</p>
<p>稳住对方，撤退或转移，决不是惊慌失措，消极逃跑，而是保留形式，抽走内容，稳住对方，</p>
<p>使自己脱离险境，达到己方战略目标，己方常常可用巧妙分兵转移的机会出击另一部分敌人</p>
<p>认真分析形势，准确作出判断，摆脱敌人，转移部队，决不是消极逃胞，一走了事，而应该是一种分身术，</p>
<p>要巧妙地暗中调走精锐部队去袭击别处的敌人。但这种调动要神不知，鬼不觉，极其隐蔽。因此，一定要把假象造得有逼真的效果。</p>
<p>转移时，依然要旗帜招展，战鼓隆隆，好象仍然保持着原来的阵势，这样可以使敌军不敢动，友军不怀疑。</p>
<p>檀道济在被敌人围困时，竟然能带着武装士兵，自己穿着显眼的白色服装，坐在车上，不慌不忙地向外围进发。。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163240865.png" alt="image-20220930163240865"></p>
<h2 id="关门捉贼"><a href="#关门捉贼" class="headerlink" title="关门捉贼"></a>关门捉贼</h2><blockquote>
<p>小敌困之。剥，不利有攸往。</p>
</blockquote>
<p>是说对小股敌人要即时围困消灭，</p>
<p>而不于去急追或者远袭。</p>
<p>给围困着一定的活动空间,不要把它逼急了,让他信以为还有救,于是不断的消耗自己的体力找出路</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163451379.png" alt="image-20220930163451379"></p>
<p>关门捉贼，不仅仅是恐怕敌人逃走，而且怕它逃走之后被他人所利用。</p>
<p>如果门关不紧，让敌人脱逃，千万不可轻易追赶，防止中了敌人的诱兵之计。</p>
<p>这个贼，指的是那些出没无常、偷袭我军的游击队伍。他们的企图，是使我军疲劳，以便实现他们的目的。</p>
<p>兵书《吴子》中特别强调不可轻易追逐逃敌。他打了一个比方，一个亡命之徒隐藏在旷野里，你派一千个人去捉他，也会十分困难，</p>
<p>这是为什么呢？主要是怕对方突然袭击而损害自己。所以说，一个人只要是玩命不怕死，就会让一千个人害怕。</p>
<p>根据这个道理推测，敌军如能脱逃，势必拼命战斗，如果截断他的去路，敌军就易于歼灭了。</p>
<p>所以，对弱敌必须围而歼之，如果不能围歼，暂时放它逃走也未尝不可，千万不可轻易追击。</p>
<h2 id="远交近攻"><a href="#远交近攻" class="headerlink" title="远交近攻"></a>远交近攻</h2><blockquote>
<p>形禁势格，利从近取，害以远隔。上火下泽。</p>
</blockquote>
<p>先攻取就近的敌人有利，越过近敌先去攻取远隔之敌是有害的。</p>
<p>应该和远敌结好,进攻近敌,形成包围的趋势</p>
<p>应先攻取就近的敌人，而不能越过近敌去打远离自己的敌人。</p>
<p>为了防止敌方结盟，要千方百计去分化敌人，各个击破。消灭了近敌之后，“远交”的国家又成为新的攻击对象了。</p>
<p>“远交”的目的，实际上是为了避免树敌过多而采用的外交诱骗。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163650221.png" alt="image-20220930163650221"></p>
<h2 id="假途伐虢"><a href="#假途伐虢" class="headerlink" title="假途伐虢"></a>假途伐虢</h2><blockquote>
<p>两大之间，敌胁以从，我假以势。困，有言不信。</p>
</blockquote>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930125248551.png" alt="image-20220930125248551"></p>
<p>A想要打败C,就必须走A-B-C的路线</p>
<p>但是B-C是好朋友,B不是给A让道</p>
<p>于是A收买了B,B拿人手短,就答应让道</p>
<p>A灭了C后,在B做了停留,于是把B也给灭了</p>
<p>利其幸存之心,速得全势 :用不侵犯它利益的方式诱惑它,用它侥幸的心理去控制全局</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163822511.png" alt="image-20220930163822511"></p>
<h1 id="并战"><a href="#并战" class="headerlink" title="并战"></a>并战</h1><h2 id="偷梁换柱"><a href="#偷梁换柱" class="headerlink" title="偷梁换柱"></a>偷梁换柱</h2><blockquote>
<p>频更其阵，抽其劲旅，待其自败，而后乘之，曳其轮也</p>
</blockquote>
<p>频更其阵 : 改变敌人固有是思路,动摇敌人的意志</p>
<p>抽其劲旅 : 乘对方注意不定时,立马攻击敌人</p>
<p>从军事谋略上去理解本计，重点也可以放在对敌军“频更共阵”上。</p>
<p>也就是多次佯攻，促使敌人变换阵容，然后伺机攻其弱点。这种调动敌人的谋略，也能收到很好的效果。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930163916209.png" alt="image-20220930163916209"></p>
<h2 id="指桑骂槐"><a href="#指桑骂槐" class="headerlink" title="指桑骂槐"></a>指桑骂槐</h2><blockquote>
<p>大凌小者，警以诱之。刚中而应，行险而顺</p>
</blockquote>
<p>强大者要适当的震慑,警告来诱导和胁迫弱者</p>
<p>强大者要控制弱下者，要用警戒的办法去诱导他。</p>
<p>有时采取适当的强刚手段便会得到应和，</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164022049.png" alt="image-20220930164022049"></p>
<p>一是要运用各种政治和外交谋略，“指桑”而“骂槐”，施加压力配合军事行动。</p>
<p>对于弱小的对手，可以用警告和利诱的方法，不战而胜。</p>
<p>对于比较强大的对手也可以旁敲侧击威慑他。</p>
<p>春秋时期，齐相管仲为了降服鲁国和宋国，就是运用此计。</p>
<p>他先攻下弱小的遂国，鲁国畏惧，立即谢罪求和，宋见齐鲁联盟，也只得认输求和。管仲“敲山震虎”，不用大的损失就使鲁、宋两国臣服。</p>
<h2 id="假痴不颠"><a href="#假痴不颠" class="headerlink" title="假痴不颠"></a>假痴不颠</h2><blockquote>
<p>宁伪作不知不为，不伪作假知妄为。静不露机，云雪屯也。</p>
</blockquote>
<p>伪装,隐蔽自己的能力,同时也要认清自己的实力</p>
<p>示弱是表象,认清形式伺机行动才是本质</p>
<p>有时为了以退求进，必得假痴不癫，老成持重，以达后发制人</p>
<p>此计用在军事上，指的是，虽然自己具有相当强大的实力，</p>
<p>但故意不露锋芒，显得软弱可欺，用以麻痹敌人，骄纵敌人，然后伺机给敌人以措手不及的打击。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164240494.png" alt="image-20220930164240494"></p>
<h2 id="上屋抽梯"><a href="#上屋抽梯" class="headerlink" title="上屋抽梯"></a>上屋抽梯</h2><blockquote>
<p>假之以便，唆之使前，断其援应，陷之死地。遇毒，位不当也。</p>
</blockquote>
<p>假之以便 : 去攻击</p>
<p>唆之使前 : 假装丢下物质u撤退,让他们去捡物质</p>
<p>断其援应 : 背后偷袭军营</p>
<p>遇毒，位不当也。: 利用敌人的贪恋</p>
<p>此计运用此理，是说敌入受我之唆，犹如贪食抢吃，只怪自己见利而受骗，才陷于了死地。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164322541.png" alt="image-20220930164322541"></p>
<p>什么是唆？就是用利去引诱敌人。如果敌人不肯轻易上钩，怎么办呢？</p>
<p>本来，你不给敌人先开个方便之门，它怎么会进你预先设下的口袋呢？</p>
<p>开方便之门，就是事先给敌人安放一个梯子。既不能使它猜疑，也要能让敌人清楚的看到梯子。</p>
<p>只要敌人爬上了梯子，就不怕它不进己方事先设置的圈套。</p>
<h2 id="树上开花"><a href="#树上开花" class="headerlink" title="树上开花"></a>树上开花</h2><blockquote>
<p>借局布势，力小势大。鸿渐于陆，其羽可用为仪也。</p>
</blockquote>
<p>关键在于造势,隐藏自己的弱势</p>
<p>首先洞察大局,利用周边形式造</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164515832.png" alt="image-20220930164515832"></p>
<p>此计运用此理，是说弱小的部队通过凭借某种因素，改变外部形态之后，自已阵容显得充实强大了，就象鸿雁长了羽毛丰满的翅膀一样。</p>
<p>古人按语说：此树本无花，而树则可以有花，剪彩贴之，不细察者不易发，使花与树交相辉映，而成玲珑全局也。</p>
<p>此盖布精兵于友军之阵，完其势以威敌也。</p>
<p>用假花冒充真花，取得乱真的效果，前边已作过分析。因为战场上情况复杂，瞬息万变，指挥官很容易被假象所惑。</p>
<p>所以，善于布置假情况，巧布迷魂阵，虚张声势，可以慑服甚至击败敌人。</p>
<p>此按语的最后一句，是将此计解释为：把自己的军队布置在盟军阵地上，以造成强大声势慑服敌人。</p>
<h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><blockquote>
<p>乘隙插足，扼其主机，渐之进也。</p>
</blockquote>
<p>变被动为主动</p>
<p>人按语说：</p>
<p>为人驱使者为奴，为人尊处者为客，不能立足者为暂客，能立足者为久客，客久而不能主事者为贱客，能主事则可渐握机要，而为主矣。</p>
<p>故反客为主之局：第一步须争客位；第二步须乘隙；第三步须插足；第四足须握机；第五乃成功。为主，则并人之军矣；此渐进之阴谋也</p>
<p>反客为主，用在军事上，是指在战争中，要努力变被动为主动，争取掌握战争主动权的谋略。尽量想办法钻空子，</p>
<p>插脚进去，控制它的首脑机关或者要害部位，抓住有利时机，兼并或者控制他人。</p>
<p>古人使用本计，多是对于盟友的。往往是借援助盟军的机会，先站稳脚跟，然后步步为营，取而代之。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164638188.png" alt="image-20220930164638188"></p>
<h1 id="败战"><a href="#败战" class="headerlink" title="败战"></a>败战</h1><h2 id="美人计"><a href="#美人计" class="headerlink" title="美人计"></a>美人计</h2><blockquote>
<p>兵强者， 攻其将；兵智者，伐其情。将弱 兵颓，其势自萎。利用御寇，顺 相保也。</p>
</blockquote>
<p>顺应了敌人情绪的特点,让他依靠情绪做出不理性的决定,</p>
<p>养其乱臣以迷之，进美女淫声以惑之。</p>
<p>意思是，对于用军事行动难以征服的敌方，要使用“糖衣炮弹”，</p>
<p>先从思想意志上打败敌方的将帅，使其内部丧失战斗力，然后再行攻取。就</p>
<p>象本计正文所说，对兵力强大的敌人，要制服它的将帅；对于足智多谋的将帅，要设法去腐蚀他．</p>
<p>将帅斗志衰退，部队肯定士气消沉，就失去了作战能力。利用多种手段，攻其弱点，己方就能顺势保存实力，由弱变强。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930164836720.png" alt="image-20220930164836720"></p>
<h2 id="空城计"><a href="#空城计" class="headerlink" title="空城计"></a>空城计</h2><blockquote>
<p>虚者虚之，疑中生疑；刚柔之际，奇而复奇。</p>
</blockquote>
<p>虚虚实实，兵无常势，变化无穷。</p>
<p>在敌乘我虚之时，当展开心理战。一定要充分掌握对方主帅的心理和性格特征，切切不可轻易出此险招。</p>
<p>况且，此计多数情况下，只能当作缓兵之计，还得防止敌人卷土重来。所以还必须有实力与敌方对抗，要救危局，还是要凭真正实力。</p>
<p>空城计，这是一种心理战术。在己方无力守城的情况下，故意向敌人暴露我城内空虚，就是所谓“虚者虚之”。</p>
<p>敌方产生怀疑，更会犹豫不前，就是所谓“疑中生疑”。敌人怕城内有埋伏，怕陷进埋伏圈内。</p>
<p>但这是悬而又悬的“险策”。使用此计的关键，是 <code>要清楚地了解并掌握敌方将帅的心理状况和性格特征</code>。</p>
<p>诸葛亮使用空城计解围，就是他充分地了解司马懿谨慎多疑的性格特点才敢出此险策。诸葛亮的空城计名闻天下，</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930165007386.png" alt="image-20220930165007386"></p>
<h2 id="反间计"><a href="#反间计" class="headerlink" title="反间计"></a>反间计</h2><blockquote>
<p>疑中之疑。比之自内，不自失也。</p>
</blockquote>
<p>反过来利用对方间谍</p>
<p>了结对方弱点,以假乱真</p>
<p>采用反间计的关键是“以假乱真”，造假要造得巧妙，造得逼真，才能使敌人上当受骗，信以为真，作出错误的判断，采取错误的行动。</p>
<p>反间计，原文的大意是说：在疑阵中再布疑阵，使敌内部自生矛盾，我方就可万无一失。</p>
<p>说得更通俗一些，就是巧妙地利用敌人的间谍反过来为我所用。在战争中，双方使用间谍是十分常见的。《</p>
<p>孙子兵法》就特别强调间谍的作用，认为将帅打仗必须事先了解敌方的情况。要准确掌握敌方的情况，不可靠鬼神，不可靠经验，</p>
<p>“必取于人，知敌之情者也。”这里的“人”，就是间谍。</p>
<p>《孙子兵法》专门有一篇《用间篇》，指出有五种间谍，</p>
<p>利用敌方乡里的普通人作间谍，叫因间；</p>
<p>收买敌方官吏作间谍，叫内间；</p>
<p>收买或利用敌方派来的间谍为我所用，叫反间；</p>
<p>故意制造和泄露假情况给敌方间谍，叫死间；</p>
<p>派人去敌方侦察，再回来报告情况，叫生间。</p>
<p>唐代社收解释反间计特别清楚，他说：“敌有间来窥我，我必先知之，或厚赂诱之，反为我用；或佯为不觉，示以伪情而纵之，则敌人之间，反为我用也。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930165157182.png" alt="image-20220930165157182"></p>
<h2 id="苦肉计"><a href="#苦肉计" class="headerlink" title="苦肉计"></a>苦肉计</h2><blockquote>
<p>人不自害，受害必真；假真真假，间以得行。童蒙之吉，顺以巽也。</p>
</blockquote>
<p>伤害自己,欺骗敌人,迎合敌人的同情心理</p>
<p>本计用此象理，是说用采用这种办法欺骗敌人，就是顺应着他那柔弱的性情达到目的。</p>
<h2 id="连环计"><a href="#连环计" class="headerlink" title="连环计"></a>连环计</h2><blockquote>
<p>将多兵众，不可以敌，使其自累，以杀其势。在师中吉，承天宠也</p>
</blockquote>
<p>古人还说：“大凡用计者，非一计之可孤行，必有数计以襄（辅助）之也。</p>
<p>……故善用兵者，行计务实施。</p>
<p>运巧必防损，立谋虑中变。”</p>
<p>意思说明，用计重在有效果，一计不成，又出多计，在情况变化时，要相应再出计，这样才会使对方防不胜防。</p>
<p>连环计，指多计并用，计计相连，环环相扣，一计累敌，一计攻敌，任何强敌，无攻不破。</p>
<p>此计正文的意思是如果敌方力量强大，就不要硬拼，要用计使其自相钳制，借以削弱敌方的战斗力。巧妙地运用谋略，就如有天神相助。</p>
<p>此计的关键是要使敌人“自累”，就是指互相钳制，背上包袱，使其行动不自由。这样，就给围歼敌人创造良好的条件。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930165628454.png" alt="image-20220930165628454"></p>
<h2 id="走为上"><a href="#走为上" class="headerlink" title="走为上"></a>走为上</h2><blockquote>
<p>全师避敌。左次无咎，未失常也</p>
</blockquote>
<p>走为上，指敌我力量悬殊的不利形势下，采取有计划的主动撤退，避开强敌，寻找战机，以退为进。这在谋略中也应是上策。</p>
<p>撤退的目的是避免与敌主力决战。主动撤退还可以诱敌，调动敌人，制造有利的战机。总之退是为进。</p>
<p><img src="https://re4mile.gitee.io/res/photo/book/image-20220930165800833.png" alt="image-20220930165800833"></p>
]]></content>
      <categories>
        <category>课外书</category>
      </categories>
      <tags>
        <tag>谋略</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux汇编语言基础部分</title>
    <url>/re4mile/2023/01/11/language/Asm/linux/language/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>好的文章和资源</title>
    <url>/re4mile/2023/01/11/other/%E8%B5%84%E6%BA%90/other/</url>
    <content><![CDATA[<h1 id="好的文章和资源"><a href="#好的文章和资源" class="headerlink" title="好的文章和资源"></a>好的文章和资源</h1><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p><a href="https://ascii.org.cn/">介绍ascii</a></p>
<p><a href="https://chengzhaoxi.xyz/">算法</a></p>
<p>[Java 尚硅谷]:(<a href="https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A">https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A</a> 8op3)</p>
<p>[wp 合集] (<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzMTc1MjExOQ==&amp;action=getalbum&amp;album_id=1345842232737316865&amp;scene=173&amp;from_msgid=2247507882&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzMTc1MjExOQ==&amp;action=getalbum&amp;album_id=1345842232737316865&amp;scene=173&amp;from_msgid=2247507882&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</a>)</p>
<p>花指令 :</p>
<p>如何构造: <a href="https://www.52pojie.cn/thread-326995-1-1.html">https://www.52pojie.cn/thread-326995-1-1.html</a></p>
<p>如何用IDC解决: <a href="https://www.cnblogs.com/LyShark/p/13100048.html">https://www.cnblogs.com/LyShark/p/13100048.html</a></p>
<p>汇编指令的一个英文网站,看上去不错,主要介绍指令的</p>
<p><a href="https://www.felixcloutier.com/x86/index.html">https://www.felixcloutier.com/x86/index.html</a></p>
<h1 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h1><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>iso系统最新版下载 :</p>
<p><a href="https://www.imsdn.cn/">https://www.imsdn.cn/</a></p>
<p>系统内核工具 <a href="https://423down.lanzouv.com/b0f1oadze">https://423down.lanzouv.com/b0f1oadze</a></p>
<h2 id="Github资源加速下载网站"><a href="#Github资源加速下载网站" class="headerlink" title="Github资源加速下载网站"></a>Github资源加速下载网站</h2><p><a href="https://d.serctl.com/">https://d.serctl.com/</a></p>
<p><a href="https://doget.nocsdn.com/#/">https://doget.nocsdn.com/#/</a></p>
<h2 id="linux学习的"><a href="#linux学习的" class="headerlink" title="linux学习的"></a>linux学习的</h2><h1 id="实用网站"><a href="#实用网站" class="headerlink" title="实用网站"></a>实用网站</h1><p>一般论坛和网站的网站 <a href="http://c.biancheng.net/sitemap/">http://c.biancheng.net/sitemap/</a></p>
<p>MG-GB ：　<a href="https://www.99cankao.com/digital-computation/mb-gb-converter.php">https://www.99cankao.com/digital-computation/mb-gb-converter.php</a></p>
<p>代码格式化</p>
<p>js : <a href="https://www.qianbo.com.cn/Tool/Beautify/Js-Formatter.html">https://www.qianbo.com.cn/Tool/Beautify/Js-Formatter.html</a></p>
<p>C语言代码格式化 : <a href="https://tool.uvooc.com/formatc/">https://tool.uvooc.com/formatc/</a></p>
<p>css 代码格式化 : <a href="https://tool.ip138.com/css/">https://tool.ip138.com/css/</a></p>
<p>图片去除底色:</p>
<p><a href="https://www.aigei.com/bgremover/">https://www.aigei.com/bgremover/</a></p>
<p><a href="https://picwish.cn/remove-background">https://picwish.cn/remove-background</a></p>
<p>图标大全：<a href="https://www.aigei.com/icon/class/">https://www.aigei.com/icon/class/</a></p>
<p>变量命名: Codelf <a href="https://unbug.github.io/codelf/">https://unbug.github.io/codelf/</a></p>
<p>取照片rgb颜色： <a href="https://c.runoob.com/front-end/6214/#f9d94c">https://c.runoob.com/front-end/6214/#f9d94c</a></p>
<p>ico图标生成: <a href="http://www.ico51.cn/">http://www.ico51.cn/</a></p>
<p>gif: <a href="https://www.aigei.com/design/pkg/">https://www.aigei.com/design/pkg/</a></p>
<p>免费加速器 <a href="https://zhuanlan.zhihu.com/p/468551511">https://zhuanlan.zhihu.com/p/468551511</a></p>
<p>搜索引擎谷歌 <a href="https://fsoufsou.com/">https://fsoufsou.com/</a></p>
<p>专利申请书范围内容 <a href="http://www.soopat.com/">http://www.soopat.com/</a></p>
<p>在线搜索 <a href="https://limestart.cn/">https://limestart.cn/</a></p>
<p>RGB颜色 <a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">https://www.sioe.cn/yingyong/yanse-rgb-16/</a></p>
<p>像素画 <a href="http://www.lizibuluo.com/xs">http://www.lizibuluo.com/xs</a></p>
<p><a href="https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E5%8A%A9%E6%89%8B/nonmafimegllfoonjgplbabhmgfanaka/related">谷歌应用商店</a></p>
<p><a href="http://tools.bugscaner.com/text/quhanghao.html">代码去除行号</a></p>
<p><a href="http://tools.jb51.net/code/quhanghao">代码去除行行号</a></p>
<h1 id="130余个实用网站"><a href="#130余个实用网站" class="headerlink" title="130余个实用网站"></a>130余个实用网站</h1><p>原文链接 <a href="https://blog.csdn.net/wucz122140729/article/details/105182717">https://blog.csdn.net/wucz122140729/article/details/105182717</a></p>
<h2 id="1、搞学习"><a href="#1、搞学习" class="headerlink" title="1、搞学习"></a>1、搞学习</h2><p>CSDN： <a href="https://www.csdn.net/">https://www.csdn.net/</a></p>
<p>C语言技术网：<a href="http://www.freecplus.net/">http://www.freecplus.net/</a></p>
<p>TED（最优质的演讲）：<a href="https://www.ted.com/">https://www.ted.com/</a></p>
<p>谷粉学术： <a href="https://gfsoso.99lb.net/scholar.html">https://gfsoso.99lb.net/scholar.html</a></p>
<p>大学资源网：<a href="http://www.dxzy163.com/">http://www.dxzy163.com/</a></p>
<p>简答题：<a href="http://www.jiandati.com/">http://www.jiandati.com/</a></p>
<p>网易公开课：<a href="https://open.163.com/ted/">https://open.163.com/ted/</a></p>
<p>网易云课堂：<a href="https://study.163.com/">https://study.163.com/</a></p>
<p>中国大学MOOC：<a href="http://www.icourse163.org/">www.icourse163.org</a></p>
<p>网易云课堂：study.163.com</p>
<p>哔哩哔哩弹幕网： <a href="http://www.bilibili.com/">www.bilibili.com</a></p>
<p>我要自学网： <a href="http://www.51zxw.net/">www.51zxw.net</a></p>
<p>知乎：<a href="http://www.zhihu.com/">www.zhihu.com</a></p>
<p>学堂在线：<a href="http://www.xuetangx.com/">www.xuetangx.com</a></p>
<p>爱课程：<a href="http://www.icourses.cn/">www.icourses.cn</a></p>
<p>猫咪论文：<a href="https://lunwen.im/">https://lunwen.im/</a></p>
<p>iData（论文搜索）：<a href="http://www.cn-ki.net/">www.cn-ki.net</a></p>
<p>文泉考试：<a href="https://www.wqkaoshi.com/">https://www.wqkaoshi.com</a></p>
<h2 id="2、找书籍"><a href="#2、找书籍" class="headerlink" title="2、找书籍"></a>2、找书籍</h2><p>书栈网（极力推荐）： <a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a></p>
<p>码农之家（计算机电子书下载）：<a href="http://www.xz577.com/">www.xz577.com</a></p>
<p>鸠摩搜书：<a href="http://www.jiumodiary.com/">www.jiumodiary.com</a></p>
<p>云海电子图书馆：<a href="http://www.pdfbook.cn/">www.pdfbook.cn</a></p>
<p>周读（书籍搜索）：ireadweek.com</p>
<p>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a></p>
<p>脚本之家电子书下载：<a href="https://www.jb51.net/books/">https://www.jb51.net/books/</a></p>
<p>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html">http://www.soshuvip.com/all.html</a></p>
<p>书格（在线古籍图书馆）：<a href="https://new.shuge.org/">https://new.shuge.org/</a></p>
<p>caj云阅读：<a href="http://cajviewer.cnki.net/cajcloud/">http://cajviewer.cnki.net/cajcloud/</a></p>
<p>必看网（人生必看的书籍）：<a href="https://www.biikan.com/">https://www.biikan.com/</a></p>
<h2 id="3、冷知识-x2F-黑科技"><a href="#3、冷知识-x2F-黑科技" class="headerlink" title="3、冷知识 &#x2F; 黑科技"></a>3、冷知识 &#x2F; 黑科技</h2><p>上班摸鱼必备（假装电脑系统升级）： <a href="http://fakeupdate.net/">http://fakeupdate.net/</a></p>
<p>PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：<br><a href="http://www.species-in-pieces.com/">http://www.species-in-pieces.com/</a></p>
<p>图片立体像素画： <a href="https://pissang.github.io/voxelize-image/">https://pissang.github.io/voxelize-image/</a></p>
<p>福利单词（一个不太正经的背单词网站）： <a href="http://dict.ftqq.com/">http://dict.ftqq.com</a></p>
<p>查无此人（刷新网站，展现一张AI<br>生成的人脸照片）：<a href="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/</a></p>
<p>在线制作地图图例：<a href="https://mapchart.net/">https://mapchart.net/</a></p>
<p>创意光线绘画：<a href="http://weavesilk.com/">http://weavesilk.com/</a></p>
<p>星系观察： <a href="https://stellarium-web.org/">https://stellarium-web.org/</a></p>
<p>煎蛋：<a href="http://jandan.net/">http://jandan.net/</a></p>
<p>渣男-说话的艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a></p>
<p>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a></p>
<p>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a></p>
<p>术语在线：<a href="http://www.termonline.cn/">http://www.termonline.cn/</a></p>
<h2 id="4、写代码"><a href="#4、写代码" class="headerlink" title="4、写代码"></a>4、写代码</h2><p>GitHub：<a href="https://github.com/">https://github.com/</a></p>
<p>码云：<a href="https://gitee.com/">https://gitee.com/</a></p>
<p>源码之家：<a href="https://www.mycodes.net/">https://www.mycodes.net/</a></p>
<p>JSON to Dart： <a href="https://javiercbk.github.io/json_to_dart/">https://javiercbk.github.io/json_to_dart/</a></p>
<p>Json在线解析验证： <a href="https://www.json.cn/">https://www.json.cn/</a></p>
<p>在线接口测试（Getman）：<em><a href="https://getman.cn/">https://getman.cn/</a></em></p>
<p>freecplus框架：<a href="http://www.freecplus.net/">http://www.freecplus.net/</a></p>
<h2 id="5、资源搜索"><a href="#5、资源搜索" class="headerlink" title="5、资源搜索"></a>5、资源搜索</h2><p>DogeDoge搜索引擎：<a href="http://www.dogedoge.com/">www.dogedoge.com</a></p>
<p>秘迹搜索：<a href="https://mijisou.com/">https://mijisou.com/</a></p>
<p>小白盘：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com/</a></p>
<p>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com/">www.yunpanjingling.com</a></p>
<p>虫部落（资源搜索）：<a href="http://www.chongbuluo.com/">www.chongbuluo.com</a></p>
<p>如风搜（资源搜索）：<a href="http://www.rufengso.net/">http://www.rufengso.net/</a></p>
<p>爱扒：<a href="https://www.zyboe.com/">https://www.zyboe.com/</a></p>
<h2 id="6、小工具"><a href="#6、小工具" class="headerlink" title="6、小工具"></a>6、小工具</h2><p>奶牛快传（在线传输文件利器）： cowtransfer.com</p>
<p>文叔叔（大文件传输，不限速）：<a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a></p>
<p>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/">https://uzer.me/</a></p>
<p>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：<a href="https://www.xiangdang.net/">https://www.xiangdang.net/</a></p>
<p>二维码生成：<a href="https://cli.im/">https://cli.im/</a></p>
<p>搜狗翻译：fanyi.sogou.com</p>
<p>熵数（图表制作，数据可视化）：<a href="https://dydata.io/appv2/#/pages/index/home">https://dydata.io/appv2/#/pages/index/home</a></p>
<p>拷贝兔：<a href="https://cp.anyknew.com/">https://cp.anyknew.com/</a></p>
<p>图片无限变放大：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a></p>
<p>幕布（在线大纲笔记工具）：mubu.com</p>
<p>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/">https://zh.justcnw.com/</a></p>
<p>调查问卷制作：<a href="https://www.wenjuan.com/">https://www.wenjuan.com/</a></p>
<p>果核剥壳（软件下载）：<a href="https://www.ghpym.com/">https://www.ghpym.com/</a></p>
<p>软件下载：<a href="https://www.unyoo.com/">https://www.unyoo.com/</a></p>
<p>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p>
<h2 id="7、导航页（工具集）"><a href="#7、导航页（工具集）" class="headerlink" title="7、导航页（工具集）"></a>7、导航页（工具集）</h2><p>世界各国网址大全： <a href="http://www.world68.com/">http://www.world68.com/</a></p>
<p>小森林导航：<a href="http://www.xsldh6.com/">http://www.xsldh6.com/</a></p>
<p>简捷工具：<a href="http://www.shulijp.com/">http://www.shulijp.com/</a></p>
<p>NiceTool.net 好工具网：<a href="http://www.nicetool.net/">http://www.nicetool.net/</a></p>
<p>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/">http://tool.uixsj.cn/</a></p>
<p>蓝调网站：<a href="http://lcoc.top/">http://lcoc.top/</a></p>
<p>偷渡鱼：<a href="https://touduyu.com/">https://touduyu.com/</a></p>
<p>牛导航：<a href="http://www.ziliao6.com/">http://www.ziliao6.com/</a></p>
<p>小呆导航：<a href="https://www.webjike.com/index.html">https://www.webjike.com/index.html</a></p>
<p>简法主页：<a href="http://www.jianfast.com/">http://www.jianfast.com/</a></p>
<p>KIM主页：<a href="https://kim.plopco.com/">https://kim.plopco.com/</a></p>
<p>聚BT：<a href="https://jubt.net/cn/index.html">https://jubt.net/cn/index.html</a></p>
<p>精准云工具合集：<a href="https://jingzhunyun.com/">https://jingzhunyun.com/</a></p>
<p>兔2工具合集：<a href="https://www.tool2.cn/">https://www.tool2.cn/</a></p>
<p>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com/">www.toolnb.com</a></p>
<p>工具导航：<a href="https://hao.logosc.cn/">https://hao.logosc.cn/</a></p>
<h2 id="8、看视频"><a href="#8、看视频" class="headerlink" title="8、看视频"></a>8、看视频</h2><p>阿木影视： <a href="https://www.aosk.online/">https://www.aosk.online/</a></p>
<p>电影推荐（分类别致）：<a href="http://www.mvcat.com/">http://www.mvcat.com</a></p>
<p>APP影院：<a href="https://app.movie/">https://app.movie/</a></p>
<p>去看TV：<a href="https://www.qukantv.net/">https://www.qukantv.net/</a></p>
<p>动漫视频网：<a href="http://www.zzzfun.com/">http://www.zzzfun.com/</a></p>
<p>94神马电影网：<a href="http://www.9rmb.com/">http://www.9rmb.com/</a></p>
<p>NO视频官网：<a href="http://www.novipnoad.com/">http://www.novipnoad.com/</a></p>
<p>蓝光画质电影：<a href="http://www.languang.co/">http://www.languang.co/</a></p>
<p>在线看剧：<a href="http://dy.27234.cn/">http://dy.27234.cn/</a></p>
<p>大数据导航：<a href="http://hao.199it.com/">http://hao.199it.com/</a></p>
<p>多功能图片网站：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>
<p>牛牛TV：<a href="http://www.ziliao6.com/tv/">http://www.ziliao6.com/tv/</a></p>
<p>VideoFk解析视频：<a href="http://www.videofk.com/">http://www.videofk.com/</a></p>
<p>蓝调网站：<a href="http://lcoc.top/vip2.3/">http://lcoc.top/vip2.3/</a></p>
<p>永久资源采集网：<a href="http://www.yongjiuzy1.com/">http://www.yongjiuzy1.com/</a></p>
<h2 id="9、学设计"><a href="#9、学设计" class="headerlink" title="9、学设计"></a>9、学设计</h2><p>码力全开（产品&#x2F;设计师&#x2F;独立开发者的资源库）：<br><a href="https://www.maliquankai.com/designnav/">https://www.maliquankai.com/designnav/</a></p>
<p>免费音频素材：<a href="https://icons8.cn/music">https://icons8.cn/music</a></p>
<p>新CG儿（视频素材模板，无水印+免费下载）：<a href="https://www.newcger.com/">https://www.newcger.com/</a></p>
<p>Iconfont（阿里巴巴矢量图标库）： <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p>
<p>小图标下载：<a href="https://www.easyicon.net/">https://www.easyicon.net/</a></p>
<p>Flight Icon：<a href="https://www.flighticon.co/">https://www.flighticon.co/</a></p>
<p>第一字体转换器：<a href="http://www.diyiziti.com/">http://www.diyiziti.com/</a></p>
<p>doyoudosh（平面设计）：<a href="http://www.doyoudo.com/">www.doyoudo.com</a></p>
<p>企业宣传视频在线制作：<a href="https://duomu.tv/">https://duomu.tv/</a></p>
<p>MAKE海报设计官网：<a href="http://maka.im/">http://maka.im/</a></p>
<p>一键海报神器：<a href="https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral">https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral</a></p>
<p>字由（字体设计）：<a href="http://www.hellofont.cn/">http://www.hellofont.cn/</a></p>
<p>查字体网站：<a href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a></p>
<p>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：<br><a href="http://www.aigei.com/">http://www.aigei.com/</a></p>
<p>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor">https://bilibili.clipchamp.com/editor</a></p>
<h2 id="10、搞文档"><a href="#10、搞文档" class="headerlink" title="10、搞文档"></a>10、搞文档</h2><p>即书（在线制作PPT）：<a href="https://www.keysuper.com/">https://www.keysuper.com/</a></p>
<p>PDF处理：<a href="https://smallpdf.com/cn">https://smallpdf.com/cn</a></p>
<p>PDF处理：<a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a></p>
<p>PDF处理： <a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a></p>
<p>PDF处理：<a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a></p>
<p>图片压缩，PDF处理：<a href="https://docsmall.com/">https://docsmall.com/</a></p>
<p>腾讯文档（在线协作编辑和管理文档）：docs.qq.com</p>
<p>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com/">www.processon.com</a></p>
<p>iLovePDF（在线转换PDF利器）：<a href="http://www.ilovepdf.com/">www.ilovepdf.com</a></p>
<p>PPT在线制作：<a href="https://www.woodo.cn/">https://www.woodo.cn/</a></p>
<p>PDF24工具（pdf处理工具）：<a href="https://tools.pdf24.org/en">https://tools.pdf24.org/en</a></p>
<p>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai/">www.imgbot.ai</a></p>
<p>福昕云编辑（在线编辑PDF）：edit.foxitcloud.cn</p>
<p>TinyPNG（在线压缩图片）：tinypng.com</p>
<p>UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套</p>
<p>）：uzer.me</p>
<p>优品PPT（模板下载）： <a href="http://www.ypppt.com/">http://www.ypppt.com/</a></p>
<p>第一PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/">http://www.1ppt.com/xiazai/</a></p>
<p>三顿PPT导航：sandunppt.com</p>
<p>Excel函数表：<br><a href="https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188">https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188</a></p>
<h2 id="11、找图片"><a href="#11、找图片" class="headerlink" title="11、找图片"></a>11、找图片</h2><p>电脑壁纸：<a href="http://lcoc.top/bizhi/">http://lcoc.top/bizhi/</a></p>
<p><a href="https://unsplash.com/">https://unsplash.com/</a></p>
<p><a href="https://pixabay.com/">https://pixabay.com/</a></p>
<p><a href="https://www.pexels.com/">https://www.pexels.com/</a></p>
<p><a href="https://visualhunt.com/">https://visualhunt.com/</a></p>
<p><a href="https://www.ssyer.com/">https://www.ssyer.com/</a></p>
<p>彼岸图网：<a href="http://pic.netbian.com/">http://pic.netbian.com/</a></p>
<p>极像素（超高清大图）：<a href="https://www.sigoo.com/">https://www.sigoo.com/</a></p>
<p>免费版权图片搜索：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>
<p>持续更新中。。。</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title>信安数学基础</title>
    <url>/re4mile/2023/01/11/%E6%9C%AC%E7%A7%91%E4%B8%93%E4%B8%9A/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/zy/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="方法一-穷举法"><a href="#方法一-穷举法" class="headerlink" title="方法一 穷举法"></a>方法一 穷举法</h3><p>公约数从小-&gt;大</p>
<p>他们同时除一个数,如果都能除尽,说明是公约数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2, i, output,min;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个正整数，以空格分隔: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line">	min=n1&lt;n2?n1:n2; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt;=min; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断 i 是否为最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(n1%i==<span class="number">0</span> &amp;&amp; n2%i==<span class="number">0</span>)<span class="comment">//i从1开始,一直遍历到最大值,如果满足同时被2个数整除就记录一下</span></span><br><span class="line">            output = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最大公约数是 %d&quot;</span>, n1, n2, output); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的另外一个模板是</p>
<p>原理一模一样,从大的公约数到小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, gcd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个正整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    gcd=x&lt;y?x:y;</span><br><span class="line">    <span class="keyword">while</span>(x % gcd ||y % gcd)<span class="comment">//当余数同时为0就退出 </span></span><br><span class="line">        gcd--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gcd = %d\n&quot;</span>, gcd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法二-未知方法"><a href="#方法二-未知方法" class="headerlink" title="方法二 未知方法"></a>方法二 未知方法</h3><p>公约数从大-&gt;小</p>
<p>缺陷:负数不行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个数，以空格分隔: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n1,&amp;n2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(n1!=n2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1 &gt; n2)</span><br><span class="line">            n1 -= n2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n2 -= n1;</span><br><span class="line">        <span class="comment">//大小的ifelse保证结果为正</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GCD = %d&quot;</span>,n1);<span class="comment">//组后n1与n2都是一样的 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="欧几里得之辗转相除法"><a href="#欧几里得之辗转相除法" class="headerlink" title="欧几里得之辗转相除法"></a>欧几里得之辗转相除法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> buff;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入两个正整数：\n&quot;</span>);	 </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这下面这个代码的顺序很重要 </span></span><br><span class="line">	<span class="keyword">while</span> (y != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		buff = x % y;</span><br><span class="line">		x = y;</span><br><span class="line">		y = buff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -x);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="辗转相除法-函数递归"><a href="#辗转相除法-函数递归" class="headerlink" title="辗转相除法-函数递归"></a>辗转相除法-函数递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, func(x, y));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (y != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> func(y, x % y);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外一种写法,可能它的步骤更加前进些</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,func(<span class="number">21</span>,<span class="number">49</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(m % n != <span class="number">0</span>)    <span class="comment">//直接运算后判断,返回那个商,而那个商是以前的余数</span></span><br><span class="line">		<span class="keyword">return</span> func(n, m%n);   </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><h3 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2, max;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个正整数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line"> 	</span><br><span class="line"> 	max=n1&gt;n2?n1:n2;</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(max%n1==<span class="number">0</span>&amp;&amp;max%n2==<span class="number">0</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">	 		<span class="keyword">break</span>;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	max++;</span><br><span class="line">	&#125;</span><br><span class="line">	  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="难以琢磨"><a href="#难以琢磨" class="headerlink" title="难以琢磨"></a>难以琢磨</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,buff,gcd;</span><br><span class="line">    n1=<span class="number">72</span>;</span><br><span class="line">    n2=<span class="number">120</span>;</span><br><span class="line">    gcd=n1&lt;n2?n1:n2;</span><br><span class="line">	<span class="keyword">while</span>(n1%gcd||n2%gcd)</span><br><span class="line">		gcd--; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(n1*n2)/gcd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="整除和同余"><a href="#整除和同余" class="headerlink" title="整除和同余"></a>整除和同余</h1><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>(1)	如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a)</p>
<p>(2)	整除的传递性: 	如果a|b,且b|c,那么a|c</p>
<p>(3)	如果c|a,且c|b,那么c|ua+vb ,其中u和v是任意整数</p>
<p>(4)	如果c|a1…c|a<del>k</del>,那么有c|(u<del>1</del>a<del>1</del>+…+u<del>k</del>a<del>k</del>)</p>
<p>(5)	0是任何非零整数的整数倍</p>
<p>(6)	±1是任何整数的因数</p>
<p>(7)	出0外,任何数是自己的整数倍,也就是是自己的一倍</p>
<p>&#x2F;&#x2F;如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a)</p>
<p>为什么说还有一个负数额情况?</p>
<p>比如-2%2&#x3D;0,2%-2&#x3D;0</p>
<p>理解的角度</p>
<ul>
<li>负号剥离</li>
<li>(-2+2)%2&#x3D;0,2</li>
</ul>
<p>如果b|a,且a|b,那么b&#x3D;a或者b&#x3D;(-a)</p>
<p>注意这里,我们可以用于数据的校验..</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType unsigned char</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType ,bType)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	func(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType x,bType y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&amp;&amp;y)<span class="comment">//为了不发生异常的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%y==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(y%x==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>整除的传递性: 	如果a|b,且b|c,那么a|c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> bType;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType ,bType,bType)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swapt</span><span class="params">(bType* ,bType* )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=func(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType x,bType y,bType z)</span></span><br><span class="line">&#123;</span><br><span class="line">	bType b_Arr[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	b_Arr[<span class="number">0</span>]=x;</span><br><span class="line">	b_Arr[<span class="number">1</span>]=y;</span><br><span class="line">	b_Arr[<span class="number">2</span>]=z;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">2</span>-i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b_Arr[j]&gt;b_Arr[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				swapt(&amp;b_Arr[j],&amp;b_Arr[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x=b_Arr[<span class="number">0</span>];</span><br><span class="line">	y=b_Arr[<span class="number">1</span>];</span><br><span class="line">	z=b_Arr[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span>(x!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y%x==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			label1:</span><br><span class="line">			<span class="keyword">if</span>(y!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(z%y==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//现在都有2个0了,当然会是成立</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">goto</span> label1;<span class="comment">//如果第一数是0,并不能说明什么,我们还得继续判断</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swapt</span><span class="params">(bType* x,bType* y)</span></span><br><span class="line">&#123;</span><br><span class="line">	bType tmp=<span class="number">0</span>;</span><br><span class="line">	tmp=*x;</span><br><span class="line">	*x=*y;</span><br><span class="line">	*y=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 如果c|a,且c|b,那么c|ua+vb ,其中u和v是任意整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> bType;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	bType flag[]=<span class="string">&quot;D0g3&#123;resmile&#125;&quot;</span>;</span><br><span class="line">	ret=func(flag);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType * flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">6</span>,c=<span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len =<span class="built_in">strlen</span>(flag)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((flag[<span class="number">2</span>*i+<span class="number">0</span>]*a+flag[<span class="number">2</span>*i+<span class="number">1</span>]*b)%c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p style="color:red;font-size: 20px">浅谈%求余来判断整除</p>

<p><img src="/re4mile/../../../blog/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6/image-20221129114028804.png" alt="image-20221129114028804"></p>
<p style="color:yellow;font-size: 16px">对于正数的求余</p>

<p>比如9%12&#x3D;9,从起点出发,走过9的距离,所以结果是9</p>
<p>比如15%12&#x3D;3,从起点出发,走过12个距离,到达终点,终点又变为新的起点继续走,走了3个距离,距离起点3,结果是3</p>
<p style="color:yellow;font-size: 16px">对于负数取余</p>

<p>比如-4%12的意义,从起点出发,走过距离4,距离终点8,所以结果是8</p>
<p>比如-16%13的意义,走过一圈13,新的起点,然后走3,距离终点10,所以结果是10</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>关于取模负数的计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">retGuess= A - A / B * B;</span><br><span class="line">retCheck= A % B;</span><br></pre></td></tr></table></figure>

<p>上面2个公式是等价的为什么等价?</p>
<p>n&#x3D; A &#x2F; B 其实是变相的说明有n个B,然后n乘以B,用被除数减去nB就是余数</p>
<p>如果A&lt;B,那么结果就是A,好比7%8,7&lt;8,那么结果就是8,因为7的内部含有0个8</p>
<p>如果A&gt;B,那么就减去重复的被除数,剩下的就是结果,好比12%8,减去几个8? 12&#x2F;8&#x3D;1,所以减去1个8,余下4,4&lt;8,所以结果就是4</p>
<p>有下面这个式子: 34&#x2F;7&#x3D;4…6</p>
<p>我对这个的理解是34&#x3D;7x4+6,认为4和7都可以作为除数,因为他们是等价的</p>
<p>但是…</p>
<p>34&#x2F;4&#x3D;7…6,这个式子确实成立,但是已经脱离了意义,因为6&gt;4</p>
<p>所以我们会要求a&#x3D;bq+r中,已知a,b,求q,r,其中r &lt; |b|</p>
<p>基于a&#x3D;bq+r求出q,r</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> bType;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	bType flag[]=<span class="string">&quot;D0g3&#123;resmile&#125;&quot;</span>;</span><br><span class="line">	func(flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(bType * flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	bType x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">	len=<span class="built_in">strlen</span>((<span class="type">char</span>*)flag);</span><br><span class="line">	<span class="keyword">if</span>(len&amp;<span class="number">1</span>)</span><br><span class="line">		len++;</span><br><span class="line">	len/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x=flag[<span class="number">2</span>*i+<span class="number">0</span>];</span><br><span class="line">		y=flag[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">			y=<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c / %c = %02X .. %02X\n&quot;</span>,x,y,x/y,x%y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大公因数-gcd"><a href="#最大公因数-gcd" class="headerlink" title="最大公因数 gcd"></a>最大公因数 gcd</h2><h3 id="最大公因数-1"><a href="#最大公因数-1" class="headerlink" title="最大公因数"></a>最大公因数</h3><blockquote>
<p>1).</p>
</blockquote>
<p>gcd(x,y)&#x3D;gcd(x,-y)&#x3D;gcd(-x,y)&#x3D;gcd(-x,-y)</p>
<p>在这里,如果一个数<code>(所有的公因子)|某个公因子</code>也无法确定某个公因子是xx</p>
<p>比如xx&#x3D;-70满足条件,但是他的对立面,70也是满足条件的,所以我们讨论最大公因子其实是正在正数的角度</p>
<p>可用于算法的校验</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>  <span class="title function_">gcd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	gcd(<span class="number">12</span>, <span class="number">24</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//功能：利用欧几里德算法，求整数a，b的最大公约数</span></span><br><span class="line"><span class="comment">//参数：整数a，b</span></span><br><span class="line"><span class="comment">//返回：a,b的最大公约数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">gcd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) </span><br><span class="line">	&#123; <span class="comment">//保证a大于等于b，便于a%b的运算</span></span><br><span class="line">	</span><br><span class="line">		tmp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y)</span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">		tmp = x % y;</span><br><span class="line">		x = y;</span><br><span class="line">		y = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2). 如果y!&#x3D;0,(0,y) &#x3D; |y|</p>
<p>3). m&gt;0,则m(x,y)&#x3D;(mx,my)</p>
<p>4).</p>
<p>整数a,b,c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 (a,c)=1</span><br><span class="line">	则(ab,c)=(b,c)</span><br></pre></td></tr></table></figure>

<p>无论a&#x3D;1还是b&#x3D;1,都成立</p>
<p>5).</p>
<p>整数a,b,c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 a|bc &amp;&amp; (a,b)=1</span><br><span class="line">	则 a|c</span><br></pre></td></tr></table></figure>



<h3 id="欧几里得扩展算法"><a href="#欧几里得扩展算法" class="headerlink" title="欧几里得扩展算法"></a>欧几里得扩展算法</h3><p>对于自然界的正整数…a,b…一定满足ax+by&#x3D;&#x3D;gcd(a,b); (解一定存在，根据数论中的相关定理）</p>
<p>一个求公因数的定理</p>
<p>对于任意2个A,B</p>
<p>存在AxM+BxN&#x3D;(A,B)</p>
<p>另外,如果A,B互素,当然只会有一个公因数1,也就是结果为1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Euclid</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> num1, <span class="type">unsigned</span> <span class="type">char</span> num2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> flag[] = <span class="string">&quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> x, y;</span><br><span class="line">	len = <span class="built_in">strlen</span>(flag);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=Euclid(flag[<span class="number">2</span> * i + <span class="number">0</span>], flag[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">		x = tmp &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		y = tmp &amp; <span class="number">0xff</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02X %02X\n&quot;</span>, x&amp;<span class="number">0xFF</span> ,y&amp;<span class="number">0xFF</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Euclid</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> num1, <span class="type">unsigned</span> <span class="type">char</span> num2)</span><span class="comment">//传递进来的是无符号正数,最后处理的时候却变为了有符号</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> x[<span class="number">64</span>], y[<span class="number">64</span>];</span><br><span class="line">	<span class="type">char</span> ret1 = <span class="number">0</span>, ret2 = <span class="number">0</span>, ret1_bak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	x[<span class="number">0</span>] = num1;</span><br><span class="line">	y[<span class="number">0</span>] = num2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正向存储的过程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; y[i]; i++)<span class="comment">//我可能存了一些不必要的数据进去</span></span><br><span class="line">	&#123;</span><br><span class="line">		x[i + <span class="number">1</span>] = y[i];</span><br><span class="line">		y[i + <span class="number">1</span>] = x[i] % y[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向求值的过程</span></span><br><span class="line">	ret1 = <span class="number">0</span>;</span><br><span class="line">	ret1_bak = ret1;</span><br><span class="line">	ret2 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		ret1_bak = ret1;</span><br><span class="line">		ret1 = ret2;</span><br><span class="line">		ret2 = x[i] / y[i] * (<span class="number">-1</span>) * ret1 + ret1_bak;</span><br><span class="line">	&#125;</span><br><span class="line">	result	= (<span class="type">unsigned</span> <span class="type">int</span>)ret1;</span><br><span class="line">	result	=result &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	result = result |  (ret2 &amp; <span class="number">0xFF</span>);<span class="comment">//很不理解</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">44*05+30*F9=(D,0)=04</span><br><span class="line">67*01+33*FE=(g,3)=01</span><br><span class="line">7B*01+52*FF=(&#123;,R)=29</span><br><span class="line">47*E9+56*13=(G,V)=01</span><br><span class="line">75*FD+5A*04=(u,Z)=09</span><br><span class="line">31*03+46*FE=(1,F)=07</span><br><span class="line">31*21+65*F0=(1,e)=01</span><br><span class="line">47*23+6C*E9=(G,l)=01</span><br><span class="line">68*F0+62*11=(h,b)=02</span><br><span class="line">6D*0A+63*F5=(m,c)=01</span><br><span class="line">75*D1+7D*2C=(u,&#125;)=01</span><br></pre></td></tr></table></figure>



<p>递归版本,copy from <a href="https://blog.csdn.net/AAMahone/article/details/79320635">https://blog.csdn.net/AAMahone/article/details/79320635</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,s,t,gcd;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> *x,<span class="type">int</span> *y)</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        gcd=exgcd(a,b,&amp;s,&amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> *x,<span class="type">int</span> *y)</span><span class="comment">//扩展欧几里得算法;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *x=<span class="number">1</span>;</span><br><span class="line">        *y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> t=*x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=t-a/b*(*y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>3个不全为0的整数</p>
<p>y&#x3D;m*x+z</p>
<p>则(x,y)&#x3D;(x,z)</p>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>与素数相反的概念是合数</p>
<p>1既不是素数也不是合数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==素数)</span><br><span class="line">&#123;</span><br><span class="line">	n∈正整数;</span><br><span class="line">	<span class="keyword">if</span>(!(p|n))</span><br><span class="line">		<span class="keyword">if</span>(p&gt;=<span class="number">2</span>&amp;&amp;p&lt;=<span class="built_in">sqrt</span>(n))</span><br><span class="line">			n是素数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>关于能不能被整除,取%一下就OK</p>
<p>下面是素数的判断,有素数就返回非0,没有素数当然返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;<span class="comment">//用于跳出循环的标志</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//有多少个素数</span></span><br><span class="line">	<span class="keyword">for</span>(j=n;j&gt;<span class="number">1</span>;j--)</span><br><span class="line">	&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; j; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j % i == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">0</span>;<span class="comment">//不是素数</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			flag=<span class="number">1</span>;<span class="comment">//是素数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>)<span class="comment">//这里只不过是打印一下,但是cnt++是必要的</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>,j);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>公理</p>
<p>ps:假设求素数个数的公式是cntPrime()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cntPrime(x) / (x/log(x)) </span><br><span class="line">这个数学函数是一个递减的函数,值应该和1差不多,并且会无限趋于1,但是不会等于1吧</span><br></pre></td></tr></table></figure>



<p>孪生素数猜想:</p>
<p>就是指相差2的素数对，例如3和5，5和7，11和13…。这个猜想正式由希尔伯特在1900年国际数学家大会的报告上第8个问题中提出，</p>
<p>可以这样描述：</p>
<p>存在无穷多个素数p，使得p + 2是素数。</p>
<p>素数对（p, p + 2）称为孪生素数。</p>
<p>在1849年，阿尔方·德·波利尼亚克提出了一般的猜想：对所有自然数k，存在无穷多个素数对（p, p + 2k）。k &#x3D; 1的情况就是孪生素数猜想</p>
<p>素数的判断,当然会有,如果p是素数,会有(p+偶数)也是素数,这个可以起到移动的混淆作用</p>
<p>哥德巴赫猜想</p>
<p>任一大于2的整数都可写成三个质数之和</p>
<p>任一大于5的整数都可写成三个质数之和</p>
<p>任一大于2的偶数都可写成两个质数之和 但是对应的质数不唯一,也就是可能与很多对</p>
<p>任何一个大于7的奇数都能被表示成三个奇质数的和</p>
<h2 id="最小公倍数-1"><a href="#最小公倍数-1" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>规定符号[x,y]就是求出x,y的最小公倍数</p>
<ol>
<li><p>x,y是互素的正整数</p>
<ul>
<li>&#96;&#96;&#96;<br>if (x|z &amp;&amp; y|Z)<br>则xy|z<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - [x,y]=xy</span><br><span class="line"></span><br><span class="line">2. a,b∈正整数</span><br><span class="line"></span><br><span class="line">   - [a,b]=ab/(a,b)</span><br><span class="line"></span><br><span class="line">3. a,b∈正整数</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     if( a|m &amp;&amp; b|m)</span><br><span class="line">     &#123;</span><br><span class="line">     	[a,b]|m</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>a1,a2,a3,a4,a5.an 是n个整数</p>
</li>
</ol>
<p>​	让</p>
<p>​	[A1,A2]&#x3D;M2,</p>
<p>​	[M2,A3]&#x3D;M3,</p>
<p>​	[M3,A4]&#x3D;M4,</p>
<p>​	…</p>
<p>​	[Mn-1,An]&#x3D;Mn</p>
<p>​	那么的话,[A1,A2,A3…An]&#x3D;Mn</p>
<p>算术基本原理</p>
<p>任何一个数,都可以分解为唯一的素数之乘积(包考虑顺序的话)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE unsigned char</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(BYTE param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> flag[] = <span class="string">&quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">	len = <span class="built_in">strlen</span>(flag);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c:%02X &quot;</span>,flag[i],flag[i]);</span><br><span class="line">		func(flag[i]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(BYTE param)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">2</span>;<span class="comment">//2是最小的素数</span></span><br><span class="line">	<span class="keyword">while</span> (param &gt; i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (param % i == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, i);</span><br><span class="line">			param /= i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, param);<span class="comment">//最后无法分解了，则剩下的这个数就是最后一个质数因子</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">D:<span class="number">44</span> <span class="number">020211</span></span><br><span class="line"><span class="number">0</span>:<span class="number">30</span> <span class="number">0202020203</span></span><br><span class="line">g:<span class="number">67</span> <span class="number">67</span></span><br><span class="line"><span class="number">3</span>:<span class="number">33</span> <span class="number">0311</span></span><br><span class="line">&#123;:<span class="number">7B</span> <span class="number">0329</span></span><br><span class="line">R:<span class="number">52</span> <span class="number">0229</span></span><br><span class="line">G:<span class="number">47</span> <span class="number">47</span></span><br><span class="line">V:<span class="number">56</span> <span class="number">022B</span></span><br><span class="line">u:<span class="number">75</span> <span class="number">03030</span>D</span><br><span class="line">Z:<span class="number">5</span>A <span class="number">02030305</span></span><br><span class="line"><span class="number">1</span>:<span class="number">31</span> <span class="number">0707</span></span><br><span class="line">F:<span class="number">46</span> <span class="number">020507</span></span><br><span class="line"><span class="number">1</span>:<span class="number">31</span> <span class="number">0707</span></span><br><span class="line">e:<span class="number">65</span> <span class="number">65</span></span><br><span class="line">G:<span class="number">47</span> <span class="number">47</span></span><br><span class="line">l:<span class="number">6</span>C <span class="number">0202030303</span></span><br><span class="line">h:<span class="number">68</span> <span class="number">0202020</span>D</span><br><span class="line">b:<span class="number">62</span> <span class="number">020707</span></span><br><span class="line">m:<span class="number">6</span>D <span class="number">6</span>D</span><br><span class="line">c:<span class="number">63</span> <span class="number">03030B</span></span><br><span class="line">u:<span class="number">75</span> <span class="number">03030</span>D</span><br><span class="line">&#125;:<span class="number">7</span>D <span class="number">050505</span></span><br></pre></td></tr></table></figure>





<h1 id="2同余"><a href="#2同余" class="headerlink" title="2同余"></a>2同余</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>(1)</p>
<p>对于正整数m,和2个整数a,b</p>
<p>如果 m&gt;b, m|<code>a-b</code>,就有<code>a%m=b</code></p>
<p>这个结论可以理解为</p>
<p>存在k&gt;0,m&gt;b,km&#x3D;a-b,那么会有a%m&#x3D;b</p>
<p>(2)</p>
<p>规定符号≡</p>
<p>a≡b(%m)</p>
<p>意思就是 m|<code>a-b</code>,a%m&#x3D;b</p>
<p>跳过上面那个结论,我们就可以延伸</p>
<p>m∈正整数</p>
<p>自反性:a≡a(%m)</p>
<p>对称性:如果a≡b(%m) 则 b≡a(%m)</p>
<p>传递性: 如果a≡b(%m),b≡c(%m) 则 a≡c(%m)</p>
<p>(3)</p>
<p>设m为正整数,a,b,c,d为整数</p>
<p>如果a≡b(% m),c≡d(%m)</p>
<p>有 <code>a+c</code> ≡ <code>b + d</code> (%m) , ac ≡ bd (%m)</p>
<p>(4) </p>
<p>m为正整数, a,b,k 为整数,如果a≡b(%m)</p>
<p>有 <code>a + k</code> ≡ <code>b + k</code> (%m)  , ak ≡ bk(%m)</p>
<p>(5)</p>
<p>如果 a≡b(%m) ,则有 na≡nb(%m),n为正整数</p>
<p>如果 a≡b(%m) ,则有 a^n^≡b^n^(%m),</p>
<p>一些运算规则</p>
<ul>
<li><p>(a+b)%m &#x3D; (a%m + b%m)%m</p>
</li>
<li><p>(ab)%m &#x3D;( a%m x b%m ) %m</p>
</li>
<li><p>(na)%m &#x3D; n(a%m)%m</p>
</li>
<li><p>N&#x3D;N1+N2</p>
<p>那么,(NA)%m &#x3D; (N1xA%m+N2xA%m)%m</p>
<p>​	a^N^%m&#x3D;(a%m)^n^%m</p>
<p>​		&#x3D;((a%m)^N1^x(a%m)^N2^)%m</p>
</li>
</ul>
<p>(6)</p>
<p>如果m为正整数,a,b为整数,ad≡bd(%m), (d,m)&#x3D;1</p>
<p>那么a≡b(%m)</p>
<p>(7)</p>
<p>设m为正整数,a,b为整数,若a≡b(%m),且k&gt;0</p>
<p>则ak≡bk(%mk)</p>
<p>(8)</p>
<p>设m为正整数</p>
<p>a,b为整数</p>
<p>a≡b(%m)</p>
<p>d|(a,b,m)</p>
<p>d&gt;0</p>
<p>则(a&#x2F;d)≡(b&#x2F;d)%(m&#x2F;d)</p>
<p>(8)</p>
<p>设m为正整数</p>
<p>a,b为整数</p>
<p>a≡b(%m)</p>
<p>d|m</p>
<p>则a≡b(%d)</p>
<p>(9)</p>
<p>设m为正整数</p>
<p>a,b为整数</p>
<p>a≡b(%m)</p>
<p>则(a,m)&#x3D;(b,m)</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>什么叫互质,或者互为素数?</p>
<p>也就是2数,除了1以外,就没有公因数了</p>
<p>设n以内有m个和n互质的数,用符号φ(n)&#x3D;m表示那个结果</p>
<p>n和m之间不是一个一一对应的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mgcd</span><span class="params">(<span class="type">char</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>    flag[] = <span class="string">&quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;</span>;</span><br><span class="line">	<span class="type">int</span>     i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; flag[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c:%d\n&quot;</span>, flag[i], mgcd(flag[i]));</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值为1则互质</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mgcd</span><span class="params">(<span class="type">char</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> res = n, t = n;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果p为素数,有φ(p)&#x3D;p-1;</p>
<p>如果p为素数,α&gt;&#x3D;1,则φ(p^α^)&#x3D;p^α^-p^α-1^</p>
<p>如果正整数m,n 且(m,n)&#x3D;1,则φ(mn)&#x3D;φ(m)*φ(n)</p>
<p>如果整数n&#x3D;pq,其中p,q是不同的素数,则φ(n)&#x3D;(p-1)*(q-1)</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>m是大于1的整数,如果(a,m)&#x3D;1,则有a^φ(m)^≡1(%m)</p>
<h2 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h2><p>设p为素数,a为任意正整数,且a不是p的整数倍,有a^m-1^≡1(%m)</p>
<p>设a为素数,a为任意正整数,则a^p^^m-1^≡a(%p)</p>
<p>设m&gt;1是正整数,则m为素数的必要条件是:对某个a,不是m的整数倍,有a^m-1^≡1(%m)</p>
<h2 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h2><p>之前不是有个定理判断素数吗a≡b(%m)</p>
<p>现在我们的函数运算的是a^n^≡b(%m)</p>
<p>要求的结果是b为多少</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">powerModRec</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> b * powerModRec(b, n - <span class="number">1</span>, m) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">powerMod</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// a存放计算结果，初始化为1.</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i, k = <span class="number">0</span>, num = n;</span><br><span class="line">	<span class="comment">/*计算指数的二进制位数k.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">		num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		++k;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 也可以将指数的二进制用一个数组或队列存放，方便取值.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 取n的二进制的第i位，判断是否为1.</span></span><br><span class="line">		<span class="keyword">if</span> ((n &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">			a = a * b % m;</span><br><span class="line">		b = b * b % m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a, n, m;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>    flag[] = <span class="string">&quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	len = <span class="built_in">strlen</span>(flag);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b = powerMod(flag[i*<span class="number">3</span>], flag[i * <span class="number">3</span> +<span class="number">1</span>], flag[i * <span class="number">3</span> +<span class="number">2</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c^%c (mod %c) = %d\n&quot;</span>, flag[i * <span class="number">3</span>], flag[i * <span class="number">3</span> + <span class="number">1</span>], flag[i * <span class="number">3</span> + <span class="number">2</span>], b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h1><p>解一次同余方程</p>
<p>eg</p>
<h2 id="密码学中的应用"><a href="#密码学中的应用" class="headerlink" title="密码学中的应用"></a>密码学中的应用</h2><p>仿射密码算法,一个对称加密的算法,woc</p>
<p>对应</p>
<p>数组table[]&#x3D;{0,1,2,…,61,62,63},长度是64</p>
<p>选取一个公式</p>
<p>c≡k×p+b(%64) 这是一个加密的公式</p>
<p>其中</p>
<p>k满足的关系,(k,64)&#x3D;1,也就是k和64互质</p>
<p>b满足的关系,b&lt;64</p>
<p>那么解密公式的满足情况呢?</p>
<p>当然会是</p>
<p>p≡(c-b)&#x2F;p(%64)</p>
<p>但是这个1&#x2F;p不利于运算,可能不利于,会涉及小数吧</p>
<p>然后我们需要寻找一个和1&#x2F;p等价的数字,叫为逆元m</p>
<p>逆元满足的干系,p*(1&#x2F;p)≡1(%64)</p>
<p>那么p*m≡1(%64)</p>
<p>所以解密公式转化为</p>
<p>p≡(c-b)*m(%64)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//c=(37p+47)%64  //37是公钥,37是和64互质的数字</span></span><br><span class="line">	<span class="comment">//p=(c-47)*45%64 //45是私钥,45是和37互质的数字</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>	table[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyz0123456789&#123;&#125;&quot;</span>;</span><br><span class="line">	<span class="type">char</span>	flag[] = &#123; <span class="number">3</span>,<span class="number">52</span>,<span class="number">32</span>,<span class="number">55</span>,<span class="number">62</span>,<span class="number">17</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">46</span>,<span class="number">25</span>,<span class="number">53</span>,<span class="number">5</span>,<span class="number">53</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">37</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">28</span>,<span class="number">46</span>,<span class="number">63</span>, &#125;;</span><br><span class="line">	<span class="comment">//char  flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;//字符串版本</span></span><br><span class="line">	<span class="type">char</span>	encode[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span>	decode[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span>		len = <span class="keyword">sizeof</span>(flag)/<span class="keyword">sizeof</span>(flag[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span>		tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	encode[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">	decode[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加密的过程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		encode[i] = (flag[i] * <span class="number">37</span> + <span class="number">47</span>) % <span class="number">64</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//解密的过程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = (<span class="type">unsigned</span> <span class="type">int</span>)((encode[i] - <span class="number">47</span>) * <span class="number">45</span>) % <span class="number">64</span>;<span class="comment">//这个符号的处理很重要的</span></span><br><span class="line">		decode[i] = table[tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(decode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char    flag[] = &quot;D0g3&#123;RGVuZ1F1eGlhbmcu&#125;&quot;;//字符串版本</span></span><br></pre></td></tr></table></figure>







<h1 id="自己的想法"><a href="#自己的想法" class="headerlink" title="自己的想法"></a>自己的想法</h1><p>如果满足<code>a|b,b|a</code>,则b&#x3D;a或者b&#x3D;-a</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DataCheck</span><span class="params">(<span class="type">char</span>* param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> input[]=<span class="string">&quot;D0g3&#123;123&#125;&quot;</span>;</span><br><span class="line">	DataCheck(input);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">DataCheck</span><span class="params">(<span class="type">char</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> org[]=<span class="string">&quot;D0g3&#123;123&#125;&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *lp1=(<span class="type">unsigned</span> <span class="type">char</span>*)org;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *lp2=(<span class="type">unsigned</span> <span class="type">char</span>*)param;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(org);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(lp1[i]%lp2[i]&amp;&amp;lp2[i]%lp1[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;You Lose\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信安专业</category>
      </categories>
  </entry>
  <entry>
    <title>有趣的C语言</title>
    <url>/re4mile/2023/01/11/language/C/%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80/language/</url>
    <content><![CDATA[<h1 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mmsystem.h&gt;</span><span class="comment">//包含多媒体设备接口头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib,<span class="string">&quot;winmm.lib&quot;</span>)<span class="comment">//加载静态库</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//alias   的作用是取别名</span></span><br><span class="line">	mciSendString(<span class="string">&quot;open E:/0xC0de/C/2010/C1/C1/青花瓷.mp3 alias dqx &quot;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//音乐在当前目录下也可以写&quot;open ./2.mp3&quot;./这里可以省略</span></span><br><span class="line">	mciSendString(<span class="string">&quot;play dqx&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);<span class="comment">//这里没有暂停程序会直接停止听不到音乐</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值：MCIERROR即DWORD类型，而DWORD类型就是unsigned int，执行成功返回0，出错返回非0值</span></span><br><span class="line"><span class="comment">参数  :</span></span><br><span class="line"><span class="comment">1，lpstrCommand，指向以null结尾的命令字符串：”命令 设备[参数]” open 打开音乐文件 play 播放音乐 repeat 重复播放 close 关闭音乐文件</span></span><br><span class="line"><span class="comment">2，lpstrReturnString，指向接收返回信息的缓冲区，为NULL时不返回信息</span></span><br><span class="line"><span class="comment">3，uReturnLength，上述缓冲区的大小</span></span><br><span class="line"><span class="comment">4，hwndCallback，在命令串中含notify时，它指定一个回调窗口的句柄，一般为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/re4mile/2023/01/11/language/C/%E5%9F%BA%E7%A1%80/language/</url>
    <content><![CDATA[<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="参数栈"><a href="#参数栈" class="headerlink" title="参数栈"></a>参数栈</h3><p>函数传递进来的参数在栈里面的分布情况</p>
<p> <img src="https://re4mile.gitee.io/res/photo/language/image-20221214143302362.png" alt="image-20221214143302362"></p>
<h3 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * va_list;</span><br></pre></td></tr></table></figure>



<h3 id="INTSIZEOF"><a href="#INTSIZEOF" class="headerlink" title="INTSIZEOF"></a>INTSIZEOF</h3><p><code>_INTSIZEOF(n)</code>: 把 n 圆整到 sizeof(int) 的倍数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n)       ( (sizeof(n)+sizeof(int)-1) &amp; ~(sizeof(int)-1) )</span></span><br></pre></td></tr></table></figure>

<p><code>_INTSIZEOF(n)</code>整个做的事情就是将字节长度n化为int长度的整数倍</p>
<p>~(sizeof(int)-1)  &#x3D; 1111 1100</p>
<p>一个数&amp; 1111 1100 ,结果一定为4的倍数</p>
<p>然后(sizeof(n)+ 3)&amp;1111 1100</p>
<p>例如，若<code>1≤sizeof(n)≤4</code>，则<code>_INTSIZEOF(n)＝4</code>；若<code>5≤sizeof(n)≤8</code>，则<code>_INTSIZEOF(n)=8</code></p>
<p>至于如何化到整数倍,我觉得不是我们应该关心的,我我们应该关心,为什么要化到整数倍</p>
<p>答案: 方便字节对齐,然后方便指针的访问,指针直接4字节4字节的移动</p>
<p>疑惑: 可不可以不要那个方便…可以呀,如果只去掉那个方便,你的程序会g</p>
<p>因为所有的参数都是push进去的,每个参数都战4字节,哪怕传递一个char进去</p>
<p>所以你的指针只能4字节4字节的访问</p>
<h3 id="va-start"><a href="#va-start" class="headerlink" title="va_start"></a>va_start</h3><p><code>va_start(out_ap,in_v)</code></p>
<p>初始化 out_ap 指针，</p>
<p>使其指向最第一个可变参数。</p>
<p>也就是地址最低,最后push进去,最上面那个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(out_ap,in_v)      (out_ap = (char*)&amp;in_v + _INTSIZEOF(in_v)) <span class="comment">//于是就指向来了下一次参数</span></span></span><br></pre></td></tr></table></figure>

<h3 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg"></a>va_arg</h3><p><code> va_arg(in_ap, type)</code></p>
<p> 该宏返回当前变参值,并使 in_ap 指向列表中的下个变参,地址向下移动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(in_ap, type)    \</span></span><br><span class="line"><span class="meta">	( </span></span><br><span class="line">		*(type *)(</span><br><span class="line">            		(	in_ap += _INTSIZEOF(type) - _INTSIZEOF(type)	)</span><br><span class="line">        		)</span><br></pre></td></tr></table></figure>

<h3 id="va-end"><a href="#va-end" class="headerlink" title="va_end"></a>va_end</h3><p><em>va_end</em>(ap)  ,将指针 ap 置为无效，结束变参的获取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap)             ( ap = (va_list)0 )</span></span><br></pre></td></tr></table></figure>



<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如何遍历参数?</p>
<ol>
<li>设置cnt,记录有效参数个数</li>
<li>设置哨兵,-1</li>
<li>根据参数特定的标志来判断,eg: printf,scanf</li>
</ol>
<p>情况1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_valist_by_num</span><span class="params">(<span class="type">int</span> arg_cnt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    parse_valist_by_num(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数定义可变参数的个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_valist_by_num</span><span class="params">(<span class="type">int</span> arg_cnt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    va_list p_args;</span><br><span class="line">    va_start(p_args, arg_cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(idx = <span class="number">1</span>; idx &lt;= arg_cnt; ++idx)&#123;</span><br><span class="line">        val = va_arg(p_args, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个参数: %d\n&quot;</span>, idx, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">    va_end(p_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>情况2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_valist_by_flag</span><span class="params">(<span class="type">int</span> num_1, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    parse_valist_by_flag(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    parse_valist_by_flag(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义一个结束标记(-1)，调用时通过最后一个参数传递该标记，以结束变参的遍历打印。</span></span><br><span class="line"><span class="comment">//最后一个参数作为变参结束符(-1)，用于循环获取变参内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_valist_by_flag</span><span class="params">(<span class="type">int</span> num_1, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list p_args;</span><br><span class="line">    va_start(p_args, num_1);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = num_1;</span><br><span class="line">    <span class="keyword">while</span>(val != <span class="number">-1</span>)&#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个参数: %d\n&quot;</span>, idx, val);</span><br><span class="line">        val = va_arg(p_args, <span class="type">int</span>); <span class="comment">//得到下个变参值</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(p_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>情况3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">minprintf</span><span class="params">(<span class="type">char</span>* fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span>* p, * sval;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    <span class="keyword">for</span> (p = fmt; *p; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(*p);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (*++p)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            ival = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ival);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            dval = va_arg(ap, <span class="type">double</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, dval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (sval = va_arg(ap, <span class="type">char</span>*); *sval; sval++)</span><br><span class="line">                <span class="built_in">putchar</span>(*sval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">putchar</span>(*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    minprintf(<span class="string">&quot;%d %d&quot;</span>, <span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>随机生成不重复的4选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;Four_Option;i++)	<span class="comment">//之所以是1开头,是因为0已经排好了 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>												<span class="comment">//生成不重复的随机数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        Rand_Option_Flag=rand()%Num_Of_Words;</span><br><span class="line">        <span class="comment">//避免生成相同的随机数选项 </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(Option_Arr[j]==Rand_Option_Flag)								</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这里只是跳出这个小的for的循环 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i!=j);<span class="comment">//这个判断说明了它发现了存在相同的随机数 </span></span><br><span class="line">    Option_Arr[i]=Rand_Option_Flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/re4mile/2023/01/11/language/Python/%E5%9F%BA%E7%A1%80/language/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>记录一次全局变量,注意它的反汇编语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0</span>  <span class="comment"># initialize variable a</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coo</span>():</span><br><span class="line">    <span class="keyword">global</span> a  <span class="comment"># call a</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(coo())</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coo</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(coo())</span><br></pre></td></tr></table></figure>



<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>参考链接 <a href="https://blog.csdn.net/python1639er/article/details/112325519">https://blog.csdn.net/python1639er/article/details/112325519</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Li hua&quot;</span></span><br><span class="line">age = <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello %s, you are %d years old&quot;</span> % (name, age))</span><br></pre></td></tr></table></figure>



<h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h2 id="重定向示例"><a href="#重定向示例" class="headerlink" title="重定向示例"></a>重定向示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">console = sys.stdout  <span class="comment"># 备份一下文件描述符  </span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">r&quot;.\file\data.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">sys.stdout = file    <span class="comment"># 把输出重定向到文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\n&#x27;</span>+<span class="string">&#x27;java\n&#x27;</span>+<span class="string">&#x27;python&#x27;</span>)   <span class="comment"># 输出自然会送往文件</span></span><br><span class="line">sys.stdout = console  <span class="comment"># 恢复重定向</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">33</span>)  <span class="comment"># 向控制台打印33</span></span><br><span class="line"> </span><br><span class="line">console = sys.stdin   <span class="comment"># 备份一下文件描述符  </span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">r&quot;F:/input.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">sys.stdin = file  <span class="comment"># 把输入重定向到文件  </span></span><br><span class="line">mod = <span class="built_in">input</span>() <span class="comment"># 一下输入均来自文件</span></span><br><span class="line">src = <span class="built_in">input</span>()</span><br><span class="line">des = <span class="built_in">input</span>()</span><br><span class="line">size= <span class="built_in">input</span>()</span><br><span class="line">file.close() <span class="comment"># 关闭文件</span></span><br><span class="line">sys.stdin = console  <span class="comment"># 恢复重定向</span></span><br><span class="line"><span class="built_in">print</span>(mod) <span class="comment"># 打印到控制台</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(src,<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(des,<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(size,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>



<h2 id="读取文件的二进制数据"><a href="#读取文件的二进制数据" class="headerlink" title="读取文件的二进制数据"></a>读取文件的二进制数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加载测试数据</span></span><br><span class="line">fpath=<span class="string">&#x27;./data.bin&#x27;</span></span><br><span class="line">f = <span class="built_in">open</span>(fpath,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">nums=<span class="built_in">int</span>(os.path.getsize(fpath)/<span class="number">4</span>) <span class="comment"># 4 是浮点数字节</span></span><br><span class="line">data = struct.unpack(<span class="string">&#x27;f&#x27;</span>*nums,f.read(<span class="number">4</span>*nums))  <span class="comment">#注意一次只能读取一次，直接再读取会报错</span></span><br><span class="line">f.close()</span><br><span class="line">data =  np.array(data).reshape(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h1 id="强制转化"><a href="#强制转化" class="headerlink" title="强制转化"></a>强制转化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">· int(x)             将x转换为一个整数</span><br><span class="line">· float(x)           将x转换到一个浮点数</span><br><span class="line">· str(x)             将对象 x 转换为字符串</span><br><span class="line">· tuple(s)           将序列 s 转换为一个元组</span><br><span class="line">· list(s)            将序列 s 转换为一个列表</span><br><span class="line">· set(s)             将序列 s 转换为一个集合</span><br><span class="line"></span><br><span class="line">int(x [,base]) ⇒ 将x转换为一个十进制的整数</span><br><span class="line">long(x [,base]) ⇒ 将x转换为一个十进制的长整数</span><br><span class="line">float(x) ⇒ 将x转换为一个浮点数</span><br><span class="line">str(object) ⇒ 转换为字符串</span><br><span class="line">repr(object) ⇒ 转换为表达式字符串</span><br><span class="line">eval(str) ⇒ 用来计算在字符串中的有效Python表达式,并返回一个对象</span><br><span class="line">tuple(seq) ⇒ 将序列seq转换为一个元组</span><br><span class="line">list(seq) ⇒ 将序列seq转换为一个列表</span><br><span class="line">chr(x ) ⇒ 将一个整数转换为一个字符</span><br><span class="line">unichr(x ) ⇒ 将一个整数转换为Unicode字符</span><br><span class="line">ord(x ) ⇒ 将一个字符转换为它的整数值</span><br><span class="line">hex(x ) ⇒ 将一个整数转换为一个十六进制字符串</span><br><span class="line">oct(x ) ⇒ 将一个整数转换为一个八进制字符串</span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>参考链接</p>
<p><a href="https://www.cxybb.com/article/qq_43679818/86574114">https://www.cxybb.com/article/qq_43679818/86574114</a></p>
<p>struct 类型表</p>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">C Type</th>
<th align="left">Python type</th>
<th align="left">Standard size</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x</code></td>
<td align="left">pad byte</td>
<td align="left">no value</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>c</code></td>
<td align="left"><code>char</code></td>
<td align="left">string of length 1</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left"><code>signed char</code></td>
<td align="left">integer</td>
<td align="left">1</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>B</code></td>
<td align="left"><code>unsigned char</code></td>
<td align="left">integer</td>
<td align="left">1</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left"><code>_Bool</code></td>
<td align="left">bool</td>
<td align="left">1</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left"><code>short</code></td>
<td align="left">integer</td>
<td align="left">2</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>H</code></td>
<td align="left"><code>unsigned short</code></td>
<td align="left">integer</td>
<td align="left">2</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td align="left"><code>int</code></td>
<td align="left">integer</td>
<td align="left">4</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>I</code></td>
<td align="left"><code>unsigned int</code></td>
<td align="left">integer</td>
<td align="left">4</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left"><code>long</code></td>
<td align="left">integer</td>
<td align="left">4</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left"><code>unsigned long</code></td>
<td align="left">integer</td>
<td align="left">4</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left"><code>long long</code></td>
<td align="left">integer</td>
<td align="left">8</td>
<td align="left">(2), (3)</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left"><code>unsigned long long</code></td>
<td align="left">integer</td>
<td align="left">8</td>
<td align="left">(2), (3)</td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left"><code>float</code></td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left"><code>double</code></td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left"><code>char[]</code></td>
<td align="left">string</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>p</code></td>
<td align="left"><code>char[]</code></td>
<td align="left">string</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>P</code></td>
<td align="left"><code>void *</code></td>
<td align="left">integer</td>
<td align="left"></td>
<td align="left">(5), (3)</td>
</tr>
</tbody></table>
<h4 id="struct-pack"><a href="#struct-pack" class="headerlink" title="struct.pack"></a>struct.pack</h4><h4 id="struct-unpack"><a href="#struct-unpack" class="headerlink" title="struct.unpack"></a>struct.unpack</h4><h4 id="struct-calcsize"><a href="#struct-calcsize" class="headerlink" title="struct.calcsize"></a>struct.calcsize</h4><h4 id="struct-pack-into"><a href="#struct-pack-into" class="headerlink" title="struct.pack_into"></a>struct.pack_into</h4><h4 id="struct-unpack-from"><a href="#struct-unpack-from" class="headerlink" title="struct.unpack_from"></a>struct.unpack_from</h4>]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/C/language/</url>
    <content><![CDATA[<h1 id="文件示例"><a href="#文件示例" class="headerlink" title="文件示例"></a>文件示例</h1><h2 id="文件末尾"><a href="#文件末尾" class="headerlink" title="文件末尾"></a>文件末尾</h2><p>由于字符的ASCII码不可能出现 -1, 因此EOF定义为 -1 是合适的</p>
<p>当以文本形式读取文件内容, 读入的字符值等于EOF时, 表示读入的已不是正常的字符而是文件结束符</p>
<p>当以二进制形式读取文件内容, 信息都是以数值方式存在的, EOF的值可能就是所要处理的二进制文件中的信息, 此时需要用 feof() 来判断是否到达了文件结尾</p>
<p>即EOF可以作为文本文件的结束标志, 但不能作为二进制文件的结束符, feof函数既可以判断二进制文件, 又可以判断文本文件</p>
<p>文本方式在读文件时, 会将换行符号CRLF(0x0D 0x0A)全部转换成单个的0x0A, 并且当遇到结束符CTRLZ(0x1A)时, 就认为文件已经结束, </p>
<p>相应的, 写文件时, 会将所有的0x0A换成0x0D0x0A,</p>
<p> 所以, 若使用文本方式打开二进制文件时, 就很容易出现文件读不完整, 或內容不对的错误, 即使是用文本方式打开文本文件, </p>
<p>也要谨慎使用, 比如复制文件, 就不应该使用文本方式</p>
<p>Linux下带不带 “b” 是相同的</p>
<h2 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ReadFileSize</span><span class="params">(<span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">	FILE* fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;wrong open\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">	size = ftell(fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="修改文件名字"><a href="#修改文件名字" class="headerlink" title="修改文件名字"></a>修改文件名字</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//way1</span></span><br><span class="line">	rename(<span class="string">&quot;tmp.js&quot;</span>,<span class="string">&quot;tmp.exe&quot;</span>); </span><br><span class="line">	ShellExecute(<span class="literal">NULL</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;tmp.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOWNORMAL); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	//way2</span></span><br><span class="line"><span class="comment">	char cmd[]=&quot;ren  help.server tmp.exe&quot;;</span></span><br><span class="line"><span class="comment">	system(cmd);</span></span><br><span class="line"><span class="comment">	ShellExecute(NULL, &quot;open&quot;, &quot;tmp.exe&quot;, NULL, NULL, SW_SHOWNORMAL); </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="目录示例"><a href="#目录示例" class="headerlink" title="目录示例"></a>目录示例</h1><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;direct.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> filename[<span class="number">128</span>] = <span class="string">&quot;F:/linux/syscall&quot;</span>;<span class="comment">//50</span></span><br><span class="line">	<span class="keyword">if</span> (_access(filename, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_mkdir(filename);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mkdir wrong %s\n&quot;</span>, filename);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中,</p>
<p><code>_access</code>用于监测,该文件是否存在</p>
<p><code>_mkdir</code>用于创建文件</p>
<p>值得注意的是,<code>_mkdir</code>一次调用只能创建一个文件夹,也就是不能递归创建,只能多次调用</p>
<p>下面是我创建文件夹,然后往文件夹里面创建文件的一个操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;direct.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> errorCode = <span class="number">0</span>;</span><br><span class="line">	FILE* fp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> filename[<span class="number">128</span>] = <span class="string">&quot;F:/5008/Note/re4mile/source/_posts/linux/syscall/中断详讲&quot;</span>;<span class="comment">//50</span></span><br><span class="line">	<span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">if</span> (_access(filename, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_mkdir(filename);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mkdir wrong %s\n&quot;</span>, filename);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">400</span>; i += <span class="number">16</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">		<span class="built_in">memset</span>(filename + <span class="number">57</span>, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sprintf</span>(tmp, <span class="string">&quot;/%03d-%03d&quot;</span>, i, i + <span class="number">15</span>);<span class="comment">//要创建的文件夹</span></span><br><span class="line">		<span class="built_in">strcat</span>(filename, tmp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (_access(filename, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_mkdir(filename);<span class="comment">//然后创建文件夹</span></span><br><span class="line">			<span class="comment">//打开那个文件夹.在里面创建文件</span></span><br><span class="line">			<span class="built_in">strcat</span>(filename, <span class="string">&quot;/linux.md&quot;</span>);</span><br><span class="line">			fp = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (fp != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				fclose(fp);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s yes\n&quot;</span>, filename);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s no\n&quot;</span>, filename);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;mkdir wrong %s\n&quot;</span>,filename);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="一级目录扫描"><a href="#一级目录扫描" class="headerlink" title="一级目录扫描"></a>一级目录扫描</h2><p>参考链接</p>
<p><a href="https://blog.csdn.net/qq_24662747/article/details/80669627">qq_24662747</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">printDir</span><span class="params">(<span class="type">const</span>  <span class="type">char</span>* path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>   nRet = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  _<span class="title">finddata_t</span>  <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">int</span>  hnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hnd= _findfirst(path, &amp;data);     <span class="comment">// 查找文件名与正则表达式chRE的匹配第一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (hnd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nRet = (hnd &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nRet &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.attrib == _A_SUBDIR)   <span class="comment">// 如果是目录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;d:%s\n&quot;</span>, data.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;f:%s\n&quot;</span>, data.name);</span><br><span class="line">        &#125;</span><br><span class="line">        nRet = _findnext(hnd, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">    _findclose(hnd);      <span class="comment">// 关闭当前句柄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printDir(<span class="string">&quot;d:/*.*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="未命名"><a href="#未命名" class="headerlink" title="未命名"></a>未命名</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 功  能 : 打印目录path中与模式chRE匹配的所有文件明</span></span><br><span class="line"><span class="comment">// 输  入 : path - 待打印的目录</span></span><br><span class="line"><span class="comment">//          chRE - 要求匹配的正则表达式</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* chRE)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* chCurPath = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);              <span class="comment">// 当前工作目录</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;current work path: %s\n&quot;</span>, chCurPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = _chdir(path);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(path);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* newPath = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;new work path: %s\n&quot;</span>, newPath);</span><br><span class="line">	<span class="built_in">free</span>(newPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">data</span>;</span></span><br><span class="line">	<span class="type">long</span> hnd = _findfirst(chRE, &amp;data);    <span class="comment">// 查找文件名与正则表达式chRE的匹配第一个文件</span></span><br><span class="line">	<span class="comment">// 返回唯一的搜索句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hnd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(chRE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>  nRet = (hnd &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nRet &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (data.attrib == _A_SUBDIR)  <span class="comment">// 如果是目录</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;   [%s]*\n&quot;</span>, data.name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;   [%s]\n&quot;</span>, data.name);</span><br><span class="line"></span><br><span class="line">		nRet = _findnext(hnd, &amp;data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_findclose(hnd);     <span class="comment">// 关闭当前句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	chdir(chCurPath);         <span class="comment">// 切换回之前的工作目录</span></span><br><span class="line">	<span class="built_in">free</span>(chCurPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="函数-API"><a href="#函数-API" class="headerlink" title="函数| API"></a>函数| API</h1><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h4 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h4><p>读取文本到缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setbuf(FILE *stream, char *buffer)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<p>FILE *stream,  一个流</p>
<p>char *buffer 一个缓冲区</p>
<p>功能 </p>
<p>把指向流的数据显缓冲在缓冲区,然后通过fflush送到流</p>
<p>返回值</p>
<p>注意事项</p>
<p><strong>buffer</strong> – 这是分配给用户的缓冲，它的长度至少为 BUFSIZ 字节，BUFSIZ 是一个宏常量，表示数组的长度 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, buf);</span><br></pre></td></tr></table></figure>



<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buff[BUFSIZ];</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, buff);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的语句会被送达缓冲区</p>
<p>0x31,0x32,0x33,0xa,0x34,0x35,0x36,0xa,</p>
<p>然后fflush把缓冲区的数据送到流stdout</p>
<h4 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h4><p>相比较setbuf,它多了模式mode可言</p>
<p>C 库函数 <strong>int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</strong> 定义流 stream 应如何缓冲。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buffer, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>





<p>参数</p>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> – 这指定了文件缓冲的模式：</li>
</ul>
<p>关于mode</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_IOFBF</td>
<td align="left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td align="left">_IOLBF</td>
<td align="left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td align="left">_IONBF</td>
<td align="left"><strong>无缓冲</strong>：不使用缓冲。每个 I&#x2F;O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody></table>
<ul>
<li><strong>size</strong> –这是缓冲的大小，以字节为单位。</li>
</ul>
<p>功能</p>
<p>返回值</p>
<p>如果成功，则该函数返回 0，否则返回非零值。</p>
<p>和setbuf没太多的区别</p>
<h4 id="tmpfile"><a href="#tmpfile" class="headerlink" title="tmpfile"></a>tmpfile</h4><p>创建临时文件</p>
<p>以二进制更新模式(wb+)创建临时文件</p>
<p>流关闭的时候或者在程序终止的时候自动删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line"></span><br><span class="line">   fp = tmpfile();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;临时文件被创建\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 您可以在这里使用临时文件</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   ...</span></span><br><span class="line"><span class="comment">   ...</span></span><br><span class="line"><span class="comment">   ...</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="tmpnam"><a href="#tmpnam" class="headerlink" title="tmpnam"></a>tmpnam</h4><p>返回临时文件名字的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *arr)</span></span><br></pre></td></tr></table></figure>



<p>返回一个指向字符串arr的指针</p>
<p><code>arr</code>是一个字符串数组</p>
<p>参数<code>arr</code>也可以为<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* ptr;</span><br><span class="line">	<span class="type">char</span> buffer[L_tmpnam];</span><br><span class="line">	<span class="comment">//L_tmpnam = 16</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//库函数被调用1次 [0]</span></span><br><span class="line">	ptr=tmpnam(buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;临时名称 : %s\n&quot;</span>, buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;临时名称 : %s\n&quot;</span>, ptr);</span><br><span class="line">	<span class="comment">//库函数被调用2次 [1]</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;临时名称 : %s\n&quot;</span>, tmpnam(<span class="literal">NULL</span>));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>永久删除文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span><span class="comment">//里面是一个字符串罢了</span></span><br></pre></td></tr></table></figure>



<p>删除如果成功，则返回零。</p>
<p>如果错误，则返回 -1，并设置 errno。</p>
<p>另外垃圾桶找不到文件了,可以说真的删除找不到了</p>
<h4 id="clearerr"><a href="#clearerr" class="headerlink" title="clearerr"></a>clearerr</h4><p>文件错误的清理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *file_ptr)</span></span><br></pre></td></tr></table></figure>

<p>清除文件发生的错误</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><p> 重命名文件的名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *old_filename, <span class="type">const</span> <span class="type">char</span> *new_filename)</span></span><br></pre></td></tr></table></figure>

<p>const char *old_filename: 原来文件的名字</p>
<p>const char *new_filename: 新的文件名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line">   <span class="type">char</span> oldname[] = <span class="string">&quot;d:/file.txt&quot;</span>;</span><br><span class="line">   <span class="type">char</span> newname[] = <span class="string">&quot;d:/dqx.txt&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   ret = rename(oldname, newname);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(ret == <span class="number">0</span>) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;文件重命名成功&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;错误：不能重命名该文件&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果找到了”d:&#x2F;file.txt”</p>
<p>但是没有找到d:&#x2F;dqx.txt”;</p>
<p>那么源文件会被永久的删除</p>
<p>程序暂时还不会报错,正常的退出</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h4 id="ferror"><a href="#ferror" class="headerlink" title="ferror"></a>ferror</h4><p>文件获取的错误类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *file_ptr)</span></span><br></pre></td></tr></table></figure>



<p>返回文件发生错误的类型,</p>
<p>出错就返回非零的编号</p>
<p>没出错就返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( ferror(fp) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h2><p>函数说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span>  _findfirst(  <span class="type">char</span>  *filespec,  <span class="keyword">struct</span>  <span class="type">_finddata_t</span>  *fileinfo );  </span><br><span class="line"><span class="comment">// 功  能 : 提供与filespec指定入口泛式匹配的第一个文件.通常后继用_findnext（）函数来完成某泛式下的文件遍历.  </span></span><br><span class="line"><span class="comment">// 头文件 : #include &lt;io.h&gt;  </span></span><br><span class="line"><span class="comment">// 参  数 : filespec - 目标文件规范,可以包含通配符  </span></span><br><span class="line"><span class="comment">//          fileinfo - 文件信息buffer  </span></span><br><span class="line"><span class="comment">// 返回值 : 成功返回唯一的搜索句柄  </span></span><br><span class="line"><span class="comment">//          出错返回-1,且设置errno为如下值:  </span></span><br><span class="line"><span class="comment">//          ENOENT 该泛式无法匹配  </span></span><br><span class="line"><span class="comment">//          EINVAL 无效文件名  </span></span><br><span class="line"><span class="type">int</span>  _findnext(  <span class="type">long</span>  handle,  <span class="keyword">struct</span>  <span class="type">_finddata_t</span>  *fileinfo );  </span><br><span class="line"><span class="comment">// 功  能 : 按照前面_findfirst中的泛式规则，查找下一个符合该泛式的文件，并以此为依据修改fileinfo中的值  </span></span><br><span class="line"><span class="comment">// 头文件 : #include &lt;io.h&gt;  </span></span><br><span class="line"><span class="comment">// 参  数 : long handle - 搜索句柄(通常由紧靠其前的_findfirst()返回)  </span></span><br><span class="line"><span class="comment">//          fileinfo    - 文件信息buffer  </span></span><br><span class="line"><span class="comment">// 返回值 : 成功返回0  </span></span><br><span class="line"><span class="comment">//          出错返回-1</span></span><br><span class="line"><span class="type">int</span>  _findclose(  <span class="type">long</span>  handle );  </span><br><span class="line"><span class="comment">// 功  能 : 关闭搜寻句柄并释放相应资源  </span></span><br><span class="line"><span class="comment">// 头文件 : #include &lt;io.h&gt;  </span></span><br><span class="line"><span class="comment">// 参  数 : long handle - 搜索句柄(通常由紧靠其前的_findfirst()返回)  </span></span><br><span class="line"><span class="comment">// 返回值 : 成功返回0  </span></span><br><span class="line"><span class="comment">//          出错返回-1</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>文件目录处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Cpp/language/</url>
    <content><![CDATA[<p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>
<p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象</p>
<h1 id="文件流的数据类型"><a href="#文件流的数据类型" class="headerlink" title="文件流的数据类型"></a>文件流的数据类型</h1><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示&#x3D;&#x3D;读取&#x3D;&#x3D;文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示&#x3D;&#x3D;写入&#x3D;&#x3D;文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时&#x3D;&#x3D;具有 ofstream 和 ifstream 两种功能&#x3D;&#x3D;，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>
<h1 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a>open() 函数</h1><p> open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void open(const char *filename, ios::openmode mode);</span><br></pre></td></tr></table></figure>



<p>在这里，<strong>open()</strong> 成员函数的</p>
<p>第一参数指定要打开的文件的名称和位置</p>
<p>第二个参数定义文件被打开的模式。</p>
<table>
<thead>
<tr>
<th align="left">模式标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::app</td>
<td align="left">追加模式。所有写入都追加到文件末尾。append</td>
</tr>
<tr>
<td align="left">ios::ate</td>
<td align="left">文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::in</td>
<td align="left">打开文件用于读取。read</td>
</tr>
<tr>
<td align="left">ios::out</td>
<td align="left">打开文件用于写入。write</td>
</tr>
<tr>
<td align="left">ios::trunc</td>
<td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
<tr>
<td align="left">还有很多的模式,比如二进制的写入</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>您可以把以上两种或两种以上的模式结合使用。</p>
<p>例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>
<p>&#x3D;&#x3D;这是一个二进制位的操作&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream  afile;</span><br><span class="line">afile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>





<h1 id="close-函数"><a href="#close-函数" class="headerlink" title="close() 函数"></a>close() 函数</h1><p>当 C++ 程序终止时，</p>
<p>它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。</p>
<p>但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Java/language/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br></pre></td></tr></table></figure>



<p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p>
<p>public void close() throws IOException{} 类似于fclose。抛出IOException异常。</p>
<p>protected void finalize()throws IOException {} 这个方法清除与该文件的连接。</p>
<p>确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</p>
<table>
<thead>
<tr>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td>
</tr>
<tr>
<td align="left">public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td>
</tr>
<tr>
<td align="left">public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td>
</tr>
</tbody></table>
<h3 id="创建-amp-写入"><a href="#创建-amp-写入" class="headerlink" title="创建&amp;写入"></a>创建&amp;写入</h3><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/java/hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">fOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br></pre></td></tr></table></figure>

<p>建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">3</td>
<td align="left">public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。</td>
</tr>
</tbody></table>
<p>除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接：</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>**mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>
<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dirname</span> <span class="operator">=</span> <span class="string">&quot;D:/tmp/user/java/bin&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname);</span><br><span class="line">        d.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>读取目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        String s[]=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/vm&quot;</span>);<span class="comment">//路径是一个存在的</span></span><br><span class="line">        <span class="keyword">if</span> (f.isDirectory())</span><br><span class="line">        &#123;</span><br><span class="line">            s = f.list();</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/vm/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory())</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个目录&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个文件&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;d:/vm不是一个目录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>列出目录下的文件和文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ep</span> <span class="keyword">implements</span> <span class="title class_">FilenameFilter</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Ep</span>().fileShow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File f, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.java&quot;</span>);<span class="comment">//返回当前目录下以.java结尾的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileShow</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\0xC0de\\C\\2010\\C1&quot;</span>);</span><br><span class="line">        String []filename=f.list();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;filename.length;i++)</span><br><span class="line">            System.out.println(filename[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>删除目录或者文件</p>
<p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法。</p>
<p>以下代码会删除目录 **&#x2F;tmp&#x2F;java&#x2F;**，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里修改为自己的测试目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">fp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/ShareIsHappy&quot;</span>);</span><br><span class="line">        rDelete(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rDelete</span><span class="params">(File fp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        File[] files = fp.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory())</span><br><span class="line">                    rDelete(f);<span class="comment">//是目录,就进入目录,然后子文件</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f.delete();<span class="comment">//是目录为空,就删除空目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fp.delete();<span class="comment">//删除根目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h2><p>二进制写入和读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        OutputStream fpW=<span class="literal">null</span>;</span><br><span class="line">        InputStream fpR=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span> bWrite[] = &#123; <span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            fpW = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> ( x = <span class="number">0</span>; x &lt; bWrite.length; x++)</span><br><span class="line">                fpW.write(bWrite[x]); <span class="comment">// writes the bytes</span></span><br><span class="line">            fpW.close();</span><br><span class="line"></span><br><span class="line">            fpR = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">            size = fpR.available();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (x = <span class="number">0</span>; x&lt; size; x++)</span><br><span class="line">                System.out.print((<span class="type">char</span>) fpR.read() + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            fpR.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文本写入和读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fpW</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        OutputStreamWriter writer=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fpR</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        fpW=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line"></span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fpW, <span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//默认为操作系统默认编码,windows上是gbk</span></span><br><span class="line">        writer.append(<span class="string">&quot;邓渠香&quot;</span>);</span><br><span class="line">        writer.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        writer.append(<span class="string">&quot;dqx&quot;</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">        fpW.close();</span><br><span class="line"></span><br><span class="line">        fpR = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fpR, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (reader.ready())  </span><br><span class="line">            sb.append((<span class="type">char</span>) reader.read());</span><br><span class="line">        reader.close();</span><br><span class="line">        fpR.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这是一个main方法，是程序的入口：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将文件封装为一个File类的对象：</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/A/B/C/dqx.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件是否可读：&quot;</span>+f.canRead());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件是否可写：&quot;</span>+f.canWrite());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的名字：&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;上级目录：&quot;</span>+f.getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是一个目录：&quot;</span>+f.isDirectory());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是一个文件：&quot;</span>+f.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否隐藏：&quot;</span>+f.isHidden());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的大小：&quot;</span>+f.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在：&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径：&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;相对路径：&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;toString:&quot;</span>+f.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinuxC文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Linux/language/</url>
    <content><![CDATA[<h1 id="文件和IO"><a href="#文件和IO" class="headerlink" title="文件和IO"></a>文件和IO</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2</span></span><br></pre></td></tr></table></figure>

<p>导入汇编</p>
<p>下面是调用中断来printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">	msg:	.ascii <span class="string">&quot;Hello, world!\n&quot;</span>  </span><br><span class="line">	len = . - msg  </span><br><span class="line">	 </span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"> </span><br><span class="line">	movl $len,%edx </span><br><span class="line">	movl $msg,%ecx  </span><br><span class="line"> </span><br><span class="line">	movl $<span class="number">1</span>,%ebx  </span><br><span class="line">	movl $<span class="number">4</span>,%eax  </span><br><span class="line">	<span class="type">int</span> $<span class="number">0x80</span> </span><br><span class="line"> </span><br><span class="line">	movl $<span class="number">0</span>,%ebx  </span><br><span class="line">	movl $<span class="number">1</span>,%eax </span><br><span class="line">	<span class="type">int</span> $<span class="number">0x80</span>  </span><br></pre></td></tr></table></figure>

<p>在调write系统调用时</p>
<p>eax	寄存器保存着write的系统调用号4</p>
<p>ebx、ecx、edx寄存器分别保存着write系统调用需要的三个参数</p>
<p>如果用C语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len 14</span></span><br><span class="line"><span class="type">char</span> msg[<span class="number">14</span>] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	write(<span class="number">1</span>, msg, len);</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是等价的</p>
<p>notn</p>
<h2 id="I-x2F-O库函数底层原理"><a href="#I-x2F-O库函数底层原理" class="headerlink" title="I&#x2F;O库函数底层原理"></a>I&#x2F;O库函数底层原理</h2><p>fopen&#x2F;fgetc&#x2F;fputs&#x2F;fclose用到了缓冲区,在用户层</p>
<p>write&#x2F;read&#x2F;close没有用到缓冲区,每次读写都要进内核,在底层 ,慢很多,</p>
<p>fopen(3)</p>
<p>调用open(2)打开指定的文件，返回这个FILE结构体的地址。其中包含该文件的描述符(就是一个int类型的编号）、I&#x2F;O缓冲区和当前读写位置等信息，</p>
<p>fgetc(3)</p>
<p>通过传入的FILE *参数找到该文件的描述符、I&#x2F;O缓冲区和当前读写位置，</p>
<p>判断能否从I&#x2F;O缓冲区中读到下一个字符，如果能读到就直接返回该字符，</p>
<p>否则调用read(2)，把文件描述符传进去，让内核读取该文件的数据到I&#x2F;O缓冲区，然后返回下一个字符。</p>
<p>注意，对于C标准I&#x2F;O库来说，打开的文件由FILE *指针标识，</p>
<p>而对于内核来说，打开的文件由文件描述符标识，文件描述符从open系统调用获得，</p>
<p>在使用read、write、close系统调用时都需要传文件描述符</p>
<p>fputc(3)</p>
<p>判断该文件的I&#x2F;O缓冲区是否有空间再存放一个字符，</p>
<p>如果有空间则直接保存在I&#x2F;O缓冲区中并返回</p>
<p>如果I&#x2F;O缓冲区已满就调用write(2)，让内核把I&#x2F;O缓冲区的内容写回文件</p>
<p>fclose(3)</p>
<p>如果I&#x2F;O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件，</p>
<p>释放FILE结构体和I&#x2F;O缓冲区。</p>
<p>对于上面,我有一个问题,最后的I&#x2F;O缓冲区会不会写入内核?也就是缓冲区没有满的情况下?</p>
<p>答案:认真看书,你会发现,fclose的解释</p>
<p>fclose:</p>
<p>如果I&#x2F;O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件，</p>
<p>释放FILE结构体和I&#x2F;O缓冲区</p>
<p>所以,如果你不调用fclose或者close,你的数据会一直留在缓冲区,不会写入文件</p>
<p>浅谈 非缓冲区函数和缓冲区文件处理函数</p>
<ul>
<li>用Unbuffered I&#x2F;O函数每次读写都要进内核，</li>
</ul>
<p>调一个系统调用比调一个用户空间的函数要慢很多，</p>
<p>所以在用户空间开辟I&#x2F;O缓冲区还是必要的，</p>
<p>用C标准I&#x2F;O库函数就比较方便，省去了自己管理I&#x2F;O缓冲区的麻烦。</p>
<ul>
<li>用C标准I&#x2F;O库函数要时刻注意I&#x2F;O缓冲区和实际文件有可能不一致，</li>
</ul>
<p>在必要时需调用fflush(3)。fllush可以把数据写入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* fp=<span class="literal">NULL</span>;</span><br><span class="line">	fp=fopen(<span class="string">&quot;e:/q.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">		perror(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;HelloWorld&quot;</span>,fp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//看上去,我们的数据不会写入文件,其实还是写进去了</span></span><br></pre></td></tr></table></figure>



<p>关于我们为什么要fclose</p>
<p>我们知道fclose(FILE *)可以关闭文件流,但是我们偶尔也会发现似乎不加也没有什么问题.那我们还加他干嘛,那不浪费感情么(开玩笑,别当真,怕被打)</p>
<p>一.清空相关的缓冲区</p>
<p>以写文件为例,程序会先将文本信息存入缓冲区中,然后根据缓冲区刷新指令或者等缓冲区满了以后才向文件写入,那么我们如果不使用fclose()关闭流,就有可能有部分文本信息在缓冲区中没有写入到文本文件中,从而导致文本信息缺失.但是这东西看运气.</p>
<p>二.释放内存</p>
<p>我们知道,如果我们不手动关闭这个流,系统会维持打开的状态,维持当然需要消耗一定的内存资源,本着苍蝇再小也是块肉的原则当然是要把它关掉了,其实如果有很多流在使用后没有关闭,这部分内存资源也是十分可观的.</p>
<p>[</p>
<p>](<a href="https://blog.csdn.net/qq_32792307/article/details/112686052">https://blog.csdn.net/qq_32792307/article/details/112686052</a>)</p>
<h2 id="文件描述符号"><a href="#文件描述符号" class="headerlink" title="文件描述符号"></a>文件描述符号</h2><p> 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，</p>
<p>文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：</p>
<p>已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体</p>
<p><img src="https://resmile.gitee.io/blog/sysC/image-20221110115334426.png" alt="image-20221110115334426"></p>
<p>那个文件指针指向了<code>/home/akaedu/foo.txt</code></p>
<p>已打开的文件在内核中用什么结构体表示?这里暂且不提</p>
<p>用户程序不能直接访问内核中的文件描述符表，而只能使用文件描述符表的索引（即0、1、2、3这些数字），</p>
<p>这些索引就称为文件描述符,</p>
<p>这些索引是整形int,不同的索引对应了不同的文件指针?</p>
<p>当调用open打开一个文件或创建一个新文件时，内核分配一个文件描述符(一个int索引),并返回给用户程序，</p>
<p>该文件描述符表项中的指针指向新打开的文件。</p>
<p>当读写文件时，用户程序把文件描述符传给read或write，</p>
<p>内核根据文件描述符index找到相应的表项，再通过表项中的指针找到相应的文件</p>
<h2 id="open-x2F-close"><a href="#open-x2F-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><p>open函数</p>
<p>open函数可以打开或创建一个文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数1</strong></p>
<p>pathname 文件名</p>
<p><strong>参数2</strong></p>
<p>flags参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来</p>
<p><strong>必选项</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">O_RDONLY  <span class="comment">//只读模式</span></span><br><span class="line">O_WRONLY  <span class="comment">//只写模式</span></span><br><span class="line">O_RDWR    <span class="comment">//读写模式</span></span><br></pre></td></tr></table></figure>



<p><strong>可选项</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">O_APPEND   <span class="comment">//每次写操作都写入文件的末尾</span></span><br><span class="line">O_CREAT    <span class="comment">//如果指定文件不存在，则创建这个文件</span></span><br><span class="line">O_EXCL     <span class="comment">//如果要创建的文件已存在，则返回-1，并且修改errno的值</span></span><br><span class="line">O_TRUNC    <span class="comment">//如果文件存在，并且以只写/读写方式打开，则清空文件全部内容(即将其长度截短为0)</span></span><br><span class="line">O_NOCTTY   <span class="comment">//如果路径名指向终端设备，不要把这个设备用作控制终端。</span></span><br><span class="line">O_NONBLOCK <span class="comment">//如果路径名指向FIFO/块文件/字符文件，则把文件的打开和后继I/O</span></span><br></pre></td></tr></table></figure>



<p><strong>参数3</strong></p>
<p>参数mode指定文件权限</p>
<p>可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示</p>
<p>也可以是八进制数表示，比如0644表示-rw-r–r–</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;somefile&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>)</span><br></pre></td></tr></table></figure>



<p><strong>返回值：</strong></p>
<p>成功返回新分配的文件描述符，出错返回-1并设置errno</p>
<p>close函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">返回值：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span>并设置errno</span><br></pre></td></tr></table></figure>



<p>书上有一些关于mod和flag的练习,第二次做一下</p>
<h2 id="read-x2F-write"><a href="#read-x2F-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><p>和fgets和fputs很像</p>
<p>read函数从打开的设备或文件中读取数据</p>
<p>read</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">返回值：成功返回读取的字节数，出错返回<span class="number">-1</span>并设置errno，</span><br><span class="line">如果在调read之前已到达文件末尾，则这次read返回<span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>在C标准库中分别用FILE *指针stdin、stdout和stderr表示。</p>
<p>这三个文件的描述符分别是0、1、2，保存在相应的FILE结构体中。</p>
<p>头文件unistd.h中有如下的宏定义来表示这三个文件描述符	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2</span></span><br></pre></td></tr></table></figure>

<p>参数 fd 就是那个0&#x2F;1&#x2F;2</p>
<p>参数 buf 接受数据的指针</p>
<p>参数 count 打算读取的字节数</p>
<p>参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。</p>
<p>注意这个读写位置和使用C标准I&#x2F;O库时的读写位置有可能不同，这个读写位置是记在内核中的，</p>
<p>而使用C标准I&#x2F;O库时的读写位置是用户空间I&#x2F;O缓冲区中的位置。</p>
<p>比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I&#x2F;O缓冲区中，再返回第一个字节，这时</p>
<p>该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t，</p>
<p>表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。  不是在内核中读取的字节数</p>
<p>有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如</p>
<p>1). 读常规文件时，在读到count个字节之前已到达文件末尾。</p>
<p>2). 从终端设备读，通常以行为单位，读到换行符就返回了。</p>
<p>3). 从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，</p>
<p>后面socket编程部分会详细讲解</p>
<p>读取和阻塞问题</p>
<p>读常规文件通常是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回  </p>
<p>如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，</p>
<p>如果一直没有数据到达就一直阻塞在那里。</p>
<p>write</p>
<p>write函数向打开的设备或文件中写数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">返回值：成功返回写入的字节数，出错返回<span class="number">-1</span>并设置errno</span><br></pre></td></tr></table></figure>

<p>写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = read(STDIN_FILENO, buf, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;read STDIN_FILENO&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,它只读取5个字符,多的字符,会留在终端设备</p>
<p>比如输入12345pwd回车</p>
<p>于是12345被就收.pwd回车留在了stdin</p>
<p>读取完毕后,pwd回车被执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C$ ./q.elf</span><br><span class="line"><span class="number">12345</span>pwd</span><br><span class="line"><span class="number">12345</span>dqx@dqx:~/桌面/C$ pwd</span><br><span class="line">/home/dqx/桌面/C</span><br></pre></td></tr></table></figure>

<p>第一次执行q.elf的结果很正常，而第二次执行的过程有点特殊，现在分析一下：</p>
<ol>
<li>Shell进程fork一个q.elf进程，q.elf进程开始执行，而Shell进程睡眠等待q.elf进程退出。</li>
<li>q.elf调用read时睡眠等待，直到终端设备输入了换行符才从read返回，read只读走10个<br> 字符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。</li>
<li>q.elf进程打印并退出，这时Shell进程恢复运行，Shell继续从终端读取用户输入的命令，<br> 于是读走了终端设备输入缓冲区中剩下的字符pwd和换行符，把它当成一条命令解释执行，</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> fd, n;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY|O_NONBLOCK);<span class="comment">//不会阻塞</span></span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">tryagain:</span><br><span class="line">	n = read(fd, buf, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EAGAIN) </span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			write(STDOUT_FILENO, MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">			<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">		perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然不是阻塞,但是也只是跳过了阻塞,一直输出tryagain</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TIMEOUT <span class="string">&quot;timeout\n&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> fd, n, i;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY|O_NONBLOCK);<span class="comment">//不是阻塞</span></span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="comment">//等待一定的时间,等不到就算了</span></span><br><span class="line">	&#123;</span><br><span class="line">		n = read(fd, buf, <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)<span class="comment">//成功读取到一些字符串</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(errno!=EAGAIN) </span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;read wrong&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		write(STDOUT_FILENO, MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">		write(STDOUT_FILENO, MSG_TIMEOUT,<span class="built_in">strlen</span>(MSG_TIMEOUT));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>lseek和标准I&#x2F;O库的fseek函数类似，可以移动当前读写位置（或者叫偏移量)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>参数offset和whence的含义和fseek函数完全相同。只不过第一个参数换成了文件描述符。</p>
<p>和fseek一样，偏移量允许超过文件末尾，这种情况下对该文件的下一次写操作将延长文件，</p>
<p>中间空洞的部分读出来都是0</p>
<p>lseek成功时返回当前偏移量 , 失败时返回-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">off_t</span> currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>

<p>参数 offset 的含义取决于参数 whence：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果 whence 是 SEEK_SET，文件偏移量将被设置为 offset.</span><br><span class="line">2. 如果 whence 是 SEEK_CUR，文件偏移量将被设置为 当前位置 加上 offset.</span><br><span class="line">3. 如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上offset.</span><br></pre></td></tr></table></figure>



<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>用fcntl函数改变一个已打开的文件的属性，可以重新设置读、写、追加、非阻塞等标志</p>
<p>（这些标志称为File StatusFlag），而不必重新open文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>可变参数的类型和个数取决于前面的cmd参数</p>
<p>File StatusFlag里面有很多的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	flags = fcntl(STDIN_FILENO, F_GETFL);<span class="comment">//获取以及有的属性</span></span><br><span class="line">	flags |= O_NONBLOCK;</span><br><span class="line">	<span class="keyword">if</span> (fcntl(STDIN_FILENO, F_SETFL, flags) == <span class="number">-1</span>)<span class="comment">//设置属性</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	tryagain:</span><br><span class="line">	n = read(STDIN_FILENO, buf, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EAGAIN) </span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			write(STDOUT_FILENO, MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">		<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">		perror(<span class="string">&quot;read stdin&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>说一下,上面那个代码的</p>
<p>它不会阻塞read,也就是它不会给你时间输入,虽然你可以输入,但是你在那个时间片段,很难输入5个字符</p>
<p>所以他会一直循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">&quot;usage: a.out &lt;descriptor#&gt;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fcntl error for fd %d\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span>(val &amp; O_ACCMODE) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> O_RDONLY:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> O_WRONLY:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> O_RDWR:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">fputs</span>(<span class="string">&quot;invalid access mode\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;, nonblocking&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><p>感觉,这里没啥要讲的东西</p>
<p>ioctl用于向设备发控制和配置命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>d是某个设备的文件描述符。request是ioctl的命令，可变参数取决于request，</p>
<p>通常是一个指向变量或结构体的指针</p>
<p>若出错则返回-1，</p>
<p>若成功则返回其他值，</p>
<p>返回值也是取决于request</p>
<p>读取控制台窗口大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">size</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (isatty(STDOUT_FILENO) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;size)&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl TIOCGWINSZ error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d rows, %d columns\n&quot;</span>, size.ws_row, size.ws_col);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>就是把磁盘文件内存映射</p>
<p>mmap可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，</p>
<p>感觉就像MapView的那个win32的API</p>
<p>对文件的读写可以直接用指针来做而不需要read&#x2F;write函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> filedes, <span class="type">off_t</span> off)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *加载地址, <span class="type">size_t</span> 加载长度, <span class="type">int</span> 内存属性, <span class="type">int</span> 多进程访问属性, <span class="type">int</span> 文件描述符, <span class="type">off_t</span> 从文件的什么位置开始映射)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>如果addr参数为NULL，内核会选择合适的地址建立映射。</p>
<p>如果addr不是NULL，内核会选择addr之上的某个合适的地址开始映射。</p>
<p>建立映射后，真正的映射首地址通过返回值可以得到。</p>
<p>len参数是需要映射的那一部分文件的长度。</p>
<p>off参数是从文件的什么位置开始映射，必须是页大小的整数倍（在32位体系统结构上通常是4K）。</p>
<p>filedes是代表该文件的描述符</p>
<p>prot参数有四种取值：</p>
<p>PROT_EXEC 		表示映射的这一段可执行，例如映射共享库</p>
<p>PROT_READ  	表示映射的这一段可读</p>
<p>PROT_WRITE 	表示映射的这一段可写</p>
<p>PROT_NONE 	表示映射的这一段不可访问</p>
<p>flag参数有很多种取值，这里只讲两种，其它取值可查看mmap(2)</p>
<p>MAP_SHARED</p>
<p>多个进程对同一个文件的映射是共享的，一个进程对映射的内存做了修改，另一个进程也会看到这种变化。</p>
<p>MAP_PRIVATE</p>
<p>多个进程对同一个文件的映射不是共享的，一个进程对映射的内存做了修改，</p>
<p>另一个进程并不会看到这种变化，也不会真的写到文件中去。</p>
<p>如果mmap成功则返回映射首地址，</p>
<p>如果出错则返回常数MAP_FAILED。</p>
<p>当进程终止时，该进程的映射内存会自动解除，也可以调用munmap解除映射。</p>
<p>munmap成功返回0，出错返回-1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	<span class="type">int</span> fd = open(<span class="string">&quot;hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;open hello&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">6</span>, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (p == MAP_FAILED) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">0x30313233</span>;</span><br><span class="line">	munmap(p, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello文件</p>
<p>dqx is a good boy</p>
<p>执行程序后</p>
<p>3210is a good boy</p>
<p>什么????</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>I&#x2F;O库函数底层原理小节:</p>
<p>主要讲了内核和缓冲区的一个交互过程</p>
<p>文件描述符号小节</p>
<p>简单介绍了一下,进程描述表和文件描述表,进程描述表包含了文件描述表</p>
<p>而文件描述表给用户提供了文件描述符来访问进程的文件描述表,而不是直接提供文件描述表</p>
<p>open&#x2F;close&#x2F;read&#x2F;write&#x2F;lseek小节</p>
<p>简单介绍了一下函数,没有说到底层原理</p>
<p>然后说到了阻塞的问题</p>
<p>fcntl&#x2F;ioctl&#x2F;mmap小节</p>
<p>简单说了一下fcntl,就是修改一些文件描述符的属性,比如阻塞的相关属性</p>
<p>ioctl ..没怎么讲</p>
<p>mmap,可能会用的比较多把,涉及的是内存映射,但是具体怎么用,还不太知道</p>
<h1 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     DIR *dirp; </span><br><span class="line">     <span class="class"><span class="keyword">struct</span>  <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">     dirp = opendir( <span class="string">&quot;.&quot;</span> );  <span class="comment">//打开目录指针</span></span><br><span class="line">     <span class="keyword">while</span>  ((dp = readdir(dirp)) != <span class="literal">NULL</span>) </span><br><span class="line">     &#123;  <span class="comment">//通过目录指针读目录</span></span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">&quot;%s\n&quot;</span> , dp-&gt;d_name );</span><br><span class="line">     &#125;      </span><br><span class="line">     ( <span class="type">void</span> ) closedir(dirp);  <span class="comment">//关闭目录</span></span><br><span class="line">     <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Python/language/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1>]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Win32文件处理</title>
    <url>/re4mile/2023/01/11/language/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/win32/language/</url>
    <content><![CDATA[<h1 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h1><h2 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> CreateFileA(filename, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>)</span><br><span class="line"> <span class="comment">//    filename 要创建文件的名字 </span></span><br><span class="line"> <span class="comment">//    GENERIC_WRITE 覆盖重写   </span></span><br><span class="line"> 	</span><br><span class="line">hFile = CreateFileA(filename, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//创建了一个文件</span></span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateFile error.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h2 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h2><p>将数据写入指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE       hFile, <span class="comment">//一个文件的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPCVOID      lpBuffer, <span class="comment">//指向将写入文件的 数据缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nNumberOfBytesToWrite, <span class="comment">//要写入数据的字节数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPDWORD      lpNumberOfBytesWritten, <span class="comment">//实际写入文件的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteFile(hFile, sz_tmp, strlen(sz_tmp), NULL, NULL);</span><br><span class="line">//hFile是CreateFile返回的句柄</span><br><span class="line">//sz_tmp是写入的数据的指针</span><br><span class="line">//strlen(sz_tmp)写入的长度</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>win32</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/re4mile/2023/01/11/language/Cpp/%E5%9F%BA%E7%A1%80/language/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法和数据结构基础篇</title>
    <url>/re4mile/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80/pc/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>用一张图就可以很好的说明插入排序的一个过程</p>
<p>但是不同于我们平时打扑克牌插入排序</p>
<p>我们得从第i张牌,拿着[0,i-1]的牌和第i张牌做一个比较</p>
<p>而不是一个双向的比较过程</p>
<p><img src="https://re4mile.gitee.io/res/photo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20221204151545277.png" alt="image-20221204151545277"></p>
<blockquote>
<p>非递归 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insertion_sort</span><span class="params">(mType* Arr,bType len)</span></span><br><span class="line">&#123;</span><br><span class="line">	mType tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">2</span>)<span class="comment">//没有比较的必要</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// &quot;0489351762&quot;;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)<span class="comment">//每次插入都可以保证前面的牌是正确的顺序</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = Arr[i];</span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Arr[j] &lt;tmp)<span class="comment">//发现找到数据了,就不再遍历</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//就是为了找到那个比自己小的牌,然后插在它的后面</span></span><br><span class="line">			&#125;</span><br><span class="line">			Arr[j + <span class="number">1</span>] = Arr[j];<span class="comment">//一直比较,数据一直后移动的过程</span></span><br><span class="line">		&#125;</span><br><span class="line">		Arr[j + <span class="number">1</span>] = tmp;<span class="comment">//主要是为了找到正确的位置j,然后把我们的的牌插在后面</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	mType resmile[] = <span class="string">&quot;0489351762&quot;</span>;</span><br><span class="line">	Insertion_sort(resmile, <span class="built_in">strlen</span>((<span class="type">char</span>*)resmile));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="分治算法-归并排序"><a href="#分治算法-归并排序" class="headerlink" title="分治算法-归并排序"></a>分治算法-归并排序</h3><p>分治模式在每层递归时都有三个步骤:</p>
<p><strong>分解</strong>原问题为若干子问题，这些子问题是原问题的规模较小的实例。</p>
<p><strong>解决</strong>这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。</p>
<p><strong>合并</strong>这些子问题的解成原问题的解。</p>
<p>归并排序算法完全遵循分治模式。</p>
<p>直观上其操作如下:</p>
<p><strong>分解</strong>:分解待排序的n个元素的序列成各具n&#x2F;2个元素的两个子序列。</p>
<p><strong>解决</strong>:使用归并排序递归地排序两个子序列。</p>
<p><strong>合并</strong>:合并两个已排序的子序列以产生已排序的答案。</p>
<p>当待排序的序列长度为1时，递归<strong>“开始回升”</strong>，在这种情况下不要做任何工作，因为长度为1的每个序列都已排好序。</p>
<p>其实就是一个不断的1&#x2F;2的过程,然后排序</p>
<p>说一下这个原理</p>
<p>假设有2堆扑克牌,是已经排好序的</p>
<p>我们把2堆扑克牌最顶上2张比较,然后抽出较小的放在第三堆</p>
<p>然后继续比较刚才2堆,继续把较小的放在底三堆</p>
<p>一直比较抽出到其中一堆没有牌比较为止</p>
<p><img src="https://re4mile.gitee.io/res/photo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20221204151719592.png" alt="image-20221204151719592"></p>
<p>下面分别用循环和递归实现,排序2个有序队列用的是相同的</p>
<p><code>void Merge(mType* nums, bType start, bType mid, bType end);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType unsigned char</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_XH</span><span class="params">(mType* nums, bType length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_DG</span><span class="params">(mType* nums, bType start,bType End)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(mType* nums, bType start, bType mid, bType end)</span>;</span><br><span class="line">bType <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	mType a[] = &#123; <span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1,7,2 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1,7, &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4,0,1 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4,0&#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4&#125;;</span></span><br><span class="line">	len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	MergeSort_DG(a, <span class="number">0</span>,len);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//num	-- 待排序的数组</span></span><br><span class="line"><span class="comment">//start -- 排序的起点</span></span><br><span class="line"><span class="comment">//end	-- 排序的终点,</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_DG</span><span class="params">(mType* Arr, bType start, bType end)</span> </span><br><span class="line">&#123;</span><br><span class="line">	bType mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断起点是否小于终点</span></span><br><span class="line">	<span class="keyword">if</span> (end - start &lt; <span class="number">2</span>) <span class="comment">//成员只有0,1个的时候,就不再排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//进行分割操作</span></span><br><span class="line">	mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	MergeSort_DG(Arr, start, mid);<span class="comment">//0-4</span></span><br><span class="line">	MergeSort_DG(Arr, mid, end);<span class="comment">//4-7</span></span><br><span class="line">	<span class="comment">//归并两个子列</span></span><br><span class="line">	Merge(Arr, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arr -- 待排序数组</span></span><br><span class="line"><span class="comment">//len -- 数组长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_XH</span><span class="params">(mType* Arr, bType len)</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	bType j = <span class="number">0</span>;</span><br><span class="line">	bType Length_of_Compare = <span class="number">0</span>;</span><br><span class="line">	bType Begin1 = <span class="number">0</span>, Begin2 = <span class="number">0</span>, EndFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span>)<span class="comment">//i的2次方,对拥有2的幂次方个数值的小组进行两两合并</span></span><br><span class="line">	&#123;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j + <span class="number">2</span> * i &lt;= len)<span class="comment">//因为是终点,所以会&lt;=判断</span></span><br><span class="line">		&#123;</span><br><span class="line">			j += <span class="number">2</span> * i;</span><br><span class="line">			Begin1 = j - <span class="number">2</span> * i;					<span class="comment">//j+[0,i)</span></span><br><span class="line">			Begin2 = j - i;				<span class="comment">//j+[i,2*i)</span></span><br><span class="line">			EndFlag = j + <span class="number">0</span>;									<span class="comment">//总长度[0,2*i)</span></span><br><span class="line">			Merge(Arr, Begin1, Begin2, EndFlag);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//剩下1,2</span></span><br><span class="line">		<span class="keyword">if</span> (j + i &lt; len)<span class="comment">//如果有剩余的,看看有没有和它匹配的</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			Begin1 = j + <span class="number">0</span>;<span class="comment">//起点的一半</span></span><br><span class="line">			Begin2 = j + i;<span class="comment">//另外一半</span></span><br><span class="line">			EndFlag = len;</span><br><span class="line">			Merge(Arr, Begin1, Begin2, EndFlag);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(mType* Arr, bType Start1, bType Start2, bType End)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//需要一个临时数组来存放排序好的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对分割数列进行归并</span></span><br><span class="line">	bType i = Start1;</span><br><span class="line">	bType j = Start2;</span><br><span class="line">	bType Max1 = Start2;</span><br><span class="line">	bType Max2 = End;</span><br><span class="line"></span><br><span class="line">	bType k = <span class="number">0</span>;</span><br><span class="line">	bType len = <span class="number">0</span>;</span><br><span class="line">	mType* ArrTmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	len = End - Start1;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		ArrTmp = (mType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(mType) * len);</span><br><span class="line">	&#125; <span class="keyword">while</span> (!ArrTmp);</span><br><span class="line">	<span class="built_in">memset</span>(ArrTmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mType) * len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//从两个子序列中取出数据放入临时数组</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; Max1 &amp;&amp; (Arr[i] &lt; Arr[j] || j == Max2))</span><br><span class="line">		&#123;</span><br><span class="line">			ArrTmp[k] = Arr[i];<span class="comment">//把小的那个拿出来</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ArrTmp[k] = Arr[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将临时数组的值重现赋给数组</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">char</span>*)Arr + Start1, ArrTmp, len * <span class="keyword">sizeof</span>(mType));</span><br><span class="line">	<span class="comment">//释放临时数组</span></span><br><span class="line">	<span class="built_in">free</span>(ArrTmp);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>书上说他是一个比较流行但是垃圾的算法,原理是反复交换相邻的未按给定次序排列的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType unsigned char</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_Sort</span><span class="params">(mType* dw_Arr, bType len)</span>;</span><br><span class="line">bType <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	mType a[] = &#123; <span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1,7,2 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1,7, &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 0,4,8,9,3,5,1 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4,0,1 &#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4,0&#125;;</span></span><br><span class="line">	<span class="comment">//mType a[] = &#123; 4&#125;;</span></span><br><span class="line">	len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    Bubble_Sort(a,len);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_Sort</span><span class="params">(mType* dw_Arr,bType len)</span></span><br><span class="line">&#123;</span><br><span class="line">    bType i = <span class="number">0</span>;</span><br><span class="line">    bType j = <span class="number">0</span>;</span><br><span class="line">    mType dw_tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dw_Arr[j] &gt; dw_Arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dw_tmp = dw_Arr[j];</span><br><span class="line">                dw_Arr[j] = dw_Arr[j + <span class="number">1</span>];</span><br><span class="line">                dw_Arr[j + <span class="number">1</span>] = dw_tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p><img src="https://re4mile.gitee.io/res/photo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20221204173604526.png" alt="image-20221204173604526"></p>
<p>比如地图如图所示,其中有很多的0,我们不记录,只记录关键的数据</p>
<p>然后我们可以类似的做出下面的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Valid_Values</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">    bType x;<span class="comment">//记录有效数据的x坐标</span></span><br><span class="line">    bType y;<span class="comment">//记录有效数据的y坐标</span></span><br><span class="line">    bType data;<span class="comment">//记录有效数据的值</span></span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">head_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    bType cnt_row;<span class="comment">//记录有几行</span></span><br><span class="line">    bType cnt_col;<span class="comment">//记录有几列</span></span><br><span class="line">    bType cnt_Values;<span class="comment">//记录有几个有效数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SparseArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">head_info</span> <span class="title">headinfo_</span>;</span><span class="comment">//描述了稀疏矩阵的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Valid_Values</span>* <span class="title">lp_data</span>;</span><span class="comment">//指向有效数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType  long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType  char</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	bType	row;<span class="comment">//行</span></span><br><span class="line">	bType	col;<span class="comment">//列</span></span><br><span class="line">	bType	cnt;<span class="comment">//多少个数据</span></span><br><span class="line">	bType* Data;<span class="comment">//具体数据(x,y)</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	SparseMap()</span><br><span class="line">	&#123;</span><br><span class="line">		row = <span class="number">0</span>;</span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SparseMap(bType In_Row, bType In_Col)</span><br><span class="line">	&#123;</span><br><span class="line">		row = In_Row;</span><br><span class="line">		col = In_Col;</span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~SparseMap()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Data)</span><br><span class="line">			<span class="built_in">free</span>(Data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">InitMap</span><span class="params">(bType* In_Arr, bType In_len)</span>;<span class="comment">//当作一个二维数组来算</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">ShowMap</span><span class="params">()</span>;<span class="comment">//输出稀疏矩阵</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SparseMap::InitMap</span><span class="params">(bType* In_Arr, bType In_len)</span><span class="comment">//当作一个二维数组来算</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i = <span class="number">0</span>, local_row = <span class="number">0</span>, local_col = <span class="number">0</span>;</span><br><span class="line">	Data = <span class="number">0</span>;</span><br><span class="line">	cnt = In_len;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Data = (bType*)<span class="built_in">malloc</span>(In_len * <span class="number">3</span> * <span class="keyword">sizeof</span>(bType));</span><br><span class="line">	&#125; <span class="keyword">while</span> (!Data);</span><br><span class="line">	<span class="built_in">memset</span>(Data, <span class="number">0</span>, In_len * <span class="number">3</span> * <span class="keyword">sizeof</span>(bType));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; In_len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		local_row = *(In_Arr + <span class="number">2</span> * i + <span class="number">0</span>);</span><br><span class="line">		local_col = *(In_Arr + <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">		*(Data + <span class="number">3</span> * i + <span class="number">0</span>) = local_row;</span><br><span class="line">		*(Data + <span class="number">3</span> * i + <span class="number">1</span>) = local_col;</span><br><span class="line">		*(Data + <span class="number">3</span> * i + <span class="number">2</span>) = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SparseMap::ShowMap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i = <span class="number">0</span>, j = <span class="number">0</span>, local_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (local_cnt &lt; cnt &amp;&amp; (i == *(Data + <span class="number">3</span> * local_cnt + <span class="number">0</span>)) &amp;&amp; (j == *(Data + <span class="number">3</span> * local_cnt + <span class="number">1</span>)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, *(Data + <span class="number">3</span> * local_cnt + <span class="number">2</span>));</span><br><span class="line">				local_cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	class SparseMap <span class="title function_">local_SparseMap</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span>;</span><br><span class="line">	bType Data[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>, &#125;;</span><br><span class="line">	local_SparseMap.InitMap(Data, <span class="number">5</span>);</span><br><span class="line">	local_SparseMap.ShowMap();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>置于地图如何转化为稀疏矩阵,我就不再多写</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType char</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	bType First;</span><br><span class="line">	bType Last;</span><br><span class="line">	bType Max;</span><br><span class="line">	bType cnt = <span class="number">0</span>;</span><br><span class="line">	bType *Data;<span class="comment">//0不用于存放,用于计数</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	ArrQueue()</span><br><span class="line">	&#123;</span><br><span class="line">		First	= <span class="number">0</span>;<span class="comment">//指向当前那个</span></span><br><span class="line">		Last	= <span class="number">0</span>;<span class="comment">//指向当前那个</span></span><br><span class="line">		Data	= <span class="number">0</span>;</span><br><span class="line">		Max = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ArrQueue(bType In_Length)</span><br><span class="line">	&#123;</span><br><span class="line">		First	= <span class="number">0</span>;</span><br><span class="line">		Last	= <span class="number">0</span>;</span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		Max = In_Length;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			Data = (bType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(mType) * In_Length);</span><br><span class="line">		&#125; <span class="keyword">while</span> (!Data);</span><br><span class="line">		<span class="built_in">memset</span>(Data, <span class="number">0</span>, <span class="keyword">sizeof</span>(mType) * In_Length);</span><br><span class="line">	&#125;</span><br><span class="line">	~ArrQueue()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(Data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mType <span class="title function_">in</span><span class="params">(mType qValue)</span>;</span><br><span class="line">	mType <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">mType <span class="title function_">ArrQueue::in</span><span class="params">( mType In_Value)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cnt != Max)</span><br><span class="line">	&#123;</span><br><span class="line">		*((mType*)Data + Last) = In_Value;</span><br><span class="line">		cnt++;</span><br><span class="line">		Last = (Last + <span class="number">1</span>) % Max;</span><br><span class="line">		<span class="keyword">return</span> In_Value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">mType <span class="title function_">ArrQueue::out</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 </span><br><span class="line">	mType local_Ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		local_Ret = *((mType*)Data + First);</span><br><span class="line">		*((mType*)Data + First) = <span class="number">0</span>;</span><br><span class="line">		cnt--;</span><br><span class="line">		First = (First + <span class="number">1</span>) % Max;</span><br><span class="line">		<span class="keyword">return</span> 	local_Ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ArrQueue::show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n--------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, *((mType*)Data + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n--------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	class ArrQueue <span class="title function_">local_ArrQueue</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	local_ArrQueue.out();</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">	local_ArrQueue.out();</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">	local_ArrQueue.in(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">	local_ArrQueue.show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>代码报告:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要你去delete,它自己会有比较好的内存灰色机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	mType Data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">	LinkNode()</span><br><span class="line">	&#123;</span><br><span class="line">		next = <span class="number">0</span>;</span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkNode(mType In_Data)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		next = <span class="number">0</span>;</span><br><span class="line">		Data = In_Data;</span><br><span class="line">	&#125;</span><br><span class="line">	~LinkNode()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;Die\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNodeAdmin</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	bType cnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>		<span class="title">Head</span>;</span></span><br><span class="line">public:</span><br><span class="line">	LinkNodeAdmin()</span><br><span class="line">	&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		Head.Data = <span class="number">0</span>;</span><br><span class="line">		Head.next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~LinkNodeAdmin()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp1</span> =</span> <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp2</span> =</span> <span class="number">0</span>;</span><br><span class="line">		tmp1 = Head.next;</span><br><span class="line">		<span class="keyword">while</span> (tmp1)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp2 = tmp1-&gt;next;</span><br><span class="line">			delete tmp1;</span><br><span class="line">			tmp1 = tmp2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	bType				<span class="title function_">Add</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	bType				<span class="title function_">AddByOrder</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">Display_in_reverse_order</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">struct</span> LinkNode*	<span class="title function_">Find</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	bType				<span class="title function_">Update</span><span class="params">(<span class="keyword">struct</span> LinkNode*, <span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	bType				<span class="title function_">De1ete</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	<span class="keyword">struct</span>	LinkNode*	<span class="title function_">GetIndex</span><span class="params">(bType)</span>;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">ReverseLintList</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line">bType					<span class="title function_">LinkNodeAdmin::Add</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_LinkNode)</span><span class="comment">//不会有检测相同元素的功能</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">	tmp = &amp;Head;</span><br><span class="line">	<span class="keyword">while</span> (tmp-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp-&gt;next = In_LinkNode;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">bType					<span class="title function_">LinkNodeAdmin::AddByOrder</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_LinkNode)</span><span class="comment">//不会有检测相同元素的功能</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">	tmp = &amp;Head;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//我的终止 1.遍历到最后,导致如果我么有</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(tmp-&gt;next))<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (In_LinkNode-&gt;Data &lt; tmp-&gt;next-&gt;Data)<span class="comment">//找到下一个比我大的</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	In_LinkNode-&gt;next = tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next = In_LinkNode;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span>	LinkNode* <span class="title function_">LinkNodeAdmin::Find</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_LinkNode)</span><span class="comment">//直接对已有的数据修改,而不是查找编号什么的</span></span><br><span class="line">&#123;</span><br><span class="line">	bType flag = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> &amp;Head;</span><br><span class="line">	<span class="keyword">while</span> (cnt)<span class="comment">//链表是否为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(tmp-&gt;next))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//已经遍历完链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;next-&gt;Data == In_LinkNode-&gt;Data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//找到</span></span><br><span class="line">			delete In_LinkNode;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据flag 判断是否找到要修改的节点</span></span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//tmp-&gt;Data = In_LinkNode-&gt;Data;</span></span><br><span class="line">		<span class="comment">//返回上一个节点,更加利于后续操作</span></span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//没有找到</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没有找到 %c 数据\n&quot;</span>, In_LinkNode-&gt;Data);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bType					<span class="title function_">LinkNodeAdmin::De1ete</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Target_LinkNode)</span><span class="comment">//我需要找到它的前驱</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp1</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp2</span> =</span> <span class="number">0</span>;</span><br><span class="line">	tmp1 = Find(In_Target_LinkNode);<span class="comment">//返回的是目标的上一个结点</span></span><br><span class="line">	<span class="keyword">if</span> (tmp1)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp2 = tmp1-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (tmp2)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp2 = tmp2-&gt;next;<span class="comment">//防止只有2个节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		delete(tmp1-&gt;next);</span><br><span class="line">		tmp1-&gt;next = tmp2;</span><br><span class="line">		cnt--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没有找到数据\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bType					<span class="title function_">LinkNodeAdmin::Update</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Target_LinkNode, <span class="keyword">struct</span> LinkNode* In_LinkNode_src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (De1ete(In_Target_LinkNode))<span class="comment">//可能会delete失败,因为自带find</span></span><br><span class="line">	&#123;</span><br><span class="line">		AddByOrder(In_LinkNode_src);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没有找到数据\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span>					LinkNode* <span class="title function_">LinkNodeAdmin::GetIndex</span><span class="params">(bType In_Index)</span><span class="comment">//输入负数就是倒数第几个</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> &amp;Head;</span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	bType flag = <span class="number">0</span>;</span><br><span class="line">	bType max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (In_Index &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		In_Index++;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">		In_Index = <span class="number">0</span> - In_Index;</span><br><span class="line">		max = cnt - In_Index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		In_Index--;</span><br><span class="line">		max = In_Index + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (In_Index &gt;= <span class="number">0</span> &amp;&amp; In_Index &lt; cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>					<span class="title function_">LinkNodeAdmin::Show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> &amp;Head;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, tmp-&gt;Data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>					<span class="title function_">LinkNodeAdmin::ReverseLintList</span><span class="params">()</span><span class="comment">//必须要自己画图去过一遍</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>*	<span class="title">MyHeadA</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>	<span class="title">MyHeadB</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>*	<span class="title">next</span> =</span> <span class="number">0</span>;	</span><br><span class="line">	</span><br><span class="line">	MyHeadA = Head.next;</span><br><span class="line">	<span class="keyword">if</span> (Head.next == <span class="number">0</span> || Head.next-&gt;next==<span class="number">0</span>)<span class="comment">//如果前面一个成立，后面就不需要判断了,也就不会出现那种什么0-&gt;next了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (MyHeadA) </span><br><span class="line">	&#123;</span><br><span class="line">		next			= MyHeadA-&gt;next;	<span class="comment">//为什么会有next=xx，因为下面会修改 cur-&gt;next，作用主要是备份数据</span></span><br><span class="line">		MyHeadA-&gt;next	= MyHeadB.next;	 <span class="comment">//</span></span><br><span class="line">		MyHeadB.next	= MyHeadA;</span><br><span class="line">		MyHeadA			= next;			</span><br><span class="line">	&#125;</span><br><span class="line">	Head.next = MyHeadB.next;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>					<span class="title function_">LinkNodeAdmin::Display_in_reverse_order</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//可以用栈的思想,但是用栈的话,开销也不小,所以我自己就new了一个数组,然后用数组去逆序的打印呗</span></span><br><span class="line">	<span class="comment">//他的cnt告诉了我要new多少个</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>** <span class="title">Arr</span> =</span> new <span class="keyword">struct</span>	LinkNode* [cnt];<span class="comment">//这个是数组装的是指针,装的是*,所以自己是**</span></span><br><span class="line"></span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> Head.next;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Arr[i] = tmp;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = cnt<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, Arr[i]-&gt;Data);</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] Arr;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">LinkNodeAdmin</span> <span class="title">local_LinkTable</span>;</span></span><br><span class="line">	<span class="comment">//add之类的,new后会继续使用</span></span><br><span class="line">	<span class="comment">//find的,</span></span><br><span class="line"></span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	local_LinkTable.AddByOrder(new LinkNode(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">	<span class="comment">//local_LinkTable.GetIndex(0);</span></span><br><span class="line">	<span class="comment">//local_LinkTable.Show();</span></span><br><span class="line">	<span class="comment">//local_LinkTable.ReverseLintList();</span></span><br><span class="line">	<span class="comment">//local_LinkTable.Show();</span></span><br><span class="line">	local_LinkTable.Display_in_reverse_order();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bType long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要你去delete,它自己会有比较好的内存灰色机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>*	<span class="title">Previous</span>;</span></span><br><span class="line">	mType				Data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>*	<span class="title">Next</span>;</span></span><br><span class="line">	LinkNode()</span><br><span class="line">	&#123;	</span><br><span class="line">		Previous = <span class="number">0</span>;</span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		Next = <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	LinkNode(mType In_Data)</span><br><span class="line">	&#123;</span><br><span class="line">		Previous = <span class="number">0</span>;</span><br><span class="line">		Data = In_Data;</span><br><span class="line">		Next = <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	~LinkNode()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;Die\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNodeAdmin</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">//增加删除修改查找</span></span><br><span class="line">private:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>		<span class="title">Head</span>;</span>			<span class="comment">//因为是一个环形的,所以从具体的意义上来说是分不清谁是头谁是尾,但是我们必须设置一个头尾</span></span><br><span class="line">	bType				cnt;			<span class="comment">//为了方便,我们仍然会去计数一下</span></span><br><span class="line"></span><br><span class="line">public :</span><br><span class="line">	LinkNodeAdmin()</span><br><span class="line">	&#123;</span><br><span class="line">		cnt				= <span class="number">0</span>;</span><br><span class="line">		Head.Data		= <span class="number">0</span>;</span><br><span class="line">		Head.Previous	= &amp;Head;</span><br><span class="line">		Head.Next		= &amp;Head;</span><br><span class="line">	&#125;</span><br><span class="line">	~LinkNodeAdmin()</span><br><span class="line">	&#123;</span><br><span class="line">		bType i = <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp1</span> =</span> Head.Next;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp2</span> =</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp2 = tmp1-&gt;Next;</span><br><span class="line">			delete tmp1;</span><br><span class="line">			tmp1 = tmp2;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">Add</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	<span class="type">void</span>				<span class="title function_">AddByOrder</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	<span class="keyword">struct</span> LinkNode*	<span class="title function_">Find</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	bType				<span class="title function_">De1ete</span><span class="params">(<span class="keyword">struct</span> LinkNode*)</span>;</span><br><span class="line">	bType				<span class="title function_">Update</span><span class="params">(<span class="keyword">struct</span> LinkNode*, <span class="keyword">struct</span> LinkNode* )</span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LinkNodeAdmin::Add</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Node)</span><span class="comment">//插在哪里?我们是不需要遍历的,因为我们可以通过头结点知道最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//直接插,插的话,不需要知道还有几个</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">Tail</span> =</span> Head.Previous;</span><br><span class="line">	Head.Previous = In_Node;</span><br><span class="line">	Tail-&gt;Next = In_Node;</span><br><span class="line">	In_Node-&gt;Previous = Tail;</span><br><span class="line">	In_Node-&gt;Next = &amp;Head;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LinkNodeAdmin::AddByOrder</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> Head.Next;<span class="comment">//</span></span><br><span class="line">	<span class="comment">//涉及一个比较的过程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">local_pre</span> =</span><span class="number">0</span> ;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;Data &gt; In_Node-&gt;Data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//我们要找的就是这个比自己大的,我们要插在他前面</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有一种情况,我要插在Head的后面</span></span><br><span class="line">	local_pre = tmp-&gt;Previous;</span><br><span class="line">	local_pre-&gt;Next = In_Node;</span><br><span class="line">	tmp-&gt;Previous	= In_Node;</span><br><span class="line">	In_Node-&gt;Previous = local_pre;</span><br><span class="line">	In_Node-&gt;Next = tmp;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LinkNodeAdmin::Show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> Head.Next;<span class="comment">//</span></span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, tmp-&gt;Data);</span><br><span class="line">		tmp = tmp-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> LinkNode* <span class="title function_">LinkNodeAdmin::Find</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Node)</span></span><br><span class="line">&#123;</span><br><span class="line">	bType i = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> Head.Next;</span><br><span class="line">	<span class="keyword">if</span> (In_Node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp-&gt;Data == In_Node-&gt;Data)</span><br><span class="line">			&#123;</span><br><span class="line">				delete In_Node;</span><br><span class="line">				<span class="keyword">return</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp = tmp-&gt;Next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete In_Node;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bType		<span class="title function_">LinkNodeAdmin::De1ete</span><span class="params">(<span class="keyword">struct</span> LinkNode* In_Node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">local_pre</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">local_next</span> =</span> <span class="number">0</span>;</span><br><span class="line">	tmp = Find(In_Node);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		local_pre = tmp-&gt;Previous;</span><br><span class="line">		local_next = tmp-&gt;Next;</span><br><span class="line">		delete tmp;</span><br><span class="line">		local_pre-&gt;Next = local_next;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//然后删除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bType		<span class="title function_">LinkNodeAdmin::Update</span><span class="params">(<span class="keyword">struct</span> LinkNode* Target, <span class="keyword">struct</span> LinkNode* rep)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (De1ete(Target))<span class="comment">//自带find,所以一避免多次delete</span></span><br><span class="line">	&#123;</span><br><span class="line">		AddByOrder(rep);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">LinkNodeAdmin</span> <span class="title">local_LinkNodeAdmin</span>;</span></span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;G&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">	local_LinkNodeAdmin.AddByOrder(new LinkNode(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	<span class="comment">//local_LinkNodeAdmin.De1ete(new LinkNode(&#x27;B&#x27;));</span></span><br><span class="line">	<span class="comment">//local_LinkNodeAdmin.Show();</span></span><br><span class="line">	local_LinkNodeAdmin.Update(new LinkNode(<span class="string">&#x27;E&#x27;</span>), new LinkNode(<span class="string">&#x27;X&#x27;</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/%E5%B0%8F%E7%BB%93/language/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.shuzhiduo.com/topic/win32%e6%b1%87%e7%bc%96%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad/">https://www.shuzhiduo.com/topic/win32%e6%b1%87%e7%bc%96%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad/</a></p>
<p><a href="https://liuzhian.github.io/2018/07/28/%E6%B1%87%E7%BC%96-INT21h%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">https://liuzhian.github.io/2018/07/28/%E6%B1%87%E7%BC%96-INT21h%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</a></p>
<p><a href="https://blog.csdn.net/yyxhhx/article/details/24190915">https://blog.csdn.net/yyxhhx/article/details/24190915</a></p>
<p><a href="https://blog.csdn.net/ttzyanswer/article/details/2049175">https://blog.csdn.net/ttzyanswer/article/details/2049175</a></p>
<p><a href="https://wenku.baidu.com/view/11ceaae54328915f804d2b160b4e767f5bcf804d.html?_wkts_=1672367915748">https://wenku.baidu.com/view/11ceaae54328915f804d2b160b4e767f5bcf804d.html?_wkts_=1672367915748</a></p>
]]></content>
  </entry>
  <entry>
    <title>ctype.h</title>
    <url>/re4mile/2023/01/11/language/C/%E5%BA%93%E5%87%BD%E6%95%B0/ctype/language/</url>
    <content><![CDATA[<h1 id="isprint-检测是否可打印"><a href="#isprint-检测是否可打印" class="headerlink" title="isprint 检测是否可打印"></a>isprint 检测是否可打印</h1><p>空格也可以打印</p>
<blockquote>
<p>  int isprint(int ASCII)</p>
</blockquote>
<p>可打印返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isprint</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! &quot; # $ % &amp; &#x27; ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z &#123; | &#125; ~</span><br></pre></td></tr></table></figure>



<h1 id="isgraph-检测是否有图形表示-空格除外"><a href="#isgraph-检测是否有图形表示-空格除外" class="headerlink" title="isgraph 检测是否有图形表示(空格除外)"></a>isgraph 检测是否有图形表示(空格除外)</h1><blockquote>
<p>  int isgraph(int ASCII)</p>
</blockquote>
<p>可打印返回非零(空格除外)</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isgraph</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! &quot; # $ % &amp; &#x27; ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z &#123; | &#125; ~</span><br></pre></td></tr></table></figure>



<h1 id="isalnum-检测是否是数字或者字母"><a href="#isalnum-检测是否是数字或者字母" class="headerlink" title="isalnum 检测是否是数字或者字母"></a>isalnum 检测是否是数字或者字母</h1><blockquote>
<p>   int isalnum(int ASCII)</p>
</blockquote>
<p>检测你的ASCII是不是数字或者字母</p>
<p>1不是ASCII的1</p>
<p>‘1’才是ASCII的‘1’</p>
<p>函数</p>
<p>返回非零状态,表示字母数字</p>
<p>返回零,不是字母数字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>



<h1 id="isalpha-检测是不是字母"><a href="#isalpha-检测是不是字母" class="headerlink" title="isalpha 检测是不是字母"></a>isalpha 检测是不是字母</h1><blockquote>
<p>   <strong>int isalpha(int ASCII)</strong></p>
</blockquote>
<p>是字母返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>



<h1 id="islower-检测是小写字母"><a href="#islower-检测是小写字母" class="headerlink" title="islower 检测是小写字母"></a>islower 检测是小写字母</h1><blockquote>
<p>  <strong>int islower(int ASCII)</strong></p>
</blockquote>
<p>是小写字母返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">islower</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>



<h1 id="isupper-检测是大写字母"><a href="#isupper-检测是大写字母" class="headerlink" title="isupper 检测是大写字母"></a>isupper 检测是大写字母</h1><blockquote>
<p>  <strong>int isupper(int c)</strong></p>
</blockquote>
<p>是大写字母返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isupper</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span><br></pre></td></tr></table></figure>



<h1 id="isdigit-检测是不是10以内的ASCII-gt-10进制数字"><a href="#isdigit-检测是不是10以内的ASCII-gt-10进制数字" class="headerlink" title="isdigit 检测是不是10以内的ASCII-&gt;10进制数字"></a>isdigit 检测是不是10以内的ASCII-&gt;10进制数字</h1><blockquote>
<p>  int isdigit(inr ASCII)</p>
</blockquote>
<p>是10进制数字返回非零</p>
<p>否者返回0</p>
<p>‘0x20’不是10进制数字,更像一个字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isdigit</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<h1 id="isxdigit-检测是不是16进制的字符串"><a href="#isxdigit-检测是不是16进制的字符串" class="headerlink" title="isxdigit 检测是不是16进制的字符串"></a>isxdigit 检测是不是16进制的字符串</h1><p>是16进制数字返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   	<span class="type">char</span> str[<span class="number">64</span>]=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isxdigit</span>(str[i])!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> A B C D E F a b c d e f</span><br></pre></td></tr></table></figure>



<h1 id="iscntrl-检测是不是控制字符"><a href="#iscntrl-检测是不是控制字符" class="headerlink" title="iscntrl 检测是不是控制字符"></a>iscntrl 检测是不是控制字符</h1><blockquote>
<p>  int iscntrl(int ASCII)</p>
</blockquote>
<p>是控制字符返回非零</p>
<p>否者返回0</p>
<p>控制字符不可打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">iscntrl</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出它的10进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 127</span><br></pre></td></tr></table></figure>





<h1 id="ispunct-检测是不是标点符号"><a href="#ispunct-检测是不是标点符号" class="headerlink" title="ispunct 检测是不是标点符号"></a>ispunct 检测是不是标点符号</h1><blockquote>
<p>  int ispunct(int ascii)</p>
</blockquote>
<p>可标点符号返回非零(空格除外)</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C 语言中所有可打印的标点符号: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ispunct</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! &quot; # $ % &amp; &#x27; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ _ ` &#123; | &#125; ~ </span><br></pre></td></tr></table></figure>



<h1 id="isspace-检测是不是空白字符"><a href="#isspace-检测是不是空白字符" class="headerlink" title="isspace 检测是不是空白字符"></a>isspace 检测是不是空白字符</h1><blockquote>
<p>  int isspace(int c)</p>
</blockquote>
<p>空白字符:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; &#x27;     (0x20)    space (SPC) 空格符</span><br><span class="line">&#x27;\t&#x27;    (0x09)    horizontal tab (TAB) 水平制表符    </span><br><span class="line">&#x27;\n&#x27;    (0x0a)    newline (LF) 换行符</span><br><span class="line">&#x27;\v&#x27;    (0x0b)    vertical tab (VT) 垂直制表符</span><br><span class="line">&#x27;\f&#x27;    (0x0c)    feed (FF) 换页符</span><br><span class="line">&#x27;\r&#x27;    (0x0d)    carriage return (CR) 回车符</span><br></pre></td></tr></table></figure>



<p>是返回非零</p>
<p>否者返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ecx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(i)!=<span class="number">0</span>)</span><br><span class="line">            ecx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0-127中,有%d个空白字符&quot;</span>,ecx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-127中,有6个空白字符</span><br></pre></td></tr></table></figure>



<h1 id="tolower-大写变小写"><a href="#tolower-大写变小写" class="headerlink" title="tolower 大写变小写"></a>tolower 大写变小写</h1><blockquote>
<p>  <strong>int tolower(int 大写)</strong> </p>
</blockquote>
<p>返回值是小写的值</p>
<p>如果原本本来就是小写,或者他不是字母就不处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot;DQX is FINE&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">while</span>( str[i] ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="built_in">tolower</span>(str[i]));</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dqx is fine</span><br></pre></td></tr></table></figure>



<h1 id="toupper-小写变大写"><a href="#toupper-小写变大写" class="headerlink" title="toupper 小写变大写"></a>toupper 小写变大写</h1><blockquote>
<p>   <strong>int toupper(int c)</strong></p>
</blockquote>
<p>返回一个大写的int值</p>
<p>如果原来就是大写,或者字符不存在大写就不管</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot;dqx IS fien&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">while</span>( str[i] ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="built_in">toupper</span>(str[i]));</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="toascii-把任意数字转化位可见字符"><a href="#toascii-把任意数字转化位可见字符" class="headerlink" title="toascii 把任意数字转化位可见字符"></a>toascii 把任意数字转化位可见字符</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,toascii(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实它不是函数,他是一个宏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __toascii(c)   ((c) &amp; 0x7f)</span><br></pre></td></tr></table></figure>

<p>可能上面很多函数都是宏,只是没注意</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C语言库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>win32入门篇-1</title>
    <url>/re4mile/2023/01/11/language/C/win32/mfc/language/</url>
    <content><![CDATA[<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>关于模块的概念</p>
<p>不是说一个exe就是u一个模块</p>
<p>好比一辆汽车，发动机可以跑，空调可以吹</p>
<p>此刻发动机，空调就是2个模块，然后构成了一个汽车</p>
<p>汽车就是 由很多的模块构成</p>
<p>handle 一般是编号,因为和内核相关,HWND也是编号</p>
<p>hinstance和hmodule一般是内存地址</p>
<h2 id="一个编译流程"><a href="#一个编译流程" class="headerlink" title="一个编译流程"></a>一个编译流程</h2><p><img src="https://re4mile.gitee.io/res/photo/language/image-20221019085719714.png" alt="image-20221019085719714"></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20221019090304274.png" alt="image-20221019090304274"></p>
<h2 id="初始化的一个过程"><a href="#初始化的一个过程" class="headerlink" title="初始化的一个过程"></a>初始化的一个过程</h2><p><img src="https://re4mile.gitee.io/res/photo/language/image-20221023204517435.png" alt="image-20221023204517435"></p>
<p>CreateWindwos发出一个消息,进入消息队列</p>
<p>然后消息循环抓取到消息,做一些处理的函数</p>
<p>当窗口发出WO_CLOSE消息,会触发DestroyWindow()</p>
<p>然后会触发WM_DESTROY,才会触发摧毁</p>
<p>关于一般的流程</p>
<h2 id="一般的流程"><a href="#一般的流程" class="headerlink" title="一般的流程"></a>一般的流程</h2><p>程序初始化过程中调用CreateWindow，为程序建立了一个窗口，做为程序的屏幕舞台。</p>
<p>1	 CreateWindow 产生窗口之后会送出WM_CREATE直接给窗口函数</p>
<p>​	  后者于是可以在此时机做些初始化动作（例如配置内存、开文件、读初始数据…）。</p>
<p>2	 程序活着的过程中，不断以GetMessage从消息贮列中抓取消息。</p>
<p>​	  如果这个消息是WM_QUIT，GetMessage 会传回0而结束while循环，进而结束Mian整个程序。</p>
<p>3	 DispatchMessage 通过Windows USER 模块的协助与监督，把消息分派至窗口函数。消息将在该处被判别并处理。</p>
<p>4 	程序不断进行2.和3.的动作。消息循环</p>
<p>点击关闭, 发出系统SYS送出WM_CLOSE,一般 DefWindowProc处理这个消息,然后DefWindowProc处理调用DestroyWindow 把窗口清除</p>
<p>DestroyWindow 本身又会送出WM_DESTROY。消息循环对WM_DESTROY的标准反应是调用PostQuitMessage</p>
<p>PostQuitMessage  本身又会送出WM_QUIT,消息循环中的GetMessage 取得，结束消息循环。</p>
<h2 id="空闲时间的处理"><a href="#空闲时间的处理" class="headerlink" title="空闲时间的处理"></a>空闲时间的处理</h2><p><img src="https://re4mile.gitee.io/res/photo/language/image-20221023211346105.png" alt="image-20221023211346105"></p>
<h2 id="一个窗口的建立过程"><a href="#一个窗口的建立过程" class="headerlink" title="一个窗口的建立过程"></a>一个窗口的建立过程</h2><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>也就是一个窗口的身份注册</p>
<p>RegisterClass(&amp;wc)只注册了窗口基本的信息</p>
<p>很多的窗口可以拿着相同的WndClass去DIY属于自己的窗口</p>
<p>DIY的过程就是进一步完善自己窗口信息的过程,类似于一个继承的行为,然后重新或者增加</p>
<p>窗口类就是一个结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct tagWNDCLASSW &#123;</span><br><span class="line">    UINT        style    ;            // 类风格</span><br><span class="line">    WNDPROC     lpfnWndProc;           // 窗口的处理过程</span><br><span class="line">    int         cbClsExtra;            // 指定紧随在 WNDCLASS 数据结构后分配的字节数</span><br><span class="line">    int         cbWndExtra;            // 指定紧随在窗口实例之后分配的字节数            </span><br><span class="line">    HINSTANCE   hInstance;             // 窗口类所在模块的实例句柄</span><br><span class="line">    HICON       hIcon;                 // 窗口类的图标</span><br><span class="line">    HCURSOR     hCursor;               // 窗口类的光标</span><br><span class="line">    HBRUSH      hbrBackground;         // 窗口类的背景画刷</span><br><span class="line">    LPCWSTR     lpszMenuName;          // 窗口类的菜单资源名</span><br><span class="line">    LPCWSTR     lpszClassName;         // 窗口类的名称</span><br><span class="line">&#125; WNDCLASSW</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW );<span class="comment">//背景色</span></span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;<span class="comment">//默认光标,</span></span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;<span class="comment">//默认图标</span></span><br><span class="line">wc.hInstance = hInstance; <span class="comment">//ImageABse</span></span><br><span class="line">wc.lpfnWndProc = WndProc_DIY;<span class="comment">//窗口处理函数,请引起注意,</span></span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Dqx-x9d&quot;</span>;<span class="comment">//窗口类的名字,也就是模板窗口的名字</span></span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">//没有菜单</span></span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;<span class="comment">//窗口的属性风格</span></span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wc);<span class="comment">//直接把窗口结构体的地址给他,这个函数就把窗口类的信息写入内核</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统窗口类</p>
<p>系统已经定义好的窗口类,无需注册</p>
<p>所有应用程序都可以直接使用。</p>
<p>类似的系统窗口有很多</p>
<p>包括：BUTTON（按钮），EDIT（文本框），LISTBOX（列表），MDICLIENT（子窗口），SCROLLBAR（滚动条），RICHEDIT（富文本），STATIC（静态控件）；</p>
<h3 id="基于窗口类创建窗口"><a href="#基于窗口类创建窗口" class="headerlink" title="基于窗口类创建窗口"></a>基于窗口类创建窗口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindowEx</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">        DWORD    dwExStyle,    <span class="comment">//窗口的扩展风格</span></span></span><br><span class="line"><span class="params">      LPCTSTR    lpClassName,  <span class="comment">//已经注册的窗口类名称 wc.lpszClassName</span></span></span><br><span class="line"><span class="params">      LPCTSTR    lpWindowName, <span class="comment">//窗口标题栏的名字</span></span></span><br><span class="line"><span class="params">        DWORD    dwStyle,    <span class="comment">//窗口的基本风格</span></span></span><br><span class="line"><span class="params">          <span class="type">int</span>    x,          <span class="comment">//窗口左上角水平坐标位置</span></span></span><br><span class="line"><span class="params">          <span class="type">int</span>    y,          <span class="comment">//窗口左上角垂直坐标位置</span></span></span><br><span class="line"><span class="params">          <span class="type">int</span>    nWidth,     <span class="comment">//窗口的宽度</span></span></span><br><span class="line"><span class="params">          <span class="type">int</span>    nHeight,    <span class="comment">//窗口的高度</span></span></span><br><span class="line"><span class="params">         HWND    hWndParent, <span class="comment">//窗口的父窗口句柄,针对与子窗口,父窗口的话,这里就是NULL</span></span></span><br><span class="line"><span class="params">        HMENU    hMenu,      <span class="comment">//窗口菜单句柄</span></span></span><br><span class="line"><span class="params">    HINSTANCE    hInstance,  <span class="comment">//应用程序实例句柄</span></span></span><br><span class="line"><span class="params">       LPVOID    lpParam     <span class="comment">//窗口创建时附加参数   </span></span></span><br><span class="line"><span class="params">)</span>; <span class="comment">//创建成功返回窗口句柄</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dw_Append_Wind_Style = WS_OVERLAPPEDWINDOW;</span><br><span class="line">Hwnd01 = CreateWindowEx(</span><br><span class="line">       <span class="literal">NULL</span>, wc.lpszClassName, </span><br><span class="line">       <span class="string">&quot;MY_Title&quot;</span>, dw_Append_Wind_Style, </span><br><span class="line">       <span class="number">200</span>, <span class="number">200</span>, <span class="number">1000</span>, <span class="number">1000</span>,</span><br><span class="line">       <span class="literal">NULL</span>,<span class="literal">NULL</span>, hInstance, str</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>



<p>创建的原理</p>
<p> 拿着RegisterClass的信息,去根据那个信息注册窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateWindwos</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> ok=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)<span class="comment">//3是局部窗口,全局窗口,系统窗口,一共3个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;局部窗口个数;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ok=<span class="built_in">strcmp</span>( lpClassName,局部窗口[j].name);</span><br><span class="line">            <span class="keyword">if</span>(ok==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(实例句柄==局部窗口[j].实例句柄)</span><br><span class="line">                &#123;</span><br><span class="line">                    申请一块内存,把之前<span class="keyword">register</span>注册的一些信息和createwindow传入的信息写入内存</span><br><span class="line">                    <span class="keyword">return</span> 内存的句柄;<span class="comment">//于是他就是窗口句柄</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;全局窗口个数;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ok=<span class="built_in">strcmp</span>( lpClassName,全局窗口[j].name);</span><br><span class="line">            <span class="keyword">if</span>(ok==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                申请一块内存,把之前<span class="keyword">register</span>注册的一些信息和Createwindow传入的信息写入内存</span><br><span class="line">                <span class="keyword">return</span> 内存的句柄;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;系统窗口个数;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ok=<span class="built_in">strcmp</span>( lpClassName,系统窗口[j].name);</span><br><span class="line">            <span class="keyword">if</span>(ok==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                申请一块内存,把之前<span class="keyword">register</span>注册的一些信息和Createwindow传入的信息写入内存</span><br><span class="line">                <span class="keyword">return</span> 内存的句柄;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>dwStyle:指定窗口样式。其值为以下值中的一个或多个：</p>
<table>
<thead>
<tr>
<th>WS_BORDER</th>
<th>创建一个有边框的窗口。</th>
</tr>
</thead>
<tbody><tr>
<td>WS_CAPTION</td>
<td>创建一个具有标题栏 （意味着WS_BORDER样式） 的窗口。不能用的WS_DLGFRAME样式。</td>
</tr>
<tr>
<td>★ WS_CHILD</td>
<td>创建一个子窗口。不能用的WS_POPUP样式。★</td>
</tr>
<tr>
<td>WS_CHILDWINDOW</td>
<td>与WS_CHILD样式相同。</td>
</tr>
<tr>
<td>WS_CLIPCHILDREN</td>
<td>不包括在父窗口内绘制时子窗口所占用的区域。当您创建父窗口时使用。</td>
</tr>
<tr>
<td>WS_CLIPSIBLINGS</td>
<td>剪辑子窗口彼此;也就是说，当一个特定的子窗口接收绘制消息， WS_CLIPSIBLINGS风格剪辑子窗口要更新的区域外的所有其他重叠的子窗口。 （如果没有给WS_CLIPSIBLINGS和子窗口重叠内子窗口的客户区, 绘制时，它是可能内相邻的子窗口的客户区的绘制。与WS_CHILD样式只一起使用。</td>
</tr>
<tr>
<td>WS_DISABLED</td>
<td>创建一个窗口是最初被禁用。</td>
</tr>
<tr>
<td>WS_DLGFRAME</td>
<td>创建一个窗口，但是没有头衔的双边框。</td>
</tr>
<tr>
<td>WS_GROUP</td>
<td>指定一组控件，用户可以从一个控件移向下的箭头键的第一个控件。用虚假的WS_GROUP样式后的第一个控件定义的所有控件都属于同一个组。 WS_GROUP样式的下一控件启动下一个组 （就是下一步的开始位置的一组结束）。</td>
</tr>
<tr>
<td>WS_HSCROLL</td>
<td>创建一个具有水平滚动条的窗口。</td>
</tr>
<tr>
<td>WS_ICONIC</td>
<td>创建一个最初最小化的窗口。WS_MINIMIZE样式相同。</td>
</tr>
<tr>
<td>WS_MAXIMIZE</td>
<td>创建一个窗口的最大大小。</td>
</tr>
<tr>
<td>WS_MAXIMIZEBOX</td>
<td>创建一个窗口有最大化按钮。</td>
</tr>
<tr>
<td>WS_MINIMIZE</td>
<td>创建一个最初最小化的窗口。与仅WS_OVERLAPPED样式一起使用。</td>
</tr>
<tr>
<td>WS_MINIMIZEBOX</td>
<td>创建一个具有最小化按钮的窗口。</td>
</tr>
<tr>
<td>WS_OVERLAPPED</td>
<td>创建重叠的窗口。重叠的窗口通常具有标题和边框。</td>
</tr>
<tr>
<td>WS_OVERLAPPEDWINDOW</td>
<td>与WS_OVERLAPPED、 WS_CAPTION、 WS_SYSMENU、 WS_THICKFRAME、 WS_MINIMIZEBOX和WS_MAXIMIZEBOX样式创建重叠的窗口。</td>
</tr>
<tr>
<td>WS_POPUP</td>
<td>创建一个弹出窗口。不能使用具有WS_CHILD样式。</td>
</tr>
<tr>
<td>WS_POPUPWINDOW</td>
<td>用WS_BORDER， WS_POPUP和WS_SYSMENU的样式创建一个弹出窗口。WS_CAPTION样式必须结合WS_POPUPWINDOW样式，以使控制菜单上可见。</td>
</tr>
<tr>
<td>WS_SIZEBOX</td>
<td>创建一个具有大小调整边框的窗口。WS_THICKFRAME样式相同。</td>
</tr>
<tr>
<td>WS_SYSMENU</td>
<td>创建一个窗口，都有一个控制菜单框在其标题栏中。仅用于带有标题栏的窗口。</td>
</tr>
<tr>
<td>WS_TABSTOP</td>
<td>指定任意数量的控件，通过它用户可以通过使用 TAB 键移动之一。TAB 键移动用户到指定WS_TABSTOP风格的下一个控件。</td>
</tr>
<tr>
<td>WS_THICKFRAME</td>
<td>创建一个窗口，用厚厚的框架，可以用来调整窗口的大小。</td>
</tr>
<tr>
<td>WS_TILED</td>
<td>创建重叠的窗口。重叠的窗口有标题栏和边框。WS_OVERLAPPED样式相同。</td>
</tr>
<tr>
<td>WS_TILEDWINDOW</td>
<td>用 WS_OVERLAPPED、 WS_CAPTION、 WS_SYSMENU、 WS_THICKFRAME、 WS_MINIMIZEBOX 和 WS_MAXIMIZEBOX 的样式创建重叠的窗口。 与WS_OVERLAPPEDWINDOW 样式相同。</td>
</tr>
<tr>
<td>WS_VISIBLE</td>
<td>创建的窗体可见</td>
</tr>
<tr>
<td>WS_VSCROLL</td>
<td>创建一个具有垂直滚动条的窗口.</td>
</tr>
</tbody></table>
<h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><h4 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h4><p><strong>(1)MSG 结构体</strong></p>
<p>消息组成( windows平台下)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMSG</span> </span><br><span class="line">&#123;</span><br><span class="line">    HWND        hwnd;		<span class="comment">//窗口的句柄,属于哪个窗口发出的消息</span></span><br><span class="line">    UINT        message;	<span class="comment">//窗口发出的是什么类型的消息</span></span><br><span class="line">    WPARAM      wParam; 	<span class="comment">//附加参数x2</span></span><br><span class="line">    LPARAM      lParam; </span><br><span class="line">    DWORD       time;		<span class="comment">//消息产生的时间</span></span><br><span class="line">    POINT       pt;			<span class="comment">//消息产生时,鼠标的位置</span></span><br><span class="line">&#125; MSG;</span><br></pre></td></tr></table></figure>



<p>1.窗口句柄,也就是hWnd,这个参数由CreateWindow函数返回,说明了这个消息是属于哪个窗口的</p>
<p>2.消息ID,每个消息都有他的ID编号,这个编号说明了窗口发出的是什么类型的消息</p>
<p>3&#x2F;4.</p>
<p>消息的两个参数(两个附带信息),消息产生时,不仅仅是产生单独的消息,还会夹杂一些附带的信息,通过这个2个参数返回</p>
<p>PS: GetMessage(&amp;msg, NULL, 0, 0)会初始化Msg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">    <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(2)消息队列</strong></p>
<p>GetMessage可以从程序的消息队列中获取消息。</p>
<p>系统消息队列- 由系统维护的消息队列。存放系统产生的消息,例如鼠标、键盘等。<code>会不定时的</code>把一些程序的消息派发到程序的消息队列</p>
<p>程序消息队列- 属于每一个应用程序(线程)的消息队列。由应用程序(线程)维护。程序消息队列不会直接的抓取消息,而是由系统消息队列转发到程序消息队列</p>
<p>所有的消息产生都是依靠下面2个函数产生</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SendMessage</span>()</span><br><span class="line"><span class="built_in">PostMessage</span>()</span><br></pre></td></tr></table></figure>



<p>消息分为队列消息和非队列消息</p>
<p>但是队列消息和非队列消息不是消息的本身属性</p>
<p>你把消息放入队列,他就是队列消息,然后Gestmessage抓取,然后处理</p>
<p>你不把消息方放入队列,他就是非队列消息,然后就会直接调用对应的消息处理函数,而不会直接接触GetMeesage</p>
<p>大多数的消息都会被放入消息队列</p>
<p>● 队列消息-消息发送后，首先放入队列,然后通过消息循环的GetMessage,从队列当中获取。</p>
<p>​		GetMessage  -从消息队列中获取消息一</p>
<p>​		PostMessage -将消息投递到消息队列</p>
<p>​		常见队列消息: WM_PAINT、 键盘、鼠标、定时器。</p>
<p>● 非队列消息-消息发送时，首先查找消息接收窗口的窗口处理函数, 直接调用处理函数,完成消息。</p>
<p>​	   SendMessage -直接将消息发送给窗口的处理函数,并等候处理结果。</p>
<p>​	   常见消息:   WM_CREATE、WM_SIZE等。</p>
<p>消息产生后首先会进入系统消息队列,而不是本进程的的队列</p>
<p>系统消息队列根据Msg变量,寻找Hwnd成员,每个窗口的Hwnd成员是独一无二</p>
<p>根据Hwnd,把产生的消息转发给该进程</p>
<p>SendMessage既不会把消息给系统队列也不会给本进程的消息队列</p>
<p>WM_QUIT一定是队列消息,如果GetMessage抓不到它,消息循环就不会退出</p>
<p>WM_CREATE一定不是队列消息,因为WM_CREAT是在Register之后,Show_Windwo之前,消息循环之前产生的</p>
<p>所以GetMessage是抓不到他的,因为WM_CREATE产生时,GetMessage还没有出生</p>
<h4 id="消息循环的函数"><a href="#消息循环的函数" class="headerlink" title="消息循环的函数"></a>消息循环的函数</h4><h5 id="GetMessage-抓"><a href="#GetMessage-抓" class="headerlink" title="GetMessage 抓"></a>GetMessage 抓</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">GetMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">//阻塞函数</span></span></span><br><span class="line"><span class="params">    LPMSG IpMsg, <span class="comment">//存放获取到的消息的结构体</span></span></span><br><span class="line"><span class="params">    HWND hWnd, <span class="comment">//窗口句柄 ,表示抓哪个窗口</span></span></span><br><span class="line"><span class="params">    UINT min_ID,<span class="comment">//获取消息的最小ID编号</span></span></span><br><span class="line"><span class="params">    UINT Max_ID<span class="comment">//获取消息的最大ID编号</span></span></span><br><span class="line"><span class="params">    <span class="comment">//在[min_ID,Max_ID]之间抓取,如果都为0 ,表示没有范围,什么都抓取</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>他会去程序的消息队列,抓取本进程的消息,也不是不可以抓其他的进程(那是黑客编程的事情)</p>
<p>从程序的消息队列获取消息,将消息从消息队列中移除,</p>
<p>比如抓取鼠标的消息,抓取键盘的消息,成功地抓取消息后他就会返回,不再阻塞</p>
<p>当系统无消息时,会一直等候下一条消息,等待的过程中就是一个消息也没有抓取到,相当于一直在睡觉,一直阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GerMessge原理</span><br><span class="line"></span><br><span class="line">GerMessge首先去本进程的程序消息队列抓取消息</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(抓取到了)</span><br><span class="line">&#123;</span><br><span class="line">	就执行消息处理函数</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    GetMessage就循询问系统消息队列,那里有没有它的消息</span><br><span class="line">    <span class="keyword">if</span>(有)</span><br><span class="line">    &#123;</span><br><span class="line">        系统消息队列由之前的不定时派发消息到各个进程</span><br><span class="line">		变为了马上就派发各个消息到对应的程序消息队列</span><br><span class="line">		然后执行消息处理函数	</span><br><span class="line">       	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        那么getMessage就去查看有没有要重新绘制的窗口</span><br><span class="line">        <span class="keyword">if</span>(有)</span><br><span class="line">        &#123;</span><br><span class="line">            就发出WM_PAINT消息,然后处理</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            自己去寻找有没有要炸的定时器</span><br><span class="line">            <span class="keyword">if</span>(有)</span><br><span class="line">            &#123;</span><br><span class="line">                 就发出消息ID为WM_TIMER,然后处理消息</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                GetMessag就去整理一下程序的资源和内存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">开始阻塞,实在无事可做</span><br></pre></td></tr></table></figure>



<h5 id="TranslateMessage-翻译"><a href="#TranslateMessage-翻译" class="headerlink" title="TranslateMessage 翻译"></a>TranslateMessage 翻译</h5><p>它只会抓取键盘的可见字符消息</p>
<p>检查消息是否是按键的消息,如果不是按键消息,不做任何处理。</p>
<p>TranslateMessage在转换WM_KEYDOWN消息时,对于可见字符可以产生WM_CHAR的消息,对于不可见字符无此消息。</p>
<p>附带信息:</p>
<p>WPARAM  -输入的字符的ASCII字符编码值</p>
<p>LPARAM  -按键的相关参数</p>
<p>当你按下一个键帽,发出一个KEY_DOWN的消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TranslateMessage</span><span class="params">(msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(msg.mseID!=KEYDOWN)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(msg.wParam!=可见字符的虚拟键值)</span><br><span class="line">		reurn;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(大写锁打开了)</span><br><span class="line">		PostMessage(msg.hWnd,WM_CHAR,虚拟按键的可见大写ASCII大写,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		PostMessage(msg.hWnd,WM_CHAR,虚拟按键的可见小写ASCII大写,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当TranslateMessage发送了WM_CAHR到系队消息队列,早晚会被getMessage抓取,然后TranslateMessage接收到消息不是</p>
<p>WM_KEYDOWN,而是WM_CHAR</p>
<p>于是就直接返回</p>
<h5 id="DispatchMessage-调遣"><a href="#DispatchMessage-调遣" class="headerlink" title="DispatchMessage() 调遣"></a>DispatchMessage() 调遣</h5><p>根据消息,调用消息处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DispatchMessage(&amp;msg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的具体流程是</p>
<p>msg.Hwnd-&gt;WndProc_deal,根据Msg结构体遍历他的成员,最后寻找消息处理函数</p>
<p>拿到消息处理函数WidnProc,把Msg的前4个成员作为参数传递给消息处理函数,此刻的4个参数都已经被初始化了</p>
<p>调用WndProc_deal_DIY(hWnd,MsgID,wParam,lParam)</p>
<h5 id="PeekMessag-侦察"><a href="#PeekMessag-侦察" class="headerlink" title="PeekMessag 侦察"></a>PeekMessag 侦察</h5><p>PeekMessage -非阻塞,以查看的方式从系统获取消息,可以不将消息从系统移除,</p>
<p>当系统有消息时,返回true,继续执行后续代码。</p>
<p>当系统无消息时,返回FALSE,不会阻塞继续执行后续代码。</p>
<p>这个函数相比较与GetMessage</p>
<p>它有眼睛去侦察消息,</p>
<p>有嘴巴去返回消息</p>
<p>可以用手去移除消息,但是一般没有手,于是主要的功能就是侦察</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span></span></span><br><span class="line"><span class="function"><span class="params">(          </span></span></span><br><span class="line"><span class="params"><span class="function">	LPMSG lpMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wMsgFilterMin, <span class="comment">//first message</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wMsgFilterMax, <span class="comment">//last message</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wRemoveMsg    <span class="comment">//PM_REMOVE 加上手 PM_NOREMOVE 移除</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>主要是去侦察消息,然后返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_NOREMOVE))<span class="comment">//有消息返回非0,无消息就不处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                TranslateMessage(&amp;msg);</span><br><span class="line">                DispatchMessage(&amp;msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(<span class="number">100</span>);</span><br><span class="line">            WriteConsole(g_handle, <span class="string">&quot;...&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;...&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="消息派发"><a href="#消息派发" class="headerlink" title="消息派发"></a>消息派发</h4><p>无论什么消息的发送,都是直接或者间接的调用这2个函数</p>
<p>SendMessage -发送消息,会等候消息处理的结果。这是一个阻塞函数,发送的消息直接调消息处理函数,而不会进入消息循环</p>
<p>PostMessage -投递消息,消息发出后立刻返回,不等候消息执行结果。不是一个阻塞函数,发送消息到系统消息队列</p>
<p>说一下这2个函数的区别</p>
<p>SendMessage就像是打电话,你拨打一个电话,于是就相当于发出一个消息,然后你就会等待对方接通</p>
<p>接通完毕后,消息处理,你才会挂断电话,然后返回,不在阻塞</p>
<p>PostMessage.可以看到Post这个单词,也就是邮递的意思</p>
<p>这个函数就像是你去邮局寄一封信,然后你把信件扔进邮箱,于是你就马上离开了</p>
<p>你也不会说等到对方把信收到手了,然后才离开邮局</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(          </span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">//这个消息是哪个窗口的,我要送到那里去</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT Msg,  <span class="comment">//这是一个什么样的消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, <span class="comment">//下面是附带的2个参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">PostMessage</span><span class="params">(          </span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT Msg,</span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们之前遇到的第一个消息产生的函数</p>
<p>PostQuitMessage(0),他的内部也是调用的SendMessage或者PostMessage</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="comment">//PostQuitMessage(0);//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="comment">//SendMessage(hWnd,WM_QUIT,0,0);关闭失败</span></span><br><span class="line">        PostMessage(hWnd,WM_QUIT,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//可以成功地退出      </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="MsgID"><a href="#MsgID" class="headerlink" title="MsgID"></a>MsgID</h1><h2 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h2><p>WM_CREATE 			 窗口创建</p>
<p>WM_DESTROY 			窗口摧毁消息</p>
<p>WM_ QUIT 			  窗口进程结束消息</p>
<p>WM_SIZE &#x2F; WM_PAINT 	窗口绘制消息</p>
<p>WM_KEYDOWN 			-按键被按下时产生消息</p>
<p>WM_KEYUP 	  		-按键被放开时产生消息</p>
<p>WM_SYSKEYDOWN   		-系统键按下时产生的消息,比如ALT、F10,他们</p>
<p>WM_SYSKEYUP     		-系统键放开时产生的消息</p>
<p>●基本鼠标消息</p>
<p>WM_LBUTTONDOWN -鼠标左键按下</p>
<p>WM_LBUTTONUP   -鼠标左键抬起</p>
<p>WM_RBUTTONDOWN -鼠标右键按下</p>
<p>WM_RBUTTONUP   -鼠标右键抬起</p>
<p>WM_MOUSEMOVE   -鼠标移动消息</p>
<p>●双击消息</p>
<p>​	WM_ LBUTTONDBLCLK -鼠标左键双击按下</p>
<p>​	WM_ RBUTTONDBLCLK -鼠标右键双击按下</p>
<p>●滚轮消息</p>
<p>​	WM_ MOUSEWHEEL -  鼠标滚轮消息</p>
<p>●鼠标点击菜单发生的消息</p>
<p>WM_SYSCOMMAND 		鼠标点击系统菜单栏发生的消息,放大缩小,关闭</p>
<p>WM_COMMADN    		鼠标点击菜单发生的消息</p>
<p>WM_TIMER 	 		定时器消息</p>
<p>WM_INITDIALOG 		对话框创建之后显示之前发出的消息,注意这里的特殊之处 <code>不是产生WM_CREATE</code>,而是WM_INITDIALOG</p>
<p><strong>系统消息ID &#x2F; 自定义消息ID</strong></p>
<p>系统消息- ID范围(0 - 0x03FF),一共有0x400个</p>
<p>由系统定义好的消息,可以在程序中直接使用。</p>
<p>系统消息只是系统或者人为的发送,消息的处理也是系统来做</p>
<p>用户自定义消息D范围0x0400 -0x7FFF ()</p>
<p>由用户自己定义,满足用户自己的需求。需要由用户自己发出消息,并处理消息</p>
<blockquote>
<p>自定义消息宏: WM_USER+n</p>
<p>自定义一个消息<code>#define dqx ( 0x400+10 )</code></p>
<p>然后选择一个时间点,发送消息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        PostMessage(hWnd, dqx, <span class="number">13</span>, <span class="number">14</span>);<span class="comment">//选择了一个消息发送的时间</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:      </span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> dqx:</span><br><span class="line">        Ondqx(hWnd, wParam, lParam);<span class="comment">//写了一个消息处理的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>自己写的一个消息处理函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ondqx</span><span class="params">(HWND hWnd, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;爱你%d%d&quot;</span>, wParam, lParam);</span><br><span class="line">    <span class="built_in">MessageBox</span>(hWnd, str, <span class="string">&quot;info&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="窗口消息"><a href="#窗口消息" class="headerlink" title="窗口消息"></a>窗口消息</h2><h3 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h3><blockquote>
<p>WM_CREATE 窗口创建</p>
</blockquote>
<p>● 产生时间:    在窗口创建成功但还未显示时。<code>CreateWindow已经创建好了,但是还没有ShowWindwo</code></p>
<p>● 附带信息:	IParam : 为CREATESTRUCT类型的结构体指针。通过这个指针可以获取CreatWindowEx中的全部12个参数的信息。</p>
<p>● 般用法:	常用于初始化窗口的参数、资源等等,包括创建子窗口等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> junk NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dqx ( 0x400+10 )</span></span><br><span class="line">HANDLE g_handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">just_for_fun</span><span class="params">(HWND hWnd, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    CREATESTRUCT* ptr1 = (CREATESTRUCT*)lParam;</span><br><span class="line">    <span class="type">char</span>* ptr2 = (<span class="type">char</span>*)(ptr1-&gt;lpCreateParams);</span><br><span class="line">    HWND  father_window = hWnd;</span><br><span class="line">    MessageBox(hWnd, ptr2, <span class="string">&quot;info&quot;</span>, MB_OK);<span class="comment">//我们先弹窗,然后出现一个子窗口,编辑框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc__DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">        just_for_fun(hWnd, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="窗口摧毁消息"><a href="#窗口摧毁消息" class="headerlink" title="窗口摧毁消息"></a>窗口摧毁消息</h3><blockquote>
<p> WM_DESTROY 窗口摧毁消息</p>
</blockquote>
<p>产生时间:        点击关闭按钮,窗口被销毁时</p>
<p>●附带信息:		不用它 	   </p>
<p>●一般用法:		常用于在窗口被销毁之前,做相应的善后处理,例如资源、内存…的处理,也就是要死了,留下的遗言</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:<span class="comment">//这个case代表了消息要死了,而要执行的语句就是i留下的遗言</span></span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);<span class="comment">//这里就是遗言的具体内容</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="窗口进程结束消息"><a href="#窗口进程结束消息" class="headerlink" title="窗口进程结束消息"></a>窗口进程结束消息</h3><blockquote>
<p>WM_ QUIT 窗口进程结束消息</p>
</blockquote>
<p>● 产生时间:  程序员有我们发送。也就会程序员自己调用PostQuitMessage()发出WM_QUIT的消息</p>
<p>● 附带信息:  wParam: PostQuitMessage函数传递的参数。<br>         		   IParam : 0。</p>
<p>●一般用法:  用于结束消息循环，</p>
<p>程序死亡前,发送WM_DESTORY</p>
<p>然后消息处理函数根据WM_DESTORY派遣PostMessage发送WM_QUIT</p>
<p>最后GetMessage抓取后,返回0,退出消息循环</p>
<h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><p>WM_KEYDOWN 	 		-按键被按下时产生消息</p>
<p>WM_KEYUP 	          -按键被放开时产生消息</p>
<p>WM_SYSKEYDOWN   		-系统键按下时产生的消息,比如ALT、F10,他们</p>
<p>WM_SYSKEYUP         	-系统键放开时产生的消息</p>
<blockquote>
<p>其它键帽消息</p>
<p>WM_CHAR 键盘消息</p>
<p>TranslateMessage接受到可见字符按下时,派遣消息加工厂发送了WM_CAHR</p>
</blockquote>
<p>附带信息:<br>    WPARAM -按键的Virtual Key键值 </p>
<p>​	LPARAM -按键的参数,例如按下次数 </p>
<p>可以同时按下ctrl+可见字符键,他们也有对应ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(HWND hWnd, WPARAM wParam )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;down:%#x\n&quot;</span>, wParam);</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(HWND hWnd, WPARAM wParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;up:%#x\n&quot;</span>, wParam);</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">        down(hWnd, wParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">        up(hWnd, wParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>WM_CHAR</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OnChar</span><span class="params">(HWND hWnd, WPARAM wParam )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;ASCII:%c\n&quot;</span>, wParam);</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:</span><br><span class="line">        OnChar(hWnd,wParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h2><blockquote>
<p>WM_SETCURSOR 这个消息的产生就是在你移动鼠标的时候</p>
<p>WM_SETCURSOR消息参数</p>
<p>​	wPARAM   -当前使用的光标句柄</p>
<p>​	IPARAM    -<code>LOWORD</code>当前区域的代码( Hit-Test code )</p>
<p>​			  	   HTCLIENT &#x2F; HTCAPTION…客户区域,标题栏区域</p>
<p>​				     HIWORD -当前鼠标消息ID.比如是左键还是右键按下等等,基本上不用</p>
</blockquote>
<blockquote>
<p>WM_COMMAND,鼠标点击菜单发生的消息</p>
<p>●附带信息:</p>
<p>wPARAM :</p>
<p>​	HIWORD -对于菜单为0 &#x2F;&#x2F;无用</p>
<p>​    LOWORD -菜单项的ID</p>
<p>IPARAM -对于菜单为0 &#x2F;&#x2F;无用,鼠标点击菜单发生的消息</p>
</blockquote>
<h3 id="基本鼠标消息"><a href="#基本鼠标消息" class="headerlink" title="基本鼠标消息"></a>基本鼠标消息</h3><p>●基本鼠标消息</p>
<p>WM_LBUTTONDOWN -鼠标左键按下</p>
<p>WM_LBUTTONUP   -鼠标左键抬起</p>
<p>WM_RBUTTONDOWN -鼠标右键按下</p>
<p>WM_RBUTTONUP   -鼠标右键抬起</p>
<p>WM_MOUSEMOVE   -鼠标移动消息</p>
<p>●基本鼠标消息的附带信息:<br>    wPARAM :其他按键的状态,例如Ctrl&#x2F;Shift, 好比你ctrl c的时候,鼠标在选中一些东西复制</p>
<p>​	IPARAM :鼠标的位置,窗口客户区坐标系。</p>
<p>​		   LOWORD X坐标位置</p>
<p>​		   HIWORD Y坐标位置</p>
<p>●一般情况鼠标按下&#x2F;抬起成对出现。在鼠标移动过程中, 会根据移动速度产生一系列的WM_ MOUSEMOVE消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(HWND hWnd, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;down: %d other :[%03d,%03d]\n&quot;</span>, wParam, LOWORD(lParam), HIWORD(lParam));</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(HWND hWnd, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;up  : %d other :[%03d,%03d]\n&quot;</span>, wParam,LOWORD(lParam),HIWORD(lParam));</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        down(hWnd, wParam,lParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">        up(hWnd, wParam, lParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>一般来说按下与按上,之间相差一个值</p>
<p>你可以在某个地方按下,在另外一个地方按上去,,哈哈,笑死</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteConsole(g_handle, <span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你的鼠标移动的越快,它发送消息的时间就越少,</p>
<p>你的鼠标移动的越慢,它发送消息的时间就越多,</p>
<h3 id="双击消息"><a href="#双击消息" class="headerlink" title="双击消息"></a>双击消息</h3><p>●双击消息<br>    WM_ LBUTTONDBLCLK -鼠标左键双击按下<br>    WM_ RBUTTONDBLCLK -鼠标右键双击按下</p>
<p>●<br>附带信息:<br>wPARAM -其他按键的状态,例如Ctrl&#x2F;Shift等<br>IPARAM -鼠标的位置,窗口客户区坐标系。<br>LOWORD(IParam) &#x2F;&#x2F;X坐标位置<br>HIWORD(IParam) &#x2F;&#x2F;Y坐标位置<br>●消息产生顺序<br>以左键双击为例:</p>
<p><code>使用时需要在register注册窗口类的时候添加CS_DBLCLKS 风格。而不是CreateWindow创建窗口的时候</code></p>
<blockquote>
<p>​	WM_ LBUTTONDOWN 	左键按下<br>​	WM_ LBUTTONUP		左键弹起<br>​	WM_ LBUTTONDBLCLK	左键双击<br>​	WM_ LBUT TONUP		左键弹起</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Ldd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteConsole(g_handle, <span class="string">&quot;double clink\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;double clink\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteConsole(g_handle, <span class="string">&quot;up\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;up\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Ldown</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteConsole(g_handle, <span class="string">&quot;down\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;down\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        Ldown();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">        Lup();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">        Ldd();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口注册</span></span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure>



<h3 id="滚轮消息"><a href="#滚轮消息" class="headerlink" title="滚轮消息"></a>滚轮消息</h3><p>滚轮消息</p>
<p>​	WM_ MOUSEWHEEL -  鼠标滚轮消息</p>
<p>●附带信息:<br>wPARAM :<br>    LOWORD -其他按键的状态<br>    HIWORD -滚轮的偏移量,通过正负值表示表示滚动方向。<br>        正:向前滚动<br>        负:向后滚动<br>IPARAM :鼠标当前的位置,屏幕坐标系&#x2F;<br>    LOWORD- X坐标<br>    HIWORD - Y坐标<br>●使用:<br>通过偏移量,获取滚动的方向和距离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mouse_whell</span><span class="params">(WPARAM wParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n&quot;</span>, (<span class="type">signed</span> <span class="type">short</span>)HIWORD(wParam));</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">        mouse_whell(wParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="鼠标点击系统菜单栏发生的消息"><a href="#鼠标点击系统菜单栏发生的消息" class="headerlink" title="鼠标点击系统菜单栏发生的消息"></a>鼠标点击系统菜单栏发生的消息</h3><p>WM_SYSCOMMAND 鼠标点击系统菜单栏发生的消息</p>
<p>●产生时间: 当点击窗口的最大化、最小化、关闭…</p>
<p>●附带信息: </p>
<p>wParam:  具体点击的位置,例如关闭SC_CLOSE等.</p>
<p>IParam : 鼠标光标的位置。是一个4字节数据<br>         LOWORD(IParam) ; &#x2F;&#x2F;水平位置<br>         HIWORD(IParam) ; &#x2F;&#x2F;垂直位置</p>
<p>●-般用法: 常用在窗口关闭时,提示用户处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_SYSCOMMAND:</span><br><span class="line">        <span class="keyword">if</span> (wParam == SC_CLOSE)<span class="comment">//如果点击的是关闭的按钮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret=MessageBox(hWnd, <span class="string">&quot;Close it ?&quot;</span>, <span class="string">&quot;info&quot;</span>, MB_YESNO);</span><br><span class="line">            <span class="keyword">if</span> (ret == IDYES)</span><br><span class="line">                ;<span class="comment">//因为点击了关闭按钮,默认函数会销毁窗口,然后发出WM_DESTROY,然后PostQuitMessage(0)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表示不关闭,直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//点击其它的按钮由默认出函数处理,因为是其它的按钮,所以就不是关闭的按钮</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你点击关闭的按钮后</p>
<p>最先获取的消息是WM_SYSCOMMAND</p>
<p>然后跳出MessagebOx</p>
<p>在return的时候,DefWindowProc默认的给你销毁窗口,除非你先前就return了</p>
<p>否则不会有一个WM_DESTROY的消息,</p>
<p><img src="https://img-blog.csdnimg.cn/6948b7d079224260ac89fc1ea2e08157.png" alt="在这里插入图片描述"></p>
<h2 id="定时器消息"><a href="#定时器消息" class="headerlink" title="定时器消息"></a>定时器消息</h2><p>●产生时间:<br>    在程序中创建定时器,当到达时间间隔时,定时器会向程序发送一个WM_TIMER消息。定时器的精度是毫秒，但是准确度很低。</p>
<p>例如设置时间间隔为1000ms，但是会在非1000毫秒到达消息。</p>
<p>●附带信息:<br>    wPARAM :定时器ID<br>    IPARAM :定时器处理函数的指针</p>
<p>定时器消息主要是给GetMessage函数使用的</p>
<p>埋了很多的炸弹,如果其中一个炸弹炸了,我得根据不同的炸弹炸了,干不同的事情,于是就需要知道定时器ID</p>
<p>创建定时器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UINT_PTR SetTimer(          </span><br><span class="line">	HWND hWnd,//定时器的窗口句柄,也就是炸弹炸了,哪个窗口的处理函数来处理消息WM_TIME</span><br><span class="line">    UINT_PTR nIDEvent,//定时器的ID</span><br><span class="line">    UINT uElapse, //时间间隔,毫秒级别</span><br><span class="line">    TIMERPROC lpTimerFunc //定时器函数处理指针,一般为NULL,</span><br><span class="line">);//创建成功返回非0</span><br></pre></td></tr></table></figure>

<p>销毁定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">KillTimer</span><span class="params">(          </span></span><br><span class="line"><span class="params">	HWND hWnd, <span class="comment">//定时器窗口句柄</span></span></span><br><span class="line"><span class="params">    UINT_PTR uIDEvent <span class="comment">//定时器ID</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(HWND hWnd,WPARAM wParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;Iam %d\n&quot;</span>, wParam);</span><br><span class="line">    WriteConsole(g_handle, str, <span class="built_in">strlen</span>(str), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//KillTimer(hWnd, 1);//如果要杀死其中一个炸弹</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_deal_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        SetTimer(hWnd, <span class="number">1</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);<span class="comment">//埋下炸弹</span></span><br><span class="line">        SetTimer(hWnd, <span class="number">2</span>, <span class="number">3000</span>, <span class="literal">NULL</span>);<span class="comment">//埋下炸弹</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER:</span><br><span class="line">        func(hWnd,wParam);<span class="comment">//炸弹爆炸时要做的事情</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="窗口绘制消息"><a href="#窗口绘制消息" class="headerlink" title="窗口绘制消息"></a>窗口绘制消息</h2><p>WM_SIZE&#x2F;WM_PAINT 窗口绘制消息</p>
<p>WM_SIZE</p>
<p>产生时间:	 在窗口的大小发生变化需要重新绘制,</p>
<p>附带信息:     wParam : 窗口大小变化的原因。</p>
<p>​		     IParam : 窗口变化后的大小。</p>
<p>​			 LOWORD(IParam) &#x2F;&#x2F;变化后的宽度</p>
<p>​			 HIWORD(IParam) &#x2F;&#x2F;变化后的高度</p>
<p>一般用法:	常用于窗口大小变化后,调整窗口内各个部分的布局。</p>
<p>WM_PAINT</p>
<p>产生时间:    GetMessage找不到事情干并且窗口需要重新绘制的时候,基本上都是GetMessage派遣SendMessage去MW_PAINT</p>
<p>​			 Show_window的时候,只会发送一次</p>
<p>附带信息:    他的附带信息都没用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Onpaint</span><span class="params">(HWND hWnd)</span><span class="comment">//如果你修改一些东西,就会触发这个消息</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteConsole(g_handle, <span class="string">&quot;wind need paint\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;wind need paint\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OnSize</span><span class="params">(HWND hWnd, LPARAM lParam)</span><span class="comment">//如果你修改一些东西,就会触发这个消息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> nWidth = LOWORD(lParam);</span><br><span class="line">    <span class="type">short</span> nHight = HIWORD(lParam);</span><br><span class="line">    <span class="type">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(szText, <span class="string">&quot;宽:%d,高:%d\n&quot;</span>, nWidth, nHight);</span><br><span class="line">    WriteConsole(g_handle, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc_DIY</span><span class="params">(HWND hWnd, UINT MsgID, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MsgID)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);<span class="comment">//它可以让你的窗口退出后,进程也退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        OnSize(hWnd, lParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        Onpaint(hWnd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, MsgID, wParam, lParam);<span class="comment">//默认处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>win32入门篇-2</title>
    <url>/re4mile/2023/01/11/language/C/win32/win32/language/</url>
    <content><![CDATA[<h1 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h1><p>普通窗口:	自定义函数最后调用缺省函数</p>
<p>对话框窗口:  缺省函数先调用自定义函数</p>
<p>对话框窗口处理函数(并非真正的对话框窗口处理函数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INT CALLBACK <span class="title function_">DialogProc</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hwndDlg, <span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">    UINT uMsg，<span class="comment">//消息ID</span></span></span><br><span class="line"><span class="params">    WPARAM wParam, <span class="comment">//消息参数</span></span></span><br><span class="line"><span class="params">    LPARAM IParam <span class="comment">//消息参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">返回TRUE -缺省处理函数不需要处理。</span><br><span class="line">返回FALSE-交给缺省处理函数处理。</span><br><span class="line">不需要调用缺省对话框窗口处理函数</span><br></pre></td></tr></table></figure>



<p><strong>阻塞形对话框</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INT <span class="title function_">DialogBox</span><span class="params">(</span></span><br><span class="line"><span class="params">    HINSTANCE hInstance,	<span class="comment">//应用程序实例句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpTemplate, 	<span class="comment">//对话框资源ID</span></span></span><br><span class="line"><span class="params">    HWND hWndParent, 		<span class="comment">//对话框父窗口</span></span></span><br><span class="line"><span class="params">    DLGPROC IpDialogFunc 	<span class="comment">//自定义函数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>DialogBox 是一个阻塞函数,只有当对话框关闭后,才会返回,继续执行后续代码。返回值是通过EndDialog设置。</p>
<p>EndDialog 可以结束阻塞形对话框对话框,然后消除阻塞,消除阻塞这一步非常的重要</p>
<p>对话框的关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">EndDialog</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hDIg,<span class="comment">//关闭的对话框窗口句柄,你要关闭哪个对话框?</span></span></span><br><span class="line"><span class="params">	INT_ PTR nResult <span class="comment">//关闭的返回值 ,关闭后,你要返回什么值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>关闭模式对话框,只能使用EndDialog ,不能使用DestroyWindow等函数</p>
<p>nResult是DialogBox函数退出时的返回值</p>
<p><strong>非阻塞行对话框</strong></p>
<p>●创建对话框</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HWND <span class="title function_">CreateDialog</span><span class="params">(</span></span><br><span class="line"><span class="params">    HINSTANCE hInstance, <span class="comment">//应用程序实例句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpTemplate，<span class="comment">//模板资源ID</span></span></span><br><span class="line"><span class="params">    HWND hWndParent,<span class="comment">//父窗口</span></span></span><br><span class="line"><span class="params">    DLGPROC IpDialogFunc <span class="comment">//自定义函数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>非阻塞函数,创建成功返回窗口句柄, <code>需要使用ShowWindow函数显示对话框。</code></p>
<p>对话框的关闭</p>
<p>关闭时使用DestroyWindow销毁窗口, 不能使用EndDialog关闭对话框。</p>
<p>SetWindowText</p>
<p>更改指定窗口标题栏的文本（如果有的话）。如果指定的窗口是控件，则更改控件的文本。但是，<strong>SetWindowText</strong>不能更改另一个应用程序中控件的文本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetWindowTextA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HWND   hWnd, <span class="comment">//改变文本内容的窗口或控件的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpString <span class="comment">//指向一个空结束的字符串的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>





<h1 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h1><p>静态链接库就是把源代码放入.c文件，或者说 在静态编译的时候，把二进制数据放入源文件</p>
<p>如果lib文件发生了修改，那么.c文件也要重新编译</p>
<p>动态链接库，只是提供一个接口</p>
<p>如果dll文件发生了改变，.c文件的exe不需要重新编译，就会使用最新的dll</p>
<h2 id="DLlMain"><a href="#DLlMain" class="headerlink" title="DLlMain"></a>DLlMain</h2><p>DOS     程序的入口函数是 main()</p>
<p>Win32   程序的入口函数是 WinMain() </p>
<p>DLL 	程序的入口函数是 DllMain()</p>
<p>一些例子中，DLL并没有提供DllMain函数，应用工程也能成功引用DLL，</p>
<p>这是因为Windows在找不到DllMain的时候，系统会从其它运行库中引入一个不做任何操作的缺省DllMain函数版本，并不意味着DLL可以放弃DllMain函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(</span></span><br><span class="line"><span class="params">   HINSTANCE hinstDLL, <span class="comment">// Dll的ImageBase</span></span></span><br><span class="line"><span class="params">   DWORD fdwReason, <span class="comment">// 调用原因</span></span></span><br><span class="line"><span class="params">   LPVOID lpvReserved <span class="comment">// 表示一个保留参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>其中fdwReason用来表示Dll被调用的状态，一共分为四种：</p>
<ul>
<li>DLL_PROCESS_ATTACH  &#x3D;&#x3D;1 被进程加载 进程映射 LoadLibiary的时候</li>
<li>DLL_PROCESS_DETACH  &#x3D;&#x3D;0 被进程释放 进程卸载 FreeLibiary的时候</li>
<li>DLL_THREAD_ATTACH   &#x3D;&#x3D;2 被线程加载 线程映射</li>
<li>DLL_THREAD_DETACH   &#x3D;&#x3D;3 被线程释放 线程卸载</li>
</ul>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>way-1</p>
<p>将xxx.h和xxx. 1ib复制到要使用的项目中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxx.x. h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib,<span class="string">&quot;xxx.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>way-2</p>
<p>将xxx.h和xxx. lib复制到要使用的项目中<br>在需要使用的文件中包含: #include xxx. h</p>
<p>然后</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220824232555541.png" alt="image-20220824232555541"></p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h3><h4 id="声明导出"><a href="#声明导出" class="headerlink" title="声明导出"></a>声明导出</h4><p>使用_declspec(dllexport)导出函数,只需要在函数声明<code>最前面</code>加上这一句就欧克[^这里我会非常任意忘记]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不写_declspec的话,你的函数就不会导出,也就是不会出现在导出表里面</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:动态库编译链接后, 也会有LIB文件,是作为动态库函数<code>映射</code>使用,与静态库<code>不完全相同</code>。</p>
<p>这种导出方式对于cpp文件来说,会出现换名的机制,woc</p>
<h4 id="模块定义文件"><a href="#模块定义文件" class="headerlink" title="模块定义文件"></a>模块定义文件</h4><p>模块定义文件.def<br>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIBRARY DLLFunc //库,LIBRARY是必须写的,后面的是dll的名字,此刻不带后缀名</span><br><span class="line">EXPORTS    //库导出表</span><br><span class="line">add_func @1 //导出的函数</span><br><span class="line">sub_func @2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>为什么会有模块化定义文件的序号导出??</p>
<p>因为函数的名字就是最好的注释</p>
<p>如果函数的名字没有,只有符号,那么对于逆向分析就会加大难度</p>
<h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>操作系统负责使动态库执行,系统悄悄的把数据丢到内存</p>
<p>可以在函数原型的声明前,增加 <code>_declspec(dllimport)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment( lib, <span class="string">&quot;lib的绝对/相对路径&quot;</span>) <span class="comment">//寻找lib文件,dll文件得放在系统目录或者当前目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明下面为导入的函数</span></span><br><span class="line">_declspec(dllimport) <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">_declspec(dllimport) <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret=add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> ret2=sub(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dll的源文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把下面的函数声明为导出函数</span></span><br><span class="line">__declspec(dllexport)<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport)<span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>隐式链接的情况，dll文件可以存放的路径:</p>
<p>( 1 ) 与执行文件中同一个目录下</p>
<p>( 2 ) 当前工作目录</p>
<p>( 3 ) Windows目录</p>
<p>( 4 ) Windows&#x2F;System32目录</p>
<p>( 5 ) Windows&#x2F;System</p>
<p>( 6 ) 环境变量PATH指定目录</p>
<h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>显式链接(程序员自己负责使动态库执行)</p>
<p>1 )定义函数指针类型、typedef</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef  int(*ptr)(int, int);</span><br></pre></td></tr></table></figure>



<p>2 )加载动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HMODULE <span class="title function_">LoadLibrary</span><span class="params">(</span></span><br><span class="line"><span class="params">	LPCTSTR IpFileName <span class="comment">//动态库文件名或全路径</span></span></span><br><span class="line"><span class="params">)</span>;返回DLL的实例句柄( HINSTANCE )</span><br></pre></td></tr></table></figure>

<p>3 )获取函数地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule,   <span class="comment">//DLL句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR IpProcName  <span class="comment">//函数名称</span></span></span><br><span class="line"><span class="params">)</span>;成功返回函数地址</span><br></pre></td></tr></table></figure>

<p>4 )使用函数</p>
<p>5 )卸载动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">FreeLibrary</span><span class="params">(</span></span><br><span class="line"><span class="params">	HMODULE hModule <span class="comment">//DLL的实例句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>cpp文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="title function_">int</span><span class="params">(*ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE dll_ptr = LoadLibrary(<span class="string">&quot;dll.dll&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (dll_ptr == <span class="literal">NULL</span>) </span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    ptr me_add = (ptr)GetProcAddress(dll_ptr, <span class="string">&quot;?add@@YAHHH@Z&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (me_add == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> sum = me_add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>dll文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_declspec(dllexport)<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="动态链接库封装一个类"><a href="#动态链接库封装一个类" class="headerlink" title="动态链接库封装一个类"></a>动态链接库封装一个类</h3><p>话不多说</p>
<p>关于dll项目</p>
<p>设立头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DLLCLASS_H <span class="comment">//注意这个东西,记住就可以了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DLLCLASS_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个宏定义值得学习,如果有会是怎么样,如果没有会是怎么样</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> dll_class_botton</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> dll_class _declspec(dllexport)<span class="comment">//DLL开发者</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> dll_class _declspec(dllimport)<span class="comment">//使用者</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dll_class</span> <span class="title">math</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	public: <span class="comment">//注意这个权限</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//注意这个东西,记住就可以了</span></span></span><br></pre></td></tr></table></figure>



<p>关于源文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dll_class_botton  <span class="comment">//打开那个开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span> <span class="comment">//包含刚才的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">math::sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//定义一下刚才的头文件</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于main项目如何使用dll的class</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment( lib, <span class="string">&quot;../Main_NULL/Debug/one.lib&quot;</span> ) <span class="comment">//隐式的调用lib文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&quot;../one/test.h&quot;</span> <span class="comment">//访问那个dll的类class</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	math class_math;<span class="comment">//用那个声明创建一个对象</span></span><br><span class="line">	<span class="type">int</span> sum = class_math.sub(<span class="number">10</span>, <span class="number">3</span>);<span class="comment">//调用成员函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum=&quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>进程4GB,线程eip</p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes, 	<span class="comment">//安全属性,一个废弃的参数,直接0</span></span></span><br><span class="line"><span class="params">    SIZE_T dwStackSize, 						<span class="comment">//栈空间分配大小,0</span></span></span><br><span class="line"><span class="params">    LPTHREAD_START_ROUTINE lpStartAddress, 		<span class="comment">//线程函数址</span></span></span><br><span class="line"><span class="params">    LPVOID lpParameter, 						<span class="comment">//线程处理函数的参数指针,</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags, 						<span class="comment">//线程的创建的方式.分为立即执行和休眠2钟方式</span></span></span><br><span class="line"><span class="params">    												<span class="comment">//立即执行是0</span></span></span><br><span class="line"><span class="params">    												<span class="comment">//挂起是CREATE_SUSPENDWD,线程在挂起状态下创建，直到调用 ResumeThread 才会恢复</span></span></span><br><span class="line"><span class="params">    LPDWORD lpThreadId 							<span class="comment">//返回线程的ID,可以选择不接受</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hThread =  CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Proc1, <span class="string">&quot;*********&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE                 hProcess, <span class="comment">//线程所属进程的进程句柄.</span></span></span><br><span class="line"><span class="params">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,<span class="comment">//线程的安全属性.</span></span></span><br><span class="line"><span class="params">  [in]  SIZE_T                 dwStackSize, <span class="comment">//线程堆栈大小，一般设置为0，表示使用默认的大小</span></span></span><br><span class="line"><span class="params">  [in]  LPTHREAD_START_ROUTINE lpStartAddress, <span class="comment">//线程函数的地址</span></span></span><br><span class="line"><span class="params">  [in]  LPVOID                 lpParameter, <span class="comment">//线程参数指针</span></span></span><br><span class="line"><span class="params">  [in]  DWORD                  dwCreationFlags, <span class="comment">//线程的创建标志</span></span></span><br><span class="line"><span class="params">  [out] LPDWORD                lpThreadId <span class="comment">//输出参数，记录创建的远程线程的ID,如果创建失败,该参数为NULL.</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">hThread = CreateRemoteThread(Target_Process, <span class="literal">NULL</span>, <span class="number">0</span>,pThreadProc, p_RemoteBuf_D, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<p>如果函数成功，则返回值是新线程的句柄。</p>
<p>如果函数失败，则返回值为<strong>NULL</strong>。</p>
<h2 id="线程处理函数"><a href="#线程处理函数" class="headerlink" title="线程处理函数"></a>线程处理函数</h2><p>线程处理函数,函数的返回值类型不能修改,函数的参数类型不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD CALLBACK Proc1(LPVOID pParam);</span><br></pre></td></tr></table></figure>

<p>LoadLibrary函数与线程处理函数的类型是一样的</p>
<p>使用类型转化,就可以实现把LoadLibrary当作线程处理函数</p>
<h2 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h2><p><strong>另开一个线程来退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">TerminateThread</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">  __inout  HANDLE hThread,</span></span><br><span class="line"><span class="params">  __in     DWORD dwExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//不会清理堆栈,为了后续的使用留了一手</span></span><br><span class="line"><span class="comment">//会清理自己的栈空间,堆不会清理,erminalThread是一个异步的调用,</span></span><br><span class="line">&#123;</span><br><span class="line">    TerminalThread()</span><br><span class="line">    code1</span><br><span class="line">    code2</span><br><span class="line">&#125;</span><br><span class="line">意味着TerminalThread函数要另外开一个线程来关闭线程</span><br><span class="line">那么的话,在TerminalThread()执行中,code1,code2就已经执行了</span><br></pre></td></tr></table></figure>



<p><strong>退出当前线程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VOID WINAPI <span class="title function_">ExitThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  DWORD dwExitCode <span class="comment">//这是线程处理函数的返回值,同时也是退出码</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ExitThread是一个同步的调用</span><br><span class="line">&#123;</span><br><span class="line">	ExitThread()</span><br><span class="line">	code1</span><br><span class="line">	code2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意识就是ExitThread()函数执行完,才会执行code1,code1</span></span><br></pre></td></tr></table></figure>









<h2 id="获取当前线程的句柄"><a href="#获取当前线程的句柄" class="headerlink" title="获取当前线程的句柄"></a>获取当前线程的句柄</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">GetCurrentThread</span><span class="params">()</span>;<span class="comment">//参数为0</span></span><br></pre></td></tr></table></figure>

<h2 id="获取当前线程的ID"><a href="#获取当前线程的ID" class="headerlink" title="获取当前线程的ID"></a>获取当前线程的ID</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD GetCurrentThreadId();//参数为空</span><br></pre></td></tr></table></figure>



<h2 id="句柄等待"><a href="#句柄等待" class="headerlink" title="句柄等待"></a>句柄等待</h2><p>阻塞函数</p>
<p><strong>WaitForSingleObject</strong></p>
<p>等待单个句柄有信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HANDLE hHandle,</span></span><br><span class="line"><span class="params">  [in] DWORD  dwMilliseconds</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(A_Handle_Of_Resource, INFINITE); </span><br><span class="line"><span class="comment">//参数1 要等待的句柄</span></span><br><span class="line"><span class="comment">//参数2 等待的时间</span></span><br><span class="line">	<span class="number">-1</span>==INFINIT,表示时间无限长,一直等待</span><br><span class="line">    等待实现是毫秒为单位</span><br><span class="line">        </span><br><span class="line">什么时候等待结束?</span><br><span class="line">    <span class="number">1.</span>事件信号被触发</span><br><span class="line">    <span class="number">2.</span>事件的时间等待超时了,我不想等了,直接退出阻塞</span><br><span class="line">    否则就一直阻塞</span><br></pre></td></tr></table></figure>



<p>返回类型</p>
<p>有三种返回类型：</p>
<p>WAIT_OBJECT_0 &#x3D;&#x3D;0       表示不再阻塞,对方有信号</p>
<p>WAIT_TIMEOUT &#x3D;0x102     表示等待指定时间内，对象一直没有信号,我继续阻塞</p>
<p>WAIT_ABANDONED 		 表示对象有信号，但还是不能执行  一般是因为未获取到锁或其他原因</p>
<p><strong>WaitForMultipleObjects</strong></p>
<p>等待多个句柄有信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">WaitForMultipleObjects</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">  __in  DWORD nCount, 				<span class="comment">//等候多少个句柄有信号</span></span></span><br><span class="line"><span class="params">  __in  <span class="type">const</span> HANDLE* lpHandles, 	<span class="comment">//句柄数组的地址</span></span></span><br><span class="line"><span class="params">  __in  BOOL bWaitAll, 				<span class="comment">//等候方式	</span></span></span><br><span class="line"><span class="params">    									<span class="comment">//TRUE,当所有的句柄都有信号的时候才会解除阻塞</span></span></span><br><span class="line"><span class="params">    									<span class="comment">//FALSE ,但凡有1个句柄有信号就会解除阻塞			</span></span></span><br><span class="line"><span class="params">  __in  DWORD dwMilliseconds 		<span class="comment">//最大等候时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>bWaitAll&#x3D; true  表示等待所有进程结束</p>
<p>bWaitAll&#x3D; false 表示其中一个进程结束就不再等待</p>
<pre><code>bWaitAll为TRUE时，			 返回WAIT_OBJECT_0 =0 代码所以内核对象都变成已通知
bWaitAll为FALSE时，		 返回最先变成已通知的内核对象在数组中的索引index														
WAIT_TIMEOUT(0x102)			超时				
</code></pre>
<h2 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">SuspendThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hThread <span class="comment">//线程句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ResumeThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hThread  <span class="comment">//线程句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h2><p>什么是上下文.就是一个环境罢了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONTEXT st_context; <span class="comment">//上下文结构体</span></span><br><span class="line">st_context.ContextFlags=CONTEXT_CONTROL;<span class="comment">//获取上下文的什么类型的内容</span></span><br><span class="line">st_context.Eip=<span class="number">0x00401000</span>;				<span class="comment">//获取的是CONTEXT_CONTROL内容的eip内容,然后修改他</span></span><br><span class="line">SetThreadContext(lp_Thread01,&amp;st_context);</span><br></pre></td></tr></table></figure>

<p>st_context.ContextFlags决定来st_context具体存储什么内容</p>
<p>SetThreadContext(lp_Thread01,&amp;st_context);是注入上下文</p>
<p><strong>SetThreadContext</strong></p>
<p>给线程的环境赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE        hThread, 	<span class="comment">//要设置其环境的线程的句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    							<span class="comment">//句柄必须具有线程的 THREAD_SET_CONTEXT访问权限。有关详细信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">const</span> CONTEXT *lpContext <span class="comment">//指向包含要在指定线程中设置的上下文的CONTEXT结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    							<span class="comment">//此结构的ContextFlags成员的值指定要设置线程上下文的哪些部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果设置了上下文，则返回值非零。</p>
<p>如果函数失败，则返回值为零。要获取扩展的错误信息</p>
<p><strong>GetThreadContext</strong></p>
<p>获取线程的环境</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      HANDLE    hThread, <span class="comment">//要检索其环境的线程的句柄,</span></span></span></span><br><span class="line"><span class="params"><span class="function">    							<span class="comment">//句柄还必须具有THREAD_QUERY_INFORMATION访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPCONTEXT lpContext <span class="comment">//向接收指定线程的适当上下文的CONTEXT</span></span></span></span><br><span class="line"><span class="params"><span class="function">    							<span class="comment">//此结构的ContextFlags成员的值指定检索线程上下文的哪些部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h1 id="线程资源分配"><a href="#线程资源分配" class="headerlink" title="线程资源分配"></a>线程资源分配</h1><p>在一个进程之内的资源访问,首选临界区</p>
<p>主要是很多个wait不好看,来个互斥体,会很整齐</p>
<p>互斥体</p>
<p>多个线程对于同一个资源的有序访问,这个挺好的,</p>
<p>事件</p>
<p>可以实现多个线程同时的读取一个资源,而不是写入</p>
<p>也可以实现多个线程对同一个资源的有序访问,相当于互斥体</p>
<p>信号量</p>
<p>它基于事件,限制了事件的次数,可以精确控制信号发出的个数</p>
<p>事件和信号量没有太大的区别</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>对应的结构体</p>
<p>CRITICAL_SECTION cs</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span> &#123;</span>		</span><br><span class="line">    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;		</span><br><span class="line">    LONG LockCount;		</span><br><span class="line">    LONG RecursionCount;		</span><br><span class="line">    HANDLE OwningThread;       		</span><br><span class="line">    HANDLE LockSemaphore;		</span><br><span class="line">    DWORD SpinCount;		</span><br><span class="line">&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;</span><br></pre></td></tr></table></figure>





<p>使用的流程</p>
<ol>
<li></li>
</ol>
<p>创建一个全局的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION cs;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitializeCriticalSection(&amp;cs);//使用前必须初始化结构体</span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EnterCriticalSection(&amp;cs);//获取令牌</span><br><span class="line">LeaveCriticalSection(&amp;cs);//丢弃令牌	</span><br></pre></td></tr></table></figure>

<ol start="4">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DeleteCriticalSection(&amp;g_cs);//使用后销毁</span><br></pre></td></tr></table></figure>



<p>‪代码示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">D:/JGY/P0st/post/Language/Win32/Code/线程资源分配/临界区<span class="number">1.</span>c</span><br></pre></td></tr></table></figure>



<h2 id="互斥加锁"><a href="#互斥加锁" class="headerlink" title="互斥加锁"></a>互斥加锁</h2><p>多个线程对于同一个资源的有序访问</p>
<p>创建互斥</p>
<p>解决多个线程下对同一个代码资源的共享问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in_opt  	LPSECURITY_ATTRIBUTES lpMutexAttributes, <span class="comment">//安全属性,垃圾,NULL	</span></span></span><br><span class="line"><span class="params">  __in      	BOOL bInitialOwner,</span></span><br><span class="line"><span class="params">            		<span class="comment">//true 互斥信号这属于当前线程</span></span></span><br><span class="line"><span class="params">            		<span class="comment">//false 互斥信号不属于任何人</span></span></span><br><span class="line"><span class="params">  __in_opt  LPCTSTR lpName <span class="comment">//互斥的字符串名字,随便取</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//返回线程句柄的东西,就是创建了一个内存空间</span></span><br><span class="line"><span class="comment">//也就是这个空间最后是要释放的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_hMUtex=CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="string">&quot;HB&quot;</span>);</span><br></pre></td></tr></table></figure>





<p>通常,我们让 bInitialOwner&#x3D;FALSE</p>
<p>因为这样实现了在任意地方创建,可以在任意地方获取</p>
<p>如果是TRUE的话,就让该互斥体只属于了该线程,显得不那么灵活</p>
<p>坐等互斥信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WaitForSingleObject(hHandle);</span><br></pre></td></tr></table></figure>

<p>WaitForSingleObject()相当于进入互斥区</p>
<p>互斥信号的释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">ReleaseMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hMutex <span class="comment">//创建互斥的时候返回的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>句柄的关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CloseHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hObject</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OpenMutex Function</p>
<p>打开互斥体,常用于进程之间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">OpenMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  DWORD dwDesiredAccess,</span></span><br><span class="line"><span class="params">  __in  BOOL bInheritHandle,</span></span><br><span class="line"><span class="params">  __in  LPCTSTR lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>实例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:/JGY/P0st/post/Language/Win32/Code/线程资源分配/互斥体/进程之间</span><br></pre></td></tr></table></figure>

<p>如果同时执行2个项目,</p>
<p>那么项目B执行完CreateMutex</p>
<p>项目A是可以打开项目B的互斥体的</p>
<p>临界区可以实现在一个进程里,多个线程之间对同一个资源的互斥访问</p>
<p>互斥体可以实现多个进程的不同线程中对同一个资源资源的互斥访问</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>可以实现多个线程同时的读取一个资源,而不是写入</p>
<p>也可以实现多个线程对同一个资源的有序访问,相当于互斥体</p>
<p>为什么创建互斥体可以实现进程之间的访问??</p>
<p>因为互斥体是内核对象,所以通过红色的内核对象桥梁,就可以实现进程之间的通信</p>
<p>创建事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateEvent</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">  __in_opt  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">//安全属性,直接设置为NULL就可</span></span></span><br><span class="line"><span class="params">  __in      BOOL bManualReset, </span></span><br><span class="line"><span class="params">    				<span class="comment">//有信号-&gt;无信号的过程</span></span></span><br><span class="line"><span class="params">    				<span class="comment">//TRUE  手动控制,也就是需要手动关闭信号,发展无法关闭信号,resetevent</span></span></span><br><span class="line"><span class="params">    				<span class="comment">//FALSE 自动控制,也就是WaitForSingleObject后,自动的变为无信号,于是需要手动发信号 setevent</span></span></span><br><span class="line"><span class="params">  __in      BOOL bInitialState,<span class="comment">//事件的状态</span></span></span><br><span class="line"><span class="params">    				<span class="comment">//true  一创建就有信号,别人可以通过wait获取 waitforsingleobject</span></span></span><br><span class="line"><span class="params">    				<span class="comment">//false 一开始没信号,也就是别人和自己都无法wait得到,必须有人setevent</span></span></span><br><span class="line"><span class="params">  __in_opt  LPCTSTR lpName <span class="comment">//事件的字符串名字</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>PS:最好不要不要去手动复位,而要自动复位,那样会存在一个线程安全的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL bManualReset, 有信号-&gt;无信号的过程</span><br><span class="line"></span><br><span class="line">	TRUE   手动控制 ,如果不去手动干扰的话,信号一旦发出,就会一直存在,适用于多个线程并发的读取一个资源</span><br><span class="line"></span><br><span class="line">	注意是读取一个资源,可以写TRUE, 写入, 一定不TRUE</span><br><span class="line"></span><br><span class="line">	FALSE 自动控制,也就是WaitForSingleObject接触阻塞后,自动的变为无信号,信号消失</span><br></pre></td></tr></table></figure>







<p>发送的信号</p>
<p>信号 无-&gt;有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">SetEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hEvent <span class="comment">//创建事件时返回的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>消除已有的信号</p>
<p>信号 有-&gt;无</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">ResetEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  HANDLE hEvent <span class="comment">//创建事件时返回的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>线程的死锁,有必要了解一下,可以出题</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>除了事件,还有信号量可以解决事件问题</p>
<p>它基于事件,限制了事件的次数</p>
<p>创建信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateSemaphore</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in_opt  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, <span class="comment">//安全属性,NULL</span></span></span><br><span class="line"><span class="params">  __in      LONG InitialCount, 		<span class="comment">//可以解除wait阻塞的初始化次数</span></span></span><br><span class="line"><span class="params">    								<span class="comment">//当InitialCount=5,可以无条件通过wait,相当于有信号,每通过一次,就InitialCount--.少1</span></span></span><br><span class="line"><span class="params">    								<span class="comment">//当lInitialCoun=0,无法通过</span></span></span><br><span class="line"><span class="params">  __in      LONG lMaximumCount, 	<span class="comment">//信号量的可设置的最大个数</span></span></span><br><span class="line"><span class="params">  __in_opt  LPCTSTR lpName		 	<span class="comment">//信号量的字符串名字</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它也拥有可等候的信号句柄</p>
<p>打开信号量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HANDLE OpenSemaphore(		</span><br><span class="line">		</span><br><span class="line">  DWORD dwDesiredAccess,		</span><br><span class="line">		</span><br><span class="line">  BOOL bInheritHandle,		</span><br><span class="line">		</span><br><span class="line">  LPCTSTR lpName		</span><br><span class="line">		</span><br><span class="line">);		</span><br></pre></td></tr></table></figure>

<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g_hSemaphore = CreateSemaphore(NULL,0,3,NULL);		</span><br></pre></td></tr></table></figure>



<p>函数说明：		</p>
<p>第一个参数表示访问权限，对一般传入SEMAPHORE_ALL_ACCESS。详细解释可以查看MSDN文档。		</p>
<p>第二个参数表示信号量句柄继承性，一般传入FALSE即可。		</p>
<p>第三个参数表示名称，不同进程中的各线程可以通过名称来确保它们访问同一个信号量。		</p>
<p>​			</p>
<p>给信号量指定数量,释放信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">ReleaseSemaphore</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in       HANDLE hSemaphore, <span class="comment">//信号量句柄,创建信号返回的句柄</span></span></span><br><span class="line"><span class="params">  __in       LONG lReleaseCount, <span class="comment">//新的信号量数量</span></span></span><br><span class="line"><span class="params">  __out_opt  LPLONG lpPreviousCount <span class="comment">//一个指针,返回原来剩余的信号量</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ReleaseSemaphore 就让信号量处于一定的数量</p>
<p>WaitforSinglesObject 可以让信号量–</p>
<p>最后CloseHandle</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="创建一个进程"><a href="#创建一个进程" class="headerlink" title="创建一个进程"></a>创建一个进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in_opt     LPCTSTR lpApplicationName, <span class="comment">//应用程序的字符串名字</span></span></span><br><span class="line"><span class="params">  __inout_opt  LPTSTR lpCommandLine,	<span class="comment">//对应的命令行参数</span></span></span><br><span class="line"><span class="params">  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//与CreateProcess创建的进程的进程句柄是否可以继承有关</span></span></span><br><span class="line"><span class="params">  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// 与CreateProcess创建的进程的线程句柄是否可以继承有关</span></span></span><br><span class="line"><span class="params">  __in         BOOL bInheritHandles, <span class="comment">//创建子进程的时候,是否[需要]继承父进程的句柄表中能够继承的部分,</span></span></span><br><span class="line"><span class="params">    								<span class="comment">//只有那些父进程句柄表中安全属性结构体SECURITY_ATTRIBUTES::bInheritHandle = TRUE;</span></span></span><br><span class="line"><span class="params">    								<span class="comment">//子进程创建的时候,参数5 InheritHandles=true,才代表一定传递下去</span></span></span><br><span class="line"><span class="params">  __in         DWORD dwCreationFlags, <span class="comment">//出现的形式,如果为null,子进程将会使用父进程的控制台</span></span></span><br><span class="line"><span class="params">  __in_opt     LPVOID lpEnvironment,</span></span><br><span class="line"><span class="params">  __in_opt     LPCTSTR lpCurrentDirectory,<span class="comment">//如果为NULL,那么子进程的argv[0]将会是父进程的地址,你可以为子进程指定一个字符串地址</span></span></span><br><span class="line"><span class="params">  __in         LPSTARTUPINFO lpStartupInfo, <span class="comment">//exe以怎样的方式出现</span></span></span><br><span class="line"><span class="params">  __out        LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//会返回 进程句柄	,主线程句柄	,进程ID   ,线程ID</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>创建进程实例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">D:/JGY/P0st/post/Language/Win32/Code/进程/直接创建进程/<span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>





<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><p>我现在还没有办法获取火绒或者360的进程句柄,也就无法关闭它</p>
<p>为什么无法获取那个句柄</p>
<p>这可能和权限有关把</p>
<p>终止进程的三种方式：										</p>
<p>1、VOID　ExitProcess(UINT fuExitCode)	&#x2F;&#x2F;进程自己调用			</p>
<p>2、BOOL TerminateProcess(HANDLE hProcess, UINT fuExitCode);	&#x2F;&#x2F;终止其他进程			</p>
<p>3、ExitThread			&#x2F;&#x2F;终止进程中的所有线程，进程也会终止</p>
<p>​	</p>
<h2 id="继承事件句柄"><a href="#继承事件句柄" class="headerlink" title="继承事件句柄"></a>继承事件句柄</h2><p>​					</p>
<p>通过进程的内核句柄表,实现事件句柄的继承给子进程</p>
<p>项目A中句柄表中的事件句柄直接继承到了项目B的句柄表中</p>
<p>项目B直接可以使用那个对应的句柄</p>
<p>项目A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Console02.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">// vs2010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qdll.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">	testA();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> sz_Buffer[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;							</span><br><span class="line">	<span class="type">char</span> sz_Handle[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;							</span><br><span class="line">	HANDLE hEvent =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	SECURITY_ATTRIBUTES sa;</span><br><span class="line">	STARTUPINFO si = &#123;<span class="number">0</span>&#125;;   							</span><br><span class="line">	PROCESS_INFORMATION pi;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//三个成员的意义：大小、默认安全属性、是否可以继承		</span></span><br><span class="line">	sa.nLength = <span class="keyword">sizeof</span>(sa);							</span><br><span class="line">	sa.lpSecurityDescriptor = <span class="literal">NULL</span>;							</span><br><span class="line">	sa.bInheritHandle = TRUE; </span><br><span class="line">	<span class="comment">//创建一个可以被继承的内核对象							</span></span><br><span class="line">	hEvent = CreateEvent(&amp;sa, TRUE, FALSE, <span class="literal">NULL</span>);		</span><br><span class="line"></span><br><span class="line">	<span class="comment">//组织命令行参数	让另外一个exe获取我们的句柄参数		</span></span><br><span class="line">	qzero(sz_Buffer,<span class="number">64</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(sz_Buffer,<span class="string">&quot;D:/Console.exe %#x&quot;</span>,hEvent);							</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义创建进程需要用的结构体														</span></span><br><span class="line">	si.cb = <span class="keyword">sizeof</span>(si);													</span><br><span class="line">	CreateProcess(<span class="literal">NULL</span>, sz_Buffer, 						</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, 						</span><br><span class="line">		TRUE, 				<span class="comment">//TRUE的时候，说明我的子进程可以继承父进程的句柄表		</span></span><br><span class="line">		CREATE_NEW_CONSOLE, 						</span><br><span class="line">		<span class="literal">NULL</span>,<span class="literal">NULL</span>, &amp;si, &amp;pi); 						</span><br><span class="line"></span><br><span class="line">	SetEvent(hEvent);		<span class="comment">//设置事件为已通知	,观察子进程是否可以正常的使用父进程的事件句柄</span></span><br><span class="line">	CloseHandle(hEvent);   <span class="comment">//关闭句柄 无论你CloseHandle,内核对象都不会被销毁 								</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>项目B</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>		</span><br><span class="line">&#123;		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> sz_Handle[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;						</span><br><span class="line">	DWORD dw_Handle = <span class="number">0</span>;		</span><br><span class="line">	<span class="built_in">memcpy</span>(sz_Handle,argv[<span class="number">1</span>],<span class="number">8</span>);	<span class="comment">//	从另外一个获取的参数		</span></span><br><span class="line">	<span class="built_in">sscanf</span>(sz_Handle,<span class="string">&quot;%x&quot;</span>,&amp;dw_Handle);						</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %#x/n&quot;</span>,argv[<span class="number">0</span>],dw_Handle);					</span><br><span class="line">	HANDLE g_hEvent = (HANDLE)dw_Handle;						</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;开始等待...../n&quot;</span>);							</span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);	<span class="comment">//当事件变成已通知时						</span></span><br><span class="line">	DWORD dwCode = GetLastError();						</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等到消息.....%x/n&quot;</span>,dwCode);						</span><br><span class="line">	getchar();			</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>项目B生产的exe放在了D盘根目录</p>
<p>单步调试项目A</p>
<p>出现了2个进程,一个是父进程,一个是子进程</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220729210314519.png" alt="image-20220729210314519"></p>
<p>子进程在等待父进程发出信号</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220729210351392.png" alt="image-20220729210351392"></p>
<p>​				</p>
<p>当父进程SetEvent后,子进程等待结束</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220729210440652.png" alt="image-20220729210440652"></p>
<p>​						</p>
<h2 id="继承线程句柄和进程句柄"><a href="#继承线程句柄和进程句柄" class="headerlink" title="继承线程句柄和进程句柄"></a>继承线程句柄和进程句柄</h2><p>创建一个进程</p>
<p>会生成句柄表</p>
<p>会生成<code>进程</code>的内核对象和<code>线程</code>的内核对象</p>
<p>在句柄表中有这2个内核对象的信息</p>
<p>如果创建进程的时候,你的第3&#x2F;4个参数是NULL,那么你的进程的句柄表中的<code>线程内核对象和进程内核对象</code>就无法继承</p>
<p>其实就是关于是否可以继承 <code>进程句柄和线程句柄</code>的2个参数</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220729211858229.png" alt="image-20220729211858229"></p>
<p>只有当</p>
<p>参数3&#x2F;4中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES SA_Process;							</span><br><span class="line">SA_Process.nLength = sizeof(SA_Process);							</span><br><span class="line">SA_Process.lpSecurityDescriptor = NULL;							</span><br><span class="line">SA_Process.bInheritHandle = TRUE; 	//可以继承进程句柄							</span><br><span class="line">							</span><br><span class="line">SECURITY_ATTRIBUTES SA_Thread;							</span><br><span class="line">SA_Thread.nLength = sizeof(SA_Thread);							</span><br><span class="line">SA_Thread.lpSecurityDescriptor = NULL;							</span><br><span class="line">SA_Thread.bInheritHandle = TRUE; 	//可以继承线程句柄						</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>那么才会可以继承的条件,至于是否被真的继承,取决于参数5<code>BOOL bInheritHandles, </code>  </p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220729211637470.png" alt="image-20220729211637470"></p>
<p>项目A控制项目B,项目B控制项目A的另外一个子进程</p>
<p>项目A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// vs2010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>		</span><br><span class="line">&#123;		</span><br><span class="line"></span><br><span class="line">	SECURITY_ATTRIBUTES st_IE_SA_Process;	</span><br><span class="line">	SECURITY_ATTRIBUTES st_IE_SA_Thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STARTUPINFO st_IE_Start_Info = &#123;<span class="number">0</span>&#125;;   								</span><br><span class="line">	PROCESS_INFORMATION st_IE_Process_Info;	</span><br><span class="line"></span><br><span class="line">	STARTUPINFO st_Child2_Start_Info = &#123;<span class="number">0</span>&#125;;   								</span><br><span class="line">	PROCESS_INFORMATION st_Chind2_Process_Info;		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> sz_Cmdline_IE[] =<span class="string">&quot;c://program files//internet explorer//iexplore.exe&quot;</span>;		</span><br><span class="line">	<span class="type">char</span> sz_CmdLine_Child2[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;			</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	st_IE_SA_Process.nLength = <span class="keyword">sizeof</span>(st_IE_SA_Process);								</span><br><span class="line">	st_IE_SA_Process.lpSecurityDescriptor = <span class="literal">NULL</span>;								</span><br><span class="line">	st_IE_SA_Process.bInheritHandle = TRUE; 								</span><br><span class="line"></span><br><span class="line">								</span><br><span class="line">	st_IE_SA_Thread.nLength = <span class="keyword">sizeof</span>(st_IE_SA_Thread);								</span><br><span class="line">	st_IE_SA_Thread.lpSecurityDescriptor = <span class="literal">NULL</span>;								</span><br><span class="line">	st_IE_SA_Thread.bInheritHandle = TRUE; 		</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">	st_IE_Start_Info.cb = <span class="keyword">sizeof</span>(st_IE_Start_Info);	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	CreateProcess(								</span><br><span class="line">		<span class="literal">NULL</span>,sz_Cmdline_IE, 							</span><br><span class="line">		&amp;st_IE_SA_Process, 	&amp;st_IE_SA_Thread, <span class="comment">// 代表我的线程句柄和进程句柄可以被别人被继承,不一定是儿子	,下面被同级的子进程给继承了				</span></span><br><span class="line">		FALSE, 								<span class="comment">//代表我不想继承父亲的中可以被继承的句柄				</span></span><br><span class="line">		CREATE_NEW_CONSOLE, 							</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">		&amp;st_IE_Start_Info, &amp;st_IE_Process_Info); 							</span><br><span class="line">	</span><br><span class="line">					</span><br><span class="line">	<span class="built_in">sprintf</span>(sz_CmdLine_Child2,<span class="string">&quot;D:/Console.exe		%#x		%#x&quot;</span>,st_IE_Process_Info.hProcess,st_IE_Process_Info.hThread);		</span><br><span class="line">	st_Child2_Start_Info.cb = <span class="keyword">sizeof</span>(st_Child2_Start_Info);														</span><br><span class="line">	BOOL res = CreateProcess(								</span><br><span class="line">		<span class="literal">NULL</span>, sz_CmdLine_Child2, 							</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, 							</span><br><span class="line">		TRUE, <span class="comment">//代表我想继承父亲的中可以被继承的句柄	,于是我创建的子进程就可以对我父进程创建的IE进程进行操作						</span></span><br><span class="line">		CREATE_NEW_CONSOLE, 							</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">		&amp;st_Child2_Start_Info, &amp;st_Chind2_Process_Info); 							</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p>项目B</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Console02.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">// vs210</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	DWORD dw_IE_Process_Handle = <span class="number">0</span>;							</span><br><span class="line">	DWORD dw_IE_Thread_Handle = <span class="number">0</span>;							</span><br><span class="line">	<span class="type">char</span> sz_tmp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;							</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(sz_tmp,argv[<span class="number">1</span>],<span class="number">10</span>);							</span><br><span class="line">	<span class="built_in">sscanf</span>(sz_tmp,<span class="string">&quot;%x&quot;</span>,&amp;dw_IE_Process_Handle);							</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(sz_tmp,<span class="number">0</span>,<span class="number">256</span>);							</span><br><span class="line">	<span class="built_in">memcpy</span>(sz_tmp,argv[<span class="number">2</span>],<span class="number">10</span>);							</span><br><span class="line">	<span class="built_in">sscanf</span>(sz_tmp,<span class="string">&quot;%x&quot;</span>,&amp;dw_IE_Thread_Handle);							</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IE进程:,IE线程:/n&quot;</span>,dw_IE_Process_Handle,dw_IE_Thread_Handle);		</span><br><span class="line"></span><br><span class="line">										</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;挂起Thread_IE&quot;</span>);	</span><br><span class="line">	Sleep(<span class="number">1000</span>*<span class="number">5</span>);		</span><br><span class="line">	::SuspendThread((HANDLE)dw_IE_Thread_Handle);		<span class="comment">//挂起主线程						</span></span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>*<span class="number">5</span>);												</span><br><span class="line">	::ResumeThread((HANDLE)dw_IE_Thread_Handle);		<span class="comment">//恢复主线程						</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;恢复Thread_IE&quot;</span>);							</span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>*<span class="number">5</span>);							</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭IE进程							</span></span><br><span class="line">	::TerminateProcess((HANDLE)dw_IE_Process_Handle,<span class="number">1</span>);	</span><br><span class="line"></span><br><span class="line">	::WaitForSingleObject((HANDLE)dw_IE_Process_Handle, INFINITE);							</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;IE over ..........&quot;</span>);							</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="挂起的方式创建一个进程"><a href="#挂起的方式创建一个进程" class="headerlink" title="挂起的方式创建一个进程"></a>挂起的方式创建一个进程</h2><p>在挂起的方式创建一个进程的时候,进程只是分配了4G的空间</p>
<p>还没有加载数据,内存占用小</p>
<p>于是你可以在这里偷梁换柱,加载你需要的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//vs2010</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test1();	</span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;					</span><br><span class="line"></span><br><span class="line">	STARTUPINFO st_Start_Info = &#123;<span class="number">0</span>&#125;;   									</span><br><span class="line">	PROCESS_INFORMATION st_Notepad_Process_Info;									</span><br><span class="line">	st_Start_Info.cb = <span class="keyword">sizeof</span>(st_Start_Info);									</span><br><span class="line"></span><br><span class="line">							</span><br><span class="line">	TCHAR sz_Tmp[<span class="number">256</span>] = <span class="string">&quot;D:/notepad.exe&quot;</span>;									</span><br><span class="line">	CreateProcess(									</span><br><span class="line">		<span class="literal">NULL</span>,                    							</span><br><span class="line">		sz_Tmp,               							</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>,  		            				</span><br><span class="line">		FALSE,                   							</span><br><span class="line">		CREATE_SUSPENDED,    <span class="comment">//挂起一个进程 							</span></span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>,                  						</span><br><span class="line">		&amp;st_Start_Info, &amp;st_Notepad_Process_Info                						</span><br><span class="line">		);								</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CONTEXT contx;  									</span><br><span class="line">	contx.ContextFlags = CONTEXT_FULL; <span class="comment">// look all info 									</span></span><br><span class="line">	GetThreadContext(st_Notepad_Process_Info.hThread, &amp;contx);		</span><br><span class="line">	<span class="comment">//获取入口点									</span></span><br><span class="line">	DWORD dw_EntryPoint = contx.Eax;									</span><br><span class="line">	<span class="comment">//获取ImageBase									</span></span><br><span class="line">	<span class="type">char</span>* st_PEB = (CHAR *) contx.Ebx+<span class="number">8</span>;									</span><br><span class="line">	<span class="built_in">memset</span>(sz_Tmp,<span class="number">0</span>,<span class="number">256</span>);									</span><br><span class="line">	ReadProcessMemory(st_Notepad_Process_Info.hProcess,st_PEB,sz_Tmp,<span class="number">4</span>,<span class="literal">NULL</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;EP: %#x ImageBae:%#x %#x&quot;</span>,dw_EntryPoint,st_PEB ,*((DWORD*)sz_Tmp));</span><br><span class="line"></span><br><span class="line">	ResumeThread(st_Notepad_Process_Info.hThread);	<span class="comment">//恢复进程	</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h2><p>OpenProcess </p>
<p>位置：Kernel32.dll</p>
<p>OpenProces 打开现有的本地进程对象。 ，并返回进程的句柄。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwDesiredAccess, <span class="comment">//渴望得到的访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL  bInheritHandle, <span class="comment">//表示所得到的进程句柄是否可以被继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId  <span class="comment">//被打开进程的PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    &#x2F;&#x2F;参数 访问权限,是否可继承，访问进程的PID<br>​    &#x2F;&#x2F;效果 打开某个exe,然后根据访问权限去干坏事<br>​    &#x2F;&#x2F;返回值 成功就返回进程的PID  失败就返回NULL</p>
<p>返回值</p>
<p>如成功，返回值为指定进程的句柄。</p>
<p>如失败，返回值为NULL，可调用GetLastError()获得错误代码。</p>
<h2 id="获取进程退出码"><a href="#获取进程退出码" class="headerlink" title="获取进程退出码"></a>获取进程退出码</h2><p>GetExitCodeProcess</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">GetExitCodeProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  hProcess, <span class="comment">//进程句柄</span></span></span><br><span class="line"><span class="params">  [out] LPDWORD lpExitCode <span class="comment">//进程句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="当前进程路径获取"><a href="#当前进程路径获取" class="headerlink" title="当前进程路径获取"></a>当前进程路径获取</h2><p>GetModuleFileNameA</p>
<p>检获取当前进程已加载模块的文件的完整<a href="https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84/1081474">路径</a>，该模块必须由当前进程加载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleFileNameA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HMODULE hModule, <span class="comment">//装载一个程序实例的句柄。如果该参数为NULL，该函数返回该当前应用程序全路径。</span></span></span><br><span class="line"><span class="params">  [out]          LPSTR   lpFilename, <span class="comment">//是你存放返回的名字的内存块的指针，是一个输出参数</span></span></span><br><span class="line"><span class="params">  [in]           DWORD   nSize  <span class="comment">//lpFilename缓冲区的大小，以TCHARs为单位。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<p>如果函数运行成功，返回值为字符串的长度。包含了空字符</p>
<p>如果字符串的长度大于nSize字节，返回值为nSize。包含了空字符</p>
<p>如果函数运行失败，返回值为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> Exe_Path[_MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">	<span class="built_in">GetModuleFileNameA</span>(<span class="literal">NULL</span>, Exe_Path, MAX_PATH);</span><br><span class="line">	cout &lt;&lt; Exe_Path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后他会输出当前cpp代码完整的exe路径</p>
<h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>VirtualAllocEx() 内存内分配内存</p>
<p>指定进程的虚拟空间保留或提交内存区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPVOID <span class="title function_">VirtualAllocEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           HANDLE hProcess, <span class="comment">//申请内存所在的进程句柄</span></span></span><br><span class="line"><span class="params">  [in, optional] LPVOID lpAddress, <span class="comment">//保留页面的内存地址；一般用NULL自动分配 。</span></span></span><br><span class="line"><span class="params">  [in]           SIZE_T dwSize, <span class="comment">//欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍</span></span></span><br><span class="line"><span class="params">  [in]           DWORD  flAllocationType, <span class="comment">//内存分配的类型</span></span></span><br><span class="line"><span class="params">  [in]           DWORD  flProtect <span class="comment">//页面区域的内存保护</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>返回值</p>
<p>如果函数成功，则返回值是分配的页面区域的基地址。</p>
<p>如果函数失败，则返回值为<strong>NULL</strong>。要获取扩展的错误信息，</p>
<h2 id="向进程写入数据"><a href="#向进程写入数据" class="headerlink" title="向进程写入数据"></a>向进程写入数据</h2><p>WriteProcessMemory</p>
<p>将数据写入指定进程中的内存区域。要写入的整个区域必须可访问，否则操作将失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  hProcess, 			<span class="comment">//由OpenProcess返回的进程句柄。</span></span></span><br><span class="line"><span class="params">  [in]  LPVOID  lpBaseAddress, 		<span class="comment">//指向要写入数据的指定进程中的基地址的指针 ,进程的基地址 D</span></span></span><br><span class="line"><span class="params">　　									<span class="comment">//再写入之前，此函数将先检查目标地址是否可用，并能容纳待写入的数据。</span></span></span><br><span class="line"><span class="params">  [in]  LPCVOID lpBuffer,				<span class="comment">//指向要写的数据来源的指针。 S</span></span></span><br><span class="line"><span class="params">  [in]  SIZE_T  nSize,			 		<span class="comment">//要写入的字节数。</span></span></span><br><span class="line"><span class="params">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>返回值</p>
<p>非零值代表成功。</p>
<p>他是一个复合的API</p>
<p>细节流程如下</p>
<ol>
<li>首先调用 NtQueryVirtualMemory 查询内存信息</li>
<li>如果原内存属性可写，直接调用 NtWriteVirtualMemory 写入内存</li>
<li>如果原内存属性不可执行，则还原内存属性，然后返回 STATUS_ACCESS_VIOLATION</li>
<li>如果内存类型为 MEM_IMAGE，则修改内存属性为 OldAccessProtection | PAGE_ENCLAVE_UNVALIDATED | PAGE_EXECUTE_WRITECOPY</li>
<li>如果内存类型为 MEM_PRIVATE，则修改内存属性为 OldAccessProtection | OldAccessProtection | PAGE_EXECUTE_READWRITE</li>
<li>调用NtWriteVirtualMemory写入内存</li>
<li>还原内存属性</li>
</ol>
<h2 id="在进程中读取数据"><a href="#在进程中读取数据" class="headerlink" title="在进程中读取数据"></a>在进程中读取数据</h2><p><strong>ReadProcessMemory</strong></p>
<p>将<code>指定地址范围内的Source数据</code>从指定进程的地址空间<code>copy</code>到<code>当前进程的指定缓冲区Destation中。</code></p>
<p>任何具有 PROCESS_VM_READ 访问句柄的进程都可以调用该函数。</p>
<p>要读取的整个区域必须是可访问的，如果不可访问，则函数失败</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess, 				<span class="comment">//远程进程句柄。 被读取者</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBaseAddress, 			<span class="comment">//远程进程中内存地址。 从具体何处读取 S</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPVOID  lpBuffer, 				<span class="comment">//本地进程中内存地址. 存放读取数据缓冲区； D</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize, 					<span class="comment">//一次读取的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesRead 	<span class="comment">//实际读取的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<p>如果函数成功，则返回值非零。</p>
<p>如果函数失败，则返回值为 0（零）。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p>
<p>如果请求的读取操作进入进程中不可访问的区域，则该函数将失败。</p>
<h2 id="设置进程一段内存的属性"><a href="#设置进程一段内存的属性" class="headerlink" title="设置进程一段内存的属性"></a>设置进程一段内存的属性</h2><p>VirtualProtect</p>
<p>它会在呼叫处理程序的虚拟位置空间里，变更认可页面区域上的保护</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID lpAddress,  <span class="comment">// 内存的起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T dwSize,  <span class="comment">//要保护的内存大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD  flNewProtect, <span class="comment">//新的内存属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PDWORD lpflOldProtect <span class="comment">//&amp;内存的原始属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>如果函数成功，则返回值非零。</p>
<p>如果函数失败，则返回值为零。要获取扩展的错误信息，请调用GetLastError</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PAGE_READONLY 0x02//该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访问</span><br><span class="line">PAGE_READWRITE 0x04//区域可被应用程序读写</span><br><span class="line">PAGE_EXECUTE  0x10//区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。</span><br><span class="line">PAGE_EXECUTE_READ 0x20//区域包含可执行代码，应用程序可以读该区域</span><br><span class="line">PAGE_EXECUTE_READW //区域包含可执行代码，应用程序可以读写该区域</span><br><span class="line">PAGE_GUARD 0x100//区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限</span><br><span class="line">PAGE_NOACCESS 0x01//任何访问该区域的操作将被拒绝</span><br><span class="line">PAGE_NOCACHE 0x200//RAM中的页映射到该区域时将不会被微处理器缓存（cached)</span><br></pre></td></tr></table></figure>



<h2 id="枚举窗口句柄"><a href="#枚举窗口句柄" class="headerlink" title="枚举窗口句柄"></a>枚举窗口句柄</h2><p>EnumWindows</p>
<p>该函数枚举所有屏幕上的顶层窗口，并将<a href="https://baike.baidu.com/item/%E7%AA%97%E5%8F%A3%E5%8F%A5%E6%9F%84">窗口句柄</a>传送给应用程序定义的<a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</a>。</p>
<p>回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumWindows</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] WNDENUMPROC lpEnumFunc, <span class="comment">//处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPARAM      lParam <span class="comment">//指定一个传递给回调函数的应用程序定义值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>该API会枚举所有进程&#x2F;窗口,然乎调用你的处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">BOOL CALLBACK <span class="title function_">EnumOpenWindow_Proc</span><span class="params">(HWND hWnd,LPARAM lParam)</span>  								</span><br><span class="line">&#123;  								</span><br><span class="line">	<span class="type">char</span> szTitle[MAX_PATH];</span><br><span class="line">	<span class="built_in">memset</span>(szTitle,<span class="number">0</span>,<span class="number">256</span>);</span><br><span class="line">	GetWindowText(hWnd,szTitle,MAX_PATH); 								</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,szTitle,<span class="string">&quot;[窗口]&quot;</span>,MB_OK);  								</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(szTitle,<span class="string">&quot;ipmsg_feige&quot;</span>) == <span class="number">0</span>)							</span><br><span class="line">	&#123;							</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szTitle,<span class="string">&quot;[窗口]&quot;</span>,MB_OK);  						</span><br><span class="line">		<span class="keyword">return</span> FALSE;						</span><br><span class="line">	&#125;							</span><br><span class="line">	<span class="keyword">return</span> TRUE;  								</span><br><span class="line">&#125;  								</span><br><span class="line">VOID <span class="title function_">function</span><span class="params">()</span>								</span><br><span class="line">&#123;								</span><br><span class="line">	EnumWindows(EnumOpenWindow_Proc,<span class="literal">NULL</span>);							</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	function();		</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举子窗口句柄"><a href="#枚举子窗口句柄" class="headerlink" title="枚举子窗口句柄"></a>枚举子窗口句柄</h2><p>EnumChildWindows(hWnd,EnumChildProc,0);  				</p>
<p>此函数相当于创建了一个进程,进程主要的操作是便利子窗口,便利后把子窗口的句柄给处理函数</p>
<p>进程的处理函数就是你的指定的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CALLBACK <span class="title function_">EnumChildProc</span><span class="params">(HWND hWnd,LPARAM lParam)</span>  									</span><br><span class="line">&#123;  									</span><br><span class="line">	TCHAR szTitle[MAX_PATH] = &#123;<span class="number">0</span>&#125;;									</span><br><span class="line">	GetWindowText(hWnd,szTitle,MAX_PATH); 									</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,szTitle,<span class="string">&quot;[子窗口]&quot;</span>,MB_OK);  									</span><br><span class="line">	<span class="keyword">return</span> TRUE;  									</span><br><span class="line">&#125;  									</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">EnumChildWindow</span><span class="params">()</span>									</span><br><span class="line">&#123;									</span><br><span class="line">	<span class="type">char</span> szTitle[MAX_PATH] = &#123;<span class="number">0</span>&#125;;								</span><br><span class="line">	HWND hWnd = FindWindow(TEXT(<span class="string">&quot;Afx:00007FF6C8270000:0&quot;</span>),TEXT(<span class="string">&quot;Lingoes 灵格斯&quot;</span>));								</span><br><span class="line">	<span class="keyword">if</span>(hWnd != <span class="literal">NULL</span>)															</span><br><span class="line">		EnumChildWindows(hWnd,EnumChildProc,<span class="number">0</span>);  												</span><br><span class="line">	<span class="keyword">else</span>																</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="string">&quot;[ERROR]&quot;</span>),MB_OK);															</span><br><span class="line">&#125;									</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	EnumChildWindow();			</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="获取窗口句柄"><a href="#获取窗口句柄" class="headerlink" title="获取窗口句柄"></a>获取窗口句柄</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">								</span><br><span class="line">TCHAR szTitle[MAX_PATH] = &#123;0&#125;;								</span><br><span class="line">HWND hwnd = FindWindow(&quot;#32770&quot;,&quot;飞鸽传书  IP Messenger&quot;);	//参数1  窗口类的名称 参数2 窗口的标题							</span><br><span class="line">if(hwnd != NULL)																						</span><br><span class="line">	SetWindowText(hwnd,&quot;新的窗口标题&quot;);	//修改窗口标题	飞鸽传书 IP Messenger-&gt;新的窗口标题			</span><br><span class="line">else													</span><br><span class="line">	MessageBox(NULL,&quot;窗口没有找到&quot;,&quot;[ERROR&quot;,MB_OK);														</span><br><span class="line">							</span><br></pre></td></tr></table></figure>









<h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><p>进程之间的通信</p>
<p>代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:/JGY/P0st/post/Language/Win32/Code/进程通信</span><br></pre></td></tr></table></figure>



<ol start="0">
<li></li>
</ol>
<p>A往文件里面写,B往文件里面读 未尝试</p>
<p>1 )</p>
<p>A.exe找到FindWindwos来获取B.exe的窗口句柄</p>
<p>然后给这个窗口句柄PostMessage</p>
<p>B.exe接受到消息,然后根据消息处理函数处理消息</p>
<p>SetWindowsHookEx可以实现消息处理函数的HOOK(适用于原来的case太少,想要添加一些case)</p>
<p>未尝试</p>
<ol start="2">
<li></li>
</ol>
<p>CreateFileMapping创建的内存,所有的进程都可以使用</p>
<p>MapViewFile实现了<code>CreateFileMapping创建的内存</code>创建的内存映射到自己的内存上使用</p>
<p>A.exe实现CreateFileMapping和MapViewFile</p>
<p>B.exe也实现CreateFileMapping和MapViewFile</p>
<p>那么就可以实现内存的共享</p>
<p>尝试成功</p>
<ol start="3">
<li></li>
</ol>
<p>父进程和子进程之间的通信,用到的是管道</p>
<p>尝试失败</p>
<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><p>EnumProcesses</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumProcesses</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] DWORD   *lpidProcess, <span class="comment">//是保存进程ID的数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   cb, <span class="comment">//进程组数的大小。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD lpcbNeeded <span class="comment">//返回进程数组的大小。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &quot;stdafx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwProcessID[<span class="number">0x500</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//开始的预先分配较大的缓冲区，用来存放进程ID</span></span><br><span class="line">	DWORD dwNeeded = <span class="number">0</span>;</span><br><span class="line">	BOOL bEnumRes = <span class="built_in">EnumProcesses</span>(dwProcessID, <span class="built_in">sizeof</span>(dwProcessID), &amp;dwNeeded);</span><br><span class="line">	UINT uCount = dwNeeded / <span class="built_in">sizeof</span>(DWORD);<span class="comment">//获得枚举到进程的数量</span></span><br><span class="line">	<span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; uCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//只对进程进程枚举，所以申请QUERY权限，具体还得根据应用申请权限</span></span><br><span class="line"></span><br><span class="line">		HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, FALSE, dwProcessID[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">		&#123;</span><br><span class="line">			CHAR szProcessName[<span class="number">0x50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">			DWORD dwNameLen = <span class="number">0x50</span>;</span><br><span class="line">			BOOL bRet = <span class="built_in">QueryFullProcessImageNameA</span>(hProcess, <span class="number">0</span>, szProcessName, &amp;dwNameLen);</span><br><span class="line">			<span class="keyword">if</span> (bRet)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;ID:%4d/tprocessName(%s)/n&quot;</span>, dwProcessID[i], szProcessName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &quot;stdafx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;psapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>   comment   (lib, <span class="string">&quot;psapi.lib &quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEnumProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get the list of process identifiers.</span></span><br><span class="line">	DWORD aProcesses[<span class="number">1024</span>], cbNeeded, cProcesses;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">EnumProcesses</span>(aProcesses, <span class="built_in">sizeof</span>(aProcesses), &amp;cbNeeded))       <span class="comment">//枚举进程</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	cProcesses = cbNeeded / <span class="built_in">sizeof</span>(DWORD);             <span class="comment">//计算进程个数</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cProcesses; i++)</span><br><span class="line">		<span class="keyword">if</span> (aProcesses[i] != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			TCHAR szProcessName[MAX_PATH] = <span class="built_in">TEXT</span>(<span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">			HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);     <span class="comment">//获得进程句柄</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">			&#123;</span><br><span class="line">				HMODULE hMod;</span><br><span class="line">				DWORD cbNeeded;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">EnumProcessModules</span>(hProcess, &amp;hMod, <span class="built_in">sizeof</span>(hMod), &amp;cbNeeded))        <span class="comment">//枚举进程模块信息</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">GetModuleBaseName</span>(hProcess, hMod, szProcessName, <span class="built_in">sizeof</span>(szProcessName) / <span class="built_in">sizeof</span>(TCHAR));       <span class="comment">//取得主模块全名,每个进程第一模块则为进程主模块</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;%s  (PID: %u)/n&quot;</span>), szProcessName, aProcesses[i]);     <span class="comment">//输出进程名及PID</span></span><br><span class="line">			<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MyEnumProcess</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>CreateToolhelp32Snapshot </p>
<p>函数通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照.</p>
<p>说到底，可以获取系统中正在运行的进程信息，线程信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateToolhelp32Snapshot</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwFlags, <span class="comment">//用来指定“快照”中需要返回的对象</span></span></span><br><span class="line"><span class="params">  [in] DWORD th32ProcessID  <span class="comment">//一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>返回值</p>
<p>如果函数成功，它将返回指定快照的打开句柄。</p>
<p>如果函数失败，则返回<strong>INVALID_HANDLE_VALUE</strong>。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &quot;StdAfx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlhelp32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESSENTRY32 Photo;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    typedef struct tagPROCESSENTRY32W</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    DWORD   dwSize;</span></span><br><span class="line"><span class="comment">    DWORD   cntUsage;</span></span><br><span class="line"><span class="comment">    DWORD   th32ProcessID;          // this process</span></span><br><span class="line"><span class="comment">    ULONG_PTR th32DefaultHeapID;</span></span><br><span class="line"><span class="comment">    DWORD   th32ModuleID;           // associated exe</span></span><br><span class="line"><span class="comment">    DWORD   cntThreads;</span></span><br><span class="line"><span class="comment">    DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span></span><br><span class="line"><span class="comment">    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span></span><br><span class="line"><span class="comment">    DWORD   dwFlags;</span></span><br><span class="line"><span class="comment">    WCHAR   szExeFile[MAX_PATH];    // Path</span></span><br><span class="line"><span class="comment">    &#125; PROCESSENTRY32W;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//在使用这个结构前，先设置它的大小</span></span><br><span class="line">    Photo.dwSize = <span class="built_in">sizeof</span>(Photo);</span><br><span class="line">    <span class="comment">//给系统内所有的进程拍个快照</span></span><br><span class="line">    HANDLE Photo_Handle = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (Photo_Handle == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateToolhelp32Snapshot 调用失败./n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历进程快照，轮流显示每个进程的信息</span></span><br><span class="line">    BOOL Button = ::<span class="built_in">Process32First</span>(Photo_Handle, &amp;Photo);</span><br><span class="line">    <span class="keyword">while</span> (Button)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程名称：%ls/n&quot;</span>, Photo.szExeFile); <span class="comment">//这里得到的应该是宽字符，用%ls,不然无法正常打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程ID：%#x/n/n&quot;</span>, Photo.th32ProcessID);</span><br><span class="line">        Button = ::<span class="built_in">Process32Next</span>(Photo_Handle, &amp;Photo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记清除掉snapshot对象</span></span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(Photo_Handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外一个实例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">EjectDll</span><span class="params">(DWORD Exe_PID, LPCTSTR Dll_Name)</span></span><br><span class="line">&#123;</span><br><span class="line">    BOOL bMore = FALSE, bFound = FALSE;</span><br><span class="line">    HANDLE Target_Snapshot, QQ_Process, hThread;</span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">    LPTHREAD_START_ROUTINE A_DLL_Export_Func_ThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exe_Pid = notepad </span></span><br><span class="line">    <span class="comment">// TH32CS_SNAPMODULE </span></span><br><span class="line">    Target_Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, Exe_PID);<span class="comment">//指定查看QQ的线程??/</span></span><br><span class="line"></span><br><span class="line">    bMore = Module32First(Target_Snapshot, &amp;me); <span class="comment">//Process32First,现在是MOudle,查看一个Procsee</span></span><br><span class="line">    <span class="comment">//的Modue</span></span><br><span class="line">    <span class="keyword">for</span> (; bMore; bMore = Module32Next(Target_Snapshot, &amp;me))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//路径或者直接软件的名字</span></span><br><span class="line">        <span class="comment">//szModule 是dll在内存中加载的地址</span></span><br><span class="line">        <span class="keyword">if</span> (!_tcsicmp((LPCTSTR)me.szModule, Dll_Name) ||</span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, Dll_Name))</span><br><span class="line">        &#123;</span><br><span class="line">            bFound = TRUE; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bFound)<span class="comment">//关闭刚才打开的句柄</span></span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(Target_Snapshot);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(QQ_Process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Exe_PID)))<span class="comment">//打开QQ</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]/n&quot;</span>, Exe_PID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hModule=GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);<span class="comment">//获取的dll的ImageBase,</span></span><br><span class="line">    <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    A_DLL_Export_Func_ThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="string">&quot;FreeLibrary&quot;</span>);<span class="comment">//导出函数的地址</span></span><br><span class="line">    <span class="keyword">if</span> (A_DLL_Export_Func_ThreadProc == <span class="literal">NULL</span>)<span class="comment">//这里获取的地址不是QQ的dll-&gt;freelibary,而是ejectdll.exe中dll的freelibart地址</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//看上去有点矛盾,但是所有exe调用dll的在进程中的地址都是一样的,这个后面慢慢理解</span></span><br><span class="line">    hThread = CreateRemoteThread(QQ_Process, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="comment">//现在的me指向了QQ</span></span><br><span class="line">        A_DLL_Export_Func_ThreadProc, me.modBaseAddr, <span class="comment">//mw.modBaseaddr要卸载的dll加载地址</span></span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>);<span class="comment">//打开远程线程</span></span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);<span class="comment">//一直等待线程有信号,有就返回</span></span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);<span class="comment">//关闭线程</span></span><br><span class="line">    CloseHandle(QQ_Process);<span class="comment">//关闭进程</span></span><br><span class="line">    CloseHandle(Target_Snapshot);<span class="comment">//关闭快照</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="加密壳项目需求"><a href="#加密壳项目需求" class="headerlink" title="加密壳项目需求"></a>加密壳项目需求</h1><p>ShellCode就是随便放在哪里都可以运行的硬编码</p>
<p>ShellCode化: 不使用全局变量,不使用IAT表 </p>
<p>二进制壳</p>
<p>不会去修改硬编码,而是扭曲PE文件,对关键部位加密</p>
<p>5000</p>
<p>源代码加密</p>
<p>(1)way1</p>
<p>1.将各种表移动到一个新的节区</p>
<p>2.对原来的PE文件进行加密</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220730002056486.png" alt="image-20220730002056486"></p>
<p>对于IAT表</p>
<p>有的壳会通过一定的逻辑告诉系统,让系统加载IAT表</p>
<p>有的壳就是自己一个一个的加载IAT表</p>
<p>(2)way2</p>
<p>直接对源文件所有的数据加密,然后加密的数据追加到最后一个节区</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20220730003134572.png" alt="image-20220730003134572"></p>
<p>说什么迁移表的位置,只要你不走我的外壳,你就托不了</p>
<p>1、获取SHELL程序的路径								</p>
<p>2、获取src的数据								</p>
<pre><code>(1) 定为到SHELL文件的最后一个节							
                            
(2) 将数据取出，并解密							
</code></pre>
<p>3、拉伸PE								</p>
<pre><code>将解密后的PE文件在内存中拉伸，并存储到缓冲区中							
</code></pre>
<p>4、以挂起方式运行Shell进程								</p>
<pre><code>(0) 以挂起形成创建Shell进程，并得到主线程的Context							
                            
(1) 卸载外壳程序的文件镜像(ZwUnmapViewOfSection)							
                            
(2) 在指定的位置(src的ImageBase)申请指定大小(src的SizeOfImage)的内存(VirtualAllocEx)							
                            
(3) 如果创建失败，查看src是否包含重定位表，如果包含重定位表，就在任意位置申请(src的SizeOfImage)							
    大小的内存，然后修复重定位表.							
                            
(4) 如果在指定位置申请内存失败，并且没有重定位表的数据，直接返回失败.							
                            
(5) 如果内存申请成功，将新的数据复制到内存中 							
                            
(6) 修正运行环境的基址和入口地址 							
                            
(7) 恢复主线程执行							
</code></pre>
<p>​			</p>
<p>整体流程</p>
<p>1、读取主模块的数据					</p>
<p>2、解密：得到原来的PE文件					</p>
<p>3、以挂起的形式创建进程：CreateProcess					：要创建的进程在哪里？</p>
<p>要创建的进程，就是壳子本身！					</p>
<p>4、获取外壳程序的Context,后面要用.					</p>
<p>5、卸载外壳程序.					</p>
<p>6、在指定的位置分配空间：位置就是src的ImageBase  大小就是Src的SizeOfImage					</p>
<p>7、如果成功，将Src的PE文件拉伸 复制到该空间中					</p>
<p>8、如果申请空间失败，但有重定位表：在任意位置申请空间，然后将PE文件拉伸、复制、修复重定位表。					</p>
<p>9、如果第6步申请空间失败，并且还没有重定位表，直接返回：失败.					</p>
<p>10、修改外壳程序的Context:					</p>
<pre><code>将Context的ImageBase 改成 Src的ImageBase					
                
将Context的OPE 改成 Src的OEP					
</code></pre>
<p>11、设置Context 并恢复主线程					</p>
<p>12、终止外壳程序，解壳过程结束.					</p>
<p>​						</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>64未汇编语言基础部分</title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/64/%E5%9F%BA%E7%A1%80/language/</url>
    <content><![CDATA[<h1 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h1><p>x64下好像不可以使用内敛汇编</p>
<p>然后得单独把文件写为.asm</p>
<p>然后在.c文件里面引用它</p>
<p>虽然整体也没有这么改变</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/32/%E5%9F%BA%E7%A1%80/language/</url>
    <content><![CDATA[<hr>
<h2 id="x86汇编语言基础部分"><a href="#x86汇编语言基础部分" class="headerlink" title="x86汇编语言基础部分"></a>x86汇编语言基础部分</h2><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>段寄存器</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CS(code segment)</td>
<td>代码段地址寄存器，存放代码段的起始地址</td>
</tr>
<tr>
<td>DS(data segment)</td>
<td>数据段地址寄存器，存放数据段的起始地址</td>
</tr>
<tr>
<td>SS(stack segment)</td>
<td>堆栈段地址寄存器，存放堆栈段的起始地址</td>
</tr>
<tr>
<td>ES(extra segment)</td>
<td>附加段地址寄存器，存放附加段的起始地址</td>
</tr>
</tbody></table>
<p>控制寄存器</p>
<p>IP(Instruction Pointer):指令指针寄存器，存放代码段中指令的偏移地址。</p>
<p>FR(Flags Register):标志寄存器，用于存放反映处理器和运行程序执行结果状态的控制标志和条件码标志。</p>
<h2 id="x86寄存器"><a href="#x86寄存器" class="headerlink" title="x86寄存器"></a>x86寄存器</h2><p>8个通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</p>
<p>1个标志寄存器：EFLAGS</p>
<p>其他寄存器：EIP、TSC等</p>
<table>
<thead>
<tr>
<th align="center">长度是32位寄存器</th>
<th align="center">长度是16位寄存器</th>
<th align="center">长度是8位寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EAX</td>
<td align="center">AX</td>
<td align="center">AH、AL</td>
</tr>
<tr>
<td align="center">EBX</td>
<td align="center">BX</td>
<td align="center">BH、BL</td>
</tr>
<tr>
<td align="center">ECX</td>
<td align="center">CX</td>
<td align="center">CH、CL</td>
</tr>
<tr>
<td align="center">EDX</td>
<td align="center">DX</td>
<td align="center">DH、DL</td>
</tr>
<tr>
<td align="center">ESI</td>
<td align="center">SI</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EDI</td>
<td align="center">DI</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ESP</td>
<td align="center">SP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EBP</td>
<td align="center">BP</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>eax 累加器(Accumulator), 它的低16位即是AX，而AX又可分为高8位AH和低8位AL。</p>
<p>ebx 基地址寄存器(Base Register), 它的低16位即是BX，而BX又可分为高8位BH和低8位BL。</p>
<p>ecx 计数寄存器（Count Register），它的低16位即是CX，而CX又可分为高8位CH和低8位CL。</p>
<p>edx 数据寄存器（Data Register），它的低16位即是DX，而DX又可分为高8位DH和低8位DL。</p>
<p>ESI&#x2F;EDI:做源&#x2F;目标索引寄存器(Source&#x2F;Destination Index Register)，它们的低16位分别是SI、DI。</p>
<p>EBP&#x2F;BSP 基址针寄存器（Base Pointer Register）&#x2F;堆栈指针寄存器（Stack Pointer Register），</p>
<p>​		低16位是BP、SP，其内存分别放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶&#x2F;底部</p>
<p>eax 函数的返回值,</p>
<p>ebx 主要用于在内存寻址时存放基地址</p>
<p>ecx 在循环和字符串操作时，要用它来控制循环次数；</p>
<p>​	在位操作 中，当移多位时，要用CL来指明移位的位数；</p>
<p>​	是重复(REP)前缀指令和LOOP指令的内定计数器</p>
<p>edx 在进行乘、除运算时，它可作为默认的操作数参与运算，</p>
<p>​	也可用于存放I&#x2F;O的端口地址；</p>
<p>​	且总是被用来放整数除法产生的余数。</p>
<p>esi&#x2F;edi 它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，</p>
<p>​		在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串。</p>
<p>​		此外，它们又作为通用寄存器可以进行任意的常规的操作，如加减移位或普通的内存间接寻址。</p>
<p>esp&#x2F;ebp: 主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式</p>
<p>​		指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p>
<p>​		并且规定：BP为基指针(Base 	Pointer)寄存器用它可直接存取堆栈中的数据；SP为堆栈指针(Stack Pointer)寄存器，</p>
<p>​		用它只可访问栈顶。在32位平台上，ESP每次减少4字节</p>
<h2 id="x64寄存器"><a href="#x64寄存器" class="headerlink" title="x64寄存器"></a>x64寄存器</h2><p>x64 结构提供了 16 个通用寄存器（以后称为整数寄存器），</p>
<p>16 个 XMM 寄存器 (注意xmm寄存器是128位,而不是64位)</p>
<p>xmm寄存器主要用于浮点数处理</p>
<p>ymm寄存器 256位</p>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>寄存器简介</th>
<th>主要功能</th>
<th align="center">64bit</th>
<th>32bit</th>
<th>16bit</th>
<th>8bit</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>累加器，是算术运算的主要寄存器</td>
<td>存储返回值</td>
<td align="center">rax</td>
<td>eax</td>
<td>ax</td>
<td>al</td>
</tr>
<tr>
<td>rbx</td>
<td>基址寄存器，被调用者保存</td>
<td>存放存储区的起始地址</td>
<td align="center">rbx</td>
<td>ebx</td>
<td>bx</td>
<td>bl</td>
</tr>
<tr>
<td>rcx</td>
<td>计数寄存器</td>
<td>循环操作和字串处理的计数控制；函数调用时的第4个参数</td>
<td align="center">rcx</td>
<td>ecx</td>
<td>cx</td>
<td>cl</td>
</tr>
<tr>
<td>rdx</td>
<td>I&#x2F;O指针</td>
<td>I&#x2F;O操作时提供外部设备接口的端口地址；函数调用时的第3个参数</td>
<td align="center">rdx</td>
<td>edx</td>
<td>dx</td>
<td>dl</td>
</tr>
<tr>
<td>rsi</td>
<td>(source index)源变址寄存器，与rds段寄存器联用，可以访问数据段中的任一个存储单元</td>
<td>函数调用时的第2个参数</td>
<td align="center">rsi</td>
<td>esi</td>
<td>si</td>
<td>sil</td>
</tr>
<tr>
<td>rdi</td>
<td>(destination index)目的变址寄存器，与res段寄存器联用，可以访问附加段中的任一个存储单元</td>
<td>函数调用时的第1个参数</td>
<td align="center">rdi</td>
<td>edi</td>
<td>di</td>
<td>dil</td>
</tr>
<tr>
<td>rbp</td>
<td>(base pointer)基址指针寄存器，用于提供堆栈内某个单元的偏移地址，与rss段寄存器联用，可以访问堆栈中的任一个存储单元，被调用者保存</td>
<td></td>
<td align="center">rbp</td>
<td>ebp</td>
<td>bp</td>
<td>bpl</td>
</tr>
<tr>
<td>rsp</td>
<td>(stack pointer)栈顶指针寄存器，提供堆栈栈顶单元的偏移地址，与rss段寄存器联用，以控制数据进栈和出栈</td>
<td></td>
<td align="center">rsp</td>
<td>esp</td>
<td>sp</td>
<td>spl</td>
</tr>
<tr>
<td>r8</td>
<td></td>
<td>函数调用时的第5个参数</td>
<td align="center">r8</td>
<td>r8d</td>
<td>r8w</td>
<td>r8b</td>
</tr>
<tr>
<td>r9</td>
<td></td>
<td>函数调用时的第6个参数</td>
<td align="center">r9</td>
<td>r9d</td>
<td>r9w</td>
<td>r9b</td>
</tr>
<tr>
<td>r10</td>
<td>调用者保存</td>
<td></td>
<td align="center">r10</td>
<td>r10d</td>
<td>r10w</td>
<td>r10b</td>
</tr>
<tr>
<td>r11</td>
<td>调用者保存</td>
<td></td>
<td align="center">r11</td>
<td>r11d</td>
<td>r11w</td>
<td>r11b</td>
</tr>
<tr>
<td>r12</td>
<td>被调用者保存</td>
<td></td>
<td align="center">r12</td>
<td>r12d</td>
<td>r12w</td>
<td>r12b</td>
</tr>
<tr>
<td>r13</td>
<td>被调用者保存</td>
<td></td>
<td align="center">r13</td>
<td>r13d</td>
<td>r13w</td>
<td>r13b</td>
</tr>
<tr>
<td>r14</td>
<td>被调用者保存</td>
<td></td>
<td align="center">r14</td>
<td>r14d</td>
<td>r14w</td>
<td>r14b</td>
</tr>
<tr>
<td>r15</td>
<td>被调用者保存</td>
<td></td>
<td align="center">r15</td>
<td>r15d</td>
<td>r15w</td>
<td>r15b</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movsd   xmm0, qword ptr [rsi]</span><br><span class="line">movsd   xmm1, qword ptr [rsi+8]</span><br></pre></td></tr></table></figure>

<p>奇怪啊,奇怪</p>
<h2 id="x64寄存器调用约定"><a href="#x64寄存器调用约定" class="headerlink" title="x64寄存器调用约定"></a>x64寄存器调用约定</h2><p>对于一般的函数传参,实际情况在调试的时候可以确定</p>
<table>
<thead>
<tr>
<th>参数位置</th>
<th>寄存器名字</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数1</td>
<td>rcx</td>
<td></td>
</tr>
<tr>
<td>参数2</td>
<td>rdx</td>
<td></td>
</tr>
<tr>
<td>参数3</td>
<td>r8</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>CF:  进位标志符号比     排在第0位<br>PF:  奇偶标志      排在第2位<br>AF:  辅助进位标志     排在第4位<br>ZF:  零标志       排在第6位<br>SF:  符号标志      排在第7位<br>TF:  追踪标志       排在第8位<br>IF:  中断允许标志      排在第9位<br>DF:  方向标志       排在第10位<br>OF:  溢出标志       排在第11位</p>
<p> <img src="https://resmile.gitee.io/blog/Asm-%E5%9F%BA%E7%A1%80/image-20221025005410035.png" alt="image-20221025005410035"></p>
<p>对于上面的位置,我们不需要去记住</p>
<p> <img src="https://resmile.gitee.io/blog/Asm-%E5%9F%BA%E7%A1%80/image-20221025005425740.png" alt="image-20221025005425740"></p>
<h3 id="CF-无符号溢出"><a href="#CF-无符号溢出" class="headerlink" title="CF 无符号溢出"></a>CF 无符号溢出</h3><p>无符号数溢出,无符号数进位</p>
<p>CF 把所有的数据都当作无符号的数来处理</p>
<p>Carry : 进位的意思</p>
<p>1:CY carry yes</p>
<p>0:NC not carry</p>
<p>1-2,发生了借位,CF&#x3D;&#x3D;1</p>
<p>1+9,发生了进位,CF&#x3D;1</p>
<p>进位后的数据被丢到了CF中</p>
<p>STC 让CF&#x3D;1</p>
<p>CLC 让CF&#x3D;0</p>
<p>CMC 让CF取反</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov al,<span class="number">0x7f</span></span><br><span class="line">add al,<span class="number">1</span></span><br><span class="line">不会引起CF改变</span><br><span class="line">inc al,更不会</span><br><span class="line"></span><br><span class="line">mvo al,<span class="number">0xff</span></span><br><span class="line">inc al 不会</span><br><span class="line">dec al</span><br><span class="line">add al,<span class="number">1</span>会引起改变</span><br></pre></td></tr></table></figure>



<p>dec&#x2F;inc不会影响CF</p>
<p>add&#x2F;adc指令对标志位的影响：</p>
<p>​	CF&#x3D;1  最高有效位向高位有进位</p>
<p>​	CF&#x3D;0  最高有效位向高位无进位</p>
<p>sub&#x2F;sbb&#x2F;cmp 指令对标志位的影响：</p>
<p>​     CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）</p>
<p>​     CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况）</p>
<p>neg</p>
<p>​	CF&#x3D;1 不为0的操作数求补时</p>
<p>​	CF&#x3D;0 为0的操作数求补时</p>
<h3 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h3><p>与奇偶性有关</p>
<p>parity:奇数与偶数,奇偶性</p>
<p>Evem : 偶数</p>
<p>Odd : 奇数</p>
<p>最低有效的8位有多少个1,而不是看所有的位</p>
<p>1: PE Parity_Evem,二进制中有偶数个1</p>
<p>0: PO parity_Odd ,二进制中有奇数个1</p>
<p>这是代表了一个二进制位数上的奇偶性质,数值本身的奇偶与这个标志位无关</p>
<blockquote>
<p>add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp</p>
</blockquote>
<h3 id="AF"><a href="#AF" class="headerlink" title="AF"></a>AF</h3><p>辅助进位标志AF(Auxiliary Carry Flag)：</p>
<p> 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：</p>
<p>(1)  在 双字（dword）操作时，如eax,发生低字eal,向高字eah进位或借位时；</p>
<p>(2)、在字（word）操作时，如ax,发生al低字节向高字节ah进位或借位时；</p>
<p>(3)、在字节（byte）操作时如al，发生低4位向高4位进位或借位时</p>
<p>其规律就是数据宽度的一半向另外一半进位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX,0X555EFFFF　　　　</span><br><span class="line">MOV AX,0X5EFF　　　　</span><br><span class="line">MOV AL,0X5F</span><br><span class="line">ADD EAX,0X2　　　　　　　　  </span><br><span class="line">MOV AX,0X2　　　　　   </span><br><span class="line">MOV AL,0X2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp</p>
</blockquote>
<h3 id="ZF"><a href="#ZF" class="headerlink" title="ZF:"></a>ZF:</h3><p> Zero_Flag</p>
<p>与计算结果为0相关</p>
<p>1: ZR Zero</p>
<p>0: NZ not zero</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xor eax,eax</span><br></pre></td></tr></table></figure>



<blockquote>
<p>add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp</p>
</blockquote>
<h3 id="SF"><a href="#SF" class="headerlink" title="SF:"></a>SF:</h3><p> Sign_Flag</p>
<p>Sign : 符号,正负</p>
<p>Negativbe:,负数</p>
<p>Positive ;正数</p>
<p>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</p>
<p>1 : NG Negativbe_Large,负数</p>
<p>0 : PL Positive_Little ,正数</p>
<p>如果运算产生负数,SF&#x3D;1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ah,<span class="number">0x7F</span></span><br><span class="line">add ah,<span class="number">1</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>add&#x2F;adc&#x2F;inc&#x2F;sub&#x2F;sbb&#x2F;dec&#x2F;cmp</p>
</blockquote>
<h3 id="TF"><a href="#TF" class="headerlink" title="TF:"></a>TF:</h3><p>追踪标志位trap flag</p>
<p>当TF&#x3D;1,cpu进入单步执行状态</p>
<p>每执行一条语句,产生一个中断请求</p>
<p>感觉可以在这里做一点文章…</p>
<p>该寄存器可以用于程序的调试</p>
<h3 id="IF"><a href="#IF" class="headerlink" title="IF:"></a>IF:</h3><p>interrupt enable flag</p>
<p>中断允许标志</p>
<p>中断允许标志用来决定cpu是否响应CPU外部可屏蔽中断发生的请求</p>
<p>对于不可以屏蔽的中断还有cpu内部发生的中断,他就没有办法了,必须响应</p>
<p>IF&#x3D;1,响应外部可屏蔽中断</p>
<p>IF&#x3D;0,不响应可屏蔽中断</p>
<p>STI 让IF&#x3D;1</p>
<p>CLI 让IF&#x3D;0</p>
<h3 id="DF"><a href="#DF" class="headerlink" title="DF"></a>DF</h3><p>direction_flag</p>
<p>方向位标志寄存器</p>
<p>指令std,cld可以修改它</p>
<p>STD 让DF&#x3D;1 表示-</p>
<p>CLD 让DF&#x3D;0 表示+</p>
<p>与movsb,movsw,movsd有关</p>
<p>串传送指令</p>
<h3 id="OF-有符号溢出"><a href="#OF-有符号溢出" class="headerlink" title="OF 有符号溢出"></a>OF 有符号溢出</h3><p>学习CF与OF，要始终牢记一点。</p>
<p>CF是无符号数溢出标志，</p>
<p>OF是有符号数溢出标志。</p>
<p>一个无符号的byte,超过了255就是CF&#x3D;1</p>
<p>一个有符号的byte,超过了127,就是OF&#x3D;1</p>
<p>OF : Over_Flow</p>
<p>1  : OV over_flow</p>
<p>0  : NV not_over_flag</p>
<p>OF把数据看作有符号来处理</p>
<p>超过max,小于min,就会OF&#x3D;1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor     eax, eax</span><br><span class="line">mov     al, 7Fh;127		上溢</span><br><span class="line">add     al, 1</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, 80h ; -128	下溢</span><br><span class="line">sub     al, 1</span><br></pre></td></tr></table></figure>



<p>规律2个数相加</p>
<p> <img src="https://resmile.gitee.io/blog/Asm-%E5%9F%BA%E7%A1%80/image-20221025005444436.png" alt="image-20221025005444436"></p>
<p>只有0x7F到0x80,才叫OF溢出</p>
<p>根据10进制本质的符号运算</p>
<p>正数+正数&#x3D;…</p>
<p>负数+负数&#x3D;…</p>
<p>正数[0,1&#x2F;2]</p>
<p>负数(1&#x2F;2,1)</p>
<p>那么正数+负数</p>
<p>(1&#x2F;2,3&#x2F;2) 那么是不会经过0x7F-&gt;0x80的</p>
<p>于是正数+负数是不会溢出的</p>
<blockquote>
<p>CPU是如何让OF发生改变的</p>
<p>1000 0000</p>
<p>+1100 0000</p>
<hr>
<p>8bit位,右边0开始计数</p>
<p>如果[7]发生了进位,那么ret&#x3D;1</p>
<p>如果[6]发生了进位,那么ret2&#x3D;0</p>
<p>如果ret1^ret2&#x3D;1,那么OF&#x3D;1</p>
<p>也就是ret1和ret2中只有一个位1的时候,OF&#x3D;1</p>
</blockquote>
<p>add </p>
<p>​	OF&#x3D;1  两个同符号数相加（正数+正数 或 负数+负数），结果符号与其相反。</p>
<p>​	OF&#x3D;0  两个不同符号数相加，或同符号数相加，结果符号与其相同。</p>
<p>adc&#x2F;inc </p>
<p>​    OF&#x3D;1  两个同符号数相加，结果符号与其相反，</p>
<p>​    OF&#x3D;0  两个同符号数相加，或同符号相加，结果符号与其相同</p>
<p>sub&#x2F;dec</p>
<p>​	OF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。</p>
<p>​	OF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。</p>
<p>neg</p>
<p>​	OF&#x3D;1  操作数为-128（字节运算）或操作数为-32768（字运算）</p>
<p>​    OF&#x3D;0  当求补运算的操作数不为－128（字节）或－32768（字）时</p>
<h3 id="IOPF"><a href="#IOPF" class="headerlink" title="IOPF :"></a>IOPF :</h3><p>I&#x2F;O 特权标志</p>
<p>它可表示当前运行程序或者任务访问1&#x2F;0指令的特权级</p>
<p>若当前运行程序或者任务的特权级别cpl&lt;&#x3D;IPOL(00B)的时候,则可以执行I&#x2F;O指令,否则会发生异常</p>
<p>这里可以做文章</p>
<p>该值只能被允许与CPL&#x3D;0的程序或任务通过popf&#x2F;popfd指令或者iret指令进行修改</p>
<p>因此,一般用户程序(CPL&#x3D;3)是无法执行I&#x2F;O指令的</p>
<h3 id="NT"><a href="#NT" class="headerlink" title="NT"></a>NT</h3><p>nested task flag</p>
<p>NT&#x3D;1,表示当前任务嵌套于前一任务</p>
<p>否则当前任务不嵌套于任何任务</p>
<p>当执行call指令&#x2F;中断&#x2F;异常时,cpu让NT&#x3D;1</p>
<p>当任务执行返回时,通过iret让NT&#x3D;0</p>
<p>问题来了…调用一个call就让NT&#x3D;1,就这么随便吗?</p>
<p>另外NT&#x3D;0只能是iret吗?</p>
<h3 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h3><p>恢复标志位 resume flag</p>
<p>恢复标志位用于控制cpu是否接受指令断点的调试异常</p>
<p>若RF&#x3D;0,表示接受调试异常,否则不接受</p>
<p>该标志位一般友调试器设置,可以在刚进入调试异常的时暂时关闭新调试异常,</p>
<p>以避免调试异常时又立即进入了另外一个调试异常</p>
<h3 id="VM"><a href="#VM" class="headerlink" title="VM :"></a>VM :</h3><p>virtual-8086 mode flag</p>
<p>虚拟8086模式标志</p>
<p>若VM&#x3D;1,表示cpu进入了虚拟8086模式</p>
<p>否则进入了保护模式</p>
<h3 id="AC"><a href="#AC" class="headerlink" title="AC :"></a>AC :</h3><p>Algnment check flag</p>
<p>对齐检查标志位</p>
<p>若AC&#x3D;1, 且控制寄存器的cr0的AM标志位也为1,则允许内存地址进行对齐的检测</p>
<p>否则不允许</p>
<p>当程序的特权级别为3且运行于用户模式,若地址不对齐(即字访问时地址为奇数,双字访问时,地址不能被4整除),将产生对齐检查异常</p>
<p>之前我们只是提及过,寻址偶数地址会更加的快,国更加的发挥CPU的性能</p>
<p>CPU对非对齐字节地址访问内存,时间可能更加的长,若要求必须对齐,这要进行对齐检查</p>
<h3 id="VIF"><a href="#VIF" class="headerlink" title="VIF :"></a>VIF :</h3><p>virtual interrupt  flag</p>
<p>虚拟中断标志寄存器VIF为IF标志的虚拟印象,</p>
<p>问题来了</p>
<p>什么叫虚拟印象</p>
<p>这个标志位与VIP标志配合使用,允许多任务环境下应用程序有虚拟的系统IF标志</p>
<h3 id="VIP"><a href="#VIP" class="headerlink" title="VIP:"></a>VIP:</h3><p>virtual interrupt pending flag</p>
<p>虚拟中断挂起标志</p>
<p>若vip&#x3D;1,表示有挂起的中断</p>
<p>否则没有挂起的中断</p>
<p>一般由软件对其标志位初始化或者复位</p>
<p>CPU仅仅是读取,他与VIF配合使用</p>
<h3 id="ID"><a href="#ID" class="headerlink" title="ID :"></a>ID :</h3><p>identification flag</p>
<p>识别标志位</p>
<p>若ID位能被置位或者复位,则说明CPU支持CPUID指令</p>
<p>CPUID可以提供CPU的厂商,系列号等信息</p>
<h2 id="特殊的指令和flag"><a href="#特殊的指令和flag" class="headerlink" title="特殊的指令和flag"></a>特殊的指令和flag</h2><h3 id="MUL-x2F-IMUL"><a href="#MUL-x2F-IMUL" class="headerlink" title="MUL&#x2F;IMUL"></a>MUL&#x2F;IMUL</h3><p>MUL指令的条件码设置为：</p>
<p>CF OF&#x3D;0 0 乘积的高一半为0（字节操作的（AH）或字操作的（DX））</p>
<p>CF OF&#x3D;1 1 乘积的高一半不为0</p>
<p>​           </p>
<p>IMUL指令的条件码设置为：</p>
<p>CF OF&#x3D;0 0 乘积的高一半为低一半的符号扩展.</p>
<p>CF OF&#x3D;1 1 其他情况</p>
<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p>指令对标志位的影响：</p>
<p>​           指令执行后 CF 和 OF 置零，AF无定义。</p>
<p>​           PF&#x3D;1 结果操作数中1的个数为偶数时置1</p>
<p>​           PF&#x3D;0 结果操作数中1的个数为奇数时置0 </p>
<h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p>指令对标志位的影响：</p>
<p>令执行后 CF 和 OF 置零，AF无定义。</p>
<p>PF&#x3D;1 结果操作数中1的个数为偶数时置1</p>
<p>PF&#x3D;0 结果操作数中1的个数为奇数时置0</p>
<h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>指令对标志位的影响：</p>
<p>执行后 CF 和 OF 置零，AF无定义。</p>
<p>PF&#x3D;1 结果操作数中1的个数为偶数时置1</p>
<p>PF&#x3D;0 结果操作数中1的个数为奇数时置0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax zf=0</span><br></pre></td></tr></table></figure>

<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>指令对标志位的影响：</p>
<p>令执行后 CF 和 OF 置零，AF无定义。</p>
<p>PF&#x3D;1 结果操作数中1的个数为偶数时置1</p>
<p>PF&#x3D;0 结果操作数中1的个数为奇数时置0</p>
<h3 id="逻辑左移-SHL"><a href="#逻辑左移-SHL" class="headerlink" title="逻辑左移 SHL"></a>逻辑左移 SHL</h3><p>指令对标志位的影响： CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="逻辑右移-SHR"><a href="#逻辑右移-SHR" class="headerlink" title="逻辑右移 SHR"></a>逻辑右移 SHR</h3><p>指令对标志位的影响：CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="算术左移-SAL"><a href="#算术左移-SAL" class="headerlink" title="算术左移 SAL"></a>算术左移 SAL</h3><p>指令对标志位的影响：CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="算术右移SAR"><a href="#算术右移SAR" class="headerlink" title="算术右移SAR"></a>算术右移SAR</h3><p>指令对标志位的影响：CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="循环左移-ROL"><a href="#循环左移-ROL" class="headerlink" title="循环左移 ROL"></a>循环左移 ROL</h3><p>指令对标志位的影响：CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="循环右移-ROR"><a href="#循环右移-ROR" class="headerlink" title="循环右移 ROR"></a>循环右移 ROR</h3><p>指令对标志位的影响：CF&#x3D;移入的数值</p>
<p>OF&#x3D;1 当count&#x3D;1时，移动后最高位的值发生变化。</p>
<p>OF&#x3D;0 当count&#x3D;1时，移动时最高位的值未发生变化。</p>
<h3 id="带进位的循环左移-RCL"><a href="#带进位的循环左移-RCL" class="headerlink" title="带进位的循环左移 RCL"></a>带进位的循环左移 RCL</h3><p>指令对标志位的影响：CF&#x3D;移入的数值。</p>
<p>OF&#x3D;1 当cnt&#x3D;1时，移动后最高位的值未发生变化。</p>
<p>OF&#x3D;0 当cnt&#x3D;1时，移动后最高位的值发生变化。</p>
<p>SF、ZF、PF标志位不受影响。</p>
<h3 id="带进位的循环右移-RCR"><a href="#带进位的循环右移-RCR" class="headerlink" title="带进位的循环右移 RCR"></a>带进位的循环右移 RCR</h3><p>指令对标志位的影响：CF&#x3D;移入的数值。</p>
<p> OF&#x3D;1 当cnt&#x3D;1时，操作数最高位的值未发生变化。</p>
<p> OF&#x3D;0 当cnt&#x3D;1时，操作数最高位的值发生变化。</p>
<p> SF、ZF、PF标志位不受影响。</p>
<h3 id="串比较-CMPSB-x2F-CMPSW"><a href="#串比较-CMPSB-x2F-CMPSW" class="headerlink" title="串比较 CMPSB &#x2F; CMPSW"></a>串比较 CMPSB &#x2F; CMPSW</h3><p>(compare string byte&#x2F;word)</p>
<p>指令对条件码的影响：</p>
<p>​           CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）</p>
<p>​           CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况）</p>
<p>​           OF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。</p>
<p>​           OF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。</p>
<h3 id="串扫描-SCASB-x2F-SCASW"><a href="#串扫描-SCASB-x2F-SCASW" class="headerlink" title="串扫描 SCASB &#x2F; SCASW"></a>串扫描 SCASB &#x2F; SCASW</h3><p>(scan string byte &#x2F; word)</p>
<p>指令对条件码的影响：</p>
<p>​           CF&#x3D;1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）</p>
<p>​           CF&#x3D;0 二进制减法运算中最高有效为向高位无借位（被减数〉&#x3D;减数，够减的情况）</p>
<p>​           OF&#x3D;1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。</p>
<p>​           OF&#x3D;0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。</p>
<h3 id="不影响"><a href="#不影响" class="headerlink" title="不影响"></a>不影响</h3><p>串传送MOVSB &#x2F; MOVSW </p>
<p>指令对条件码的影响：不影响条件码。</p>
<p>存串 STOSB &#x2F; STOSW</p>
<p>指令对条件码的影响：不影响条件码。</p>
<p>取串LODSB &#x2F; LODSW </p>
<p>(load from string byte&#x2F;word)</p>
<p>指令对条件码的影响：不影响条件码。</p>
<p>not</p>
<p>指令对标志位的影响：对标志位无影响</p>
<h2 id="与标志寄存器有关的指令"><a href="#与标志寄存器有关的指令" class="headerlink" title="与标志寄存器有关的指令"></a>与标志寄存器有关的指令</h2><h3 id="LAHF"><a href="#LAHF" class="headerlink" title="LAHF"></a>LAHF</h3><p>8086也有指令lahf&#x2F;sahf</p>
<p>L的意思可能就是Load</p>
<p>lahf是把所有的标志寄存器的低8位复制到ah</p>
<p>sahf把ah的数据还给标志寄存器</p>
<h3 id="SAHF"><a href="#SAHF" class="headerlink" title="SAHF"></a>SAHF</h3><p>把AH的数据给flag的低8位</p>
<h3 id="pushf-x2F-pushfd"><a href="#pushf-x2F-pushfd" class="headerlink" title="pushf&#x2F;pushfd"></a>pushf&#x2F;pushfd</h3><p>把16&#x2F;32位的寄存器数据压如栈</p>
<h3 id="popf-x2F-popfd"><a href="#popf-x2F-popfd" class="headerlink" title="popf&#x2F;popfd"></a>popf&#x2F;popfd</h3><p>把栈的值压入16&#x2F;32位的标志寄存器flag</p>
<p>pushad是把通用寄存器入栈</p>
<p>pushfd是吧标志寄存器入栈</p>
<h1 id="mxcsr寄存器"><a href="#mxcsr寄存器" class="headerlink" title="mxcsr寄存器"></a>mxcsr寄存器</h1><table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>|</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FZ</td>
<td align="center">RC</td>
<td>RC</td>
<td>PM</td>
<td>UM</td>
<td>OM</td>
<td>ZM</td>
<td>DM</td>
<td>IM</td>
<td>|</td>
<td>DAZ</td>
<td>PE</td>
<td>UE</td>
<td>OE</td>
<td>ZE</td>
<td>DE</td>
<td>IE</td>
</tr>
<tr>
<td align="center">下溢这0</td>
<td align="center">舍入控制</td>
<td>舍入控制</td>
<td>精度掩码</td>
<td>下溢掩码</td>
<td>溢出掩码</td>
<td>除0错误掩码</td>
<td>非规格化操作掩码</td>
<td>无效操作掩码</td>
<td>|</td>
<td>非规格化操作</td>
<td>精度错误</td>
<td>下溢错误</td>
<td>溢出错误</td>
<td>除0错误</td>
<td>非规格化操作</td>
<td>无效操作错误</td>
</tr>
</tbody></table>
<p>0-6位,也就是最后7位是异常发生的情况,发了就自动的置为1,没有发生就置位0</p>
<p>7-12位是对最后7位的一个异常屏蔽一一对应,</p>
<p>异常屏蔽置为了1,那么发生了异常也不会崩溃</p>
<p>异常屏蔽置为了0,那发生了异常就会崩溃</p>
<p>把DIY的mxcsr值放入寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldmxcsr ds:mxcsr_before </span><br></pre></td></tr></table></figure>

<p>把原有的mxcsr值放入一个内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stmxcsr ds:mxcsr_after</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">默认情况,没有异常</span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.0</span> = <span class="number">5.0000000000000000</span>, in hex: <span class="number">0x4014000000000000</span></span><br><span class="line">mxcsr before:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">精度异常</span><br><span class="line"><span class="number">10.0</span> / <span class="number">3.0</span> = <span class="number">3.3333333333333335</span>, in hex: <span class="number">0</span>x <span class="number">40</span> <span class="number">0</span>a aa aa aa aa aa ab</span><br><span class="line">mxcsr before:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">除<span class="number">0</span>异常</span><br><span class="line"><span class="number">10.0</span> / <span class="number">0.0</span> = inf, in hex: <span class="number">0x7ff0000000000000</span></span><br><span class="line">mxcsr before:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0100</span></span><br><span class="line"></span><br><span class="line">向上取整:</span><br><span class="line"><span class="number">10.0</span>  / <span class="number">3.0</span> = <span class="number">3.3333333333333335</span>, in hex: <span class="number">0x400aaaaaaaaaaaab</span></span><br><span class="line">mxcsr before:	 <span class="number">0101</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0101</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">向下取整:</span><br><span class="line"><span class="number">10.0</span> / <span class="number">3.0</span> = <span class="number">3.3333333333333330</span>, in hex: <span class="number">0x400aaaaaaaaaaaaa</span></span><br><span class="line">mxcsr before:	 <span class="number">0011</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0011</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">截断:</span><br><span class="line"><span class="number">10.0</span> / <span class="number">3.0</span> = <span class="number">3.3333333333333330</span>, in hex: <span class="number">0x400aaaaaaaaaaaaa</span></span><br><span class="line">mxcsr before:	 <span class="number">0111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0111</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">精度异常:</span><br><span class="line"><span class="number">11.0</span> /  <span class="number">3.0</span> = <span class="number">3.6666666666666665</span>, in hex: <span class="number">0x400d555555555555</span></span><br><span class="line">mxcsr before:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0001</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">向上取整::</span><br><span class="line"><span class="number">11.0</span> / y <span class="number">3.0</span> = <span class="number">3.6666666666666670</span>, in hex: <span class="number">0x400d555555555556</span></span><br><span class="line">mxcsr before:	 <span class="number">0101</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0101</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">向下取整:</span><br><span class="line"><span class="number">11.0</span> / <span class="number">3.0</span> = <span class="number">3.6666666666666665</span>, in hex: <span class="number">0x400d555555555555</span></span><br><span class="line">mxcsr before:	 <span class="number">0011</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0011</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">截断:</span><br><span class="line"><span class="number">11.0</span> /<span class="number">3.0</span> = <span class="number">3.6666666666666665</span>, in hex: <span class="number">0x400d555555555555</span></span><br><span class="line">mxcsr before:	 <span class="number">0111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">mxcsr after:	 <span class="number">0111</span> <span class="number">1111</span> <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这些异常处理我们针对不同的情况作了一些掩码</p>
<p>然后异常发生后,因为屏蔽作了掩码,就不会发生了异常</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1、存储数据的宽度		杯子有多大</p>
<p>2、存储数据的格式		杯子能装什么</p>
<p>3、作用范围(作用域)	 杯子可以在哪里用</p>
<p>关于变量声明</p>
<p>变量名 数据类型 数据值</p>
<p>而我们的变量名是可以缺少的,因为他的地址就可以引用它</p>
<p>没有变量名的地址就像一个没有名字的指针,我们很难引用它</p>
<p>在x86下,</p>
<p>main函数的变量在text区域</p>
<p>然后放在esp的高位栈空间</p>
<p>变量的使用就push到低位栈空间</p>
<p>x64下</p>
<p>main函数的变量也是高位栈空间</p>
<p>但是你esp+32和ebp-8不都表示高位栈空间吗?于是x64用后者表示了数据分布</p>
<h2 id="高频"><a href="#高频" class="headerlink" title="高频"></a>高频</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="x68"><a href="#x68" class="headerlink" title="x68"></a>x68</h4><p>就是定义在data区的变量</p>
<p>为什么说是全局?因为你可以跳过地址去访问那段一直不会消失的空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	xor eax,eax	</span><br><span class="line">.data </span><br><span class="line">temp dw 2001h</span><br><span class="line">.code</span><br><span class="line">	mov ax,temp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样写的话,你的代码仍然会被放进data中,只不过是最后一个加入data的</p>
<h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data		</span><br><span class="line">		</span><br><span class="line">		var	dq	10.0		</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .text</span><br><span class="line">							</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">    mov rbp, rsp; for correct debugging</span><br></pre></td></tr></table></figure>

<p>于是你的var变量任意一个函数都可以访问</p>
<h3 id="有符号的立即数"><a href="#有符号的立即数" class="headerlink" title="有符号的立即数"></a>有符号的立即数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov eax,-101</span><br><span class="line">		//eax=0xffffff9b</span><br><span class="line">		</span><br><span class="line">		mov eax,9Bh</span><br><span class="line">		//eax=9bh</span><br><span class="line">		</span><br><span class="line">		//9bh=-101</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<p>可以看到负数与他的16进制还是有很大的区别的</p>
<p>所以我们才会有定义有符号的变量</p>
<p>好比<code>var  sdword	-10</code></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>特点:地址连续,成员等宽</p>
<h4 id="8086数组"><a href="#8086数组" class="headerlink" title="8086数组"></a>8086数组</h4><h5 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">b dw 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">start:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面没有冒号<code>:</code></p>
<p>a其实代表了 1. <code>byte ptr cs:[0]</code> 2. <code>或者一个指向byte的指针</code></p>
<p>b的话就类推…..</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">b dw 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">start:</span><br><span class="line">    mov al,a;相当于mov al,cs:[0]</span><br><span class="line">    mov bx,b;mov bx,cs:[10],因为就是b就在cs的第10个位置</span><br><span class="line">    </span><br><span class="line">    mov a,66;相当于mov byte ptr cs:[0],66</span><br><span class="line">    mov b,88;相当于mov word ptr cs:[10],88</span><br><span class="line"></span><br><span class="line">    mov si,2</span><br><span class="line">    mov a[si],66;相当于mov byte ptr cs:[0+si],66;相当于mov byte ptr cs:0[si],66</span><br><span class="line">    </span><br><span class="line">    mov si,3</span><br><span class="line">    mov b[si],77;相当于mov word ptr cs:[10+si],66;相当于mov word ptr cs:10[si],66;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">    arr db 3,2,1</span><br><span class="line">    sum dw 0</span><br><span class="line">    the_ptr dw arr,sum</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>



<h5 id="使用时的注意"><a href="#使用时的注意" class="headerlink" title="使用时的注意"></a>使用时的注意</h5><p>1️⃣假设你有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">    table db &quot;0123456789ABCDEF&quot;</span><br><span class="line">    index dw 0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于table的读取,只能是table[纯数字,或者bx]</p>
<p>你需要一个中间变量的引用</p>
<p>如果用<code>mov ax,table[index]</code>就会报错,无论怎么修改类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setscreen:</span><br><span class="line">            jmp short set</span><br><span class="line">    table   dw sub1,sub2,sub3,sub4</span><br><span class="line">    s:      </span><br><span class="line">            push bx</span><br><span class="line">            cmp ah,3</span><br><span class="line">            ja sret</span><br><span class="line">            mov bl,ah</span><br><span class="line">            mov bh,0</span><br><span class="line">            add bx,bx</span><br><span class="line"></span><br><span class="line">            call word ptr table[bx];重点在这里</span><br><span class="line">    sret:</span><br><span class="line">            pop bx</span><br><span class="line">            ret </span><br></pre></td></tr></table></figure>



<p>2️⃣错误源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov          bx,index </span><br><span class="line">mov	byte ptr ds:[index],al</span><br><span class="line">inc	word ptr index </span><br></pre></td></tr></table></figure>

<p>IDA分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     bx, word_10088</span><br><span class="line">mov     byte ptr word_10088, al</span><br><span class="line">inc     word_10088</span><br></pre></td></tr></table></figure>

<p>上面在直接对index写入,而不是[index]写入</p>
<p>正确的源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     bx,index </span><br><span class="line">mov		byte ptr [bx],al</span><br><span class="line">inc		word ptr index </span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     bx, word_10088</span><br><span class="line">mov     [bx], al</span><br><span class="line">inc     word_10088</span><br></pre></td></tr></table></figure>

<p>其实他就是需要一个中间值的转化</p>
<p>后面关于x86的形式也是一样的</p>
<h4 id="x86数组"><a href="#x86数组" class="headerlink" title="x86数组"></a>x86数组</h4><h5 id="简要的介绍"><a href="#简要的介绍" class="headerlink" title="简要的介绍"></a>简要的介绍</h5><p>一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data 	</span><br><span class="line">	Arr   BYTE  5,4,3,2,1</span><br><span class="line">	str1  BYTE  &quot;Dqx_Gh0st&quot;</span><br><span class="line">		  BYTE  &quot;I am fine!&quot;,0</span><br><span class="line">	str2   \</span><br><span class="line">		  db &quot;This is Function pf &#x27;\&#x27; !&quot;</span><br><span class="line">.stack </span><br><span class="line">	;db 16 dup(&#x27;S&#x27;)</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>1️⃣.</p>
<p>值得注意的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arr   BYTE  5,4,3,2,1</span><br><span class="line">str1  BYTE  &quot;Dqx_Gh0st&quot;,0</span><br></pre></td></tr></table></figure>

<p>类似的声明它是不能在最后加上<code>,</code>逗号的,否者就报错</p>
<p>2️⃣.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str2 \</span><br><span class="line">		db &quot;This is Function pf &#x27;\&#x27; !&quot;</span><br></pre></td></tr></table></figure>



<p>关于第一行的<code>\</code></p>
<p>它的作用就是连接第2行的数据</p>
<p>于是上面的代码就等效于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str2 db &quot;This is Function pf &#x27;\&#x27; !&quot;</span><br></pre></td></tr></table></figure>

<p>它的作用就是一行写不下,另外一行</p>
<h5 id="如何调用数组"><a href="#如何调用数组" class="headerlink" title="如何调用数组"></a>如何调用数组</h5><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,[Arr+1]</span><br><span class="line">mov ah,[str2+3]</span><br><span class="line">mov ax,Arr[2*6]</span><br><span class="line">mov ax,Arr[esi]</span><br><span class="line">mov ax,Arr[esi*(type arr)];C语言 Arr[index*sizeof(int)]</span><br></pre></td></tr></table></figure>

<p>在IDA里面它就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     al, byte_405001</span><br><span class="line">mov     ah, byte_40501C</span><br><span class="line">mov     ax, byte_40500D</span><br><span class="line">mov     ax, byte_405010[esi]</span><br><span class="line">mov     ax, word_404000[esi*2]</span><br><span class="line">//间接寻址的方式会更加的好看</span><br></pre></td></tr></table></figure>

<p>这就是使用寄存器的好处.很直观</p>
<blockquote>
<p>另外注意的是</p>
<p>如果Arr是</p>
<p>db型, Arr+1就是Arr[1]</p>
<p>dw型,Arr+2*1才是Arr[1]</p>
<p>这不同于C语言,这里的每个++都是一个一个字节的处理</p>
</blockquote>
<h5 id="计算数组长度"><a href="#计算数组长度" class="headerlink" title="计算数组长度"></a>计算数组长度</h5><p>1️⃣$取地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr 	db 1,2,3,4,5,6</span><br><span class="line">arr_end	dd $</span><br><span class="line">len     =(arr_end-arr)/1</span><br><span class="line">//这个1是type arr</span><br></pre></td></tr></table></figure>



<p>2️⃣lengthof直接算个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr db 1,2,3,4,5,</span><br><span class="line">		6,7,8,9,10</span><br><span class="line">len  =  lengthof arr</span><br></pre></td></tr></table></figure>



<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="汇编指针"><a href="#汇编指针" class="headerlink" title="汇编指针"></a>汇编指针</h4><p>后面我才遇到,指针类型是<code>ptr word</code>,</p>
<p>而指针的使用是<code>word ptr</code></p>
<p>这还是有很大的不同的</p>
<p><code> off_404012</code>&#x3D;&#x3D;*(0x404012)</p>
<p><code>off_404016</code>&#x3D;&#x3D;*(0x404016)</p>
<p> 而前面的word ptr或者byte ptr 只不过是强制类型转化</p>
<p>x86 指针用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Dqx_Gh0st</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD	</span><br><span class="line"></span><br><span class="line">db_ptr typedef ptr byte</span><br><span class="line">dw_ptr typedef ptr word</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	arr1		db 9,8,7,6,5,4,3,2</span><br><span class="line">	arr2		dw 9,8,7,6,5,4,3,2,1</span><br><span class="line">	ptr1		dd arr1	</span><br><span class="line">	ptr2        dd arr2</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	xor eax,eax                                                                                          		....</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>你用了一个中间值的转化</p>
<p>然后就接没有问题</p>
<p>(在8086也遇到过这种情况)</p>
<p>esi&#x3D;*(ptr1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esi,ptr1</span><br><span class="line">mov al,byte ptr [ esi+ (type arr1)*4]</span><br><span class="line">mov esi,ptr2</span><br><span class="line">mov ax,word ptr [esi+ (type arr2)*5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>错误的用法</p>
<p>直接使用指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax    </span><br><span class="line">mov al,byte ptr [ ptr1+ (type arr1)*4];错误的写法</span><br><span class="line">mov ax,word ptr [ ptr2+ (type arr2)*5];错误的写法</span><br><span class="line"></span><br><span class="line">xor eax,eax</span><br><span class="line">mov ax, word ptr  ptr1 [(type arr1)*4] ;错误的写法</span><br><span class="line">mov ax, word ptr  ptr2 [(type arr2)*5];错误的写法</span><br></pre></td></tr></table></figure>

<p>于是上面的ptr1就是变量ptr1的地址</p>
<p>*ptr1&#x3D;&amp;arr1</p>
<p><code>mov al,[ptr1+1*4]</code>都是错的</p>
<h4 id="反汇编和C指针"><a href="#反汇编和C指针" class="headerlink" title="反汇编和C指针"></a>反汇编和C指针</h4><p>x86</p>
<p>不管你是几级的指针,它的指针长度都是4字节</p>
<p>在反汇编结果里面也直接看不出来是几级指针</p>
<p>对于char*的指针</p>
<p>我们都知道,char* ptr 中ptr++是地址+1</p>
<p>对于char** ptr的指针,ptr++就是+4了</p>
<p>其它的可以类比</p>
<p>指针运算</p>
<p>(0).</p>
<p>​	指针不可以乘除,可以加减,   运算的结果是int类型</p>
<p>​	运算,明面上是x参与运算,实际上是x*sizeof(xxx)参与运算 </p>
<p>​	不同类型的指针,不可以运算</p>
<p>(2). 指针可以参与大小的比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>**** x = (<span class="type">int</span>****)<span class="number">0</span>;</span><br><span class="line">	x=x+<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后,x&#x3D;8 不用多说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span>* x = (<span class="type">short</span>*)<span class="number">100</span>;</span><br><span class="line">	<span class="type">short</span>* y = (<span class="type">short</span>*)<span class="number">200</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y-x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		:50</span></span><br><span class="line"><span class="comment">		:D:\Code\Vs-2022\work\w1\Debug\w1.exe (进程 4116)已退出，代码为 0。</span></span><br><span class="line"><span class="comment">		:按任意键关闭此窗口. .</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>输出50…是因为<code>(200-100)/sizeof(short)</code></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>[ebx+18]&#x3D;012</p>
<p>[ebx]&#x3D;0x12</p>
<p>提供[ebx+18]这种形式就大概可以看出他是结构体</p>
<blockquote>
<p> 特点: 结构体成员的地址连续,但是一般不是等宽</p>
</blockquote>
<p>如何理解?</p>
<p>一个地址指向了一个数据区域</p>
<p>这个区域有db,dw,dd,dq…..</p>
<p>然后通过指针可以访问这些数据</p>
<p>这个指针是第一个元素的地址</p>
<h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>如果结构体成员最大字节<code>&lt;</code>默认对齐字节大小 ,按照最大成员字节对齐,而不是默认对齐</p>
<p>如果最大成员字节大小&gt;默认对齐,按照默认对齐的方式对齐</p>
<p>就近原则对齐,从局部到整体</p>
<h4 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data </span><br><span class="line">my_struct struct</span><br><span class="line">    var1 db ?</span><br><span class="line">    var2 dw ?</span><br><span class="line">    var3 dd	?</span><br><span class="line">my_struct	ends</span><br><span class="line"> </span><br><span class="line">var1	my_truct	&lt;&gt;;不初始化</span><br><span class="line">var2	my_struct	&lt;1,2,3&gt;;初始话</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dqx_good STRUCT</span><br><span class="line">    IdNum BYTE    &quot;0000000&quot;  </span><br><span class="line">    LastName BYTE 20 DUP(0) </span><br><span class="line">    ALIGN word</span><br><span class="line">    Years WORD 0                        </span><br><span class="line">    ALIGN DWORD                         </span><br><span class="line">    SalaryHistory DWORD 0,0,0,0         </span><br><span class="line">dqx_good ENDS </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person1 dqx_good &lt;&quot;2001&quot;,&quot;Dqx_Gh0st&quot;,100,&#123;4000h,,5000h,6000h&#125;&gt;</span><br><span class="line">//这是在声明的时候一起初始化</span><br></pre></td></tr></table></figure>



<p>对于变量1 IdNum 的初始化,如果你写入的数据小于预设长度,剩下的用空格填充,也就是0x20</p>
<p>对于变量2 LsatName 的初始化,如果你写入的数据小于预设长度,剩下的用0初始化</p>
<p><code>对于最后一个数组的初始话,要加一个大括号&#123;&#125;才可以不报错,否则报错</code></p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node struct</span><br><span class="line">	num			dd			?</span><br><span class="line">	next		WNDCLASS	&lt;&gt;</span><br><span class="line">	stop_flag	db			?</span><br><span class="line">node ends</span><br><span class="line"></span><br><span class="line">x	node	&lt;20,,10&gt;</span><br><span class="line">//我们只是声明了外边2个变量,中间那个变量没有初始化</span><br></pre></td></tr></table></figure>





<p>用这种形式的话,我们要<code>assuem</code>一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esi,offset var2</span><br><span class="line">assume esi:ptr my_struct_type //定义esi为my_struct_type这种数据类型</span><br><span class="line">mov al, [esi].db_var1</span><br><span class="line">assume esi:nothing//取消定义</span><br></pre></td></tr></table></figure>





<h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>假设有结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dqx STRUCT</span><br><span class="line">    ID		BYTE &quot;000000000&quot;  </span><br><span class="line">    LastName	BYTE 20 DUP(0) </span><br><span class="line">    ALIGN word</span><br><span class="line">    year  WORD 0                        </span><br><span class="line">    ALIGN DWORD                         </span><br><span class="line">    salary DWORD 0,0,0,0         </span><br><span class="line">dqx ENDS </span><br></pre></td></tr></table></figure>



<p>然后定义一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr	dqx	15 dup (&lt; &gt;)</span><br></pre></td></tr></table></figure>

<p>调用它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esi,0</span><br><span class="line">arr[esi].year=100</span><br><span class="line">add	esi,type xx_struct</span><br><span class="line">arr[esi].num=200</span><br></pre></td></tr></table></figure>



<h4 id="包含结构体的结构体"><a href="#包含结构体的结构体" class="headerlink" title="包含结构体的结构体"></a>包含结构体的结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a struct </span><br><span class="line">	x db ?</span><br><span class="line">	y db ?</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b struct </span><br><span class="line">	z a &lt;&gt;</span><br><span class="line">	q a &lt;&gt;</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">;初始化一个变量</span><br><span class="line">dqx b &lt;&#123;1,2&#125;,&#123;3,4&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>就这样就定义了一个包含结构体的结构体</p>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	dqx.z.x,6</span><br><span class="line"></span><br><span class="line">mov	esi,offset dqx</span><br><span class="line">mov	(b ptr [esi]).z.y,7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov	edi,OFFSET dqx.z</span><br><span class="line">mov	(a PTR [edi]).x, 8</span><br><span class="line"></span><br><span class="line">mov	edi,OFFSET dqx.z.y</span><br><span class="line">mov	byte PTR [edi], 9</span><br></pre></td></tr></table></figure>





<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>他和数组在堆栈中的排布类似</p>
<p>第一个成员在栈上方</p>
<p>最后一个成员在栈下方</p>
<h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>一般的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num UNION</span><br><span class="line">    D DWORD 1</span><br><span class="line">    W WORD 5</span><br><span class="line">    B BYTE 8</span><br><span class="line">Num ENDS</span><br></pre></td></tr></table></figure>

<p>把最大长度写在最前面,顺序呈降次</p>
<p>关于使用,Num的大小一直是最大尺度大小,也就是4字节</p>
<p>如果你初始化1字节,余下的字节就会用algin填充0,</p>
<p>1️⃣构体中的联合体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stu1 STRUCT</span><br><span class="line">    ID1   Num &lt;&gt;</span><br><span class="line">    Name1 BYTE 4 DUP(&#x27;X&#x27;)</span><br><span class="line">stu1 ENDS</span><br><span class="line">//沿用Num联合体</span><br></pre></td></tr></table></figure>

<p>2️⃣在结构体里面声明,但是有点不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stu2 STRUCT</span><br><span class="line">    UNION ID2</span><br><span class="line">        D DWORD 70h</span><br><span class="line">        W WORD  80h</span><br><span class="line">        B BYTE  90h</span><br><span class="line">    ENDS</span><br><span class="line">    Name2 BYTE 4 DUP(&#x27;X&#x27;)</span><br><span class="line">stu2 ENDS</span><br></pre></td></tr></table></figure>

<p>很奇怪,他有2个ends</p>
<p>第一个没有写ID2 ends</p>
<blockquote>
<p> 注意事项1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num UNION	</span><br><span class="line">	D DWORD 60h</span><br><span class="line">	W WORD  70h</span><br><span class="line">	B BYTE  80h</span><br><span class="line">Num ENDS</span><br><span class="line"></span><br><span class="line">s1 Num &lt;12345678h&gt;</span><br><span class="line">mov	s1.B, 6</span><br></pre></td></tr></table></figure>

<p>虽然你初始化了s1.b&#x3D;6,但是以前的数据还是没有全部丢失,你只是覆盖了0x78为6</p>
<p>以前是0x12345678,现在是0x12345606</p>
<blockquote>
<p>注意事项2</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num UNION	</span><br><span class="line">	D DWORD 60h</span><br><span class="line">	W WORD  70h</span><br><span class="line">	B BYTE  80h</span><br><span class="line">Num ENDS</span><br></pre></td></tr></table></figure>

<p>像这种声明,word,byte的数据会被dword掩盖,所以后面2句的初始化都是无效的</p>
<p>以供调试的代码</p>
<p>里面的字节对齐很有意思</p>
<p>algin的用法见目录篇:指令集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		                                         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Num UNION	</span><br><span class="line">	D DWORD 60h</span><br><span class="line">	W WORD  70h</span><br><span class="line">	B BYTE  80h</span><br><span class="line">Num ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 STRUCT</span><br><span class="line">    ID1   Num &lt;&gt;</span><br><span class="line">    Name1 BYTE 4 DUP(&#x27;X&#x27;)</span><br><span class="line">stu1 ENDS</span><br><span class="line"></span><br><span class="line">stu2 STRUCT</span><br><span class="line">    UNION ID2</span><br><span class="line">        D DWORD 70h</span><br><span class="line">        W WORD  80h</span><br><span class="line">        B BYTE  90h</span><br><span class="line">    ENDS</span><br><span class="line">    Name2 BYTE 4 DUP(&#x27;X&#x27;)</span><br><span class="line">stu2 ENDS</span><br><span class="line">	</span><br><span class="line">s1 Num &lt;12345678h&gt;</span><br><span class="line">s2 Num &lt;66h&gt;</span><br><span class="line">s3 Num  &lt; &gt;</span><br><span class="line">s4 stu1 &lt; &gt;</span><br><span class="line">s5 stu2 &lt; &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		mov	s1.B, 6</span><br><span class="line">		mov	s2.W, 4</span><br><span class="line">		mov	s3.D, 5</span><br><span class="line"></span><br><span class="line">		mov	s4.ID1.B,9</span><br><span class="line">		mov	s5.ID2.W,8</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line">;----------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>宏实在IDA里面不会出现的,在编译阶段实现一个数据的初始化与填充</p>
<p>在源代码的开头我们有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=1</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		xor eax,eax	</span><br><span class="line">		x=100</span><br><span class="line">		mov eax,x</span><br><span class="line">		x=1000</span><br><span class="line">		mov eax,x</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>一般会被定义位一个32位的数据长度</p>
<p>在汇编里面看到的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc near               ; CODE XREF: start↑j</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 100</span><br><span class="line">mov     eax, 1000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028      endp</span><br></pre></td></tr></table></figure>

<p>可以看到,其实变量x并没有分配到内存,因为它不存在地址…</p>
<p>而且IDA里面也不会出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=100</span><br><span class="line">x=1000</span><br></pre></td></tr></table></figure>

<p>这些操作</p>
<p>可见它真的没有分配地址</p>
<p>正式因为这样才会有下面的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push x</span><br><span class="line">x=6666</span><br><span class="line">pop x</span><br></pre></td></tr></table></figure>

<p>你可以push一个立即数,那是因为你有一个接收数据的地方</p>
<p>但是你不可以pop一个数据到立即数,就好比<code>pop 100</code></p>
<p>这一看就是一个大错误</p>
<h4 id="宏声明"><a href="#宏声明" class="headerlink" title="宏声明"></a>宏声明</h4><p>在调用宏过程时，其代码的副本将被直接插入到程序中该宏被调用的位置。相当于一个字符串替换</p>
<p>位置宏定义一般出现在程序源代码开始的位置，或者是放在独立文件中，再用 INCLUDE 伪指令复制到程序里。</p>
<p>所以的话,你应该封装一下你的函数</p>
<p>就像书上恶心的第三方库函数</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏名称	macro</span><br><span class="line">    变量/指令</span><br><span class="line">	endm</span><br></pre></td></tr></table></figure>



<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">ok	macro</span><br><span class="line">    mov al,&#x27;X&#x27;</span><br><span class="line">    mov bl,&#x27;Y&#x27;</span><br><span class="line">	endm</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line"></span><br><span class="line">		.code</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:	</span><br><span class="line">		ok</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end	start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>于是在IDA的代码里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">mov     al, 58h ; &#x27;X&#x27;</span><br><span class="line">mov     bl, 59h ; &#x27;Y&#x27;</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>

<h4 id="参数宏"><a href="#参数宏" class="headerlink" title="参数宏"></a>参数宏</h4><p>要在宏声明的时候,后面写几个参数就欧克</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">m_ok	macro var1,var2</span><br><span class="line">    	mov al,var1</span><br><span class="line">    	mov bl,var2</span><br><span class="line">endm</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line"></span><br><span class="line">		.code	</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:	</span><br><span class="line">		m_ok 97,98</span><br><span class="line">		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end	start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>如果你的参数给错了,参数给少了,怎么办?</p>
<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">mov     al, 97 ; &#x27;X&#x27;</span><br><span class="line">mov     bl, 98 ; &#x27;Y&#x27;</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>







<h4 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h4><h5 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h5><p>这里有2个函数宏</p>
<p>第一个函数宏的功能是创建字符串,然后记录下他的地址</p>
<p>第二个函数宏的功能是创建字符串,他的地址无法二次引用</p>
<p>思考一下第二个宏,每一次创建的字符串都叫@string.是有问题的.所以我们才用了local来解决这个问题</p>
<p>值得注意的是,里面的.data与.code伪指令不要忘了,会引起很大的失误的</p>
<p>如果你的宏只是在data区建立的话,就用不上写data与code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">makestr MACRO @name ,@text</span><br><span class="line">    .data</span><br><span class="line">    @name BYTE @text,0</span><br><span class="line">    .code</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">makestring MACRO @text</span><br><span class="line">    LOCAL @string</span><br><span class="line">    .data</span><br><span class="line">    @string BYTE @text,0</span><br><span class="line">    .code</span><br><span class="line">ENDM</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:	</span><br><span class="line">		makestr str1,&quot;Gh0st&quot;</span><br><span class="line">		mov	esi,offset str1 </span><br><span class="line"></span><br><span class="line">		makestr str2,&quot;Dqx&quot;</span><br><span class="line">		mov	edi,offset str2</span><br><span class="line"></span><br><span class="line">		makestring &quot;Hello&quot;</span><br><span class="line">		makestring &quot;I am fine&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>





<h5 id="其他版"><a href="#其他版" class="headerlink" title="其他版"></a>其他版</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isdefine macro button</span><br><span class="line">	ifdef  button</span><br><span class="line">		exitm&lt; 1 &gt;</span><br><span class="line">	else </span><br><span class="line">		exitm&lt; 0 &gt;</span><br><span class="line">	endif</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>exitm会返回一个数字给宏判断</p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ifdefine(flag)</span><br><span class="line">	include xx.inc</span><br><span class="line">else</span><br><span class="line">	include yy.inc</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>差不多就这样用</p>
<p>后续遇到再补充</p>
<h4 id="宏嵌套"><a href="#宏嵌套" class="headerlink" title="宏嵌套"></a>宏嵌套</h4><p>就是在一个宏里面嵌套另外一个宏</p>
<p>类似于函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">makestr MACRO @name ,@text</span><br><span class="line">    .data</span><br><span class="line">    @name byte @text,0</span><br><span class="line">    .code</span><br><span class="line">    show @text</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">show MACRO @text</span><br><span class="line">    echo @text</span><br><span class="line">ENDM</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:	</span><br><span class="line">		makestr str1,&quot;hi,Gh0st,I was created!&quot;</span><br><span class="line">		mov	esi,offset str1 </span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="条件宏"><a href="#条件宏" class="headerlink" title="条件宏"></a>条件宏</h4><p>如果满足条件,就把某段代码进行编译,否则就不进行编译</p>
<p>下面字母的缩写</p>
<p>B:blank,空的意思</p>
<p>D:define</p>
<table>
<thead>
<tr>
<th>伪指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IF 表达式</td>
<td>若 expression 为真（非零）则允许汇编。可能的关系运算符为 LT、GT、EQ、NE、LE 和 GE</td>
</tr>
<tr>
<td>IFB &lt;var1,var2&gt;</td>
<td>如果没有实参传入形参,就返回true,指向语句块</td>
</tr>
<tr>
<td>IFNB &lt;var1,var2&gt;</td>
<td>如果非空,有参数的传进,就执行语句块</td>
</tr>
<tr>
<td>IFIDN&lt; arg1&gt;,&lt; arg2 &gt;</td>
<td>若两个实参相等（相同）则允许汇编。采用区分大小写的比较</td>
</tr>
<tr>
<td>IFIDNI&lt; arg1 &gt;,&lt; arg2&gt;</td>
<td>若两个实参相等（相同）则允许汇编。采用不区分大小写的比较</td>
</tr>
<tr>
<td>IFDIF&lt; arg1 &gt;,&lt; arg2&gt;</td>
<td>若两个实参不相等则允许汇编。采用区分大小写的比较</td>
</tr>
<tr>
<td>IFDIFI&lt; arg1&gt;,&lt; arg2&gt;</td>
<td>若两个实参不相等则允许汇编。采用不区分大小写的比较</td>
</tr>
<tr>
<td>IFDIF name</td>
<td>若 name 已定义则允许汇编</td>
</tr>
<tr>
<td>IFNDEF name</td>
<td>若 name 还未定义则允许汇编</td>
</tr>
<tr>
<td>ENDIF</td>
<td>结束用一个条件汇编伪指令开始的代码块</td>
</tr>
<tr>
<td>ELSE</td>
<td>若条件为真，则终止汇编之前的语句。若条件为假，ELSE 汇编语句直到遇到下一个 ENDIF</td>
</tr>
<tr>
<td>ELSEIF expression</td>
<td>若之前条件伪指令指定的条件为假，而当前表达式为真，则汇编全部语句直到出现 ENDIF</td>
</tr>
<tr>
<td>EXITM</td>
<td>立即退出宏，阻止所有后续宏语句的展开</td>
</tr>
</tbody></table>
<p>例子:检测参数列表</p>
<p>试了一下,可以正确的检测2个参数,如果2个参数传递不够,就会语法错误,而不是执行else的语句</p>
<p>对于一个参数,是可以正常检测是否有的,如果传入就指向语句块,否则指向else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">makestr MACRO @name</span><br><span class="line"></span><br><span class="line">	ifnb &lt;@name&gt;</span><br><span class="line">		.data</span><br><span class="line">		@name byte &quot;hello,i am here&quot;,0</span><br><span class="line">		.code</span><br><span class="line">	else</span><br><span class="line">		echo haha,you are wrong</span><br><span class="line">	endif</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:	</span><br><span class="line">		makestr</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>后面详细的讲一下,条件宏</p>
<h4 id="宏调用的默认参数初始化"><a href="#宏调用的默认参数初始化" class="headerlink" title="宏调用的默认参数初始化"></a>宏调用的默认参数初始化</h4><p>如果我们传入的参数不够,我们可以用ifb来检测,但是我们也可以使用默认参数来解决问题</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏名 macro 参数名:=&lt; xxx &gt;</span><br></pre></td></tr></table></figure>





<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">makestr MACRO @name:=&lt;Empty_name&gt;,@str:=&lt;&quot;no string&quot;&gt;</span><br><span class="line">		local @name</span><br><span class="line">		.data</span><br><span class="line">		@name byte @str,0</span><br><span class="line">		.code</span><br><span class="line">		mov esi,offset @name</span><br><span class="line">		push esi</span><br><span class="line">		add  esp,4</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:	</span><br><span class="line">		makestr str1,</span><br><span class="line">		makestr ,&quot;no name&quot;</span><br><span class="line">		makestr good,&quot;bad&quot;</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>上面之所以用local是因为,如果你一直不传入name的话,他会一直调用name作为关键字,导致name重复使用的语法错误</p>
<h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><p>之前说了一下宏条件的<code>if</code>条件</p>
<p>他后面的表达式可以是布尔表达式</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">LT</td>
<td align="center">little,小于的意思</td>
<td></td>
</tr>
<tr>
<td align="center">GT</td>
<td align="center">greate,大于的意思</td>
<td></td>
</tr>
<tr>
<td align="center">EQ</td>
<td align="center">equal,等于的意思</td>
<td></td>
</tr>
<tr>
<td align="center">NE</td>
<td align="center">not equal,不相等的意思</td>
<td></td>
</tr>
<tr>
<td align="center">LE</td>
<td align="center">little and equal ,表示小于等于</td>
<td></td>
</tr>
<tr>
<td align="center">GE</td>
<td align="center">greate and equal,大于等于</td>
<td></td>
</tr>
</tbody></table>
<p>好比这么用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (X LT 0) or (Y GT 79)</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>



<h4 id="IF-x2F-ELSE-x2F-ENDIF"><a href="#IF-x2F-ELSE-x2F-ENDIF" class="headerlink" title="IF&#x2F;ELSE&#x2F;ENDIF"></a>IF&#x2F;ELSE&#x2F;ENDIF</h4><p>它后面可以接</p>
<p>整数常量</p>
<p>符号常量</p>
<p>常量</p>
<p>什么叫符号常量?什么叫整数常量</p>
<p>但不可以接寄存器或者变量名</p>
<p>常有的形式有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if </span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if</span><br><span class="line"></span><br><span class="line">esle</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<h4 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h4><h5 id="amp-替换符号"><a href="#amp-替换符号" class="headerlink" title="&amp; 替换符号"></a>&amp; 替换符号</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">makestr MACRO b_name:=&lt;Empty_name&gt;,b_str:=&lt;no string&gt;</span><br><span class="line">		local b_name</span><br><span class="line">		.data</span><br><span class="line">		b_name byte &amp;b_str,0</span><br><span class="line">		.code</span><br><span class="line">		mov esi,offset b_name</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:	</span><br><span class="line">		makestr one, &quot;I was a str!&quot;</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>你的参数<code>&quot;I was a str!&quot;</code>会用在&amp;b_str,然后直接别替换掉</p>
<p>感觉没太大的用</p>
<p>而且与原来的用法有什么区别我还不知道</p>
<h5 id="格式转化"><a href="#格式转化" class="headerlink" title="% 格式转化"></a>% 格式转化</h5><p>在TEXTEQU的运用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;makestr MACRO </span><br><span class="line"></span><br><span class="line">;ENDM</span><br><span class="line">Digit = 4</span><br><span class="line">Num textequ %(Digit+5)</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	</span><br><span class="line">		mov eax,Num</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>在之前我们也有提及textequ的宏</p>
<p>例子1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;makestr MACRO </span><br><span class="line"></span><br><span class="line">;ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">arr db 9 dup(&#x27;C&#x27;)		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	</span><br><span class="line">		echo The arr contains (SIZEOF arr) bytes	;wrong</span><br><span class="line">		echo The arr contains %(SIZEOF arr) bytes	;wrong</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		how_many textequ %(SIZEOF arr)				;正确的</span><br><span class="line">		% echo The arr contains how_many bytes</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft (R) Program Maintenance Utility Version 14.31.31105.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">        ml /c /coff x.asm</span><br><span class="line">Microsoft (R) Macro Assembler Version 6.14.8444</span><br><span class="line">Copyright (C) Microsoft Corp 1981-1997.  All rights reserved.</span><br><span class="line"></span><br><span class="line"> Assembling: x.asm</span><br><span class="line"></span><br><span class="line">***********</span><br><span class="line">ASCII build</span><br><span class="line">***********</span><br><span class="line"></span><br><span class="line">The arr contains (SIZEOF arr) bytes</span><br><span class="line">The arr contains %(SIZEOF arr) bytes</span><br><span class="line">The arr contains 9 bytes</span><br><span class="line"></span><br><span class="line">        Link /subsystem:windows x.obj</span><br><span class="line">Microsoft (R) Incremental Linker Version 5.12.8078</span><br><span class="line">Copyright (C) Microsoft Corp 1992-1998. All rights reserved.</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<p>代码的功能就是实现 val3 &#x3D; val1 * val2</p>
<p>里面有个检测</p>
<p>我们都知道乘法的eax是作为第一个因素的,不能作为第二个</p>
<p>所以这里有个检测</p>
<p>正确的代码,输出结果无</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MUL32 MACRO op1, op2, product</span><br><span class="line">	ifidni &lt;op2&gt;,&lt;eax&gt;</span><br><span class="line">	  line_Num TEXTEQU %(@LINE)</span><br><span class="line"></span><br><span class="line">	  ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">%	  ECHO *  Error on line line_Num: EAX cannot be as the second var</span><br><span class="line">	  ECHO *  argument when invoking the MUL32 macro.</span><br><span class="line">	  ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">	exitm</span><br><span class="line">	;</span><br><span class="line">	endif</span><br><span class="line">	push eax</span><br><span class="line">	mov  eax,op1</span><br><span class="line">	mul  op2</span><br><span class="line">	mov  product,eax</span><br><span class="line">	pop  eax</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">val1   DWORD 3</span><br><span class="line">val2   DWORD 2</span><br><span class="line">result DWORD ?		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	;MUL32 val1,val2,result		; val3 = val1 * val2</span><br><span class="line"></span><br><span class="line">	mov eax,val1</span><br><span class="line">	MUL32 eax,val2,result</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>错误的代码,把eax作为了第二个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MUL32 MACRO op1, op2, product</span><br><span class="line">	ifidni &lt;op2&gt;,&lt;eax&gt;</span><br><span class="line">	  line_Num TEXTEQU %(@LINE)</span><br><span class="line"></span><br><span class="line">	  ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">%	  ECHO *  Error on line line_Num: EAX cannot be as the second var</span><br><span class="line">	  ECHO *  argument when invoking the MUL32 macro.</span><br><span class="line">	  ECHO xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">	exitm</span><br><span class="line">	;exit会退出所有的宏定义,意思就是下面的语句不再执行</span><br><span class="line">	;虽然我们可以通过elseif来不执行</span><br><span class="line">	endif</span><br><span class="line">	push eax</span><br><span class="line">	mov  eax,op1</span><br><span class="line">	mul  op2</span><br><span class="line">	mov  product,eax</span><br><span class="line">	pop  eax</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">val1   DWORD 3</span><br><span class="line">val2   DWORD 2</span><br><span class="line">result DWORD ?		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	;MUL32 val1,val2,result		; val3 = val1 * val2</span><br><span class="line"></span><br><span class="line">	mov   eax,val1</span><br><span class="line">	MUL32 val2,eax,result</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft (R) Program Maintenance Utility Version 14.31.31105.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">        ml /c /coff x.asm</span><br><span class="line">Microsoft (R) Macro Assembler Version 6.14.8444</span><br><span class="line">Copyright (C) Microsoft Corp 1981-1997.  All rights reserved.</span><br><span class="line"></span><br><span class="line"> Assembling: x.asm</span><br><span class="line"></span><br><span class="line">***********</span><br><span class="line">ASCII build</span><br><span class="line">***********</span><br><span class="line"></span><br><span class="line">x.asm(36) : error A2006: undefined symbol : @LINE</span><br><span class="line"> MUL32(2): Macro Called From</span><br><span class="line">  x.asm(36): Main Line Code</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">*  Error on line 0: eax cannot be as the second var</span><br><span class="line">*  argument when invoking the MUL32 macro.</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">NMAKE : fatal error U1077: &#x27;D:\Back\C0de_IDE\Asm\x86\masm32\bin\ml.EXE&#x27; : return code &#x27;0x1&#x27;</span><br><span class="line">Stop.</span><br></pre></td></tr></table></figure>





<h5 id="lt-gt-文字文本替换符"><a href="#lt-gt-文字文本替换符" class="headerlink" title="&lt; &gt; 文字文本替换符"></a>&lt; &gt; 文字文本替换符</h5><p>他会把&lt;&gt;里的内容当做一个文本的整体导入,这个文本不是浅层意义字符串,而是xxx,就像你现在打的字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make macro t_str</span><br><span class="line">	local t_name</span><br><span class="line">	.data </span><br><span class="line">	t_name byte t_str,0</span><br><span class="line">	.code </span><br><span class="line">	mov esi,offset t_name</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		make    &quot;I am here&quot;,0Dh,0Ah</span><br><span class="line">		make    &lt;&quot;I am there&quot;,0Dh,0Ah&gt;</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>0Dh是回车,0Ah是换行</p>
<p>第一个语句看似像给str传入”I am here”,0Dh,0Ah,但是被识别为3个参数,编译器发出警告,然后舍弃最后2个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.asm(17) : warning A4006: too many arguments in macro call</span><br><span class="line"> make(1): Macro Called From</span><br></pre></td></tr></table></figure>



<p>然后第二种写法才是把他们当做一个整体写入</p>
<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403000 aIAmHere        db &#x27;I am here&#x27;,0        ; DATA XREF: start↑o</span><br><span class="line">.data:0040300A aIAmThere       db &#x27;I am there&#x27;,0Dh,0Ah,0</span><br><span class="line">.data:0040300A                                         ; DATA XREF: start+5↑o</span><br><span class="line">.data:00403017                 align 1000h</span><br></pre></td></tr></table></figure>



<h5 id="强制处理运算符"><a href="#强制处理运算符" class="headerlink" title="!  强制处理运算符"></a>!  强制处理运算符</h5><p>在C语言里面我们有转移字符</p>
<p>好比\n转义为换行</p>
<p>在masm里面,!的作用好比这个</p>
<p>多的也不说,感觉没怎么用</p>
<h4 id="宏循环"><a href="#宏循环" class="headerlink" title="宏循环"></a>宏循环</h4><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><p>看代码会更加的清晰</p>
<p>一个斐波拉契数列,后一项是前2项的sum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">x=1</span><br><span class="line">y=1</span><br><span class="line">byte x</span><br><span class="line">byte y</span><br><span class="line">z=x+y</span><br><span class="line">while z LT 10</span><br><span class="line">	byte z</span><br><span class="line">	x=y</span><br><span class="line">	y=z</span><br><span class="line">	z=x+y</span><br><span class="line">endm</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>他的效果是个啥????</p>
<p>首先我们创建了2个变量,x和y</p>
<p>然后利用循环不断的创建z变量</p>
<p>最后在data区我们得到了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000                 db    1</span><br><span class="line">.data:00403001                 db    1</span><br><span class="line">.data:00403002                 db    2</span><br><span class="line">.data:00403003                 db    3</span><br><span class="line">.data:00403004                 db    5</span><br><span class="line">.data:00403005                 db    8</span><br><span class="line">.data:00403006                 db    0</span><br><span class="line">.data:00403007                 db    0</span><br></pre></td></tr></table></figure>



<h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><p>与dup类似</p>
<p>它适用于有一定次数的循环</p>
<p>用法是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat 循环次数</span><br><span class="line">	xxx</span><br><span class="line">endm</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">count=10</span><br><span class="line">xy	struct</span><br><span class="line">	x byte 10h</span><br><span class="line">	y byte 23h</span><br><span class="line">xy	ends</span><br><span class="line"></span><br><span class="line">zq	struct</span><br><span class="line">	z byte 34h</span><br><span class="line">	q byte 56h</span><br><span class="line">zq	ends</span><br><span class="line"></span><br><span class="line">xyzq	struct</span><br><span class="line"></span><br><span class="line">	repeat count</span><br><span class="line">	local b_xy,b_zq</span><br><span class="line">	b_xy xy &lt;&gt;</span><br><span class="line">	b_zq zq &lt;&gt;</span><br><span class="line">	endm</span><br><span class="line"></span><br><span class="line">xyzq	ends</span><br><span class="line"></span><br><span class="line">one xyzq &lt;&gt;</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>在data区的效果,创建了10个xy,zq的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000                 db  10h</span><br><span class="line">.data:00403001                 db  23h ; #</span><br><span class="line">.data:00403002                 db  34h ; 4</span><br><span class="line">.data:00403003                 db  56h ; V</span><br><span class="line">.data:00403004                 db  10h</span><br><span class="line">.data:00403005                 db  23h ; #</span><br><span class="line">.data:00403006                 db  34h ; 4</span><br><span class="line">.data:00403007                 db  56h ; V</span><br><span class="line">.data:00403008                 db  10h</span><br><span class="line">.data:00403009                 db  23h ; #</span><br><span class="line">.data:0040300A                 db  34h ; 4</span><br><span class="line">.data:0040300B                 db  56h ; V</span><br><span class="line">.data:0040300C                 db  10h</span><br><span class="line">.data:0040300D                 db  23h ; #</span><br><span class="line">.data:0040300E                 db  34h ; 4</span><br><span class="line">.data:0040300F                 db  56h ; V</span><br><span class="line">.data:00403010                 db  10h</span><br><span class="line">.data:00403011                 db  23h ; #</span><br><span class="line">.data:00403012                 db  34h ; 4</span><br><span class="line">.data:00403013                 db  56h ; V</span><br><span class="line">.data:00403014                 db  10h</span><br><span class="line">.data:00403015                 db  23h ; #</span><br><span class="line">.data:00403016                 db  34h ; 4</span><br><span class="line">.data:00403017                 db  56h ; V</span><br><span class="line">.data:00403018                 db  10h</span><br><span class="line">.data:00403019                 db  23h ; #</span><br><span class="line">.data:0040301A                 db  34h ; 4</span><br><span class="line">.data:0040301B                 db  56h ; V</span><br><span class="line">.data:0040301C                 db  10h</span><br><span class="line">.data:0040301D                 db  23h ; #</span><br><span class="line">.data:0040301E                 db  34h ; 4</span><br><span class="line">.data:0040301F                 db  56h ; V</span><br><span class="line">.data:00403020                 db  10h</span><br><span class="line">.data:00403021                 db  23h ; #</span><br><span class="line">.data:00403022                 db  34h ; 4</span><br><span class="line">.data:00403023                 db  56h ; V</span><br><span class="line">.data:00403024                 db  10h</span><br><span class="line">.data:00403025                 db  23h ; #</span><br><span class="line">.data:00403026                 db  34h ; 4</span><br><span class="line">.data:00403027                 db  56h ; V</span><br><span class="line">.data:00403028                 db    0</span><br><span class="line">.data:00403029                 db    0</span><br></pre></td></tr></table></figure>







<h5 id="for-循环取整数"><a href="#for-循环取整数" class="headerlink" title="for 循环取整数"></a>for 循环取整数</h5><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for name,&lt;name1,name2,name3&gt;</span><br><span class="line">	xx</span><br><span class="line">endm</span><br></pre></td></tr></table></figure>



<p>看例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">count=10</span><br><span class="line">xy	struct</span><br><span class="line">	x byte 55h</span><br><span class="line">	y byte 66h</span><br><span class="line">xy	ends</span><br><span class="line"></span><br><span class="line">for b_name,&lt;one,two,three,four,five,six&gt;</span><br><span class="line">    b_name xy &lt;&gt;</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for b_value,&lt;97,98,99,100,101,102&gt;</span><br><span class="line">	local b_name</span><br><span class="line">	b_name byte b_value</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;for b_value,&#123;&lt;97,98&gt;,&lt;99,100&gt;,&lt;101,102&gt;&#125;</span><br><span class="line">	;local b_name</span><br><span class="line">	;b_name xy b_value</span><br><span class="line">;endm</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>最后在IDA的DATA区域得到的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000                 db  55h ; U</span><br><span class="line">.data:00403001                 db  66h ; f</span><br><span class="line">.data:00403002                 db  55h ; U</span><br><span class="line">.data:00403003                 db  66h ; f</span><br><span class="line">.data:00403004                 db  55h ; U</span><br><span class="line">.data:00403005                 db  66h ; f</span><br><span class="line">.data:00403006                 db  55h ; U</span><br><span class="line">.data:00403007                 db  66h ; f</span><br><span class="line">.data:00403008                 db  55h ; U</span><br><span class="line">.data:00403009                 db  66h ; f</span><br><span class="line">.data:0040300A                 db  55h ; U</span><br><span class="line">.data:0040300B                 db  66h ; f</span><br><span class="line">.data:0040300C                 db  61h ; a</span><br><span class="line">.data:0040300D                 db  62h ; b</span><br><span class="line">.data:0040300E                 db  63h ; c</span><br><span class="line">.data:0040300F                 db  64h ; d</span><br><span class="line">.data:00403010                 db  65h ; e</span><br><span class="line">.data:00403011                 db  66h ; f</span><br><span class="line">.data:00403012                 db    0</span><br><span class="line">.data:00403013                 align 1000h</span><br><span class="line">.data:00403013 _data           ends</span><br><span class="line">.data:00403013</span><br><span class="line">.data:00403013</span><br><span class="line">.data:00403013                 end start</span><br></pre></td></tr></table></figure>



<h5 id="forc-循环取字符"><a href="#forc-循环取字符" class="headerlink" title="forc 循环取字符"></a>forc 循环取字符</h5><p>与上一个例子类似</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forc &lt;无双引号的字符串&gt;</span><br><span class="line">	xx</span><br><span class="line">endm</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">forc code,&lt;!@#$%^&amp;*!&gt;!&lt;&gt;</span><br><span class="line">    byte &quot;&amp;code&quot;</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在IDA的data区域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000                 db &#x27;@#$%^&amp;*&gt;&lt;&#x27;,0</span><br><span class="line">.data:0040300A                 align 1000h</span><br></pre></td></tr></table></figure>



<h4 id="REQ"><a href="#REQ" class="headerlink" title="REQ"></a>REQ</h4><p>不知道什么鬼</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">m_ok	macro var1:REQ,var2:REQ</span><br><span class="line">    mov al,var1</span><br><span class="line">    mov bl,var2</span><br><span class="line">	endm</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line"></span><br><span class="line">		.code</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:	</span><br><span class="line">		m_ok 97,98		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end	start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="ECHO"><a href="#ECHO" class="headerlink" title="ECHO"></a>ECHO</h4><p>不知道什么鬼</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">m_ok	macro var1:REQ,var2:REQ</span><br><span class="line">	    ECHO  hello,I am link and masm</span><br><span class="line">        mov al,var1</span><br><span class="line">        mov bl,var2		</span><br><span class="line">	    endm</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line"></span><br><span class="line">		.code</span><br><span class="line">		</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:	</span><br><span class="line">		m_ok 97,98</span><br><span class="line">		ECHO  hello,I am Dqx_Gh0st</span><br><span class="line">		</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end	start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>ECHO的效果就是在输出字符串,不过在运行时不会输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft (R) Program Maintenance Utility Version 14.31.31105.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">        ml /c /coff x.asm</span><br><span class="line">Microsoft (R) Macro Assembler Version 6.14.8444</span><br><span class="line">Copyright (C) Microsoft Corp 1981-1997.  All rights reserved.</span><br><span class="line"></span><br><span class="line"> Assembling: x.asm</span><br><span class="line"></span><br><span class="line">***********</span><br><span class="line">ASCII build</span><br><span class="line">***********</span><br><span class="line"></span><br><span class="line">hello,I am link and masm</span><br><span class="line">hello,I am Dqx_Gh0st</span><br><span class="line">        Link /subsystem:windows x.obj</span><br><span class="line">Microsoft (R) Incremental Linker Version 5.12.8078</span><br><span class="line">Copyright (C) Microsoft Corp 1992-1998. All rights reserved.</span><br></pre></td></tr></table></figure>

<p>于是上面那里就输出了<code>hello,I am Dqx_Gh0st</code></p>
<p>但是运行x.exe是不会有输出的,就连调试也不会</p>
<h4 id="x64宏"><a href="#x64宏" class="headerlink" title="x64宏"></a>x64宏</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; macro.asm</span><br><span class="line">extern printf</span><br><span class="line"></span><br><span class="line">%define	double_it(r)	sal r, 1	;这里带有参数</span><br><span class="line"></span><br><span class="line">%macro	prntf	2					;2代表了2个参数,参数1是%1,参数2是%2</span><br><span class="line">	section .data</span><br><span class="line">			%%arg1	db	%1,0        ; first argument</span><br><span class="line">			%%fmtint	db	&quot;%s %ld&quot;,10,0 	; formatstring</span><br><span class="line">	section .text				; the printf arguments</span><br><span class="line">		mov	rdi, %%fmtint</span><br><span class="line">		mov	rsi, %%arg1</span><br><span class="line">		mov	rdx,[%2]        ; second argument</span><br><span class="line">		mov	rax,0           ; no floating point  </span><br><span class="line">		call printf</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">section .data							</span><br><span class="line">	number	dq	15					</span><br><span class="line">section .bss</span><br><span class="line">section .text							</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">	push rbp</span><br><span class="line">	mov rbp,rsp</span><br><span class="line">	prntf 	&quot;The number is&quot;, number</span><br><span class="line">	mov 	rax, [number]</span><br><span class="line">	double_it(rax)</span><br><span class="line">	mov 	[number],rax</span><br><span class="line">	prntf 	&quot;The number times 2 is&quot;, number</span><br><span class="line">	leave</span><br><span class="line">	ret	</span><br></pre></td></tr></table></figure>





<p><code>单行宏</code>以%define开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%define	double_it(r)	sal r, 1	;这里带有参数</span><br></pre></td></tr></table></figure>

<p>这个r是参数</p>
<p>根据寄存器的约束[见内联汇编扩展篇]</p>
<p>这个r的意思应该是任意寄存器的意思,也就是传入的参数可以使任意寄存器</p>
<p><code>多行宏</code>用%macro与%endmacro来包含</p>
<p>包含了宏的名字,参数个数</p>
<p>局部变量用<code>%%</code>开头,其实也不是非要用</p>
<p>这个的意思就是local差不多的意思…保证参数的名字不会重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%%arg1</span><br><span class="line">%%fmtint</span><br></pre></td></tr></table></figure>

<p>参数用<code>%</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%1 代表了第一个参数</span><br><span class="line">%2 代表了第二个参数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%macro	prntf	2					;2代表了2个参数,参数1是%1,参数2是%2</span><br><span class="line">	section .data</span><br><span class="line">			%%arg1	db	%1,0        ; first argument</span><br><span class="line">			%%fmtint	db	&quot;%s %ld&quot;,10,0 	; formatstring</span><br><span class="line">	section .text				; the printf arguments</span><br><span class="line">		mov	rdi, %%fmtint</span><br><span class="line">		mov	rsi, %%arg1</span><br><span class="line">		mov	rdx,[%2]        ; second argument</span><br><span class="line">		mov	rax,0           ; no floating point  </span><br><span class="line">		call printf</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure>







<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><p>第一次尝试,失败</p>
<p>还不知道为什么</p>
<p>关于书上的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..........</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">node struct</span><br><span class="line">	num	dd		?</span><br><span class="line">	next	WNDCLASS	&lt;&gt;</span><br><span class="line">node ends</span><br><span class="line"></span><br><span class="line">x	node	&lt;20,&gt;</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		xor eax,eax</span><br><span class="line">		mov esi,offset x</span><br><span class="line">		assume esi: ptr node</span><br><span class="line">		mov eax,[esi].next.lpfnWndProc</span><br><span class="line">		assume esi:nothing</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>





<p>失败了,不知道为什么….</p>
<p>反正我写就是报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">node struct</span><br><span class="line">	num	dd		?</span><br><span class="line">	next	dd		&lt;&gt;</span><br><span class="line">node ends</span><br><span class="line"></span><br><span class="line">x	node	&lt;20,offset y&gt;</span><br><span class="line">y	node	&lt;10,offset x&gt;</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		mov	esi,offset x</span><br><span class="line">		assume	esi: ptr node</span><br><span class="line">		mov	eax,[esi].next.num</span><br><span class="line">		assume	esi:nothing</span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">node	struct</span><br><span class="line">	value		dword	6</span><br><span class="line">	next_ptr	dword	6</span><br><span class="line">node	ends</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line"></span><br><span class="line">train_head	label	ptr node</span><br><span class="line">repeat	5</span><br><span class="line">	count=count+1</span><br><span class="line">	node &lt;,$+count*(type node)&gt;	</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">train_tail label ptr node</span><br><span class="line">node &lt;0,0&gt;</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		mov	esi,train_head</span><br><span class="line">		mov	edi,train_tail</span><br><span class="line">check_continue:</span><br><span class="line">		mov	ecx,(node ptr [esi]).next_ptr</span><br><span class="line">		cmp	ecx,0</span><br><span class="line">		je	over</span><br><span class="line">		add	esi,type node</span><br><span class="line">		jmp	check_continue</span><br><span class="line">	over:</span><br><span class="line">		echo	i find it</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>代码的作用是</p>
<p>建立5个链表</p>
<p>建立一个尾巴链表,他的next指针为null</p>
<p>然后查询链表,查到就退出</p>
<p>IDA的data区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000 dword_403000    dd 6                    ; DATA XREF: start↑r</span><br><span class="line">.data:00403004                 dd offset dword_403008</span><br><span class="line">.data:00403008 dword_403008    dd 6                    ; DATA XREF: .data:00403004↑o</span><br><span class="line">.data:0040300C                 dd offset dword_403010</span><br><span class="line">.data:00403010 dword_403010    dd 6                    ; DATA XREF: .data:0040300C↑o</span><br><span class="line">.data:00403014                 dd offset dword_403018</span><br><span class="line">.data:00403018 dword_403018    dd 6                    ; DATA XREF: .data:00403014↑o</span><br><span class="line">.data:0040301C                 dd offset dword_403020</span><br><span class="line">.data:00403020 dword_403020    dd 6                    ; DATA XREF: .data:0040301C↑o</span><br><span class="line">.data:00403024                 dd offset dword_403028</span><br><span class="line">.data:00403028 dword_403028    dd 0                    ; DATA XREF: start+6↑r</span><br><span class="line">.data:00403028                                         ; .data:00403024↑o</span><br><span class="line">.data:0040302C                 dd 0</span><br></pre></td></tr></table></figure>







<h2 id="低频"><a href="#低频" class="headerlink" title="低频"></a>低频</h2><h3 id="real"><a href="#real" class="headerlink" title="real"></a>real</h3><p>&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page56</p>
<p>里面有个real实数类型…也就是浮点数的意思</p>
<h3 id="BCD"><a href="#BCD" class="headerlink" title="BCD"></a>BCD</h3><p>还有一个BCD编码</p>
<p>&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page61</p>
<h3 id="label-数据类型"><a href="#label-数据类型" class="headerlink" title="label 数据类型"></a>label 数据类型</h3><p>用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b_var label word</span><br></pre></td></tr></table></figure>

<p>变量b_var的值就是紧挨着下一个word类型变量的地址</p>
<p>它指向一个word的数据类型</p>
<p>编译器也不会给label类型分配内存,它会与下一个数据共享一个位置</p>
<p>于是我们就可以不用offset了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	arr_label label word;IDA不会出现这句话</span><br><span class="line">	arr		  dd 12345678h;arr的低4位地址的数据与arr_label共享</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov ax,arr_label;直接使用名字可以访问指针指向的值</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov ax,[arr_label+1]</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,arr_label;直接使用名字可以访问指针指向的值</span><br></pre></td></tr></table></figure>

<p>因为arr_label指向word,所以我们用ax|16位来接收,只能接收<code>12345678h</code>的低位4字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,[arr_label+1]</span><br></pre></td></tr></table></figure>

<p>+1是字节+1</p>
<p>12345678h的低位[1]开始于是获取了3456h</p>
]]></content>
  </entry>
  <entry>
    <title>x86汇编语言实践部分</title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/32/%E6%8C%87%E4%BB%A4/language/</url>
    <content><![CDATA[<h1 id="常用指令系统"><a href="#常用指令系统" class="headerlink" title="常用指令系统"></a>常用指令系统</h1><p>x64 汇编网 <a href="https://www.felixcloutier.com/x86/index.html">https://www.felixcloutier.com/x86/index.html</a></p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令在编译阶段起作用</p>
<p>没有对应的机器码</p>
<h3 id="换行符-连接上一句"><a href="#换行符-连接上一句" class="headerlink" title="\ 换行符 连接上一句"></a>\ 换行符 连接上一句</h3><p>如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	MessageBox,	\</span><br><span class="line">NULL,				\</span><br><span class="line">offset A_Text,		\</span><br><span class="line">offset A_Title,		\</span><br><span class="line">MB_OK</span><br><span class="line">invoke	ExitProcess,NULL</span><br></pre></td></tr></table></figure>

<p><code>\</code>它的作用是连接上一句,使之成为一个整体</p>
<p>等效于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br></pre></td></tr></table></figure>



<h3 id="段指令"><a href="#段指令" class="headerlink" title="段指令"></a>段指令</h3><p>.code .data .data? .const .code这些事分段的伪指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat ,stdcall</span><br><span class="line">option casemap :none</span><br><span class="line">&lt;一些include指令&gt;</span><br><span class="line">.stack</span><br><span class="line">&lt;堆栈的大小&gt;</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有被初始化过的变量定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;一些常量的定义&gt;</span><br><span class="line">.code</span><br><span class="line">&lt;代码&gt;</span><br><span class="line">&lt;开始标号&gt;</span><br><span class="line">其它语句</span><br><span class="line">end&lt;开始标号&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>就书上的东西而言</p>
<p>x86下</p>
<p>.data .data? .const</p>
<h3 id="data"><a href="#data" class="headerlink" title=".data?"></a>.data?</h3><p>&lt;一些没有被初始化过的变量定义&gt;</p>
<p>在内存分配时,他们不占空间,编译器只是会记录这个位置区域的大小,而真正的使用它会在另外一个空间空间开辟</p>
<h3 id="const"><a href="#const" class="headerlink" title=".const"></a>.const</h3><p>&lt;一些常量,好比字符串,整形数据&gt;</p>
<p>可读不可写的常量区,如果写到这里来就会报错然后退出</p>
<p>x64下</p>
<h3 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h3><p>存放一些没有没有初始化的变量,不包含任何数值,</p>
<p>在编译阶段不会占据内存,在执行时像操作系统请求所需的内存,并初始化为0</p>
<p>如果执行时,没有足够的内存分配,程序会崩溃</p>
<p>一个例子,不是很理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .bss</span><br><span class="line">flist	resb 11</span><br></pre></td></tr></table></figure>

<p>于是就表示了filst是一个11字节的字符串</p>
<p>有一些这些类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resb 8位</span><br><span class="line">resw 16位</span><br><span class="line">resd 32位</span><br><span class="line">resq 64位</span><br></pre></td></tr></table></figure>

<p>声明一个数组</p>
<blockquote>
<p>arr resd 20</p>
</blockquote>
<p>还有一个例子就是</p>
<p>scanf的缓冲区与是放在.bss区域</p>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>放在了text节区</p>
<p>一般代码段时不可读不可写的,但是修改一些属性就可以</p>
<h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>书上说斩断时可读可写<code>可执行的</code>,woc???所以黑客攻击栈段?????</p>
<h3 id="equ-相等"><a href="#equ-相等" class="headerlink" title="equ 相等"></a>equ 相等</h3><p>EQU可以与C语言的define做一个比较</p>
<p>EQU相关的数据,内存不会给他分配空间</p>
<p>凡是遇到EQU定义的数据,系统就给你自动替换为了相应的字面量</p>
<p>3种情况</p>
<table>
<thead>
<tr>
<th align="center">左值</th>
<th align="center">EQU</th>
<th align="center">右值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dqx</td>
<td align="center">EQU</td>
<td align="center">&lt;“I am Dqx_Gh0st”,0&gt;或者&lt;1024*2&gt;</td>
<td align="center">凡是遇到Dqx就用相应的字符串或者数值替代</td>
</tr>
<tr>
<td align="center">xx</td>
<td align="center">EQU</td>
<td align="center">symble</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">xxx</td>
<td align="center">EQU</td>
<td align="center">表达式</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>既然与Define做了一个比较,那么的话define定义的都是常量,是不可以再次赋值的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">Just_A_Ejd  EQU &lt;&quot;Pess and key to continue...&quot;,0&gt;</span><br><span class="line">Just_A_Var EQU &lt;100*100&gt;</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	len					dd $-Arr</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,Just_A_Var</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>在IDA里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, 10000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>

<p>Just_A_Var被替换为了100*100</p>
<p>其实也不是这样</p>
<p>Just_A_Var会被替换位100*100,而不是100000</p>
<p>毕竟是一个字符串的替换,而不是u直接算出结果</p>
<h3 id="textequ-文本相等"><a href="#textequ-文本相等" class="headerlink" title="textequ 文本相等"></a>textequ 文本相等</h3><p>与EQU类似</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">&lt;指令表达式或者带“”的字符串&gt;</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">已经被创建的EQU宏</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">textEQU</td>
<td align="center">%数值</td>
</tr>
</tbody></table>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=20</span><br><span class="line">num  TEXTEQU %(x*10)</span><br><span class="line">move TEXTEQU &lt;mov&gt;</span><br><span class="line">init_ax  TEXTEQU &lt;move ax,num&gt;</span><br><span class="line"></span><br><span class="line">(略)</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	init_ax</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>在IDA里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     ax, 200</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我用EQU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=20</span><br><span class="line">num TEXTEQU %(x*10)</span><br><span class="line">move EQU &lt;mov&gt;</span><br><span class="line">init_ax  EQU &lt;move ax,num&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在IDA里面可以得到一样的结果</p>
<h3 id="地址标号"><a href="#地址标号" class="headerlink" title="@@ 地址标号"></a>@@ 地址标号</h3><p>@@ 是当前的地址</p>
<p>@F会指向下一个最近的@@</p>
<p>@B会指向下上一个最近的@@</p>
<p>遵循就近原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	jmp @F</span><br><span class="line"></span><br><span class="line">@@:</span><br><span class="line">	invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br><span class="line"></span><br><span class="line">	jmp @B</span><br></pre></td></tr></table></figure>

<p>实现一个死循环</p>
<h3 id="type-获取数据类型的大小"><a href="#type-获取数据类型的大小" class="headerlink" title="type 获取数据类型的大小"></a>type 获取数据类型的大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">var dword ?</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	</span><br><span class="line">	mov eax,type var</span><br><span class="line">	mov eax,type start</span><br><span class="line">	mov eax,type near</span><br><span class="line">	mov eax,type far</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 0FF04h</span><br><span class="line">mov     eax, 0FF04h</span><br><span class="line">mov     eax, 0FF06h</span><br><span class="line">mov     eax, 4</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关于,start与near,far的标号值是固定的</p>
<h3 id="lengthof-计算数组元素的个数"><a href="#lengthof-计算数组元素的个数" class="headerlink" title="lengthof 计算数组元素的个数"></a>lengthof 计算数组元素的个数</h3><p>相比于C语言,</p>
<p>如果是整数数组,它的功能就是<code>sizeof(arr)/sizeof(arr[0])</code></p>
<p>如果是字符串数组,它的功能就是<code>strlen(str)</code></p>
<p>它会返回一个32位的数值</p>
<p>关于细节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	arr1 db 1,2,3,4</span><br><span class="line">			db 5,6,7,8</span><br><span class="line">	ptr_arr dd arr1</span><br><span class="line"></span><br><span class="line">	arr2 dw 1,2,3,4,</span><br><span class="line">				5,6,7,8</span><br><span class="line">	ptr_arr2 dd arr2</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,lengthof arr1;我感觉offset的就像C语言的取地址运算符&amp;</span><br><span class="line"></span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,lengthof arr2</span><br><span class="line">	;mov eax,lengthof ptr_arr2</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>IDA源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 4</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 8</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>①.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1 	db 1,2,3,4</span><br><span class="line">		db 5,6,7,8</span><br><span class="line">ptr_arr dd arr1</span><br></pre></td></tr></table></figure>

<p>第2行与第1行没有关系</p>
<p>lengthof&#x3D;4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1 db 1,2,3,4,</span><br><span class="line">	 db 5,6,7,8</span><br><span class="line">ptr_arr dd arr1</span><br></pre></td></tr></table></figure>

<p>这样写会报错</p>
<p><code>,</code>逗号的意思…..你可以看作第一行与第二行之间有很多的空格,那个逗号就是连接的</p>
<p>报错的原有?</p>
<p>这么看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1 db 1,2,3,4 ,db 5,6,7,8</span><br></pre></td></tr></table></figure>

<p>这样当然会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1 db 1,2,3,4 db 5,6,7,8</span><br></pre></td></tr></table></figure>

<p>这样就不会报错</p>
<p>但是第二个db和第一个db就不不再有联系了(对于lengthof)的话</p>
<h3 id="sizeof-x2F-size-返回数组的总字节数"><a href="#sizeof-x2F-size-返回数组的总字节数" class="headerlink" title="sizeof&#x2F;size 返回数组的总字节数"></a>sizeof&#x2F;size 返回数组的总字节数</h3><p>可以形象的比喻它为</p>
<p>type x lengthof</p>
<p>数组单元个数x每个单元的字节数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">var dword ?</span><br><span class="line">arr word 4 dup(0)</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	</span><br><span class="line">	mov eax,size var</span><br><span class="line">	mov eax,sizeof var</span><br><span class="line">	mov eax,size arr</span><br><span class="line">	mov eax,sizeof arr</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 4</span><br><span class="line">mov     eax, 4</span><br><span class="line">mov     eax, 8</span><br><span class="line">mov     eax, 8</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>

<p>使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr1		db  &quot;hello,I am dqx_Gh0st&quot;,0</span><br><span class="line">arr2		db   sizeof arr1 dup(0)</span><br></pre></td></tr></table></figure>

<p>返回的结果是21,字符串长度+1,那个1是0的占位</p>
<h3 id="typedef-定义新的类型"><a href="#typedef-定义新的类型" class="headerlink" title="typedef 定义新的类型"></a>typedef 定义新的类型</h3><p>可以与C语言联想</p>
<p>但是不同于C语言</p>
<p>C语言</p>
<p>typedef+原来的类型+新的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *ptr B_ptr</span><br></pre></td></tr></table></figure>

<p>x86汇编</p>
<p>新的类型+typedef+老的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B_ptr typedef  ptr byte</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Dqx_Gh0st</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD	</span><br><span class="line"></span><br><span class="line">db_ptr typedef ptr byte</span><br><span class="line">dw_ptr typedef ptr word</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	arr1		db 9,8,7,6,5,4,3,2</span><br><span class="line">	arr2		dw 9,8,7,6,5,4,3,2,1</span><br><span class="line">	ptr1		dd arr1	</span><br><span class="line">	ptr2     dd arr2</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	......................</span><br></pre></td></tr></table></figure>

<h3 id="地址计数器"><a href="#地址计数器" class="headerlink" title="$ 地址计数器"></a>$ 地址计数器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	temp dd $	;偏移地址的长度data:00405000,可见它是一个4字节的长度,我们要用dd来获取</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,temp;eax就获取了temp的偏移地址</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>于是你在IDA里面看到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, off_405000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>

<p>temp直接就转化为了一个地址的变量名称</p>
<p>以前的变量名称是temp</p>
<p>写在变为了off_405000</p>
<p>40500就是偏移地址</p>
<p>源代码的data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	temp 			dd $</span><br></pre></td></tr></table></figure>

<p>IDA里面是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	off_405000      dd offset off_405000    </span><br></pre></td></tr></table></figure>



<h4 id="获取当前位置的偏移地址"><a href="#获取当前位置的偏移地址" class="headerlink" title="获取当前位置的偏移地址"></a>获取当前位置的偏移地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end				dd $</span><br></pre></td></tr></table></figure>

<p>Arr_end就是它的当前的偏移地址</p>
<p>就是获取一个偏移地址,至于后面怎么样再说</p>
<h4 id="计算数组长度"><a href="#计算数组长度" class="headerlink" title="计算数组长度"></a>计算数组长度</h4><h5 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h5><p>计算数组的长度</p>
<p>数组的第一个元素会有一个偏移量</p>
<p>数组的最后一个元素也会有一个偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end				dd $</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00405000 unk_405000      db    1                 ; Arr</span><br><span class="line">.data:00405001                 db    2</span><br><span class="line">.data:00405002                 db    3</span><br><span class="line">.data:00405003                 db    4</span><br><span class="line">.data:00405004                 db    5</span><br><span class="line">.data:00405005                 db    6</span><br><span class="line">.data:00405006                 db    7</span><br><span class="line">.data:00405007                 db    8</span><br><span class="line">.data:00405008                 db    9</span><br><span class="line">.data:00405009                 db  14h</span><br><span class="line">.data:0040500A                 dd offset unk_405000;Arr_end不太理解IDA里面为什是offset unk_405000,而不是offset unk_40500A</span><br></pre></td></tr></table></figure>

<p>Arr		-&gt;xxxx5000</p>
<p>Arr_end-&gt;xxxx500A</p>
<p>0xA-0x0&#x3D;10</p>
<p>于是就有10个数据</p>
<p>你可能会想到10个元素</p>
<p>最后一个元素index&#x3D;9,</p>
<p>第一个元素    index&#x3D;0</p>
<p>9-0&#x3D;9</p>
<p>得到数字9</p>
<p>你也知道这样得到的数据是不对的,9只是[0]和[9]的差量</p>
<p>len&#x3D;10是[10]和[0]的差量</p>
<p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	Arr_end			dd $</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov ax,Arr_end-Arr</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     ax, 10</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>



<h5 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h5><p>更加常见的的计算方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	Arr					db 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">	len					dd $-Arr</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,len</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<p>data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00405000                 db    1</span><br><span class="line">.data:00405001                 db    2</span><br><span class="line">.data:00405002                 db    3</span><br><span class="line">.data:00405003                 db    4</span><br><span class="line">.data:00405004                 db    5</span><br><span class="line">.data:00405005                 db    6</span><br><span class="line">.data:00405006                 db    7</span><br><span class="line">.data:00405007                 db    8</span><br><span class="line">.data:00405008                 db    9</span><br><span class="line">.data:00405009                 db  0Ah</span><br><span class="line">.data:0040500A dword_40500A    dd 10</span><br></pre></td></tr></table></figure>

<p>code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_402028 proc near</span><br><span class="line">mov     eax, dword_40500A;也就是10</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028 endp</span><br></pre></td></tr></table></figure>



<h5 id="其它类型数组"><a href="#其它类型数组" class="headerlink" title="其它类型数组"></a>其它类型数组</h5><table>
<thead>
<tr>
<th>db</th>
<th>len&#x3D;($-Arr)</th>
</tr>
</thead>
<tbody><tr>
<td>dw</td>
<td>len&#x3D;($-Arr)&#x2F;2</td>
</tr>
<tr>
<td>dd</td>
<td>len&#x3D;($-Arr)&#x2F;4</td>
</tr>
</tbody></table>
<p>….</p>
<h3 id="x3D-等号指令"><a href="#x3D-等号指令" class="headerlink" title="&#x3D;  等号指令"></a>&#x3D;  等号指令</h3><p>&#x3D;指令的对象是一个32位长度的数据</p>
<p>它的优点….利于代码的维护与修改</p>
<p>在我对C语言或者C++不明白的情况下</p>
<p>我觉得<code>=指令</code>给我的感觉就是一个全局的变量</p>
<p>无论你在后面赋值还是前面赋值,系统都可以为你找到数据然后赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">	x=100</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=100</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		</span><br><span class="line">	mov eax,x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>无论怎么样.在IDA里面都是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc near               ; CODE XREF: start↑j</span><br><span class="line">mov     eax, 100</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>



<p>加深一下理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line">x=1</span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">		xor eax,eax	</span><br><span class="line">		x=100</span><br><span class="line">		mov eax,x</span><br><span class="line">		x=1000</span><br><span class="line">		mov eax,x</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>在DIA里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc near               ; CODE XREF: start↑j</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, 100</span><br><span class="line">mov     eax, 1000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_402028      endp</span><br></pre></td></tr></table></figure>





<h3 id="high-x2F-low-x2F-highword-x2F-lowword"><a href="#high-x2F-low-x2F-highword-x2F-lowword" class="headerlink" title="high&#x2F;low&#x2F;highword&#x2F;lowword"></a>high&#x2F;low&#x2F;highword&#x2F;lowword</h3><p>他可以取出高8位,低8位,高16位,低16位的数据</p>
<p>他的操作数是立即数,不是变量,不是寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	mov ah,high 1234h</span><br><span class="line">	mov al,low  1234h</span><br><span class="line"></span><br><span class="line">	mov ax,highword 12345678h</span><br><span class="line">	mov ax,lowword  12345678h</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     ah, 12h</span><br><span class="line">mov     al, 34h ; &#x27;4&#x27;</span><br><span class="line">mov     ax, 1234h</span><br><span class="line">mov     ax, 5678h</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>



<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>（1）LENGTH,SIZE,WIDTH,MASK. (),[],(结构体),&lt;&gt;。<br>（2）PTR,OFFSET,TYPE,SEG,THIS,冒号。冒号用于表示段超越前缀。<br>（3）*，&#x2F;，MOD，SHL,SHR<br>（4）HIGH,LOW<br>（5）+，-<br>（6）EQ,NE,LT,LE,GT,GE<br>（7）NOT<br>（8）AND<br>（9）OR,XOR<br>（10）SHORT</p>
<h2 id="非伪指令"><a href="#非伪指令" class="headerlink" title="非伪指令"></a>非伪指令</h2><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>在C语言下,字节对齐可以自己规定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line">struct str</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#pragma pack()</span><br></pre></td></tr></table></figure>

<p>每个成员所占空间是字节对齐的倍数,不足就补0</p>
<h4 id="align"><a href="#align" class="headerlink" title="align"></a>align</h4><p>可以联想一下<code>nop</code>,这里的<code>algin</code>会填充空字节,也就是填充0</p>
<p>然后algin的原理是个啥</p>
<p>最后的结果就是让下一个数据的地址是1&#x2F;2&#x2F;4&#x2F;8&#x2F;16的倍数</p>
<p>好比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db1		byte	1</span><br><span class="line">db2		byte	2</span><br><span class="line">align	4		;让dw1的地址是4的倍数  </span><br><span class="line">dw1		word    3 </span><br><span class="line">align	2		;让dd1的地址是2的倍数</span><br><span class="line">dd1		dword	4</span><br><span class="line">dd2		dword	5</span><br><span class="line">align	4  		;让db3的地址是4的倍数</span><br><span class="line">db3		byte	6</span><br></pre></td></tr></table></figure>



<p>为了得到这些倍数,他就通过在前面补充0来填充字节</p>
<p>另外之一下</p>
<p>align 4 不是说真的填充4字节</p>
<p>align 16 也不是说填充16字节</p>
<p>可能还是填充2字节,4字节,,看地址情况而定</p>
<p>algin的主要功能之一</p>
<p>16&#x2F;32位 字节对齐</p>
<p>这对寻址很有帮助</p>
<h4 id="alignb"><a href="#alignb" class="headerlink" title="alignb"></a>alignb</h4><h3 id="BCD码指令-gt-fld-fbstp"><a href="#BCD码指令-gt-fld-fbstp" class="headerlink" title="BCD码指令-&gt;fld,fbstp"></a>BCD码指令-&gt;fld,fbstp</h3><p>见&lt;&lt;汇编语言基于x86处理器&gt;&gt;的Page-60</p>
<h3 id="inc-x2F-dec-x2F-add-x2F-sub"><a href="#inc-x2F-dec-x2F-add-x2F-sub" class="headerlink" title="inc&#x2F;dec&#x2F;add&#x2F;sub"></a>inc&#x2F;dec&#x2F;add&#x2F;sub</h3><p>自己百度</p>
<h3 id="dup-数据重复"><a href="#dup-数据重复" class="headerlink" title="dup 数据重复"></a>dup 数据重复</h3><p>db 128 dup(0)表示重复128个1,单位字节</p>
<p>db 128 dup(‘1’)表示重复128个字符’1’,单位字节</p>
<p>db 128 dup(?) 表示没有初始化</p>
<h3 id="offset-就取处偏移地址"><a href="#offset-就取处偏移地址" class="headerlink" title="offset 就取处偏移地址"></a>offset 就取处偏移地址</h3><p>他的对象是一个常数地址,不会发生变化,编译器遇到offset就会寻找那个偏移地址,然后<code>ofset xxx = 地址常量</code></p>
<blockquote>
<p>为什么?</p>
<p>offset 用于全局变量</p>
<p>全局变量是不会消失的</p>
<p>所以offset的操作数是一个全局的常量</p>
<p>在编译阶段直接由编译器赋值</p>
</blockquote>
<p>在之前我们有这样的写法</p>
<p>8086中,只能把数组写到代码段寻址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">start:</span><br><span class="line">	....</span><br><span class="line">	mov si,Arr1</span><br></pre></td></tr></table></figure>

<p>于是我们就可以获取偏移地址</p>
<p>在x86中,可以把数组写进data段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">.code</span><br><span class="line">	mov ax,[Arr1+1]</span><br></pre></td></tr></table></figure>

<p>于是我,们就可以直接把数组名当中地址来用</p>
<p>为了更加的严谨.利于代码的阅读性与维护性</p>
<p>我们用offset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	Arr1 db 1,2,3,4</span><br><span class="line">	ptr_arr dd Arr1</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	mov esi,offset Arr1;我感觉offset的就像C语言的取地址运算符&amp;</span><br><span class="line">	mov edi,ptr_arr;一个指针,</span><br><span class="line">	mov al,[esi]</span><br><span class="line">	mov ah,[edi]</span><br></pre></td></tr></table></figure>

<p>offset返回的数据是一个对应位数的偏移地址</p>
<p>8086的offset返回2字节</p>
<p>x86的offset返回4字节</p>
<h3 id="lea-取地址"><a href="#lea-取地址" class="headerlink" title="lea 取地址"></a>lea 取地址</h3><p>不同于offset,offset是编译是直接获取的常量地址</p>
<p>lea是运行时动态的算出每一次地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lea Des,Src</span><br></pre></td></tr></table></figure>



<p>lea eax,dword ptr ds:[ebx]</p>
<p>其中eax&#x3D;ebx</p>
<h3 id="ptr-重写操作数大小类型"><a href="#ptr-重写操作数大小类型" class="headerlink" title="ptr 重写操作数大小类型"></a>ptr 重写操作数大小类型</h3><p>8686下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,arr[1*2]</span><br></pre></td></tr></table></figure>

<p>ax就决定了数组的数据长度</p>
<p>x86下就离谱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, byte ptr ptr1[1*(type arr1)]</span><br><span class="line">mov ax, word ptr ptr2[1*(type arr2)]</span><br></pre></td></tr></table></figure>

<p>非要这样写,否者就报错</p>
<p>对于一个好比4字节的数据</p>
<p>你可以对它的2个字节2个字节的访问</p>
<p>或者8个字节8个字节的访问,这就会访问4字节后面的4字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD		</span><br><span class="line">.data</span><br><span class="line">	x dw 4321h</span><br><span class="line">	y dw 8765h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov eax,dword ptr x</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Attributes: noreturn</span><br><span class="line"></span><br><span class="line">sub_652028 proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     eax, dword_654000</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">sub_652028 endp</span><br></pre></td></tr></table></figure>

<p>最后EAX&#x3D;87654321h</p>
<h3 id="xchg-交换指令"><a href="#xchg-交换指令" class="headerlink" title="xchg 交换指令"></a>xchg 交换指令</h3><p><code>xchg x,y</code>那么x,y的数据会交换</p>
<p>如何交换2个数?还是要用到第3者</p>
<p>对于操作数,必须2个必须是可读可写的变量</p>
<p>way1-我自己想的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xchg x,eax		</span><br><span class="line">xchg y,eax		</span><br><span class="line">xchg x,eax		</span><br></pre></td></tr></table></figure>

<p>way-2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,x</span><br><span class="line">xchg y,eax</span><br><span class="line">mov x,eax</span><br></pre></td></tr></table></figure>

<p>way-3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov temp,x</span><br><span class="line">mov x,y</span><br><span class="line">mov y,temp</span><br></pre></td></tr></table></figure>









<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>本质是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push next_IP</span><br><span class="line">jmp call_func_location</span><br></pre></td></tr></table></figure>

<p>回归到CPU执行指令的原理</p>
<p>读取当前指令到BUFF</p>
<p>IP&#x3D;下一个IP</p>
<p>CPU执行BUFF</p>
<p>那么的话,当我们执行了Call会,IP&#x3D;下一个IP</p>
<p>那么的话call会就会push下一个指令的ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call s </span><br><span class="line">然后会push ip</span><br><span class="line"></span><br><span class="line">ret </span><br><span class="line">然后会</span><br><span class="line">pop ip</span><br><span class="line"></span><br><span class="line">call far ptr </span><br><span class="line">然后会</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line">然后会</span><br><span class="line">pop ip, pop cs</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>对一般的call</p>
<p>它就是push一些东西</p>
<p>然后再 jmp 到 call 的那个地址</p>
<p>再次说一遍,我们是push 地址,不是push一个指令</p>
<p>对far ptr</p>
<p>push cs</p>
<p>push ip</p>
<p>对于数据,肯定还要pop</p>
<p>就是</p>
<p>pop ip</p>
<p>pop cs</p>
<p>call word ptr ds:[xx]    会 push ip</p>
<p>call dword ptr ds:[xx]  会push cs, push ip</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><blockquote>
<p>loop的代码执行效率会比jmp慢,所以在实际的调试时,很少出现loop,都是一些条件跳转</p>
</blockquote>
<p>loop也有很多的形式</p>
<p>他们对计数器的要求会不同</p>
<p>他们对程序的指令的兼容性也会不同</p>
<p>遇到就查吧</p>
<p>add会偷偷修改标志寄存器</p>
<p>所以在使用寄存器的时候你要注意那些寄存器的变化</p>
<p>判断是否循环的原则</p>
<p>先对ecx&#x2F;cx作运算</p>
<p>然后看是否为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">	   	mov ax,0</span><br><span class="line">       	mov cx,4</span><br><span class="line"></span><br><span class="line">func:   add ax,2</span><br><span class="line">        loop func</span><br><span class="line">	  	mov ax,4c00h</span><br><span class="line">	   	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>对于嵌套的LOOP循环,要记住push cx和pop cx,并且注意中途少用cx</p>
<p>对于这种机制,要注意的是</p>
<p>高级语言往往是先检验是否为0,再执行cx-1</p>
<p>Loop是先执行cx-1,再去判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ecx,0</span><br><span class="line">add_sum:</span><br><span class="line">	add eax,arr[esi]</span><br><span class="line">	inc esi</span><br><span class="line">	loop add_sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它会是一个很大的循环</p>
<p>一直到ecx发生溢出或者进位,他就为0了</p>
<h3 id="cmpxchg"><a href="#cmpxchg" class="headerlink" title="cmpxchg"></a>cmpxchg</h3><p>他有2个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmpxchg x,y</span><br></pre></td></tr></table></figure>

<p>用高级语言解释一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(eax==x)</span><br><span class="line">&#123;</span><br><span class="line">    x=y;</span><br><span class="line">    ZF=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    eax=x;</span><br><span class="line">    ZF=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>在我的电脑上无法运行该指令</p>
<h3 id="bsr-x2F-bsf-位扫描"><a href="#bsr-x2F-bsf-位扫描" class="headerlink" title="bsr&#x2F;bsf 位扫描"></a>bsr&#x2F;bsf 位扫描</h3><blockquote>
<p> 数值的下标是这样安排的</p>
<p> 最右边是index&#x3D;0</p>
<p> 最左边是index&#x3D;xx</p>
<p> 字符串的下标</p>
<p> 做左边是index&#x3D;0</p>
<p> 最右边是index&#x3D;xx</p>
</blockquote>
<p>bsf :Bit Scan Forward</p>
<p>bsr :Bit Scanf Reverse</p>
<p>反汇编会被翻译为函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BitScanReverse()</span><br></pre></td></tr></table></figure>

<p>bsf指令的功能: 从右往左扫描,正向寻取 二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值</p>
<p>bsr指令的功能: 从左往右扫描 逆向寻取 寻取二进制值的&#x3D;&#x3D;最低位的1&#x3D;&#x3D;的index,返回index,然后初始化ZF的值</p>
<p>如果找到1,说明value!&#x3D;0,那么ZF&#x3D;0</p>
<p>如果找不到1,,说明value&#x3D;&#x3D;0,那么ZF&#x3D;1</p>
<p>好比1101,</p>
<p>用bsr寻取到index&#x3D;3,最左边是[3]&#x3D;1</p>
<p>用bsf寻取到index&#x3D;0,最右边是[0]&#x3D;1</p>
<p>这不同于字符串的index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bsr ecx ,vale</span><br></pre></td></tr></table></figure>

<p>那么他就把value的1值最高位返回给ecx</p>
<p>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>
<h3 id="bswap-字节反向存储"><a href="#bswap-字节反向存储" class="headerlink" title="bswap 字节反向存储"></a>bswap 字节反向存储</h3><p>好比</p>
<p>mov eax,12345678h</p>
<p>bswap eax</p>
<p>eax&#x3D;78563412h</p>
<h3 id="return返回"><a href="#return返回" class="headerlink" title="return返回"></a>return返回</h3><p>虽然本质是pop ip</p>
<p>其实我们可以在栈里面修改它那个ip,然后在pop出去</p>
<p>这就很妙</p>
<h4 id="ret近转移"><a href="#ret近转移" class="headerlink" title="ret近转移"></a>ret近转移</h4><p><code>本质</code>是<code>pop ip</code></p>
<p>他是近转移</p>
<p>ret 后面也可以带参数</p>
<p>ret 8</p>
<p>masm32下表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ip </span><br><span class="line">add esp+8</span><br></pre></td></tr></table></figure>

<h4 id="retn-近转移"><a href="#retn-近转移" class="headerlink" title="retn 近转移"></a>retn 近转移</h4><p>意思是ret near</p>
<p>retn操作：pop eip</p>
<p>retn N操作：先pop eip，然后add esp,N</p>
<p>retn 其实等价于 ret</p>
<h4 id="retf-远转移"><a href="#retf-远转移" class="headerlink" title="retf 远转移"></a>retf 远转移</h4><p>他是段间转移</p>
<p>可以修改CS:IP</p>
<blockquote>
<p>  先pop IP</p>
<p>  后pop CS</p>
<p>  因为之前有push cs,push ip</p>
</blockquote>
<p>把栈顶的word数据给IP</p>
<p>又把下一个栈顶word数据给CS</p>
<h4 id="iret-中断返回"><a href="#iret-中断返回" class="headerlink" title="iret 中断返回"></a>iret 中断返回</h4><p>中断过程中的iret</p>
<p>他会实现</p>
<p>pop ip</p>
<p>pop cs</p>
<p>popf</p>
<h3 id="二进制第i位操作"><a href="#二进制第i位操作" class="headerlink" title="二进制第i位操作"></a>二进制第i位操作</h3><p>从右往左寻找二进制的1</p>
<h4 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位传递给CF,然后,[2]位不变</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bittest()</span><br></pre></td></tr></table></figure>



<h4 id="btc"><a href="#btc" class="headerlink" title="btc"></a>btc</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btc eax,2</span><br></pre></td></tr></table></figure>

<p>将eax的第[2]传递给CF,把[2]取反</p>
<h4 id="btr"><a href="#btr" class="headerlink" title="btr"></a>btr</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btr eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位给CF,然后置[2]位为0</p>
<h4 id="bts"><a href="#bts" class="headerlink" title="bts"></a>bts</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bts eax,2</span><br></pre></td></tr></table></figure>

<p>把eax的第[2]位给CF,然后置[2]位为1</p>
<h3 id="CPU控制指令"><a href="#CPU控制指令" class="headerlink" title="CPU控制指令"></a>CPU控制指令</h3><h4 id="nop"><a href="#nop" class="headerlink" title="nop"></a>nop</h4><p>该指令的执行不会影响任何标志寄存器</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>让CPU处于等待状态,直到协处理器完成运算</p>
<p>问题来了,什么叫协处理器</p>
<h4 id="hlt-暂停指令"><a href="#hlt-暂停指令" class="headerlink" title="hlt 暂停指令"></a>hlt 暂停指令</h4><p>执行了hlt后,CPU处于暂停的工作状态,</p>
<p>EIP指向HLT的下一条指令</p>
<p>把EIP入栈</p>
<p>当产生了reset信号或者中断请求信号时,才会eip出栈,CPU继续执行</p>
<p>关于中断的产生,CPU强制去执行中断</p>
<p>CPU转去处理中断程序后,中断结束,iret弹出EIP,并唤醒HLT的下一条指令,这样CPU退出了暂停</p>
<p>所以这个IRET还是强大呀</p>
<h4 id="lock-封锁数据"><a href="#lock-封锁数据" class="headerlink" title="lock 封锁数据"></a>lock 封锁数据</h4><p>它是一个前缀指令</p>
<p>就像rep movsb指令套</p>
<p>lock会跟一个操作指令</p>
<p>lock可以保证在其后指令的执行过程中,禁止协处理器修改数据总线</p>
<p>起到单独占线的占用,该指令不会影响寄存器</p>
<h4 id="cpuid-获取CPU信息"><a href="#cpuid-获取CPU信息" class="headerlink" title="cpuid 获取CPU信息"></a>cpuid 获取CPU信息</h4><p>这应该与端口相关吧….</p>
<p>x86模式下</p>
<p>初始化eax,然后调用cpuid在最后在ebx&#x2F;edx&#x2F;ecx检查该值</p>
<p>x64模式下</p>
<p>初始化eax,然后调用cpuid在最后在ecx&#x2F;edx中检查该值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getcpu</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> b_str[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ret=getcpu(b_str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ID:%u %s&quot;</span>,ret,b_str);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getcpu</span><span class="params">(<span class="type">char</span>* b_str)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		mov eax,<span class="number">0</span></span><br><span class="line">		cpuid</span><br><span class="line">		mov eax,b_str</span><br><span class="line">		mov [eax],ebx</span><br><span class="line">		mov [eax+<span class="number">4</span>],edx</span><br><span class="line">		mov [eax+<span class="number">8</span>],ecx</span><br><span class="line">		mov eax,<span class="number">1</span></span><br><span class="line">		cpuid</span><br><span class="line">		mov eax,edx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>一般汇编语言的跳转判断是根据指定条件的相反条件</p>
<p>若满足相反条件就就指向else</p>
<p>否则顺序执行后面的语句</p>
<p>浮点数的比较</p>
<p>fcomp会影响FPU的寄存器</p>
<p>fcomi指令字节影响CPU的eflag</p>
<h4 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>CPU如何指令命令?</p>
<ol>
<li><p>CPU从CS:IP读取指令到buff</p>
</li>
<li><p>IP&#x3D;IP+刚才读取的指令长度</p>
<p>于是IP指向了下一条指令</p>
</li>
<li><p>CPU执行buff的指令</p>
</li>
</ol>
<p>CPU又开始读取IP,循环操作上面的操作</p>
<h5 id="机器码剖析"><a href="#机器码剖析" class="headerlink" title="机器码剖析"></a>机器码剖析</h5><p><img src="D:\JGY\P0st\Pho\Asm-指令\image-20220804220620675.png" alt="image-20220804220620675"></p>
<p>那么jmp的话</p>
<p>就是 <code>EB xx</code></p>
<p>那个<code>xx</code>就是一个偏移地址,这个偏移地址的基地址是jmp后面那个指令的开始字节,从字节数0开始数</p>
<p>然后,偏移到jmp的地方</p>
<p><code>xx</code>快速计算的方法就是</p>
<p>跳到那里的地址-jmp后的那个IP&#x3D;xx</p>
<p>xx是一个有符号的数值</p>
<p>比如0x00-0xFF</p>
<p>其中0x00-0x7F是往前跳</p>
<p>0x7F-0xFF是往后面跳</p>
<h5 id="其它jmp"><a href="#其它jmp" class="headerlink" title="其它jmp"></a>其它jmp</h5><p> jmp far ptr   段间转移   跳转范围 -32768~32767</p>
<p> jmp short ptr 段转移     跳转的范围小于128字节</p>
<p> jmp  word ptr ds:[0]	会取ds: [0] [1] 位ip地址</p>
<p> jmp  dword ptr ds:[1]   取[0] [1]为ip,[2] [3]为cs</p>
<p> jmp  byte ptr ds:[1]</p>
<h4 id="cmp-有符号-x2F-无符号"><a href="#cmp-有符号-x2F-无符号" class="headerlink" title="cmp-有符号&#x2F;无符号"></a>cmp-有符号&#x2F;无符号</h4><p>对于数值的cmp</p>
<p>&#x3D;&#x3D;你若看作是无符号比较,就只看ZF&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;你若看作有符号的比较,就看SF&#x2F;OF,或者ZF&#x3D;&#x3D;</p>
<p>CPU将cmp指令得到的结果记录在flag的相关标志位中，我们可以根据指令执行后，相关标志位的值来判断比较的结果。单纯的考察SF的值不可能知道结果的正负</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp al,bl</span><br><span class="line"></span><br><span class="line">SF=1,OF=0 al&lt;bl</span><br><span class="line">SF=1,OF=1 al&gt;bl	 SF=OF</span><br><span class="line">如果因为溢出导致的实际结果为负数,那么真正的结果为正数</span><br><span class="line"></span><br><span class="line">SF=0,OF=1 al&lt;bl</span><br><span class="line">SF=0,OF=0 al&gt;nl SF==OF</span><br><span class="line">如果因为溢出导致的实际结果为正数,那么真正的结果为负数</span><br><span class="line"></span><br><span class="line">OF==SF 才会有大于</span><br></pre></td></tr></table></figure>



<p>je 相等就跳转</p>
<p>jne 不相等就跳转</p>
<p>jb      jmp blow 小于就跳转</p>
<p>jnb     jmp not blow 大于等于就跳转</p>
<p>ja      jmp above 大于就跳转</p>
<p>jna     jmp not above 小于等于就跳转</p>
<h4 id="eflag跳转"><a href="#eflag跳转" class="headerlink" title="eflag跳转"></a>eflag跳转</h4><table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th>标志位&#x2F;寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>JZ</td>
<td>为零跳转</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>JNZ</td>
<td>非零跳转</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>JC</td>
<td>进位跳转</td>
<td>CF&#x3D;1</td>
</tr>
<tr>
<td>JNC</td>
<td>无进位跳转</td>
<td>CF&#x3D;0</td>
</tr>
<tr>
<td>JO</td>
<td>溢出跳转</td>
<td>OF&#x3D;1</td>
</tr>
<tr>
<td>JNO</td>
<td>无溢出跳转</td>
<td>OF&#x3D;0</td>
</tr>
<tr>
<td>JS</td>
<td>有符号跳转</td>
<td>SF&#x3D;1</td>
</tr>
<tr>
<td>JNS</td>
<td>无符号跳转</td>
<td>SF&#x3D;0</td>
</tr>
<tr>
<td>JP</td>
<td>偶校验跳转</td>
<td>PF&#x3D;1</td>
</tr>
<tr>
<td>JNP</td>
<td>奇校验跳转</td>
<td>PF&#x3D;0</td>
</tr>
</tbody></table>
<p>STC 让CF&#x3D;1</p>
<p>CLC 让CF&#x3D;0</p>
<p>CMC 让CF取反</p>
<h4 id="相等跳转"><a href="#相等跳转" class="headerlink" title="相等跳转"></a>相等跳转</h4><p>用cmp判断</p>
<table>
<thead>
<tr>
<th align="center">助记符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JE&#x2F;JZ</td>
<td>相等跳转 (leftOp&#x3D;rightOp)</td>
</tr>
<tr>
<td align="center">JNE&#x2F;JNZ</td>
<td>不相等跳转 (leftOp M rightOp)</td>
</tr>
<tr>
<td align="center">JCXZ</td>
<td>CX&#x3D;0 跳转</td>
</tr>
<tr>
<td align="center">JECXZ</td>
<td>ECX&#x3D;0 跳转,你在8086用的比较多</td>
</tr>
<tr>
<td align="center">JRCXZ</td>
<td>RCX&#x3D;0 跳转（64 位模式）</td>
</tr>
</tbody></table>
<h4 id="无符号跳转"><a href="#无符号跳转" class="headerlink" title="无符号跳转"></a>无符号跳转</h4><p>above&#x2F;below</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>JA&#x3D;JNBE</td>
<td>&gt;</td>
<td>CF|ZF&#x3D;0</td>
<td></td>
</tr>
<tr>
<td>JB&#x3D;JNAE</td>
<td>&lt;</td>
<td>CF&#x3D;1</td>
<td></td>
</tr>
<tr>
<td>JAE&#x3D;JNB</td>
<td>&gt;&#x3D;</td>
<td>CF&#x3D;0</td>
<td></td>
</tr>
<tr>
<td>JNA&#x3D;JBE</td>
<td>&lt;&#x3D;</td>
<td>CF|ZF&#x3D;1</td>
<td></td>
</tr>
</tbody></table>
<h4 id="有符号的跳转"><a href="#有符号的跳转" class="headerlink" title="有符号的跳转"></a>有符号的跳转</h4><p>greate&#x2F;little</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>JG&#x3D;JNLE</td>
<td>&gt;</td>
<td align="center">(SF ^OF)|ZF&#x3D;0</td>
</tr>
<tr>
<td>JL&#x3D;JNGE</td>
<td>&lt;</td>
<td align="center">SF^OF&#x3D;1,意思SF &#x3D; OF</td>
</tr>
<tr>
<td>JGE&#x3D;JNL</td>
<td>&gt;&#x3D;</td>
<td align="center">SF ^ OF&#x3D;0,意思是SF! &#x3D; OF</td>
</tr>
<tr>
<td>JLE&#x3D;JNG</td>
<td>&lt;&#x3D;</td>
<td align="center">(SF^OF)|ZF&#x3D;1</td>
</tr>
</tbody></table>
<h4 id="测试条件转存指令"><a href="#测试条件转存指令" class="headerlink" title="测试条件转存指令"></a>测试条件转存指令</h4><h4 id="条件跳转的应用"><a href="#条件跳转的应用" class="headerlink" title="条件跳转的应用"></a>条件跳转的应用</h4><p>举个例子al是8位</p>
<p>把8位当作开关,于是我们来检测</p>
<h5 id="某一位是否开启"><a href="#某一位是否开启" class="headerlink" title="某一位是否开启"></a>某一位是否开启</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test al,10000000b</span><br><span class="line">jnz	xxx</span><br><span class="line">//开启了就ZF!=0,</span><br><span class="line">//没开启,ZF==1</span><br></pre></td></tr></table></figure>

<p>对于<code>10001000b</code></p>
<p>0位数据不管,检测那个1位,如果他也为1,那么最后ZF&#x3D;0.否则为1</p>
<h5 id="某几位当中是否有任意一位开启"><a href="#某几位当中是否有任意一位开启" class="headerlink" title="某几位当中是否有任意一位开启"></a>某几位当中是否有任意一位开启</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test al,10010001b</span><br><span class="line">jnz	xxx</span><br></pre></td></tr></table></figure>

<p>只要开启了一位,最后的ZF&#x3D;0,都没有开启就会ZF&#x3D;1</p>
<h5 id="某几位都开启"><a href="#某几位都开启" class="headerlink" title="某几位都开启"></a>某几位都开启</h5><p>要用减法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and al,10010001b</span><br><span class="line">cmp al,10010001b</span><br><span class="line">jz	xxx</span><br></pre></td></tr></table></figure>

<p>and把无关的位数都屏蔽了,留下了要检测的</p>
<p>然后一个cmp,如果都开启,最后结果就是0,ZF&#x3D;&#x3D;1</p>
<h5 id="求3个数的最小值"><a href="#求3个数的最小值" class="headerlink" title="求3个数的最小值"></a>求3个数的最小值</h5><p>假设x,y,z</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,x</span><br><span class="line">cmp eax,y</span><br><span class="line">jbe next</span><br><span class="line">mov eax,y</span><br><span class="line">next:</span><br><span class="line">cmp	eax,z</span><br><span class="line">jbe	end</span><br><span class="line">mov	result,z</span><br><span class="line">end:</span><br><span class="line">mov	result,eax</span><br></pre></td></tr></table></figure>



<h5 id="数的比较"><a href="#数的比较" class="headerlink" title="数的比较"></a>数的比较</h5><p>char x&#x3D;0xff<br>char y&#x3D;0x1<br>比较x&#x2F;y    x&lt;y</p>
<p>unsigned char x&#x3D;0xff<br>unsigned char y&#x3D;0x1<br>比较x&#x2F;y    x&gt;y</p>
<p>在数的比较中,我们会对其进行扩展</p>
<p>好比8位的比较变化位32位了</p>
<p>无符号的比较也可能用来有符号的跳转,可能涉及了符号的扩展</p>
<h3 id="条件测试-与循环语句"><a href="#条件测试-与循环语句" class="headerlink" title="条件测试+与循环语句"></a>条件测试+与循环语句</h3><h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><h5 id="if-x2F-elseif-x2F-endif-x2F-else"><a href="#if-x2F-elseif-x2F-endif-x2F-else" class="headerlink" title=".if&#x2F;.elseif&#x2F;.endif&#x2F;.else"></a>.if&#x2F;.elseif&#x2F;.endif&#x2F;.else</h5><p>一个基本的条件循环是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>

<p>2面性判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.else</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>



<p>多面性判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if</span><br><span class="line"></span><br><span class="line">.elseif</span><br><span class="line"></span><br><span class="line">.elseif</span><br><span class="line"></span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>



<p>这些if语句会与跳转指令相挂钩</p>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>条件测试语句?</p>
<p>就是逻辑条件的判断…</p>
<p>masm条件测试的几个限制</p>
<p>表达式左边只能是常量&#x2F;寄存器</p>
<p>表达式2边不能同时是变量,可以是寄存器</p>
<p>另外表达式中不能是算术表达式,好比x*y&gt;0</p>
<p>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>一些标志寄存器的伪指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if carry</span><br><span class="line">.if overflow</span><br><span class="line">.if parity</span><br><span class="line">.if sign</span><br><span class="line">.if zero</span><br></pre></td></tr></table></figure>





<p>条件的测试语句的伪指令见后面的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx);</span><br></pre></td></tr></table></figure>

<p>这句话实现有很多个跳转</p>
<p>这句判断的判断是一个顺序的结构</p>
<p>eax&#x3D;0,跑去判断var!&#x3D;ecx,</p>
<p>eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果是,就直接跳过后面的判断,直接执行</p>
<p>eax&#x3D;1,就去判断ebx&gt;&#x3D;var,如果不是,就去判断var!&#x3D;ecx,然后看是否要执行</p>
<p>所以这个判断还是有很多的jmp&#x2F;jnz&#x2F;jz的</p>
<p>很头疼</p>
<h5 id="天坑"><a href="#天坑" class="headerlink" title="天坑"></a>天坑</h5><p>1️⃣</p>
<p>关于那些条件条件跳转</p>
<p>他们也有sign与unsigned之分,</p>
<p>好比无符号的jb&#x2F;jnb</p>
<p>mov eax,1</p>
<p>jb eax,-1</p>
<p>那么的话-1是一个很大的值</p>
<p>对于无符号的比较指令好像书上写了</p>
<p>见cmp指令的跳转指令\</p>
<p>怎么在源代码里面避免这些情况???</p>
<p>办法一是把数据类型改为有符号的数,好比sword</p>
<p>办法二,强制类型转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if sword ptr eax &gt;0</span><br><span class="line">.if eax &gt; sword ptr 0</span><br></pre></td></tr></table></figure>





<p>2️⃣</p>
<p>条件指令就那几个</p>
<p>注意在前面加上点<code>.</code>,否则他就成为了宏指令</p>
<h5 id="代码示意"><a href="#代码示意" class="headerlink" title="代码示意"></a>代码示意</h5><p>可以调试一下它!!!!巨离谱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib		user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib		kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">var	dd	20</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		xor eax,eax</span><br><span class="line">		.if eax &amp;&amp; (ebx&gt;=var) || !(var!=ecx);把前面看作一个部分,如果前面2个返回1,那么后面就不在判断</span><br><span class="line">			mov esi,1</span><br><span class="line">		.elseif edx</span><br><span class="line">			mov esi,2</span><br><span class="line">		.elseif	esi &amp; 1</span><br><span class="line">			mov esi,3</span><br><span class="line">		.elseif	ZERO? &amp;&amp; CARRY?</span><br><span class="line">			mov esi,4</span><br><span class="line">		.endif</span><br><span class="line">			</span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>





<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>while&#x2F;endw&#x2F;repeat&#x2F;until&#x2F;untilcxz&#x2F;continue&#x2F;break</p>
<p>搭配</p>
<p>while-endw</p>
<p>repeat-until</p>
<p>repeat-untilcxz</p>
<p>while+表达式</p>
<p>表示一个循环执行的条件</p>
<p>一次循环结束就jmp到while那里再次判断是否执行</p>
<p>break&#x2F;continue就类别C语言就可以了,用于中途的跳出…</p>
<p>break到哪里去?while循环外的第一条语句</p>
<p>continue不会执行后面的代码,会jmp到循环开始的while</p>
<p>until+一个表达式</p>
<p>这个表达式是结束的表达式,也就是循环到什么时候结束</p>
<p>untilcxz是一个loop的盗版,他会ecx-&#x3D;1,判断ecx是否为0,然后执行loop一样的操作</p>
<p>它也可以接上一个表达式,那么的话,循环🔚的条件就变为了2个</p>
<p>loop指令不会影响标志寄存器的,是一个很好的选择</p>
<p>关于循环语句的伪指令见指令那一章节</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib		user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib		kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">szCaption	db	&#x27;Dqx-Gh0st&#x27;,0</span><br><span class="line">szText1		db	&#x27;I&#x27;,0</span><br><span class="line">szText2		db	&#x27;Love&#x27;,0</span><br><span class="line">szText3		db	&#x27;You&#x27;,0</span><br><span class="line">szText4		db	&#x27;Deeply&#x27;,0</span><br><span class="line">fuck		db	&#x27;fuck&#x27;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">var	dd	20</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">		</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		mov eax,5</span><br><span class="line">		.while	eax&gt;0</span><br><span class="line"></span><br><span class="line">			.if eax==4</span><br><span class="line">				dec eax</span><br><span class="line">				.continue</span><br><span class="line">				;continue后面的代码是不会执行的,可以对比一下C语言</span><br><span class="line">				push eax</span><br><span class="line">				invoke	MessageBox,NULL,offset fuck,offset szCaption,MB_OK</span><br><span class="line">				pop eax	</span><br><span class="line">				;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变</span><br><span class="line">				</span><br><span class="line">			.elseif eax==3</span><br><span class="line">				push eax</span><br><span class="line">				invoke	MessageBox,NULL,offset szText1,offset szCaption,MB_OK</span><br><span class="line">				pop eax</span><br><span class="line">				dec eax</span><br><span class="line"></span><br><span class="line">			.elseif eax==2</span><br><span class="line">				.break</span><br><span class="line">			.else</span><br><span class="line">				dec eax</span><br><span class="line">			.endif</span><br><span class="line">		.endw</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		;do &#123;&#125;while(eax&gt;0)</span><br><span class="line">		mov eax,2</span><br><span class="line">		.repeat	</span><br><span class="line">			push eax</span><br><span class="line">			invoke	MessageBox,NULL,offset szText2,offset szCaption,MB_OK</span><br><span class="line">			pop eax</span><br><span class="line">			dec eax</span><br><span class="line">		.until	eax == 0</span><br><span class="line">		</span><br><span class="line">		mov ecx,2</span><br><span class="line">		.repeat</span><br><span class="line">			pushad</span><br><span class="line">			invoke	MessageBox,NULL,offset szText3,offset szCaption,MB_OK</span><br><span class="line">			popad</span><br><span class="line">		.untilcxz</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>​               </p>
<p>把上面的代码转化一下</p>
<p>​			           </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,2</span><br><span class="line">.repeat	</span><br><span class="line">	push eax</span><br><span class="line">	invoke	MessageBox,NULL,offset szText2,offset szCaption,MB_OK</span><br><span class="line">	pop eax</span><br><span class="line">	dec eax</span><br><span class="line">.until	eax == 0</span><br><span class="line"></span><br><span class="line">i=0;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line">while(i!=0)</span><br></pre></td></tr></table></figure>



<p>​         </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;汇编</span><br><span class="line">mov eax,5</span><br><span class="line">.while	eax&gt;0</span><br><span class="line"></span><br><span class="line">	.if eax==4</span><br><span class="line">		dec eax</span><br><span class="line">		.continue</span><br><span class="line">		;continue后面的代码是不会执行的,可以对比一下C语言</span><br><span class="line">		push eax</span><br><span class="line">		invoke	MessageBox,NULL,offset fuck,offset szCaption,MB_OK</span><br><span class="line">		pop eax	</span><br><span class="line">		;前面好像说过,函数的返回值一般在eax,所以这里的eax我们要保持不变</span><br><span class="line">		</span><br><span class="line">	.elseif eax==3</span><br><span class="line">		push eax</span><br><span class="line">		invoke	MessageBox,NULL,offset szText1,offset szCaption,MB_OK</span><br><span class="line">		pop eax</span><br><span class="line">		dec eax</span><br><span class="line"></span><br><span class="line">	.elseif eax==2</span><br><span class="line">		.break</span><br><span class="line">	.else</span><br><span class="line">		dec eax</span><br><span class="line">	.endif</span><br><span class="line">.endw</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;C语言</span><br><span class="line">i=5;</span><br><span class="line">for(i=5;i&gt;0;)</span><br><span class="line">&#123;</span><br><span class="line">	if(i==4)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">		continue;</span><br><span class="line">		sub();</span><br><span class="line">	&#125;</span><br><span class="line">	else if(i==3)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;xxx&quot;);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	elseif(i==2)</span><br><span class="line">		breakl;</span><br><span class="line">	else</span><br><span class="line">		i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="movsx-x2F-movzx-符号扩展"><a href="#movsx-x2F-movzx-符号扩展" class="headerlink" title="movsx&#x2F;movzx 符号扩展"></a>movsx&#x2F;movzx 符号扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cl,66</span><br><span class="line">mov ax,0</span><br><span class="line">mov al,cl</span><br></pre></td></tr></table></figure>

<p>这样就实现了cl到ax的变化</p>
<p>但是有个问题,如果cl是负数呢?我们</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cl,0xf0</span><br><span class="line">mov ax,0xffff</span><br><span class="line">mov al,cl</span><br></pre></td></tr></table></figure>

<p>这会很麻烦</p>
<p>movsx eax,cl</p>
<p>无论cl是正是负.eax都会跟着cl的符号</p>
<p>movzx eax,cl 就不会有符号的跟随</p>
<h4 id="零扩展-x2F-符号扩展"><a href="#零扩展-x2F-符号扩展" class="headerlink" title="零扩展&#x2F;符号扩展"></a>零扩展&#x2F;符号扩展</h4><p>如果你是正数,就把你的二进制高位全部置为<code>0</code></p>
<p>如果你是负数,就把你的二进制高位全部置为<code>1</code>,</p>
<p>这样扩展不会改变原来的值</p>
<p>它不会要求你的长度怎么怎么样</p>
<p>只要长度<code>左边&gt;=右边</code>就可以,它会把右边的数据自动的长度扩展</p>
<p>movzx只用于无符号的数据,但是这句话不太明白</p>
<p>书上的例子<code>mov bx,0A69B</code>,也没有指明后者是正数还是负数</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="AND-x2F-OR-x2F-NOT-x2F-XOR-x2F-TEST"><a href="#AND-x2F-OR-x2F-NOT-x2F-XOR-x2F-TEST" class="headerlink" title="AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST"></a>AND&#x2F;OR&#x2F;NOT&#x2F;XOR&#x2F;TEST</h4><p>在移位的时候,你的左移和右移是和有无符号相关的</p>
<p>所以这回是一个细节</p>
<h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>AND 对1没影响,对0会得0</p>
<p>所以AND可以</p>
<p>用1去AND,那个数,可用于检测,如果对方是1那么结果是1,如果不是就为0</p>
<p>用0去AND,结果只会是0,</p>
<p>用0去or那个数,那个数不会发生任何改变,用于保存某些位的数</p>
<p>用1去or,结果只能是1</p>
<p>NOT 是取反</p>
<p>XOR 异或</p>
<p>如果2个数相同就不相异,结果为0</p>
<p>如果2个数不相同就相异,结果为1</p>
<p>TEST </p>
<p>不会修改操作数,相当于AND</p>
<p>会影响ZF&#x2F;SF&#x2F;PF</p>
<h5 id="映射集"><a href="#映射集" class="headerlink" title="映射集"></a>映射集</h5><p>补集用<code>NOT</code></p>
<p>交集用AND,对于2个操作数,如果有都有1,那就1,否则就是0</p>
<p>并集用OR,只要有一个人有就可以了</p>
<h4 id="neg"><a href="#neg" class="headerlink" title="neg"></a>neg</h4><p>求补码</p>
<p>neg求的是有符号的数据</p>
<p>如果结果无法放入寄存器,就补码无效,也就是OF&#x3D;1,就neg无效</p>
<p>好比数据-128</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">mov al,-128</span><br><span class="line">neg al</span><br><span class="line">mov al,-60</span><br><span class="line">neg al</span><br></pre></td></tr></table></figure>

<p>第一次neg</p>
<p><code>al=128,of=1,neg无效</code>,al不发生变化,al还是原来的<code>-128</code></p>
<p>第二次neg</p>
<p>al&#x3D;-60,neg后al&#x3D;60,of&#x3D;0,neg成功</p>
<p>&#x3D;&#x3D;neg&#x3D;&#x3D;可以用来取相反数</p>
<h4 id="shl-x2F-shr"><a href="#shl-x2F-shr" class="headerlink" title="shl&#x2F;shr"></a>shl&#x2F;shr</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov al,11001100b</span><br><span class="line">mov cl,1</span><br><span class="line">shl al,cl//</span><br></pre></td></tr></table></figure>

<p>shl实际左移的位数是n%32</p>
<p>如果左移1位,  可以<code>shl al,1</code></p>
<p>如果左移&gt;1位,必须用cl保存左移的位数,cl也可以是1[^这是8086的说法]</p>
<p>左移会存在数据的进位,进位的保存会在CF中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov al,11000001b</span><br><span class="line">mov cl,1</span><br><span class="line">shr al,cl</span><br></pre></td></tr></table></figure>



<p>如果右移1位,  可以<code>shl al,1</code></p>
<p>如果右移&gt;1位,必须用cl保存左移的位数,cl也可以是,[^8086的说法]</p>
<p>右移会存在数据的移除,消失的最后一位会在CF中-</p>
<p>计算100*36</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	eax,100</span><br><span class="line">mov	ebx,eax</span><br><span class="line">shl	eax,5</span><br><span class="line">shl	ebx,2</span><br><span class="line">add	eax,ebx</span><br></pre></td></tr></table></figure>

<p>它的原理分配法</p>
<p>100x36&#x3D;100x(32+4)</p>
<h4 id="sal-x2F-sar"><a href="#sal-x2F-sar" class="headerlink" title="sal&#x2F;sar"></a>sal&#x2F;sar</h4><p>就算数左移的话,与逻辑左移没有什么区别,都是填充0</p>
<p>就是右移就有些不同</p>
<p>10001000b是负数,逻辑右移后01000100b是正数,符号的性质发生了改变</p>
<p>于是我们就要用到算数右移了</p>
<p>10001000b用sar后11000100b,结果还是负数</p>
<p>sar 右移&gt;32位的话,实际右移的位数是n%32</p>
<h4 id="ROL-x2F-ROR-后进位循环移动"><a href="#ROL-x2F-ROR-后进位循环移动" class="headerlink" title="ROL&#x2F;ROR 后进位循环移动"></a>ROL&#x2F;ROR 后进位循环移动</h4><p>什么意思?</p>
<p>好比10101111b用指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,1010 1111b</span><br><span class="line">rol al,4</span><br><span class="line">al= 1111 1010b</span><br></pre></td></tr></table></figure>

<p>左移动4位,每移动一位,CF就记录那个值,然后在右边补上</p>
<p>它的用处?</p>
<p>①.位组交换</p>
<p>它可以交换一个8bit的前4位和后4位</p>
<p>②.坑</p>
<p>我们都知道一位的16进制对应了4位的二进制</p>
<p>于是左移一位16进制就是左移4位二进制</p>
<p>于是把数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,6A4Bh</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br><span class="line">rol ax,4</span><br></pre></td></tr></table></figure>

<p>于是到了最后ax的值没有发生变化</p>
<h4 id="RCL-x2F-RCR-先进位循环移动"><a href="#RCL-x2F-RCR-先进位循环移动" class="headerlink" title="RCL&#x2F;RCR 先进位循环移动"></a>RCL&#x2F;RCR 先进位循环移动</h4><p>与上面的原理一样</p>
<p>不一样的地方在于</p>
<p>它有CF的初始化值,移动后,先用已经初始化的CF取填充,再去记录那个移动的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STC	;CF=1</span><br><span class="line">mov	cl,4</span><br><span class="line">mov	al,10010010b</span><br><span class="line">rcl	al,4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后AL=00101100</span><br></pre></td></tr></table></figure>

<p>为了做一个对比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STC</span><br><span class="line">mov	cl,4</span><br><span class="line">mov	al,10010010b</span><br><span class="line">rol	al,4</span><br></pre></td></tr></table></figure>

<p>于是最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">al= 00101001</span><br></pre></td></tr></table></figure>



<h4 id="SHLD-x2F-SHRD"><a href="#SHLD-x2F-SHRD" class="headerlink" title="SHLD&#x2F;SHRD"></a>SHLD&#x2F;SHRD</h4><p>第一个操作数是16位&#x2F;32位的寄存器或者内存单元</p>
<p>第二个操作数只能是寄存器</p>
<p>第三个操作数可以使CL或者立即数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHLD D,S,count</span><br><span class="line">SHRD D,S,count</span><br></pre></td></tr></table></figure>

<p>count啥意思?<br>就是移多少位</p>
<p>SHLD D,S,count</p>
<p>把D左移coutn位,用S的高coutn位填充D的低count位</p>
<p>好比</p>
<p>shld 0x9BA6,0xAC36,4</p>
<blockquote>
<p>4位就是16进制的一个数字</p>
</blockquote>
<p>最后的0x9BA6-&gt;0xBA60-&gt;0xBA6A</p>
<hr>
<p>SHRD D,S,count</p>
<p>把D右移count位</p>
<p>用S的低count为去填充D的高count为</p>
<p>好比</p>
<p>shrd 0x234B,0x7654,4</p>
<p>0x2345-&gt;0x0234-&gt;0x4234</p>
<h4 id="mul-乘法指令"><a href="#mul-乘法指令" class="headerlink" title="mul 乘法指令"></a>mul 乘法指令</h4><p>由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。</p>
<blockquote>
<p>   8bit类型</p>
</blockquote>
<p>AL*1Byte</p>
<p>因数1是AL</p>
<p>因数2是一个8位的数据</p>
<p>其结果默认存放在AX中</p>
<blockquote>
<p>   16bit类型</p>
</blockquote>
<p>AX*1word</p>
<p>因数1是AX</p>
<p>因数2是一个16位的数据</p>
<p>其结果默认存放</p>
<p>低16位 AX</p>
<p>高16位 DX</p>
<p>上面是8086机学到的,可以兼容32位</p>
<blockquote>
<p>32bit</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据长度</th>
<th>因数1</th>
<th>因数2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>al</td>
<td>bl&#x2F;byte ptr ds:[si]</td>
<td>AX</td>
</tr>
<tr>
<td>16位</td>
<td>ax</td>
<td>bx&#x2F;word ptr ds:[si]</td>
<td>DX:AX</td>
</tr>
<tr>
<td>32位</td>
<td>eax</td>
<td></td>
<td>EDX:EAX</td>
</tr>
</tbody></table>
<p>什么时候高位会产生数据?<br>对于无符号的数据来说,数据太大就进位</p>
<p>所以才会有高位的寄存器,当高位寄存器!&#x3D;0,那么CF&#x3D;1,表示进位了</p>
<p>好比这一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">     db 5,4,3,2,1,0 </span><br><span class="line">data ends  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mov ax,0</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov al,2</span><br><span class="line">    mov bl,3</span><br><span class="line">    mul bl</span><br><span class="line">    mul byte ptr ds:[1]</span><br><span class="line"></span><br><span class="line">    mov ax,2</span><br><span class="line">    mov bx,10</span><br><span class="line">    mul bx</span><br><span class="line">    mul word ptr ds:[0]</span><br></pre></td></tr></table></figure>





<h4 id="IMUL-指令-有符号的乘法"><a href="#IMUL-指令-有符号的乘法" class="headerlink" title="IMUL 指令 有符号的乘法"></a>IMUL 指令 有符号的乘法</h4><p>IMUL有3种语法</p>
<p>1个操作数&#x2F;2个操作数&#x2F;3个操作数</p>
<p>对于无符号的数据,好比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,48</span><br><span class="line">mov	bl,4</span><br><span class="line">imul	bl</span><br></pre></td></tr></table></figure>

<p>48*4&#x3D;192</p>
<p>192&gt;127溢出</p>
<p>192&lt;255不会进位,但是就离谱的CF&#x3D;1</p>
<p>其实我还是没有分清IMUL与MUL到底有什么区别….</p>
<p>难道说他会有一个mul的有符号填充???</p>
<p>一个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,10</span><br><span class="line">mov bl,20</span><br><span class="line">IMUL bl</span><br><span class="line">ax=al*bl</span><br></pre></td></tr></table></figure>

<p>两个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,10</span><br><span class="line">IMUL ax,20</span><br><span class="line">ax=ax*20</span><br></pre></td></tr></table></figure>

<p>三个操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imul cx,ax,bx</span><br><span class="line">//cx=ax*bx</span><br></pre></td></tr></table></figure>





<h4 id="DIV-除法指令"><a href="#DIV-除法指令" class="headerlink" title="DIV 除法指令"></a>DIV 除法指令</h4><p>24&#x2F;9&#x3D;2…6</p>
<p>被除数24</p>
<p>除数9</p>
<p>商2</p>
<p>余数6</p>
<table>
<thead>
<tr>
<th align="center">被除数</th>
<th>被除数位置</th>
<th>除数</th>
<th>除数位置</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">16bti</td>
<td>AX</td>
<td>8位</td>
<td>8bit的内存单元&#x2F;寄存器</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td align="center">32bit</td>
<td>DX:AX</td>
<td>16位</td>
<td>16bit的内存单元&#x2F;寄存器</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td align="center">64bit</td>
<td>EDX:EAX</td>
<td>32位</td>
<td>32bit的内存单元&#x2F;寄存器</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody></table>
<h4 id="IDIV-有符号除法"><a href="#IDIV-有符号除法" class="headerlink" title="IDIV 有符号除法"></a>IDIV 有符号除法</h4><p>与DIV的区别在于,IDIV要进行符号的扩张</p>
<p>也就是DX&#x2F;EDX会根据AX&#x2F;EAX的正负进行有无符号的填写</p>
<p>其余无区别了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">x	sword	-101</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	dx,0</span><br><span class="line">		mov	ax,x</span><br><span class="line">		mov	bx,2</span><br><span class="line">		idiv	bx</span><br><span class="line">		;用DIV是一样的</span><br><span class="line">		;=-51...1</span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	dx,0</span><br><span class="line">		mov	ax,x</span><br><span class="line">		cwd</span><br><span class="line">		mov	bx,2</span><br><span class="line">		idiv	bx</span><br><span class="line">		;=-50...-1</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<p>很奇怪</p>
<h4 id="cbw-x2F-cwd-x2F-cdq-x2F-cdqe-x2F-cwde符号扩展"><a href="#cbw-x2F-cwd-x2F-cdq-x2F-cdqe-x2F-cwde符号扩展" class="headerlink" title="cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展"></a>cbw&#x2F;cwd&#x2F;cdq&#x2F;cdqe&#x2F;cwde符号扩展</h4><p>cbw	;扩展到了AH,用AL的符号填充AH,AH的值会被覆盖</p>
<blockquote>
<p> 若al&#x3D;78h,cbw后ax&#x3D;78h</p>
<p> 若al&#x3D;87h,cbw后ax&#x3D;ff87h</p>
</blockquote>
<p>cwd	;扩展到了DX,用AX的符号填充DX,   DX的值会被覆盖</p>
<p>cwde AX-&gt;EAX</p>
<p>cdq	;扩展到了EDX,用EAX的符号填充EDX,EDX的值会被覆盖</p>
<p>cdqe   EAX-&gt;RAX</p>
<p>为什么要符号扩展????</p>
<p>做8位除法,被除数必须16位AX</p>
<p>做16位除法,被除数必须32位DX|AX</p>
<p>做32位除法,被除数必须64位EDX|EAX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,-48</span><br><span class="line">		mov	bl,5</span><br><span class="line">		idiv	bl</span><br><span class="line">		;-48(208)/5=40..3</span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,-48</span><br><span class="line">		cbw		;让ah=FF</span><br><span class="line">		mov	bl,5</span><br><span class="line">		idiv	bl</span><br><span class="line">		;-48/5=-9..-3;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<p>不用就会产生错误的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">	</span><br><span class="line">x	sword	-101	;=0x9b,-101一定是负数,但是0x9b却不是</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		xor	edx,edx</span><br><span class="line">		xor	eax,eax</span><br><span class="line"></span><br><span class="line">		;mov	al,9bh,al一定是负数</span><br><span class="line">		mov	al,-101		</span><br><span class="line">		cbw	;扩展到了AH</span><br><span class="line">		</span><br><span class="line">		;mov	ax,9bh,ax不是负数,cwd失效</span><br><span class="line">		mov	ax,-101</span><br><span class="line">		cwd	;扩展到了dx</span><br><span class="line"></span><br><span class="line">		;mov	eax,9bh,eax不是是负数,cdq失效</span><br><span class="line">		mov	eax,-101</span><br><span class="line">		cdq	;扩展到了edx</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<h4 id="adc-进位加法"><a href="#adc-进位加法" class="headerlink" title="adc 进位加法"></a>adc 进位加法</h4><p>adc实现了带有符号位的加法,建立在二进制位的那个符号</p>
<p><code>adc eax,dword ptr [esi]</code></p>
<p>等价于</p>
<p><code> eax=eax+dword ptr [esi]+CF</code></p>
<p> adc的优势体现在哪????</p>
<p>好比1234+4567</p>
<p>我们可以这样算</p>
<p>34+67&#x3D;01,本来是101,但是进位了1</p>
<p>然后</p>
<p>12+45&#x3D;57,于是加上进位,就是58</p>
<p>最后的结果就是5801</p>
<p>通过这种分割的形式我们可以算很长的数据</p>
<p>下面是一个8字节程度的数据,实现加法</p>
<p>好比0x1234567890102345+0x1234567890102345</p>
<p>这个代码你还还是多看一下,很妙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">	.data</span><br><span class="line">arr1	dw	12h,34h,56h,78h,9h</span><br><span class="line">arr2	dw	9h,87h,65h,43h,21h</span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">		mov esi,offset arr1</span><br><span class="line">		mov edi,offset arr2</span><br><span class="line"></span><br><span class="line">		mov ecx,5</span><br><span class="line">		xor eax,eax</span><br><span class="line">		clc</span><br><span class="line">		;clc指令把CF寄存器初始化为0,给首位adc使用</span><br><span class="line">	ok:	</span><br><span class="line">		mov ax,[esi]</span><br><span class="line">		adc [edi],ax</span><br><span class="line">		pushfd</span><br><span class="line">		add esi,2</span><br><span class="line">		add edi,2</span><br><span class="line">		popfd</span><br><span class="line">		;为什么把寄存器入栈?因为add会修改CF寄存器的值</span><br><span class="line">		loop ok</span><br><span class="line">				</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>



<h4 id="sbb-借位减法"><a href="#sbb-借位减法" class="headerlink" title="sbb 借位减法"></a>sbb 借位减法</h4><p> 就是一个借位的过程,做一些记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor	eax,eax</span><br><span class="line"></span><br><span class="line">mov	edx,7</span><br><span class="line">mov	eax,1</span><br><span class="line">sub	eax,2</span><br><span class="line">sbb	edx,0</span><br></pre></td></tr></table></figure>







<h4 id="xadd-很sb的加法"><a href="#xadd-很sb的加法" class="headerlink" title="xadd 很sb的加法"></a>xadd 很sb的加法</h4><p>z&#x3D;x+y</p>
<p>xadd的效果就是</p>
<p>z&#x3D;y+x</p>
<p>在我的电脑上,这个指令无法用</p>
<h3 id="非压缩10进制算法原理"><a href="#非压缩10进制算法原理" class="headerlink" title="非压缩10进制算法原理"></a>非压缩10进制算法原理</h3><h4 id="aaa-加法"><a href="#aaa-加法" class="headerlink" title="aaa 加法"></a>aaa 加法</h4><p>会影响AF&#x2F;CF</p>
<h5 id="通俗介绍"><a href="#通俗介绍" class="headerlink" title="通俗介绍"></a>通俗介绍</h5><blockquote>
<p>aaa 操作的对象16进制的个位数,也就是4个bit位</p>
<p>好比0x2F,他会把F拿出来,然后把F分解为1和5,因为F是15</p>
<p>好比0x39,ASCII是9,然后把9分解为0和9,也就是9</p>
</blockquote>
<p>于是下面这些例子</p>
<p>3+’6’&#x3D;0x39,然后对个位数可以转化为0和9,依次放在ah,al</p>
<p>‘3’+’6’&#x3D;0x69,然后对个位数可以转化为0和9</p>
<p>因为它只看个位数,同时请保证AH&#x3D;0,再进行操作</p>
<p>16进制个位数满足0-15,对于10进制绰绰有余,</p>
<p>AH代表了进位,会传递给一个进位者</p>
<h5 id="书上说"><a href="#书上说" class="headerlink" title="书上说"></a>书上说</h5><blockquote>
<p>如果AL的低4位&gt;9,也就数10进制进位了AL+&#x3D;6,AH+&#x3D;1…..是吗?????&#x2F;</p>
</blockquote>
<blockquote>
<p>会有CF&#x3D;1,AF&#x3D;1</p>
</blockquote>
<blockquote>
<p>否则CF&#x3D;0.AF&#x3D;0.</p>
</blockquote>
<p>难道会有置空?</p>
<h5 id="关于计算过程"><a href="#关于计算过程" class="headerlink" title="关于计算过程"></a>关于计算过程</h5><p>好比0x37&#x3D;0x39</p>
<p>也就是7+9&#x3D;0x70</p>
<p>你可以看到低4字节为0</p>
<p>但是他有一个进位</p>
<p>CF&#x3D;1,AF&#x3D;1</p>
<p>就相当于0x10&#x3D;16了</p>
<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">x		db &quot;96543&quot;			</span><br><span class="line">y		db &quot;53279&quot;		</span><br><span class="line">sum		db (sizeof x + 1) dup(&#x27;0&#x27;),0</span><br><span class="line">format		db &quot;%s&quot;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">		xor	ecx,ecx</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		;为什么esi-1</span><br><span class="line">		;因为从0开始计数,所以最后一位的index=len-1</span><br><span class="line">		;为什么edi不-1?</span><br><span class="line">		;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,会有进位</span><br><span class="line">		mov	esi,sizeof x -1</span><br><span class="line">		mov	edi,sizeof x</span><br><span class="line">		mov	ecx,sizeof x</span><br><span class="line">		;数值的填充由字符串最高位开始==数值最低位开始</span><br><span class="line"></span><br><span class="line">		;让进位值由bh来装,最先的进位还是0</span><br><span class="line">		mov	bh,0					</span><br><span class="line"></span><br><span class="line">L1:		;aaa指令要求ah=0</span><br><span class="line">		mov	ah,0					</span><br><span class="line">		mov	al,x[esi]	</span><br><span class="line">		;al每一次先加上进位值,再加上数值</span><br><span class="line">		add	al,bh					</span><br><span class="line">		aaa					</span><br><span class="line">		add	al,y[esi]		</span><br><span class="line">		aaa</span><br><span class="line">		;+了后,bh还要保持新的进位</span><br><span class="line">		</span><br><span class="line">		mov	bh,ah</span><br><span class="line">		or	al,30h</span><br><span class="line">		;转ascii然后放入sum</span><br><span class="line">		mov	sum[edi],al			</span><br><span class="line">		dec	esi 					</span><br><span class="line">		dec	edi</span><br><span class="line">		loop	L1</span><br><span class="line">		</span><br><span class="line">		;最后一个也可能有进位</span><br><span class="line">		or	bh,30h</span><br><span class="line">		mov	sum[edi],bh			</span><br><span class="line">		invoke	printf,addr format,addr sum</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>又写了一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">x		db &quot;96543&quot;,0			</span><br><span class="line">y		db &quot;53279&quot;,0		</span><br><span class="line">sum		db  sizeof x dup(0),0</span><br><span class="line">format		db &quot;%s&quot;,13,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">		xor	ecx,ecx</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		</span><br><span class="line">		;为什么esi-1</span><br><span class="line">		;因为从0开始计数,所以最后一位的index=len-1</span><br><span class="line">		;为什么edi不-1?</span><br><span class="line">		;edi本来就比esi长一个字节,好比x是4字节,那么sum就5字节,可能会有进位</span><br><span class="line">		mov	esi,sizeof x - 2</span><br><span class="line">		mov	edi,sizeof x - 1</span><br><span class="line">		mov	ecx,sizeof x - 1</span><br><span class="line">		;数值的填充由字符串最高位开始==数值最低位开始</span><br><span class="line"></span><br><span class="line">		clc					</span><br><span class="line">L1:		</span><br><span class="line">		mov	ah,0</span><br><span class="line">		mov	al,x[esi]</span><br><span class="line">		adc	al,y[esi]</span><br><span class="line">		aaa</span><br><span class="line"></span><br><span class="line">		pushfd</span><br><span class="line">		or	al,30h</span><br><span class="line">		popfd</span><br><span class="line">		mov	sum[edi],al	</span><br><span class="line">        </span><br><span class="line">		dec	esi 					</span><br><span class="line">		dec	edi</span><br><span class="line">		loop	L1</span><br><span class="line">		</span><br><span class="line">		cmp     ah,1</span><br><span class="line">		jnz     over</span><br><span class="line">		or	    ah,30h</span><br><span class="line">		mov	sum[edi],ah</span><br><span class="line">		over:</span><br><span class="line">		invoke	printf,addr format,addr sum</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>or,add,会影响CF</p>
<p>inc&#x2F;dex不会</p>
<h4 id="daa-加法"><a href="#daa-加法" class="headerlink" title="daa 加法"></a>daa 加法</h4><p>影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF</p>
<h5 id="书上说-1"><a href="#书上说-1" class="headerlink" title="书上说"></a>书上说</h5><p>其调整规则</p>
<p>若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6,</p>
<p>若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h,</p>
<p>都不成立就AF&#x3D;CF&#x3D;0</p>
<p>他把16进制的0x12</p>
<p>可以转化为10进制的0x12</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor	eax,eax</span><br><span class="line"></span><br><span class="line">mov	al,12h</span><br><span class="line">add	al,28h</span><br><span class="line">daa</span><br></pre></td></tr></table></figure>

<p>12+28&#x3D;40,</p>
<p>最后的结果是16进制的40</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">Num1 WORD 4536h</span><br><span class="line">Num2 WORD 7207h</span><br><span class="line">sum DWORD ?</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	xor	eax,eax</span><br><span class="line">	mov	sum,0</span><br><span class="line">	mov	esi,0</span><br><span class="line">	mov	ecx,type Num1</span><br><span class="line"></span><br><span class="line">	CLC</span><br><span class="line">	</span><br><span class="line">	ok:</span><br><span class="line">	mov	al,byte ptr Num1[esi]</span><br><span class="line">	add	al,byte ptr Num2[esi]</span><br><span class="line">	daa	</span><br><span class="line">	mov	byte ptr sum[esi],al</span><br><span class="line">	inc	esi</span><br><span class="line">	loop	ok</span><br><span class="line"></span><br><span class="line">	adc	byte ptr sum[esi],0</span><br><span class="line">	mov	eax,sum</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">	end	start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关于进位的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	al,56h</span><br><span class="line">add	al,92h</span><br><span class="line">daa</span><br></pre></td></tr></table></figure>

<p>56+92&#x3D;148</p>
<p>al装不下148,只能装48</p>
<p>所以就进位了</p>
<h4 id="aas-减法"><a href="#aas-减法" class="headerlink" title="aas 减法"></a>aas 减法</h4><p>影响AC&#x2F;CF</p>
<p>它操作的对象也是16进制</p>
<p>好比操作0xF,就是操作15</p>
<p>然后得到10进制意义的数值</p>
<p>可以类比aaa</p>
<h5 id="书上说-2"><a href="#书上说-2" class="headerlink" title="书上说"></a>书上说</h5><blockquote>
<p>如果AL的低4位&gt;9,也就数10进制借位了AL-&#x3D;6,AH-&#x3D;1…..是吗?????&#x2F;</p>
</blockquote>
<blockquote>
<p>会有CF&#x3D;1,AF&#x3D;1</p>
</blockquote>
<blockquote>
<p>否则CF&#x3D;0.AF&#x3D;0.</p>
</blockquote>
<p>难道会有置空?</p>
<h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	ah,0</span><br><span class="line">mov	al,5</span><br><span class="line">sub	al,10</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">add	al,30h</span><br><span class="line">popf</span><br><span class="line">;or会影响CF</span><br><span class="line"></span><br><span class="line">aas</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>0-5&#x3D;FB</p>
<p>然后aas后</p>
<p>AH&#x3D;0xFF,AL&#x3D;5</p>
<p>可能AH代表了符号,AL代表了值</p>
<p>其中产生的借位留在了CF中</p>
<h4 id="das-减法"><a href="#das-减法" class="headerlink" title="das 减法"></a>das 减法</h4><p>影响AF&#x2F;CF&#x2F;PF&#x2F;SF&#x2F;ZF\</p>
<h5 id="书上说-3"><a href="#书上说-3" class="headerlink" title="书上说"></a>书上说</h5><p>其调整规则</p>
<p>若AL的低4位有进位,则AF&#x3D;1,AL+&#x3D;6,</p>
<p>若AL的高4位有进位,则CF&#x3D;1,AL+&#x3D;60h,</p>
<p>都不成立就AF&#x3D;CF&#x3D;0</p>
<h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><p>对16进制形式操作</p>
<p>结果也是10进制意义的16进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	xor	eax,eax</span><br><span class="line">	xor	ebx,ebx</span><br><span class="line">	mov	al,85h</span><br><span class="line">	mov	bl,48h</span><br><span class="line">	sub	al,bl</span><br><span class="line">	das</span><br></pre></td></tr></table></figure>

<p>结果是10进制意义16进制的85-48&#x3D;37</p>
<p>对于负数的处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	al,50h</span><br><span class="line">sub	al,90h</span><br><span class="line">das</span><br></pre></td></tr></table></figure>

<p>其实这里的借位我算是见过了</p>
<p>诸如的结果60h</p>
<p>怎么来的</p>
<p>150-90&#x3D;60</p>
<p>所以就60h</p>
<h4 id="aam-乘法"><a href="#aam-乘法" class="headerlink" title="aam 乘法"></a>aam 乘法</h4><p>会影响PF&#x2F;SF&#x2F;ZF</p>
<p>ascii adjust after mul</p>
<p>操作的对象是16进制</p>
<p>得到结果是10进制,分别放在AH,AL</p>
<p>AH&#x3D;AL&#x2F;10</p>
<p>AL&#x3D;AL%10</p>
<p>话不多说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	ah,0</span><br><span class="line">mov	al,5</span><br><span class="line">mov	bl,6	</span><br><span class="line">mul	bl</span><br><span class="line">aam</span><br></pre></td></tr></table></figure>

<p>然后结果就是30</p>
<p>ah&#x3D;03,al&#x3D;00</p>
<p>如果结果是98.AH&#x3D;09h.AL&#x3D;08h</p>
<p>如果结果是125.AH&#x3D;12h.AL&#x3D;05h</p>
<p>就像aaa的那个程序一样</p>
<h4 id="aad-除法"><a href="#aad-除法" class="headerlink" title="aad 除法"></a>aad 除法</h4><p>会影响PF&#x2F;SF&#x2F;ZF</p>
<p>它很不一样</p>
<p>操作的是10进制,从AH,Al当中取数据</p>
<p>AL&#x3D;AH*10+AL</p>
<p>AH&#x3D;0</p>
<p>好比0x0207</p>
<p>就是操作10进制的27</p>
<p>在Al中生成商,在AH中生存余数</p>
<p>,可是数据太多怎么办?????</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	ax,0307h</span><br><span class="line">aad</span><br><span class="line">;合成了数值37=0x某某</span><br><span class="line">mov	bl,5</span><br><span class="line">div	bl</span><br></pre></td></tr></table></figure>

<p>他可以识别ax&#x3D;0x307位10进制的的37</p>
<p>于是想要使用aad的话,你得是10进制的形式然后被识别为16进制</p>
<p>好比你把一串ASCII-0x30,然后放在AH,AL中</p>
<p>“1234”</p>
<p>识别为,1,2,3,4然后除法?????woc????&#x2F;貌似不行的</p>
<h3 id="字符串基本指令"><a href="#字符串基本指令" class="headerlink" title="字符串基本指令"></a>字符串基本指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MOVSB、MOVSW、MOVSD</td>
<td>传送字符串数据： ESI的内存数据—&gt; EDI 的内存位置</td>
</tr>
<tr>
<td>CMPSB、CMPSW、CMPSD</td>
<td>比较字符串：比较分别由 ESI 和 EDI 寻址的内存数据</td>
</tr>
<tr>
<td>SCASB、SCASW、SCASD</td>
<td>扫描字符串：比较累加器 (AL、AX 或 EAX) 与 EDI 寻址的内存数据</td>
</tr>
<tr>
<td>STOSB、STOSW、STOSD</td>
<td>保存字符串数据：将累加器内容保存到 EDI 寻址的内存位置</td>
</tr>
<tr>
<td>LODSB、LODSW、LODSD</td>
<td>从字符串加载到累加器：将 ESI 寻址的内存数据加载到累加器</td>
</tr>
</tbody></table>
<h4 id="方向标志位指令"><a href="#方向标志位指令" class="headerlink" title="方向标志位指令"></a>方向标志位指令</h4><p>STD 让DF&#x3D;1 表示方向</p>
<p>CLD 让DF&#x3D;0 表示正向</p>
<table>
<thead>
<tr>
<th>DF</th>
<th>对ESI和EDI的影响</th>
<th>esi&#x2F;edi位置</th>
<th>地址顺序</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>每一次增加type 个大小</td>
<td>指向首位</td>
<td>小-&gt;大,正序</td>
</tr>
<tr>
<td>1</td>
<td>每一次减少type 个大小</td>
<td>指向末尾</td>
<td>大-&gt;小,逆序</td>
</tr>
</tbody></table>
<h4 id="字符串循环的退出条件之一"><a href="#字符串循环的退出条件之一" class="headerlink" title="字符串循环的退出条件之一"></a>字符串循环的退出条件之一</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rep</td>
<td>ECX &gt; 0 时循环</td>
</tr>
<tr>
<td>repz,repe</td>
<td>ZF&#x3D; 1 且 ECX &gt; 0 时循环</td>
</tr>
<tr>
<td>repnz,repne</td>
<td>ZF&#x3D;0 且 ECX &gt; 0 时循环</td>
</tr>
</tbody></table>
<h4 id="movs-b-x2F-w-x2F-d-数据复制"><a href="#movs-b-x2F-w-x2F-d-数据复制" class="headerlink" title="movs b&#x2F;w&#x2F;d  数据复制"></a>movs b&#x2F;w&#x2F;d  数据复制</h4><p>MoVS BYTE PTR ES:[EDI], BYTE PTR DS: [ESI] 简写为:MOVSB<br>Movs WORD PTR ES:[EDI], WORD PTR DS:[ESI]   简写为:MOvsw<br>MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  简写为:MOVSD</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">数据类型</th>
<th align="center">ESI 和 EDI 增加或减少的数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MOVSB</td>
<td align="center">传送（复制）byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">MOVSW</td>
<td align="center">传送（复制）word</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">MOVSD</td>
<td align="center">传送（复制）dword</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>从esi到edi</p>
<p>一个从尾巴到头部的复制制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A_str	db	&quot;I love you deeply&quot;,0</span><br><span class="line">len	=	lengthof A_str</span><br><span class="line">B_str	db	len dup (&#x27;C&#x27;)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A_str +len - 1 ;+len指向了0后面</span><br><span class="line">	mov	edi,offset B_str +len - 1 ;指向了最后一个C</span><br><span class="line">	mov	ecx,len	;表示循环次数0也复制进去</span><br><span class="line">	std</span><br><span class="line">	rep	movsb</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="cmpsb-x2F-sw-x2F-sd-数据比较"><a href="#cmpsb-x2F-sw-x2F-sd-数据比较" class="headerlink" title="cmpsb&#x2F;sw&#x2F;sd 数据比较"></a>cmpsb&#x2F;sw&#x2F;sd 数据比较</h4><table>
<thead>
<tr>
<th>CMPSB</th>
<th>比较字节</th>
</tr>
</thead>
<tbody><tr>
<td>CMPSW</td>
<td>比较字</td>
</tr>
<tr>
<td>CMPSD</td>
<td>比较双字</td>
</tr>
</tbody></table>
<p>通过循环可以比较字符串,与strcmp可以相当</p>
<p>比较esi与edi指向的数据串,循环ecx次</p>
<p>cmpsb 是字节比较</p>
<p>cmpsw 是字比较</p>
<p>cmpsd 是双值比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">B1	db	&quot;I l0ve You&quot;,0</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A1 </span><br><span class="line">	mov	edi,offset B1 </span><br><span class="line">	mov	ecx,lengthof A1 - 1</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	repe	cmpsb</span><br><span class="line">	;repe	如果zf=1,ecx&gt;0就继续循环</span><br><span class="line">	;故循环继续的条件是ecx&gt;0&amp;&amp;ZF==1</span><br><span class="line">	jnz	show1</span><br><span class="line">	jz	show2	</span><br><span class="line">	</span><br><span class="line">	show1:  mov	eax,1</span><br><span class="line">		jmp	over</span><br><span class="line">	show2:	mov	eax,2</span><br><span class="line">		jmp	over</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<p>对于cmpsw&#x2F;sd的比较,我就不多说了</p>
<h4 id="scasb-x2F-sw-x2F-sd-数据遍历"><a href="#scasb-x2F-sw-x2F-sd-数据遍历" class="headerlink" title="scasb&#x2F;sw&#x2F;sd 数据遍历"></a>scasb&#x2F;sw&#x2F;sd 数据遍历</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>scasb</td>
<td>扫描字节</td>
</tr>
<tr>
<td>scasw</td>
<td>扫描字</td>
</tr>
<tr>
<td>scasd</td>
<td>扫描双字</td>
</tr>
</tbody></table>
<p>通过循环,可以逐个遍历字符串然后获取其中的index</p>
<p>这个指令是拿al&#x2F;ax&#x2F;eax与edi指向的数据串进行遍历比较</p>
<p>scan-xx指令有什么要注意的</p>
<p>1️⃣.它是拿al&#x2F;ax&#x2F;eax与[edi]作比较,而不是[esi]</p>
<p>2️⃣.每比较一个就dec edi,这是一个连在一起的过程</p>
<p>3️⃣.他的用处到底是啥?寻找一个数据串当中有没有对应的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	edi,offset A1 </span><br><span class="line">	mov	ecx,lengthof A1 - 1</span><br><span class="line">	mov	al,&#x27;Y&#x27;</span><br><span class="line">	cld</span><br><span class="line">	repne	scasb</span><br><span class="line">	;相等就退出循环</span><br><span class="line">	;不相等就一直遍历,一直到ecx=0||ZF=1才退出</span><br><span class="line"></span><br><span class="line">	jnz	show1	;最后都还是没有找到相等的值</span><br><span class="line">	jz	show2	;最后找到了相等的值</span><br><span class="line">	</span><br><span class="line">	show1:  mov	eax,0</span><br><span class="line">		jmp	over</span><br><span class="line">	show2:	</span><br><span class="line">		dec	edi		;把edi再一次指向&#x27;Y&#x27;</span><br><span class="line">		mov	ah,byte ptr [edi]</span><br><span class="line">		jmp	over</span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h4 id="stos-b-x2F-w-x2F-d-数据存入"><a href="#stos-b-x2F-w-x2F-d-数据存入" class="headerlink" title="stos b&#x2F;w&#x2F;d 数据存入"></a>stos b&#x2F;w&#x2F;d 数据存入</h4><p>把Al&#x2F;AX&#x2F;EAX的值存储到[EDI]指定的内存单元</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>stosb</td>
<td>存储字节</td>
</tr>
<tr>
<td>stosw</td>
<td>存储字</td>
</tr>
<tr>
<td>stosd</td>
<td>存储双字</td>
</tr>
</tbody></table>
<p>STOS BYTE PTR ES:[EDI] 简写为STOSB<br>STos WORD PTR ES:[EDI] 简写为STOSw<br>STOS DWORD PTR ES:[EDI] 简写为STOSD</p>
<p>循环ecx次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I lOve You&quot;,0</span><br><span class="line">len	=	lengthof A1 - 1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	edi,offset A1 </span><br><span class="line">	mov	ecx,len</span><br><span class="line">	mov	al,&#x27;D&#x27;</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	rep	stosb</span><br><span class="line">	;他会把&#x27;D&#x27;依次填满字符串A1</span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>





<h4 id="losb-x2F-sw-x2F-sd-数据拿出"><a href="#losb-x2F-sw-x2F-sd-数据拿出" class="headerlink" title="losb&#x2F;sw&#x2F;sd 数据拿出"></a>losb&#x2F;sw&#x2F;sd 数据拿出</h4><p>把[esi]指向的数据串依次给了al&#x2F;ax&#x2F;eax</p>
<p>这个代码的功能</p>
<p>将数据串[esi]的每一位拿出来放在al</p>
<p>然后乘以10,</p>
<p>然后把al放进[edi]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	1,2,3,4,5</span><br><span class="line">len	dd	lengthof A1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	mov	esi,offset A1 </span><br><span class="line">	mov	edi,esi</span><br><span class="line">	mov	ecx,len</span><br><span class="line">	mov	bh,10</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">	lodsb</span><br><span class="line">	mul	bh</span><br><span class="line">	stosb</span><br><span class="line"></span><br><span class="line">	loop ok</span><br><span class="line"></span><br><span class="line">	over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>





<h4 id="xlat-x2F-xlatb"><a href="#xlat-x2F-xlatb" class="headerlink" title="xlat&#x2F;xlatb"></a>xlat&#x2F;xlatb</h4><p>他会用2个寄存器</p>
<p>ebx存放加密表的table的地址</p>
<p>al存放待加密的数据,和已经加密好的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al, byte ptr [esi]</span><br><span class="line">sub al,&#x27;+&#x27;</span><br><span class="line">xlat table</span><br><span class="line">mov byte ptr [edi],al</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后一个例子</p>
<p>加密字符串”Dqx_Gh0st”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">printf proto c:dword,:vararg</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">table	byte	&quot;+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;,0</span><br><span class="line">ming	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">len	=	sizeof	ming</span><br><span class="line">mi	byte	len-1 dup(&#x27;@&#x27;),0</span><br><span class="line">format	byte	&quot;%c %c&quot;,10,0</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	xor eax,eax </span><br><span class="line">	mov ebx,offset table</span><br><span class="line">	mov esi,offset ming</span><br><span class="line">	mov edi,offset mi</span><br><span class="line">	mov ecx,len</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	flag:</span><br><span class="line">	mov al, byte ptr [esi]</span><br><span class="line">	sub al,&#x27;+&#x27;</span><br><span class="line">	xlat table</span><br><span class="line">	mov byte ptr [edi],al</span><br><span class="line"></span><br><span class="line">	pushad</span><br><span class="line">	movzx eax,byte ptr [esi]</span><br><span class="line">	movzx ebx,byte ptr [edi]</span><br><span class="line">	invoke printf ,addr format,eax,ebx</span><br><span class="line">	popad</span><br><span class="line"></span><br><span class="line">	inc esi</span><br><span class="line">	inc edi</span><br><span class="line">	loop flag</span><br><span class="line">	</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>IDA的分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">start</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 *_esi; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 *_edi; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-20h] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp-1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// [esp-18h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  _EAX = <span class="number">0</span>;</span><br><span class="line">  _EBX = aAbcdefghijklmn;</span><br><span class="line">  _esi = (<span class="type">unsigned</span> __int8 *)aDqxGh0st;</span><br><span class="line">  _edi = (<span class="type">unsigned</span> __int8 *)asc_40304B;</span><br><span class="line">  len = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOBYTE(_EAX) = *_esi - <span class="number">43</span>;</span><br><span class="line">    __asm &#123; xlat &#125;</span><br><span class="line">    *_edi = _EAX;</span><br><span class="line">    count = len;</span><br><span class="line">    v8 = a2;</span><br><span class="line">    v7 = _EAX;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>, *_esi, *_edi);</span><br><span class="line">    _EAX = v7;</span><br><span class="line">    a2 = v8;</span><br><span class="line">    ++_esi;</span><br><span class="line">    ++_edi;</span><br><span class="line">    len = count - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( count != <span class="number">1</span> );</span><br><span class="line">  ExitProcess(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的v7&#x2F;v8应该就是源码的一个pushad和popad操作</p>
<h4 id="insb-x2F-w-x2F-d-输入串指令"><a href="#insb-x2F-w-x2F-d-输入串指令" class="headerlink" title="insb&#x2F;w&#x2F;d 输入串指令"></a>insb&#x2F;w&#x2F;d 输入串指令</h4><p>输入串操作从DX指定端口接受一个byte&#x2F;word&#x2F;dword</p>
<p>并存入以EDI为起始地址的的存储单元,DF决定了写入的方向,然后EDI根据单位值进行自增与自减</p>
<p>书上没有例子,这可能与终端有关</p>
<h4 id="outsb-x2F-w-x2F-d输出串指令"><a href="#outsb-x2F-w-x2F-d输出串指令" class="headerlink" title="outsb&#x2F;w&#x2F;d输出串指令"></a>outsb&#x2F;w&#x2F;d输出串指令</h4><p>从EDI指向内存单元输出到指定的端口</p>
<h1 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h1><p>遇到的指令</p>
<p>没有对齐的加法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movupd  xmm0, dpvector1</span><br><span class="line">movupd  xmm1, dpvector2</span><br><span class="line">addpd   xmm0, xmm1</span><br><span class="line">movupd  ds:dpvector_res, xmm0</span><br></pre></td></tr></table></figure>

<p>对齐的加法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movapd  xmm0, dpvector1</span><br><span class="line">addpd   xmm0, dpvector2</span><br><span class="line">movapd  ds:dpvector_res, xmm0</span><br></pre></td></tr></table></figure>





<h3 id="movups"><a href="#movups" class="headerlink" title="movups"></a>movups</h3><p>移动&#x3D;&#x3D;未对齐&#x3D;&#x3D;的打包单精度</p>
<p>会得到4个精度值的向量</p>
<h3 id="movaps"><a href="#movaps" class="headerlink" title="movaps"></a>movaps</h3><h3 id="movaps-1"><a href="#movaps-1" class="headerlink" title="movaps"></a>movaps</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVAPS xmm1, xmm2 / m128</span><br></pre></td></tr></table></figure>

<p>把对齐的<code>xmm2/8字节mem</code>给xmm1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVAPS xmm2 / m128.xmm1</span><br></pre></td></tr></table></figure>

<p>把对齐的xmm1给<code>xmm2/8字节mem</code></p>
<h3 id="movapd"><a href="#movapd" class="headerlink" title="movapd"></a>movapd</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVAPD xmm1, xmm2/m128</span><br></pre></td></tr></table></figure>

<p>把对齐的<code>xmm2或者8字节mem</code>的double类型给xmm1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVAPD xmm2/m128, xmm1</span><br></pre></td></tr></table></figure>

<p>把对齐的xmm1给<code>xmm2/8字节mem</code></p>
<h3 id="movss"><a href="#movss" class="headerlink" title="movss"></a>movss</h3><p>把float送到目的地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVSS xmm1, xmm2</span><br><span class="line">MOVSS xmm1, m32</span><br></pre></td></tr></table></figure>



<h3 id="movdqa"><a href="#movdqa" class="headerlink" title="movdqa"></a>movdqa</h3><p>将对齐的压缩整数值从 16字节长度 移动到 16字节</p>
<h3 id="movd"><a href="#movd" class="headerlink" title="movd"></a>movd</h3><p>4字节的mov</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVD xmm , r/m32</span><br><span class="line">MOVD r/m32 , xmm</span><br></pre></td></tr></table></figure>



<h3 id="movq"><a href="#movq" class="headerlink" title="movq"></a>movq</h3><p>8字节的mov</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVQ xmm , r/m64</span><br><span class="line">MOVQ r/m64 , xmm</span><br></pre></td></tr></table></figure>



<h3 id="movsd"><a href="#movsd" class="headerlink" title="movsd"></a>movsd</h3><p>在8字节基础上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVSD xmm1, xmm2</span><br><span class="line">MOVSD xmm1, m64</span><br><span class="line">MOVSD xmm1/m64, xmm2</span><br></pre></td></tr></table></figure>

<p>处理的数据类型是double</p>
<h3 id="addps"><a href="#addps" class="headerlink" title="addps"></a>addps</h3><p>将压缩的单精度浮点值从 16字节 数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器 中。</p>
<p>打包单精度数据相加</p>
<p>也就是每4字节相加….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401166 movaps  xmm0, spvector1</span><br><span class="line">.text:000000000040116E addps   xmm0, spvector2</span><br></pre></td></tr></table></figure>



<h3 id="appad"><a href="#appad" class="headerlink" title="appad"></a>appad</h3><p>  将压缩双精度浮点值从128位的数据长度 添加到 xmm寄存器 并将结果存储在 xmm寄存器中。</p>
<p>每8字节8字节的相加</p>
<h3 id="cvtss2sd"><a href="#cvtss2sd" class="headerlink" title="cvtss2sd"></a>cvtss2sd</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVTSS2SD xmm1, xmm2/m32</span><br></pre></td></tr></table></figure>

<p>double&lt;–flaot</p>
<h3 id="cvtsd2ss"><a href="#cvtsd2ss" class="headerlink" title="cvtsd2ss"></a>cvtsd2ss</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVTSD2SS xmm1, xmm2/m64</span><br></pre></td></tr></table></figure>

<p>float&lt;–double</p>
<h3 id="paddb-x2F-w-x2F-d-x2F-q"><a href="#paddb-x2F-w-x2F-d-x2F-q" class="headerlink" title="paddb&#x2F;w&#x2F;d&#x2F;q"></a>paddb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401166 movdqa  xmm0, pdivector1</span><br><span class="line">.text:000000000040116F paddd   xmm0, pdivector2</span><br><span class="line">//xmm0= pdivector1+ pdivector2</span><br></pre></td></tr></table></figure>



<p>加法运算…</p>
<h3 id="pextrb-x2F-w-x2F-d-x2F-q"><a href="#pextrb-x2F-w-x2F-d-x2F-q" class="headerlink" title="pextrb&#x2F;w&#x2F;d&#x2F;q"></a>pextrb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004011A3 pextrd  eax, xmm3, 0</span><br><span class="line">.text:00000000004011A9 pextrd  ebx, xmm3, 1</span><br><span class="line">.text:00000000004011AF pextrd  ecx, xmm3, 2</span><br><span class="line">.text:00000000004011B5 pextrd  edx, xmm3, 3</span><br><span class="line"></span><br><span class="line">.text:00000000004011BB pinsrd  xmm0, eax, 3</span><br><span class="line">.text:00000000004011C1 pinsrd  xmm0, ebx, 2</span><br><span class="line">.text:00000000004011C7 pinsrd  xmm0, ecx, 1</span><br><span class="line">.text:00000000004011CD pinsrd  xmm0, edx, 0</span><br></pre></td></tr></table></figure>



<p>pextrb</p>
<p>参数1&#x3D;byte 参数2[参数3]</p>
<p> pextrw</p>
<p>参数1&#x3D;word 参数2[参数3]</p>
<p> pextrd</p>
<p>参数1&#x3D;dword 参数2[参数3]</p>
<p> pextrq</p>
<p>参数1&#x3D;qword 参数2[参数3]</p>
<h3 id="pinsrb-x2F-w-x2F-d-x2F-q"><a href="#pinsrb-x2F-w-x2F-d-x2F-q" class="headerlink" title="pinsrb&#x2F;w&#x2F;d&#x2F;q"></a>pinsrb&#x2F;w&#x2F;d&#x2F;q</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004011A3 pextrd  eax, xmm3, 0</span><br><span class="line">.text:00000000004011A9 pextrd  ebx, xmm3, 1</span><br><span class="line">.text:00000000004011AF pextrd  ecx, xmm3, 2</span><br><span class="line">.text:00000000004011B5 pextrd  edx, xmm3, 3</span><br><span class="line">.text:00000000004011BB pinsrd  xmm0, eax, 3</span><br><span class="line">.text:00000000004011C1 pinsrd  xmm0, ebx, 2</span><br><span class="line">.text:00000000004011C7 pinsrd  xmm0, ecx, 1</span><br><span class="line">.text:00000000004011CD pinsrd  xmm0, edx, 0</span><br></pre></td></tr></table></figure>



<p>pinsrb</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>pinsrw</p>
<p>pinsrd</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>参数2是4字节</p>
<p>参数1是xmm寄存器</p>
<p>参数3是index</p>
<p>pinsrq</p>
<p>参数1[参数3]&#x3D;参数2</p>
<p>参数2是8字节</p>
<p>参数1是xmm寄存器</p>
<p>参数3是index</p>
<h3 id="pcmpistri"><a href="#pcmpistri" class="headerlink" title="pcmpistri"></a>pcmpistri</h3><p>打包比较隐式的字符串,返回索引</p>
<h3 id="pcmpistrm"><a href="#pcmpistrm" class="headerlink" title="pcmpistrm"></a>pcmpistrm</h3><p>打包比较隐式的字符串,返回索引,返回掩码</p>
<h3 id="pcmpestri"><a href="#pcmpestri" class="headerlink" title="pcmpestri"></a>pcmpestri</h3><p>打包比较显式的字符串,返回索引</p>
<h3 id="pcmpestrm"><a href="#pcmpestrm" class="headerlink" title="pcmpestrm"></a>pcmpestrm</h3><p>打包比较显</p>
<p>式的字符串,返回掩码</p>
<h3 id="pxor"><a href="#pxor" class="headerlink" title="pxor"></a>pxor</h3><p>16字节与16字节异或</p>
<h3 id="mulsd"><a href="#mulsd" class="headerlink" title="mulsd"></a>mulsd</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MULSD xmm1,xmm2/m64</span><br></pre></td></tr></table></figure>

<p>double低位之间的乘法</p>
<h1 id="FPU指令系统"><a href="#FPU指令系统" class="headerlink" title="FPU指令系统"></a>FPU指令系统</h1><p>里面的基础知识很多很杂,用到的地方也很少</p>
<p>遇到一个有用的指令就记录一下</p>
<p>FPU 不使用通用寄存器 (EAX、EBX 等等)。</p>
<p>反之，它有自己的一组寄存器，称为寄存器栈 (register stack)。</p>
<p>数值从内存加载到寄存器栈，然后执行计算，再将堆栈数值保存到内存。</p>
<p>他的没有esp,但是有top指针</p>
<h2 id="IEE-规范-存储小数"><a href="#IEE-规范-存储小数" class="headerlink" title="IEE 规范 存储小数"></a>IEE 规范 存储小数</h2><h3 id="化为二进制科学计算法"><a href="#化为二进制科学计算法" class="headerlink" title="化为二进制科学计算法"></a>化为二进制科学计算法</h3><p>用IEE规范转8.25</p>
<p>(1), 8转二进制0000 1000</p>
<p>(2).  0.25转二进制</p>
<p>​	0.25*2&#x3D;0.5   个位是0</p>
<p>​	0.5*2  &#x3D;1.0   个位是1</p>
<p>​	因为小数点第一位是0,所以结束</p>
<p>​	0.25&#x3D;0b01,不是0b10</p>
<p>​     这里0b10只有2位,有的可能是无限不循环,或者说是无限循环的,于是就有一个精确位的取舍</p>
<p>科学计数法</p>
<p> 8.25是1000.01,转科学计算法,1.00001*2的3次方</p>
<h3 id="分解二进制位"><a href="#分解二进制位" class="headerlink" title="分解二进制位"></a>分解二进制位</h3><p>(1)</p>
<p> 小数点后,数23位放到结果的二进制[9,31]位</p>
<p>00001-&gt;<code>00001000000000000000000 </code>没有就补0</p>
<p>(2)</p>
<p>之前的科学计算法,</p>
<p>小数点左移n位,n是正的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;1</p>
<p>小数点右移n位,n是负的, n&#x3D;n-1,取n的后7位填充结果二进制的[2,8] ,[1]&#x3D;0</p>
<p>或者直接127+n,结果后8位,填充[1,8]</p>
<p>左移n为正,右移,n位负</p>
<p>(3)</p>
<p> [0]位是符号位</p>
<blockquote>
<p>如果是8.25,[0]&#x3D;0</p>
<p>如果是-8.25,[0]&#x3D;1</p>
</blockquote>
<p>最后整合</p>
<p>01000001000001000000000000000000</p>
<p>转16进制,然后存储</p>
<p>0.25转</p>
<p>0转二进制-&gt;0b0</p>
<p>0.25转二进制-&gt;0.01</p>
<p>0.25-&gt;0b0.01-&gt;1.0*2的负二次方</p>
<p>符号位[0]&#x3D;0</p>
<p>[1]&#x3D;0 右移</p>
<p>-2-1&#x3D;-3&#x3D;1111 1101</p>
<p>取111 1101放入[2,8]</p>
<p>[1,8]&#x3D;0111 1101</p>
<p>数1.0*2的负二次方小数点后23位00000000000000000000000</p>
<p>整合</p>
<p>0    01111101   00000000000000000000000</p>
<p>最后再转16进制</p>
<h2 id="FPU-栈"><a href="#FPU-栈" class="headerlink" title="FPU 栈"></a>FPU 栈</h2><p>入栈是fld</p>
<p>出栈是fstp</p>
<p>他有栈有8个空间,st0~st7</p>
<p>这8个空间循环使用</p>
<p>栈顶指针始终指向st0</p>
<p>st只是一个标号</p>
<p>具体细节遇到后再完善</p>
<h2 id="舍入原则"><a href="#舍入原则" class="headerlink" title="舍入原则"></a>舍入原则</h2><h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p>对于0.5这种类型</p>
<p>如果整数部分是偶数,就保留整数,舍去小数部分</p>
<p>如果整数部分是奇数,就整数+1,舍去小数部分</p>
<p>对于0.1,0.2这种,直接舍去,然后整数不变</p>
<p>对于0.6,0.8这种,就直接舍去,整数+1</p>
<p>2.5&#x3D;2</p>
<p>3.5&#x3D;4</p>
<p>2.6&#x3D;3</p>
<p>2.1&#x3D;2</p>
<h3 id="向下舍入"><a href="#向下舍入" class="headerlink" title="向下舍入"></a>向下舍入</h3><p>就是小于它的最大整数</p>
<p>102.3&#x3D;102</p>
<p>-103.2&#x3D;-104</p>
<h3 id="向上舍入"><a href="#向上舍入" class="headerlink" title="向上舍入"></a>向上舍入</h3><p>就是大于它的最小整数</p>
<p>100.101&#x3D;101</p>
<p>-100.101&#x3D;-100</p>
<h3 id="向0舍入"><a href="#向0舍入" class="headerlink" title="向0舍入"></a>向0舍入</h3><p>数据向0靠齐,舍去小数部分</p>
<p>100,101&#x3D;100</p>
<p>-103.89&#x3D;-103</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>浮点指令名用字母 F 开头，以区别于 CPU 指令。</p>
<p>指令助记符的第二个字母（通常为 B 或 I）指明如何解释内存操作数：B 表示 BCD 操作数，I 表示二进制整数操作数。</p>
<p>末尾带P,表示要出栈</p>
<h3 id="实数传输指令"><a href="#实数传输指令" class="headerlink" title="实数传输指令"></a>实数传输指令</h3><h4 id="FLD-浮点数入栈"><a href="#FLD-浮点数入栈" class="headerlink" title="FLD  浮点数入栈"></a>FLD  浮点数入栈</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld x</span><br></pre></td></tr></table></figure>

<p>可以把x入FPU栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array REAL8 10 DUP (?)</span><br><span class="line">.code</span><br><span class="line">fld array                         ;直接寻址</span><br><span class="line">fld [array+16 ]                    ;直接偏移</span><br><span class="line">fld REAL8 PTR[esi]                 ;间接寻址</span><br><span class="line">fld array[esi]                      ;变址寻址</span><br><span class="line">fld array[esi*8]                    ;带比例因子的变址</span><br><span class="line">fld array[esi*TYPE array]             ;带比例因子的变址</span><br><span class="line">fld REAL8 PTR[ebx+esi]             ;基址-变址</span><br><span class="line">fld array[ebx+esi]                  ;基址-变址-偏移量</span><br><span class="line">fld aray[ebx+esi*TYPE array]         ;带比例因子的基址-变址-偏移量</span><br></pre></td></tr></table></figure>



<p>关于栈中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">dblOne REAL8 234.56</span><br><span class="line">dblTwo REAL8 10.1</span><br><span class="line">.code</span><br><span class="line">fld dblOne      ; ST(0) = dblOne</span><br><span class="line">fld dblTwo      ; ST(0) = dblTwo, ST(1) = dblOne</span><br></pre></td></tr></table></figure>

<p>st(0)&#x3D;10.1</p>
<p>st(1)&#x3D;234.56</p>
<h4 id="FLD-xxx加载常数"><a href="#FLD-xxx加载常数" class="headerlink" title="FLD-xxx加载常数"></a>FLD-xxx加载常数</h4><p>下面的指令将特定常数加载到堆栈。这些指令没有操作数：</p>
<ul>
<li>FLD1 指令将 1.0 压入寄存器堆栈。</li>
<li>FLDL2T 指令将 log210 压入寄存器堆栈。</li>
<li>FLDL2E 指令将 log2e 压入寄存器堆栈。</li>
<li>FLDPI 指令将 π  压入寄存器堆栈。</li>
<li>FLDLG2 指令将 log102 压入寄存器堆栈。</li>
<li>FLDLN2 指令将 loge2压入寄存器堆栈。</li>
<li>FLDZ（加载零）指令将 0.0 压入 FPU 堆栈。</li>
</ul>
<h4 id="FILD-将整数入栈"><a href="#FILD-将整数入栈" class="headerlink" title="FILD 将整数入栈"></a>FILD 将整数入栈</h4><p>FILD（加载整数）指令将 16 位、32 位或 64 位&#x3D;&#x3D;有符号整数源操作数转换为双精度浮点数&#x3D;&#x3D;，并加载到 ST(0)。源操作数符号保留。</p>
<p>FILD 支持的内存操作数类型与 MOV 指令一致（间接、变址、基址-变址等）</p>
<h4 id="FBLD-bcd码入栈"><a href="#FBLD-bcd码入栈" class="headerlink" title="FBLD bcd码入栈"></a>FBLD bcd码入栈</h4><h4 id="FST-栈顶数据导出"><a href="#FST-栈顶数据导出" class="headerlink" title="FST  栈顶数据导出"></a>FST  栈顶数据导出</h4><p>FST（保存浮点数值）指令将浮点操作数从 FPU 栈顶复制到内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstp x</span><br></pre></td></tr></table></figure>

<p>把栈顶的数据给了x</p>
<p>不涉及TOP的变化</p>
<p>为什么说不涉及top变化</p>
<p>FST 不是弹出堆栈。下面的指令将 ST(0) 保存到内存。</p>
<p>假设</p>
<p>ST(0) 等于 10.1，</p>
<p>ST(1) 等于 234.56：</p>
<p>我们的栈顶指针一直是st(0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fst dblThree  ; fst取出了栈顶的数据10.1</span><br><span class="line">fst dblFour   ; fst还是取出了栈顶的数据10.1</span><br></pre></td></tr></table></figure>

<p>直观地说，代码段期望 dblFour 等于 234.56。</p>
<p>但是第一条 FST 指令把 10.1 留在 ST(0) 中。</p>
<p>如果代码段的意图是把 ST(1) 复制到 dblFour，那么就要用 FSTP 指令。</p>
<h4 id="FSTP-栈顶数据弹出栈"><a href="#FSTP-栈顶数据弹出栈" class="headerlink" title="FSTP 栈顶数据弹出栈"></a>FSTP 栈顶数据弹出栈</h4><p>FSTP（保存浮点值到Dest并将st0出栈）</p>
<p>假设执行下述指令前 </p>
<p>ST(0) 等于 10.1，</p>
<p>ST(1) 等于 234.56：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstp dblThree ; 10.1</span><br><span class="line">fstp dblFour ; 234.56</span><br></pre></td></tr></table></figure>

<p>指令执行后，这两个数值会从堆栈中逻辑移除。从物理上看，每次执行 FSTP，TOP 指针都会减 1，修改 ST(0) 的位置。</p>
<h4 id="FIST-栈顶数据四舍五入后导出"><a href="#FIST-栈顶数据四舍五入后导出" class="headerlink" title="FIST  栈顶数据四舍五入后导出"></a>FIST  栈顶数据四舍五入后导出</h4><p>首先栈顶得有数据</p>
<p>然后把栈顶的数据四舍五入后导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fitp x</span><br></pre></td></tr></table></figure>

<p>出栈的数据给了x</p>
<p>不涉及top的变化</p>
<h4 id="FISTP-栈顶数据四舍五入后出栈"><a href="#FISTP-栈顶数据四舍五入后出栈" class="headerlink" title="FISTP 栈顶数据四舍五入后出栈"></a>FISTP 栈顶数据四舍五入后出栈</h4><p>原理和上面一样,不过会设计top的变化</p>
<h4 id="FBSTP-栈顶数据四舍五入后以bcd码出栈"><a href="#FBSTP-栈顶数据四舍五入后以bcd码出栈" class="headerlink" title="FBSTP 栈顶数据四舍五入后以bcd码出栈"></a>FBSTP 栈顶数据四舍五入后以bcd码出栈</h4><p>它不仅会对栈顶数据四舍五入还会对原地址的数据四舍五入</p>
<p>真的吗?</p>
<h4 id="fxch-实数交换"><a href="#fxch-实数交换" class="headerlink" title="fxch 实数交换"></a>fxch 实数交换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fxch </span><br><span class="line">fxch st(i)</span><br></pre></td></tr></table></figure>

<p>fxch实现了str[0]和st[1]的交换</p>
<p>fxch st[i]实现了st[i]与st[0]的交换</p>
<h3 id="实数比较"><a href="#实数比较" class="headerlink" title="实数比较"></a>实数比较</h3><p>浮点数不能使用 CMP 指令进行比较，因为后者是通过整数减法来执行比较的。取而代之，必须使用 FCOM 指令。</p>
<p>执行 FCOM 指令后，还需要采取特殊步骤，然后再使用逻辑 IF 语句中的条件跳转指令（JA、JB、JE 等）。</p>
<p>由于所有的浮点数都为隐含的有符号数，因此，FCOM 执行的是有符号比较。</p>
<h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><p>他们都是和st0比较</p>
<h5 id="fcom-x2F-fcomp-x2F-fcompp"><a href="#fcom-x2F-fcomp-x2F-fcompp" class="headerlink" title="fcom&#x2F;fcomp&#x2F;fcompp"></a>fcom&#x2F;fcomp&#x2F;fcompp</h5><p>FCOM（比较浮点数）指令将其源操作数与 ST(0) 进行比较,我们要把比较的数据入栈。</p>
<p>源操作数可以为内存操作数或 FPU 寄存器。其语法如下表所示：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FCOM</td>
<td>比较 ST(0) 与 ST(1)</td>
</tr>
<tr>
<td>FCOM m32fp</td>
<td>比较 ST(0) 与 m32fp</td>
</tr>
<tr>
<td>FCOM m64fp</td>
<td>比较 ST(0) 与 m64fp</td>
</tr>
<tr>
<td>FCOM ST(i)</td>
<td>比较 ST(0) 与 ST(i)</td>
</tr>
</tbody></table>
<p>FCOMP 指令的操作数类型和执行的操作与 FCOM 指令相同，但是它要将 ST(0) 弹岀堆栈。</p>
<p>FCOMPP 指令与 FCOMP 相同，但是它有两次出栈操作。</p>
<h5 id="fucom-x2F-fucomp-x2F-fucompp"><a href="#fucom-x2F-fucomp-x2F-fucompp" class="headerlink" title="fucom&#x2F;fucomp&#x2F;fucompp"></a>fucom&#x2F;fucomp&#x2F;fucompp</h5><p>他和前面讲的fcom是一样的货色</p>
<h5 id="fcomi-x2F-FCOMIP-x2F-FUCOMI-x2F-FUCOMIP"><a href="#fcomi-x2F-FCOMIP-x2F-FUCOMI-x2F-FUCOMIP" class="headerlink" title="fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP"></a>fcomi&#x2F;FCOMIP&#x2F;FUCOMI&#x2F;FUCOMIP</h5><p>它是<code>.686</code>的指令</p>
<p>在下面我们会讲一下条件码,于是会说到</p>
<p>把条件码怎么和eflag联系在一起</p>
<p>要用到fnstsw和sahf指令,这里的开销比较大</p>
<p>于是就进入了fcomi</p>
<p>跳过”把条件码怎么和eflag联系在一起”,直接把状态位给了eflag</p>
<p>FCOMI 指令代替了之前代码段中的三条指令，但是增加了一条 FLD 指令。也就是把要比较的数据都压入栈中</p>
<p>FCOMI 指令不使用内存操作数。</p>
<p>关于后面的3条指令也不多说</p>
<h5 id="FICOM-x2F-FICOMP"><a href="#FICOM-x2F-FICOMP" class="headerlink" title="FICOM&#x2F;FICOMP"></a>FICOM&#x2F;FICOMP</h5><p>就是把st0与操作数比较,初始化c3c2c0</p>
<p>ficomph会出栈</p>
<h5 id="FTST"><a href="#FTST" class="headerlink" title="FTST"></a>FTST</h5><p>将实数与0作比较,初始化c3c2c0</p>
<h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>FPU 条件码标识有 3 个，C3、C2 和 C0，用以说明浮点数比较的结果，</p>
<p>如下表所示。由于 C3、C2 和 C0 的功能分别与零标志位 (ZF)、奇偶标志位 (PF) 和进位标志位 (CF) 相同，</p>
<p>因此表中列标题给出了与之等价的 CPU 状态标识</p>
<table>
<thead>
<tr>
<th>条件 st0-操作数</th>
<th>C3&#x3D;&#x3D;ZF</th>
<th>C2&#x3D;&#x3D;PF</th>
<th>C0&#x3D;&#x3D;CF</th>
<th>使用的条件跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>ST(0) &gt; SPC</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>JA. JNBE</td>
</tr>
<tr>
<td>ST(0) &lt; SPC</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>JB. JNAE</td>
</tr>
<tr>
<td>ST(0) &#x3D; SPC</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>JE. JZ</td>
</tr>
<tr>
<td>无序</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>（无）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>JAE</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>JBE</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>JBE</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>JNE</td>
</tr>
</tbody></table>
<p>如果出现&#x3D;&#x3D;无效算术运算操作数&#x3D;&#x3D;异常（无效操作数,无穷大,无穷小,格式不正常,非实数），且该异常被屏蔽，则 C3、C2 和 C0 按照标记为“无序”的行来设置。</p>
<p>在比较了两个数值并设置了 FPU 条件码之后，遇到的主要挑战就是怎样根据条件分支到相应标号。这包括了两个步骤：</p>
<ul>
<li>用 FNSTSW 指令把 FPU 状态字送入 AX。</li>
<li>用 SAHF 指令把 AH 复制到 EFLAGS 寄存器。</li>
</ul>
<p>条件码送入 EFLAGS 之后，就可以根据 ZF、PF 和 CF 进行条件跳转。</p>
<p>问题是:为什么要送入eflag?</p>
<p>因为你的用的是FPU系统的条件码,和EFLAG无法直接联系在一起,毕竟你的跳转指令是和eflag联系的</p>
<p>所以我们才用fnstsw和sahf指令吧&#x3D;把条件码送入ax,再把ah送入eflag</p>
<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>所有算术运算指令支持的内存操作数类型与 FLD （加载）和 FST（保存）一致，’</p>
<p>因此，操作数可以是间接操作数、变址操作数和基址-变址操作数等等</p>
<table>
<thead>
<tr>
<th>FCHS</th>
<th>修改符号</th>
</tr>
</thead>
<tbody><tr>
<td>FADD</td>
<td>源操作数与目的操作数相加</td>
</tr>
<tr>
<td>FSUB</td>
<td>从目的操作数中减去源操作数</td>
</tr>
<tr>
<td>FSUBR</td>
<td>从源操作数中减去目的操作数</td>
</tr>
<tr>
<td>FMUL</td>
<td>源操作数与目的操作数相乘</td>
</tr>
<tr>
<td>FDIV</td>
<td>目的操作数除以源操作数</td>
</tr>
<tr>
<td>FDIVR</td>
<td>源操作数除以目的操作数</td>
</tr>
</tbody></table>
<h4 id="FADD-x2F-FADDP-x2F-FIADD"><a href="#FADD-x2F-FADDP-x2F-FIADD" class="headerlink" title="FADD&#x2F;FADDP&#x2F;FIADD"></a>FADD&#x2F;FADDP&#x2F;FIADD</h4><h5 id="fadd"><a href="#fadd" class="headerlink" title="fadd"></a>fadd</h5><p>FADD（加法）指令格式如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FADD</span><br><span class="line">FADD m32fp				;st0+=m32fp</span><br><span class="line">FADD m64fp				;st0+=m64fp</span><br><span class="line">FADD ST(0), ST(i)		;st0+=sti</span><br><span class="line">FADD ST(i) , ST(0)		;sti+=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣.如果 FADD 没有操作数，则 ST(0)与 ST(1)相加，结果暂存在 ST(1)。</p>
<p>然后 ST(0) 弹出堆栈，把加法结果保留在栈顶。假设堆栈已经包含了两个数值，</p>
<p>执行前</p>
<p>st0&#x3D;10.5</p>
<p>st1&#x3D;2.4</p>
<p>执行后</p>
<p>st0&#x3D;12.9</p>
<p>st1&#x3D;2.4</p>
<p>2️⃣如果参数是寄存器操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FADD ST(0), ST(1)</span><br></pre></td></tr></table></figure>

<p>同上</p>
<p>3️⃣如果使用的是内存操作数，FADD 将操作数与 ST(0) 相加。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fadd mySingle    	  ; ST(0) += mySingle</span><br><span class="line">fadd REAL8 PTR [esi]  ; ST(0) += [esi]</span><br></pre></td></tr></table></figure>



<h5 id="faddp"><a href="#faddp" class="headerlink" title="faddp"></a>faddp</h5><p>FADDP（相加并出栈）指令先执行加法操作，再将 ST(0) 弹出堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FADDP ST(i),ST(0)</span><br></pre></td></tr></table></figure>

<p>原理同上</p>
<h5 id="FIADD（整数加法）"><a href="#FIADD（整数加法）" class="headerlink" title="FIADD（整数加法）"></a>FIADD（整数加法）</h5><p>FIADD（整数加法）指令先将源操作数转换为扩展双精度浮点数，再与 ST(0) 相加。指令语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">myInteger DWORD 1</span><br><span class="line">.code</span><br><span class="line">fiadd myInteger          ; ST(0) += myInteger</span><br></pre></td></tr></table></figure>



<h4 id="FSUB-x2F-FSUBP-x2F-FISUB-x2F-FSUBR"><a href="#FSUB-x2F-FSUBP-x2F-FISUB-x2F-FSUBR" class="headerlink" title="FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBR"></a>FSUB &#x2F;FSUBP&#x2F;FISUB&#x2F;FSUBR</h4><h5 id="fsub"><a href="#fsub" class="headerlink" title="fsub"></a>fsub</h5><p>FSUB 指令从Dest中减去Source，并把result保存在Dest中。</p>
<p>Dest总是一个 FPU 寄存器，Source可以是 FPU 寄存器或者内存操作数。</p>
<p>该指令操作数类型与 FADD 指令一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FSUB				;st0=st1-st0	;这里的顺序别错的</span><br><span class="line">FSUB m32fp			;st0=st0-m32fp</span><br><span class="line">FSUB m64fp			;st0=sto-m64fp</span><br><span class="line">FSUB ST(0), ST(i)	;st0=st0-sti</span><br><span class="line">FSUB ST(i), ST(0)	;sti=sti-st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FSUB 实现 ST(1) - ST(0)，结果暂存于 ST(1)。然后 ST(0) 弹出堆栈，将减法结果留在栈顶。</p>
<p>2️⃣若 FSUB 使用内存操作数，则从 ST(0) 中减去内存操作数，且不再弹出堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fsub mySingle       ; ST(0) -= mySingle</span><br><span class="line">fsub array[edi*8]   ; ST(0) -= array[edi*8]</span><br></pre></td></tr></table></figure>



<h5 id="fsubp"><a href="#fsubp" class="headerlink" title="fsubp"></a>fsubp</h5><p>FSUBP（相减并出栈）指令先执行减法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FSUBP ST(i),ST(0)</span><br></pre></td></tr></table></figure>



<h5 id="FISUB（整数减法）"><a href="#FISUB（整数减法）" class="headerlink" title="FISUB（整数减法）"></a>FISUB（整数减法）</h5><p>FISUB（整数减法）指令先把源操作数转换为扩展双精度浮点数，再从 ST(0) 中减去该操作数：</p>
<h5 id="FSUBR"><a href="#FSUBR" class="headerlink" title="FSUBR"></a>FSUBR</h5><p>方向相减</p>
<p>之前的减法顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FSUB				;st0=st1-st0	;这里的顺序别错的</span><br><span class="line">FSUB m32fp			;st0=st0-m32fp</span><br><span class="line">FSUB m64fp			;st0=sto-m64fp</span><br><span class="line">FSUB ST(0), ST(i)	;st0=st0-sti</span><br><span class="line">FSUB ST(i), ST(0)	;sti=sti-st0</span><br></pre></td></tr></table></figure>

<p>​	用一下fubr,减法的顺序就反了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FSUBR				;st0=st1-st0	</span><br><span class="line">FSUBR m32fp			;st0=m32fp-st0</span><br><span class="line">FSUBR m64fp			;st0=m64fp-st0</span><br><span class="line">FSUBR ST(0), ST(i)	;st0=sti-st0</span><br><span class="line">FSUBR ST(i), ST(0)	;sti=st0-sti</span><br></pre></td></tr></table></figure>



<h4 id="FMUL-x2F-FMULP-x2F-FIMUl"><a href="#FMUL-x2F-FMULP-x2F-FIMUl" class="headerlink" title="FMUL &#x2F;FMULP&#x2F;FIMUl"></a>FMUL &#x2F;FMULP&#x2F;FIMUl</h4><h5 id="FMUL"><a href="#FMUL" class="headerlink" title="FMUL"></a>FMUL</h5><p>FMUL 指令将Source与Dest相乘，乘积保存在Dest中。</p>
<p>Dest总是一个 FPU 寄存器，Source可以为寄存器或者内存操作数。</p>
<p>其语法与 FADD 和 FSUB 相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMUL				;st0*=st1</span><br><span class="line">FMUL m32fp			;st0*=m32fp</span><br><span class="line">FMUL m64fp			;st0*=m64fp</span><br><span class="line">FMUL ST(0), ST(i)	;st0*=sti</span><br><span class="line">FMUL ST(i), ST(0)	;sti*=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FMUL 将 ST(O) 与 ST(1) 相乘，乘积暂存于 ST(1)。然后 ST(0) 弹出堆栈，将乘积留在栈顶</p>
<p>2️⃣使用内存操作数的 FMUL 则将内存操作数与 ST(0) 相乘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmul mySingle    ; ST(0) *= mySingle</span><br></pre></td></tr></table></figure>

<h5 id="fmulp"><a href="#fmulp" class="headerlink" title="fmulp"></a>fmulp</h5><p>FMULP（相乘并出栈）指令先执行乘法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMULP ST(i),ST(O)</span><br></pre></td></tr></table></figure>

<h5 id="FIMUL-整数相乘"><a href="#FIMUL-整数相乘" class="headerlink" title="FIMUL 整数相乘"></a>FIMUL 整数相乘</h5><h4 id="FDIV-x2F-FDIVP-x2F-FIDIV-x2F-FDIVR"><a href="#FDIV-x2F-FDIVP-x2F-FIDIV-x2F-FDIVR" class="headerlink" title="FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVR"></a>FDIV &#x2F;FDIVP&#x2F;FIDIV&#x2F;FDIVR</h4><h5 id="FDIV"><a href="#FDIV" class="headerlink" title="FDIV"></a>FDIV</h5><p>FDIV 指令执行Dest除以Source，被除数保存在Dest中。</p>
<p>Dest总是一个寄存器，Sourc可以为寄存器或者内存操作数。</p>
<p>其语法与 FADD 和 FSUB 相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FDIV					;st0=st1/st0</span><br><span class="line">FDIV m32fp				;st0/=m32fp</span><br><span class="line">FDIV m64fp				;st0/=m64fp</span><br><span class="line">FDIV ST(O), ST(i)		;st0/=sti</span><br><span class="line">FDIV ST(i), ST(O)		;sti/=st0</span><br></pre></td></tr></table></figure>



<p>1️⃣无参数 FDIV 执行 ST(1) 除以 ST(0)。然后 ST(0) 弹出堆栈，将被除数留在栈顶</p>
<p>2️⃣使用内存操作数的 FDIV 将 ST(0) 除以内存操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">dblOne REAL8 1234.56</span><br><span class="line">dblTwo REAL8 10.0</span><br><span class="line">dblQuot REAL8 ?</span><br><span class="line">.code</span><br><span class="line">fid dblOne      ; 加载到 ST (0)</span><br><span class="line">fdiv dblTwo     ; ST(0) 除以 dblTwo</span><br><span class="line">fstp dblQuot    ; 将 ST(0) 保存到 dblQuot</span><br></pre></td></tr></table></figure>

<p>若源操作数为 0，则产生除零异常。若源操作数等于正、负无穷，零或 NaN，则使用一些特殊情况。</p>
<h5 id="fdivp"><a href="#fdivp" class="headerlink" title="fdivp"></a>fdivp</h5><p>多了一个出栈的操作</p>
<h5 id="fdivp-1"><a href="#fdivp-1" class="headerlink" title="fdivp"></a>fdivp</h5><p>FIDIV 指令先将整数源操作数转换为扩展双精度浮点数，再执行与 ST(0) 的除法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIDIV ml6int</span><br><span class="line">FIDIV m32int</span><br></pre></td></tr></table></figure>



<h5 id="FDIVR"><a href="#FDIVR" class="headerlink" title="FDIVR"></a>FDIVR</h5><p>把原来的除数当做被除数,被除数当做除数</p>
<p>但是结果还是放在Dest中</p>
<h3 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h3><h4 id="FCHS-x2F-FABS-求绝对值-st0-求相反数"><a href="#FCHS-x2F-FABS-求绝对值-st0-求相反数" class="headerlink" title="FCHS&#x2F;FABS  求绝对值|st0|,求相反数"></a>FCHS&#x2F;FABS  求绝对值|st0|,求相反数</h4><p>FCHS( 修改符号 ) 指令将 ST(0) 中浮点数值的符号取反</p>
<p>FABS ( 绝对值 ) 指令清除 ST(0) 中数值的符号，以得到它的绝对值。</p>
<p>这两条指令都没有操作数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FCHS</span><br><span class="line">FABS</span><br></pre></td></tr></table></figure>



<h4 id="fsqrt-求-sqrt-st0"><a href="#fsqrt-求-sqrt-st0" class="headerlink" title="fsqrt 求 $\sqrt{st0}$"></a>fsqrt 求 $\sqrt{st0}$</h4><p>用于求st0的平方根</p>
<h4 id="fxtract-求阶码与尾数"><a href="#fxtract-求阶码与尾数" class="headerlink" title="fxtract  求阶码与尾数"></a>fxtract  求阶码与尾数</h4><p>阶码不多说</p>
<p>尾数就是小数+整数吧</p>
<p>(10进制)12&#x3D;1.1x2^3(二进制)</p>
<p>于是</p>
<p>阶码3</p>
<p>尾数1.1(二进制)&#x3D;1.5(10进制)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flad xx</span><br><span class="line">fxtract</span><br><span class="line">fstp weishu</span><br><span class="line">fstp jeima</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;使用fxtrcat,他会把阶码压入栈st1,尾数压入栈st0&#x3D;&#x3D;</p>
<p>然后获取的话就是尾数出栈,阶码出栈</p>
<h4 id="fprem-x2F-fprem1-取余数"><a href="#fprem-x2F-fprem1-取余数" class="headerlink" title="fprem&#x2F;fprem1 取余数"></a>fprem&#x2F;fprem1 取余数</h4><p>取余数的原理是什么?</p>
<p>对于fprem</p>
<p>就是x&#x2F;y&#x3D;z</p>
<p>余数&#x3D;x-y*z</p>
<p>就是这个道理</p>
<p>对于fprem1</p>
<p>他的x&#x2F;y&#x3D;z会有一个四舍五入,这样的求余数当然会有误差</p>
<h4 id="frndint-四舍五入"><a href="#frndint-四舍五入" class="headerlink" title="frndint 四舍五入"></a>frndint 四舍五入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld x</span><br><span class="line">frndint</span><br><span class="line">fstp y</span><br></pre></td></tr></table></figure>



<p>x&#x3D;2.5</p>
<p>那么y&#x3D;2</p>
<h4 id="fscale-求st0x2-st1"><a href="#fscale-求st0x2-st1" class="headerlink" title="fscale 求st0x2^st1^"></a>fscale 求st0x2^st1^</h4><p>fscale是求st0x2^st1^</p>
<p>st0乘以2的st1次方,结果返回st0</p>
<p>比如计数x*y^2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld y			;入栈</span><br><span class="line">fld x			;入栈</span><br><span class="line">fscale</span><br><span class="line">fstp result		;出栈</span><br><span class="line">fstp buff		;出栈	</span><br></pre></td></tr></table></figure>



<h4 id="f2xm1-求2-st0-1"><a href="#f2xm1-求2-st0-1" class="headerlink" title="f2xm1 求2^st0^  -1"></a>f2xm1 求2^st0^  -1</h4><p>f2xm1 是求2^st0^  -1</p>
<p>计算2^x^-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld x</span><br><span class="line">f2xm1</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h4 id="fyl2x-求-st1-times-log-2-st0"><a href="#fyl2x-求-st1-times-log-2-st0" class="headerlink" title="fyl2x 求  st1$\times$$log_2$st0"></a>fyl2x 求  st1$\times$$log_2$st0</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld x</span><br><span class="line">fld y</span><br><span class="line">fyl2x</span><br><span class="line">fstp result </span><br></pre></td></tr></table></figure>



<p>结果存st1,st0出栈</p>
<h4 id="fyl2xp1-求-st1-times-log-2-st0-1"><a href="#fyl2xp1-求-st1-times-log-2-st0-1" class="headerlink" title="fyl2xp1 求 st1$\times$$log_2$(st0+1)"></a>fyl2xp1 求 st1$\times$$log_2$(st0+1)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld x</span><br><span class="line">fld y</span><br><span class="line">fyl2xp1</span><br><span class="line">fstp result </span><br></pre></td></tr></table></figure>

<p>结果存st1,st0出栈</p>
<h4 id="三角函数-用弧度代入"><a href="#三角函数-用弧度代入" class="headerlink" title="三角函数 用弧度代入"></a>三角函数 用弧度代入</h4><h6 id="fsin-求-sin-st0"><a href="#fsin-求-sin-st0" class="headerlink" title="fsin 求$sin$(st0)"></a>fsin 求$sin$(st0)</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld jiaodu</span><br><span class="line">fmul PI</span><br><span class="line">fidiv Num_180</span><br><span class="line">fsin</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>

<p>你也可以直接算出弧度,再直接入栈</p>
<h6 id="fcos-求-cos-st0"><a href="#fcos-求-cos-st0" class="headerlink" title="fcos 求$cos$(st0)"></a>fcos 求$cos$(st0)</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st0弧度已经转化</span><br><span class="line">fld hudu&#x27;</span><br><span class="line">fcos</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h6 id="fsincos-求sin-st0-和-cos-st0"><a href="#fsincos-求sin-st0-和-cos-st0" class="headerlink" title="fsincos 求sin$(st0)和$cos(st0)"></a>fsincos 求sin$(st0)和$cos(st0)</h6><p>先计算sin入栈</p>
<p>再计算cos,入栈</p>
<p>于是</p>
<p>st1是sin</p>
<p>st0是cos</p>
<h6 id="fptan-求-tan-st0"><a href="#fptan-求-tan-st0" class="headerlink" title="fptan 求 $tan$(st0)"></a>fptan 求 $tan$(st0)</h6><p>st0还是弧度</p>
<p>不知道为什么.</p>
<p>st0会自动压入1</p>
<p>st1才是计算的结果</p>
<p>于是出栈的时候</p>
<p>先把st0弹出</p>
<p>再把结果弹出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld hudu</span><br><span class="line">fptan</span><br><span class="line">fstp buff</span><br><span class="line">fstp result</span><br></pre></td></tr></table></figure>



<h6 id="fpatan-坐标轴下的有符号角度"><a href="#fpatan-坐标轴下的有符号角度" class="headerlink" title="fpatan 坐标轴下的有符号角度"></a>fpatan 坐标轴下的有符号角度</h6><p>好比</p>
<p>(1,1)&#x3D;45^0^</p>
<p>(-1,0)&#x3D;180^0^</p>
<p>st0是x坐标</p>
<p>st1是y坐标</p>
<p>返回的是一个弧度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fld y</span><br><span class="line">fld x</span><br><span class="line">fpatan</span><br><span class="line">fimul 180</span><br><span class="line">fstp  result</span><br></pre></td></tr></table></figure>

<p>余数结果就是度数</p>
<h3 id="FPU-控制指令"><a href="#FPU-控制指令" class="headerlink" title="FPU 控制指令"></a>FPU 控制指令</h3><h4 id="finit-x2F-fninit-初始化FPU"><a href="#finit-x2F-fninit-初始化FPU" class="headerlink" title="finit&#x2F;fninit 初始化FPU"></a>finit&#x2F;fninit 初始化FPU</h4><p>控制字是什么?就那几个判断异常的东西….</p>
<p>状态字是什么?就是C3C2C0</p>
<p>标记字是什么&gt;?</p>
<p>上面可能说错的……</p>
<p>反正他们会初始化一下FPU里的东西</p>
<p>然后</p>
<p>finit初始化前会检测没有处理的异常</p>
<p>fuinit初始化前并不会取检测</p>
<h4 id="fstsw-x2F-fntstw-导出状态字"><a href="#fstsw-x2F-fntstw-导出状态字" class="headerlink" title="fstsw&#x2F;fntstw 导出状态字"></a>fstsw&#x2F;fntstw 导出状态字</h4><p>针对于状态字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftstw ax		;检测并且处理异常,再状态字传递给ax,</span><br><span class="line">ftstw m16		;检测并且处理异常,再状态字传递给内存m16,</span><br><span class="line">fnstsw ax		;不检测并且处理异常,再状态字传递给ax,</span><br><span class="line">fnstsw m16		;不检测并且处理异常,再状态字传递给内存m16,</span><br></pre></td></tr></table></figure>



<h4 id="fstcw-x2F-fnstcw-导出控制字"><a href="#fstcw-x2F-fnstcw-导出控制字" class="headerlink" title="fstcw&#x2F;fnstcw 导出控制字"></a>fstcw&#x2F;fnstcw 导出控制字</h4><p>针对于控制字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstcw m16	;检测并且处理异常,再控制字传递给m16,</span><br><span class="line">fnstcw m16	;不检测并且处理异常,再控制字传递给m16,</span><br></pre></td></tr></table></figure>





<h4 id="fldcw-导入控制字"><a href="#fldcw-导入控制字" class="headerlink" title="fldcw  导入控制字"></a>fldcw  导入控制字</h4><p>把16位变量的值加载到控制字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fldcw m16</span><br></pre></td></tr></table></figure>

<h4 id="fldenv-导入环境"><a href="#fldenv-导入环境" class="headerlink" title="fldenv 导入环境"></a>fldenv 导入环境</h4><p>将src的数据加载到FPU</p>
<h4 id="fstenv-x2F-fnstenv-导出小环境"><a href="#fstenv-x2F-fnstenv-导出小环境" class="headerlink" title="fstenv&#x2F;fnstenv 导出小环境"></a>fstenv&#x2F;fnstenv 导出小环境</h4><p>保存FPU当前操作环境到Dest内存变量指定的14或者28字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstenv dest 	;检测并且处理异常后保存到dext,再屏蔽异常</span><br><span class="line">fnstenv Dest	:不检测并且处理异常,直接保存到dext,再屏蔽异常</span><br></pre></td></tr></table></figure>

<h4 id="fsave-x2F-fnsave-导出大环境"><a href="#fsave-x2F-fnsave-导出大环境" class="headerlink" title="fsave&#x2F;fnsave 导出大环境"></a>fsave&#x2F;fnsave 导出大环境</h4><p>把fpu当前状态导出到94或者108字节的内存,然后自动初始化FPU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fsave dest		;检测/处理异常,然后导出到dext,然后初始化FPU</span><br><span class="line">fnsave	dest	;不检测/处理异常,然后导出到dest,然后出释怀fpu</span><br></pre></td></tr></table></figure>





<h4 id="fclex-x2F-fncles-清除异常"><a href="#fclex-x2F-fncles-清除异常" class="headerlink" title="fclex&#x2F;fncles  清除异常"></a>fclex&#x2F;fncles  清除异常</h4><p>清除浮点异常标志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fclex		;检测并且处理异常,然后清除异常标志位</span><br><span class="line">fnclex		;不检测并且处理异常,直接清除异常标志位</span><br></pre></td></tr></table></figure>

<p>除了像fstenv那样,他还会保存浮点数数据寄存器,按照st0-st7的顺序紧随其后</p>
<h4 id="frstor导入环境"><a href="#frstor导入环境" class="headerlink" title="frstor导入环境"></a>frstor导入环境</h4><p>把src的94或者108个字节导入到fpu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frstor src</span><br></pre></td></tr></table></figure>



<h4 id="fincstp-x2F-fdecstp-top的自增自减"><a href="#fincstp-x2F-fdecstp-top的自增自减" class="headerlink" title="fincstp &#x2F;fdecstp top的自增自减"></a>fincstp &#x2F;fdecstp top的自增自减</h4><p>Inc top 会让st0的数据转移到st7,(st0去部st7的位)</p>
<p>dec top会让st7的数据转移到st0,(st7去补st0的位)</p>
<p>可以对应一下栈图,因为他只有8个空间,要循环使用,所以的话才会有这种奇奇怪怪的转移</p>
<p>inc之前&#x2F;dec之前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br></pre></td></tr></table></figure>

<p>inc之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>dec之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.#IND</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br><span class="line">-1.#IND</span><br></pre></td></tr></table></figure>



<h4 id="ffree-sti"><a href="#ffree-sti" class="headerlink" title="ffree sti"></a>ffree sti</h4><p>free后sti就是<code>-1/#IND</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffree st(0)</span><br></pre></td></tr></table></figure>



<h4 id="fnop"><a href="#fnop" class="headerlink" title="fnop"></a>fnop</h4><p>同CPU的nop</p>
<h4 id="fwait-x2F-wait"><a href="#fwait-x2F-wait" class="headerlink" title="fwait&#x2F;wait"></a>fwait&#x2F;wait</h4><p>他们是同一个东西</p>
<p>功能是检查并且处理没有屏蔽的浮点异常</p>
<p>在浮点指令后加一条wait指令确保任何未被处理的异常在下一条IP执行前被处理</p>
<h2 id="异常同步fwait-x2F-wait"><a href="#异常同步fwait-x2F-wait" class="headerlink" title="异常同步fwait&#x2F;wait"></a>异常同步fwait&#x2F;wait</h2><p>整数 (CPU) 和 FPU 是相互独立的单元，因此，在执行整数和系统指令的同时可以执行浮点指令。这个功能被称为并行性 (concurrency)，</p>
<p>我认为这是一个很好的隐藏手段,IDA都调试不了中间过程</p>
<p>当发生未屏蔽的浮点异常时，它可能是个潜在的问题。反之，已屏蔽异常则不成问题，因为，FPU 总是可以完成当前操作并保存结果。</p>
<h2 id="FXAM"><a href="#FXAM" class="headerlink" title="FXAM"></a>FXAM</h2><p>检测st0是否是0,正无穷,负无穷,非实数,或者正常数,然后会初始化c3c2c0</p>
<p>具体遇到再说</p>
<h2 id="异常的屏蔽与未屏蔽简述"><a href="#异常的屏蔽与未屏蔽简述" class="headerlink" title="异常的屏蔽与未屏蔽简述"></a>异常的屏蔽与未屏蔽简述</h2><h3 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h3><h4 id="fstcw"><a href="#fstcw" class="headerlink" title="fstcw"></a>fstcw</h4><p> ;获取控制字</p>
<h4 id="fldcw"><a href="#fldcw" class="headerlink" title="fldcw"></a>fldcw</h4><p>;结果加载到 FPU</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>默认情况下，异常是被屏蔽的，因此，当出现浮点异常时，处理器分配一个默认值为结果，并继续平稳地工作。</p>
<p>例如，一个浮点数除以 0 生成结果为无穷，但不会中断程序,是吗?????哦????</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">.code</span><br><span class="line">fild val1        ;整数加载到ST(0)</span><br><span class="line">fdiv val2       ;ST(0) =正无穷</span><br></pre></td></tr></table></figure>

<p>如果 FPU 控制字没有屏蔽异常，那么处理器就会试着执行合适的异常处理程序。</p>
<p>清除 FPU 控制字中的相应位就可以实现异常的未屏蔽操作，如下表所示。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>无效操作异常屏蔽位</td>
<td>5</td>
<td>精度异常屏蔽位</td>
</tr>
<tr>
<td>1</td>
<td>非规格化操作数异常屏蔽位</td>
<td>8〜9</td>
<td>精度控制位</td>
</tr>
<tr>
<td>2</td>
<td>除零异常屏蔽位</td>
<td>10〜11</td>
<td>舍入控制位</td>
</tr>
<tr>
<td>3</td>
<td>上溢异常屏蔽位</td>
<td>12</td>
<td>无穷控制位</td>
</tr>
<tr>
<td>4</td>
<td>下溢异常屏蔽位</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>于是对于除0异常,我们就去看2位,把它置0</p>
<ol>
<li><p>将 FPU 控制字保存到 16 位变量。</p>
</li>
<li><p>清除位 2（除零标志位）。</p>
</li>
<li><p>将变量加载回控制字。</p>
</li>
</ol>
<p>一个自动被屏蔽的异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">hello	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">fmt	byte	&quot;%s&quot;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fild val1        ;整数加载到ST(0)</span><br><span class="line">		fdiv val2       ;ST(0) =正无穷</span><br><span class="line">		invoke  printf,offset fmt,offset hello</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后我们</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ctrlWord WORD ?</span><br><span class="line">.code</span><br><span class="line">fstcw ctrlWord                   ;获取控制字</span><br><span class="line">and ctrlWord, 1111111111111011b  ;不屏蔽除零异常</span><br><span class="line">fldcw ctrlWord                   ;结果加载回 FPU</span><br></pre></td></tr></table></figure>

<p>然后我们也没发生啥呀….woc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">val1 DWORD 1</span><br><span class="line">val2 REAL8 0.0</span><br><span class="line">ctrlWord WORD ?</span><br><span class="line"></span><br><span class="line">hello	byte	&quot;Dqx_Gh0st&quot;,0</span><br><span class="line">fmt	byte	&quot;%s&quot;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		fstcw ctrlWord</span><br><span class="line">		and ctrlWord, 1111111111111011b</span><br><span class="line">		fldcw ctrlWord</span><br><span class="line"></span><br><span class="line">		fild val1        ;整数加载到ST(0)</span><br><span class="line">		fdiv val2       ;ST(0) =正无穷</span><br><span class="line">		invoke  printf,offset fmt,offset hello</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="x64的浮点数四则运算"><a href="#x64的浮点数四则运算" class="headerlink" title="x64的浮点数四则运算"></a>x64的浮点数四则运算</h2><p>假设我们用的双精度浮点运算</p>
<h3 id="addsd-加法"><a href="#addsd-加法" class="headerlink" title="addsd 加法"></a>addsd 加法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">addsd xmm2, [number2]	; add into to xmm</span><br></pre></td></tr></table></figure>



<h3 id="subsd-减法"><a href="#subsd-减法" class="headerlink" title="subsd 减法"></a>subsd 减法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">subsd xmm2, [number2]	; subtract from xmm</span><br></pre></td></tr></table></figure>



<h3 id="mulsd-乘法"><a href="#mulsd-乘法" class="headerlink" title="mulsd 乘法"></a>mulsd 乘法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">mulsd xmm2, [number2]	; multiply with xmm </span><br></pre></td></tr></table></figure>



<h3 id="divsd-除法"><a href="#divsd-除法" class="headerlink" title="divsd 除法"></a>divsd 除法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movsd xmm2, [number1]	; double precision float into xmm</span><br><span class="line">divsd xmm2, [number2]	; divide xmm0 </span><br></pre></td></tr></table></figure>



<h3 id="sqrtsd-开方"><a href="#sqrtsd-开方" class="headerlink" title="sqrtsd 开方"></a>sqrtsd 开方</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqrtsd xmm1, [number1]</span><br><span class="line">//结果保持在xmm1中</span><br></pre></td></tr></table></figure>



<h2 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h2><h3 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h3><p>valD&#x3D;-valA+(valB*valC)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">valA REAL8 1.5</span><br><span class="line">valB REAL8 2.5</span><br><span class="line">valC REAL8 3.0</span><br><span class="line">valD REAL8 ? ; +6.0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fld valA    ; ST(0) = valA</span><br><span class="line">		fchs        ;修改 ST(0) 的符号</span><br><span class="line">		fld valB    ; 将 valB 加载到 ST(0)</span><br><span class="line">		fmul valC   ; ST(0) *= valC</span><br><span class="line">		fadd        ; ST(0) += ST(1)</span><br><span class="line">		fstp valD   ; 将 ST(0) 保存到 valD</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		;invoke	printf,addr out_fmt,edi</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">ARRAY_SIZE = 20</span><br><span class="line">sngArray REAL8 1.2,2.3,3.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		    mov		esi, 0            ;数组索引</span><br><span class="line">		    fldz			  ; 0.0 入栈</span><br><span class="line">		    mov		ecx,ARRAY_SIZE</span><br><span class="line">		L1: fld		sngArray[esi]     ;将内存操作数加载到ST(0)</span><br><span class="line">		    fadd			  ; ST(0) 加 ST(1),出栈</span><br><span class="line">		    add		esi,TYPE REAL8    ;移至!I 下一个元素</span><br><span class="line">		    loop	L1</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="开方求和"><a href="#开方求和" class="headerlink" title="开方求和"></a>开方求和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">valA REAL8 25.0</span><br><span class="line">valB REAL8 36.0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		fld valA        ; valA 入栈</span><br><span class="line">		fsqrt           ; ST(0) = sqrt(valA)</span><br><span class="line">		fld valB        ; valB 入栈</span><br><span class="line">		fsqrt           ; ST(0) = sqrt(valB)</span><br><span class="line">		fadd            ; ST (0)+ST(1)</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="C语言的强制类型转换"><a href="#C语言的强制类型转换" class="headerlink" title="C语言的强制类型转换"></a>C语言的强制类型转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> X = <span class="number">3.5</span>;</span><br><span class="line"><span class="type">double</span> Z = N + X;</span><br><span class="line"><span class="comment">//asm</span></span><br><span class="line">.data</span><br><span class="line">N SDWORD <span class="number">20</span></span><br><span class="line">X REAL8 <span class="number">3.5</span></span><br><span class="line">Z REAL8 ?</span><br><span class="line">.code</span><br><span class="line">fild n         ;整数加载到ST(<span class="number">0</span>)</span><br><span class="line">fadd X       ;将内存操作数与ST(<span class="number">0</span>)相加</span><br><span class="line">fstp z        ;将ST(<span class="number">0</span>)保存到内存操作数</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> X = <span class="number">3.5</span>;</span><br><span class="line"><span class="type">int</span> Z = (<span class="type">int</span>)(N + X);</span><br><span class="line"><span class="comment">//Asm</span></span><br><span class="line">fild N   	;整数加载到ST(<span class="number">0</span>)</span><br><span class="line">fadd X  	;将内存操作数与ST(<span class="number">0</span>)相加</span><br><span class="line">fist Z    	;将ST(<span class="number">0</span>)保存为整型内存操作数,这里就是一个转化</span><br></pre></td></tr></table></figure>



<h3 id="修改舍入模式-什么鬼"><a href="#修改舍入模式-什么鬼" class="headerlink" title="修改舍入模式,什么鬼"></a>修改舍入模式,什么鬼</h3><p>FPU 控制字的 RC 字段指定使用的舍入类型。可以先用 FSTCW 把控制字保存为一个变量，再修改 RC 字段（位 10 和 11）,最后用 FLDCW 指令把这个变量加载回控制字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstew ctrlWord             ;保存控制字</span><br><span class="line">or ctrlWord, 110000000000b ;设置眈=截断</span><br><span class="line">fldcw ctrlWord             ;加载控制字</span><br></pre></td></tr></table></figure>

<p>之后采用截断执行计算，生成结果为 Z&#x3D;23：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fild N  ;整数加载到ST(0)</span><br><span class="line">fadd X ;将内存整数与ST(0)相加</span><br><span class="line">fist Z   ;将ST(0)保存为整型内存操作数</span><br></pre></td></tr></table></figure>

<p>或者，把舍入模式重新设置为默认选项（舍入到最接近的偶数）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fstcw ctrlWord               ;保存控制字</span><br><span class="line">and ctrlWord, 001111111111b  ;重置舍入模式为默认</span><br><span class="line">fldcw ctrlWord               ;加载控制字 </span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>未公开的win32-API说明</title>
    <url>/re4mile/2023/01/11/language/C/win32/%E5%B0%8F%E4%B8%93%E9%A2%98/%E6%9C%AA%E5%85%AC%E5%BC%80API/language/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bbs.kanxue.com/thread-273199.htm">RtlpGetAssemblyStorageMapRootLocation</a></p>
<p><a href="https://bbs.kanxue.com/thread-183181.htm">未命名</a></p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>win32琐碎</title>
    <url>/re4mile/2023/01/11/language/C/win32/%E5%B0%8F%E4%B8%93%E9%A2%98/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/language/</url>
    <content><![CDATA[<h2 id="LoadLibrary和GetModuleHandle的区别"><a href="#LoadLibrary和GetModuleHandle的区别" class="headerlink" title="LoadLibrary和GetModuleHandle的区别"></a>LoadLibrary和GetModuleHandle的区别</h2><p>LoadLibrary是把一个模块映射进调用进程的地址空间，需要时增加引用计数，</p>
<p>每调用一次，引用计数增加一，</p>
<p>需要通过相同步骤地调用FreeLibrary来减少引用次数，</p>
<p>当为0时，系统卸载DLL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HMODULE WINAPI <span class="title function_">LoadLibrary</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in  LPCTSTR lpFileName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>GetModuleHandle是返回一个已经映射进调用进程地址空间的模块的句柄，并不增加引用计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HMODULE WINAPI <span class="title function_">GetModuleHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in_opt  LPCTSTR lpModuleName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>win32篇-美化</title>
    <url>/re4mile/2023/01/11/language/C/win32/%E5%B0%8F%E4%B8%93%E9%A2%98/%E7%BE%8E%E5%8C%96/language/</url>
    <content><![CDATA[<h1 id="终端字体颜色"><a href="#终端字体颜色" class="headerlink" title="终端字体颜色"></a>终端字体颜色</h1><p>SetConsoleTextAttribute函数用法</p>
<h1 id="打开网站"><a href="#打开网站" class="headerlink" title="打开网站"></a>打开网站</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fuck</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LPCSTR mode = <span class="string">&quot;open&quot;</span>;</span><br><span class="line">    LPCSTR web = <span class="string">&quot;https://www.bilibili.com/video/BV1Mh41147yo?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&quot;</span>;</span><br><span class="line">    ShellExecuteA(<span class="literal">NULL</span>, mode, web, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>stdlib字符串处理</title>
    <url>/re4mile/2023/01/11/language/C/%E5%BA%93%E5%87%BD%E6%95%B0/stdlib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/language/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_44205382/article/details/109528735">https://blog.csdn.net/qq_44205382/article/details/109528735</a></p>
<h1 id="ato"><a href="#ato" class="headerlink" title="ato-"></a>ato-</h1><p>定义函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;  <span class="comment">// string-&gt;double</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>; 	<span class="comment">// string-&gt;int</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>; 	<span class="comment">// strong-&gt;long</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>会扫描参数nptr字符串,</p>
<p>跳过前面的空格字符,</p>
<p>直到遇上数字或正负符号才开始做转换,</p>
<p>而再遇到<code>非数字</code>或<code>字符串结束</code>时才结束转换,并将结果返回。比如遇到空格就g</p>
<p>参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分,如123.456或123e-2。</p>
<p>返回值：返回转换后的浮点型数。</p>
<p>附加说明：atof()与使用strtod(nptr,(char**)NULL)结果相同</p>
<p>附加说明：atoi()与使用strtol(nptr,(char**)NULL,10);结果相同</p>
<p>附加说明：atol()与使用strtol(nptr,(char**)NULL,10);结果相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* a = <span class="string">&quot;3.1415&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* b = <span class="string">&quot;-200e-2&quot;</span>;<span class="comment">//200,整数没有科学计数法,小数才有</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf %lf \n&quot;</span>, atof(a), atof(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d \n&quot;</span>, atoi(a), atoi(b));<span class="comment">//整数没有科学计数法,小数才有</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld %ld \n&quot;</span>, atol(a),atol(b));<span class="comment">//整数没有科学计数法,小数才有</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="strto"><a href="#strto" class="headerlink" title="strto-"></a>strto-</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr,<span class="type">char</span> **endptr)</span>; <span class="comment">//string -&gt; double</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr,<span class="type">char</span> **endptr,<span class="type">int</span> base)</span>; <span class="comment">//string-&gt;long </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr,<span class="type">char</span> **endptr,<span class="type">int</span> base)</span>;<span class="comment">//strong unsigned long </span></span><br></pre></td></tr></table></figure>



<p><code>strtod函数</code>说明：</p>
<p>strtod()会扫描参数nptr字符串,</p>
<p>跳过前面的空格字符,直到遇上数字或正负符号才开始做转换,到出现非数字或字符串结束时 (‘&#x2F;0’)才结束转换,并将结果返回。</p>
<p>若endptr不为NULL,则会将遇到不合条件而终止的nptr中的字符指针由endptr传回。</p>
<p>参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分。如123.456或123e-2。</p>
<p>返回值：返回转换后的浮点型数。</p>
<p><code>strtol函数</code>说明：</p>
<p>strtol()会将参数nptr字符串根据参数base来转换成长整型数。</p>
<p>参数base范围从2至36,或0。</p>
<p>参数base代表采用的进制方式,</p>
<p>如base值为10则采用10进制,</p>
<p>若base值为16则采用16进制等。</p>
<p>当base值为0时则是采用10进制做转换,但遇到如’0x’前置字符则会使用16进制做转换。</p>
<p>一开始strtol()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上数字或正负符号才开始做转换,</p>
<p>再遇到非数字或字符串结束时(‘&#x2F;0’)结束转换,并将结果返回。</p>
<p>若参数endptr不为NULL,则会将遇到不合条件而终止的nptr中的字符指针由endptr返回。</p>
<p>返回值 返回转换后的长整型数,否则返回ERANGE并将错误代码存入errno中。</p>
<p>附加说明：ERANGE指定的转换字符串超出合法范围。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;1000000000&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[] = <span class="string">&quot;1234ffff&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d \n&quot;</span>, (<span class="type">int</span>)strtod(a, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d \n&quot;</span>, (<span class="type">int</span>)strtod(b, &amp;c));</span><br><span class="line">    <span class="keyword">if</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c = %s \n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;1000&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[] = <span class="string">&quot;0x64&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10:a = %d \n&quot;</span>, strtol(a, <span class="literal">NULL</span>,<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10:a = %d \n&quot;</span>, strtol(a, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16:a = %d \n&quot;</span>, strtol(a, <span class="literal">NULL</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;01:a = %d \n&quot;</span>, strtol(a, <span class="literal">NULL</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16:b = %d \n&quot;</span>, strtol(b, <span class="literal">NULL</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16:b = %d \n&quot;</span>, strtol(b, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *gcvt(double number,size_t ndigits,char *buf);</span><br></pre></td></tr></table></figure>



<p>gcvt函数说明：</p>
<p>gcvt()用来将参数number转换成ASCII码字符串,参数ndigits表示显示的位数。</p>
<p>gcvt()与ecvt()和fcvt()不同的地方在于,</p>
<p>gcvt()所转换后的字符串包含小数点或正负符号。若转换成功,转换后的字符串会放在参数buf指针所指的空间。</p>
<p>返回值：返回一字符串指针,此地址即为buf指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">-3.1415926</span>;</span><br><span class="line">    <span class="type">char</span>  sz_tmp[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _gcvt(a, <span class="number">2</span>, sz_tmp);<span class="comment">//保留2位数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a value = %s \n&quot;</span>, sz_tmp);</span><br><span class="line"></span><br><span class="line">    _gcvt(b, <span class="number">4</span>, sz_tmp);<span class="comment">//保留4位数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b value = %s \n&quot;</span>, sz_tmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="转ASCII"><a href="#转ASCII" class="headerlink" title="转ASCII"></a>转ASCII</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int toascii(int c)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>C语言库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>win32 API积累</title>
    <url>/re4mile/2023/01/11/language/C/win32/%E5%B0%8F%E4%B8%93%E9%A2%98/%E9%81%87%E5%88%B0%E7%9A%84API/language/</url>
    <content><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONSOLE_CURSOR_INFO</span> &#123;</span></span><br><span class="line">    DWORD  dwSize;<span class="comment">//光标大小所占一个字符的百分比</span></span><br><span class="line">    BOOL   bVisible; <span class="comment">//光标是否可见</span></span><br><span class="line">&#125; CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="WaitForDebugEvent"><a href="#WaitForDebugEvent" class="headerlink" title="WaitForDebugEvent"></a>WaitForDebugEvent</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">WaitForDebugEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out] LPDEBUG_EVENT lpDebugEvent, </span></span><br><span class="line"><span class="params">    <span class="comment">//指向接收调试事件信息的 DEBUG_EVENT 结构的指针。</span></span></span><br><span class="line"><span class="params">  [in]  DWORD         dwMilliseconds </span></span><br><span class="line"><span class="params">    <span class="comment">//等待调试事件的毫秒数。 如果此参数为零，则函数会测试调试事件并立即返回。 </span></span></span><br><span class="line"><span class="params">    <span class="comment">//如果参数为 INFINITE，则在调试事件发生之前，该函数不会返回。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>如果该函数成功，则返回值为非零值。</p>
<p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h2 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h2><h3 id="Messagebox"><a href="#Messagebox" class="headerlink" title="Messagebox"></a>Messagebox</h3><p>   MB_ABORTRETRYIGNORE：消息框含有三个按钮：Abort，Retry和Ignore。</p>
<p>　　MB_OK：消息框含有一个按钮：OK。这是缺省值。</p>
<p>　　MB_OKCANCEL：消息框含有两个按钮：OK和Cancel。</p>
<p>　　MB_RETRYCANCEL：消息框含有两个按钮：Retry和Cancel。</p>
<p>　　MB_YESNO：消息框含有两个按钮：Yes和No。</p>
<p>　　MB_YESNOCANCEL：消息框含有三个按钮：Yes，No和Cancel。</p>
<p>　　指定下列标志中的一个来显示消息框中的图标：标志的含义如下。</p>
<p>　　MB_ICONWARNING：一个惊叹号出现在消息框。</p>
<p>　　MB_ICONASTERISK：一个圆圈中小写字母i组成的图标出现在消息框。</p>
<p>返回值</p>
<p>如果没有足够的内存来创建消息框，则返回值为零。如果函数调用成功，则返回值为下列对话框返回的菜单项目值中的一个：</p>
<p>　　IDABORT：Abort 按钮被选中。IDCANCEL：Cancel按钮被选中。IDIGNORE：Ignore按钮被选中。</p>
<p>　　IDNO：NO按钮被选中。IDOK：OK按钮被选中。IDRETRY：RETRY按钮被选中。</p>
<p>　　IDYES：YES按钮被选中。</p>
<p>　　如果一个消息框有一个Cancel按钮，且如果Esc键被按下或Cancel键被选择，则函数返回IDCANCEL值。如果消息框没有Cancel按钮，则按Esc键没有作用。</p>
<p>　</p>
<h2 id="资源分配相关"><a href="#资源分配相关" class="headerlink" title="资源分配相关"></a>资源分配相关</h2><h2 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h2><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><p>  __in_opt  LPSECURITY_ATTRIBUTES lpMutexAttributes, &#x2F;&#x2F;安全属性,垃圾,NULL	</p>
<p>如果API有这种参数的话,就说明他是与内核对象相关的函数</p>
<h3 id="AdjustTokenPrivileges-特权设置"><a href="#AdjustTokenPrivileges-特权设置" class="headerlink" title="AdjustTokenPrivileges 特权设置"></a>AdjustTokenPrivileges 特权设置</h3><p>用于启用或禁止，指定访问令牌的特权</p>
<p><a href="https://developer.aliyun.com/article/366969">https://developer.aliyun.com/article/366969</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE            TokenHandle, 	<span class="comment">//包含要修改de特权的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            BOOL              DisableAllPrivileges, <span class="comment">//是否禁用所有令牌的权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PTOKEN_PRIVILEGES NewState, 		<span class="comment">//新特权信息的指针,指定了一组特权和他们的属性.</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD             BufferLength, 	<span class="comment">//指向的缓冲区的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PTOKEN_PRIVILEGES PreviousState, 	<span class="comment">//接收被改变特权当前状态的Buffer,他和都3个参数的类型一样的</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PDWORD            ReturnLength 	<span class="comment">//接收PreviousState缓存区要求的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>AdjustTokenPrivileges</strong>函数无法向访问令牌添加新权限。它只能启用或禁用令牌的现有权限。要确定令牌的权限，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">GetTokenInformation</a>函数。</p>
<p>返回值<br>如果函数成功，则返回值非零。要确定函数是否调整了所有指定的权限，请调用 GetLastError，它会在函数成功时返回以下值之一：<br>令牌不具有在NewState参数中指定的一项或多项特权。即使没有调整权限，该函数也可能会成功并出现此错误值。PreviousState参数表示已调整的权限 。</p>
<p>如果函数失败，则返回值为零。要获取扩展的错误信息，请调用GetLastError。</p>
<h3 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CopyFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCTSTR lpExistingFileName, <span class="comment">//S</span></span></span><br><span class="line"><span class="params">  [in] LPCTSTR lpNewFileName, <span class="comment">//D</span></span></span><br><span class="line"><span class="params">  [in] BOOL    bFailIfExists</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>最后一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in] bFailIfExists</span><br></pre></td></tr></table></figure>

<p>如果此参数为<strong>TRUE</strong>,原文存在,则函数失败</p>
<p>如果此参数为 <strong>FALSE</strong>,源文件不存在,于是就覆盖</p>
<p>返回值</p>
<p>如果函数成功，则返回值非零。<br>如果函数失败，则返回值为零。要获取扩展的错误信息，请调用 GetLastError。</p>
<h3 id="CallNextHookEx"><a href="#CallNextHookEx" class="headerlink" title="CallNextHookEx"></a>CallNextHookEx</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">CallNextHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HHOOK  hhk, <span class="comment">//该参数被忽略。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    nCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>ncode</p>
<p>传递给当前钩子过程的钩子代码。下一个钩子过程使用此代码来确定如何处理钩子信息。</p>
<p>类型：<strong>WPARAM</strong></p>
<p>传递给当前挂钩过程的<em>wParam值。</em>该参数的含义取决于与当前钩子链关联的钩子类型 </p>
<p>类型：<strong>LPARAM</strong></p>
<p>传递给当前挂钩过程的<em>lParam值。</em>该参数的含义取决于与当前钩子链关联的钩子类型。</p>
<p>正确的消息处理流程应该如下</p>
<p>　　物理击键</p>
<p>　　　↓</p>
<p>　　钩子管理函数←→钩子A←→钩子B←→钩子C←→钩子D</p>
<p>　　　↓</p>
<p>　　Window消息处理函数</p>
<p>在钩子A函数中，如果调用CallNextHookEx函数，则会将按键消息传给钩子B；</p>
<p>如果不调用CallNextHookEx函数，则钩子B不会得到按键消息，换句话说，钩子B失效了，当然此时的钩子C和钩子D也失效了。为了钩子间和平相处，还是应该在钩子函数里添加CallNextHookEx函数的调用。</p>
<p>钩子函数的返回值的问题。在上面的事例中，钩子A的返回值决定按键消息是否丢弃。</p>
<p>返回值0，告诉系统，消息继续传递给Window消息处理函数；</p>
<p>返回值1（非0），告诉系统，消息将丢弃，Window消息处理函数得不到按键的消息。</p>
<h3 id="ContinueDebugEvent"><a href="#ContinueDebugEvent" class="headerlink" title="ContinueDebugEvent"></a>ContinueDebugEvent</h3><p>使调试器能够继续先前报告调试事件的线程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ContinueDebugEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwThreadId,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwContinueStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>







<h3 id="DebugActiveProcess"><a href="#DebugActiveProcess" class="headerlink" title="DebugActiveProcess"></a>DebugActiveProcess</h3><p>使调试器附加到一个活动进程并且调试它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DebugActiveProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<p>如果函数成功，则返回值非零。</p>
<p>如果函数失败，则返回值为 0（零）。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a></p>
<h3 id="GetSystemDirectory"><a href="#GetSystemDirectory" class="headerlink" title="GetSystemDirectory"></a>GetSystemDirectory</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UINT <span class="title function_">GetSystemDirectoryA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out] LPSTR lpBuffer,<span class="comment">//用于装载系统目录路径名的一个字串缓冲区</span></span></span><br><span class="line"><span class="params">  [in]  UINT  uSize<span class="comment">//字串的最大长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="GlobalAlloc-全局堆分配"><a href="#GlobalAlloc-全局堆分配" class="headerlink" title="GlobalAlloc 全局堆分配"></a>GlobalAlloc 全局堆分配</h3><p>该函数从堆中分配一定数目的字节数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DECLSPEC_ALLOCATOR HGLOBAL <span class="title">GlobalAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] UINT   uFlags, <span class="comment">//  分配属性(方式)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T dwBytes <span class="comment">// 分配的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>





<p>返回值</p>
<p>若函数调用成功,则返回一个新分配的内存对象的<a href="https://baike.baidu.com/item/%E5%8F%A5%E6%9F%84">句柄</a>。</p>
<p>若函数调用失败,则返回<a href="https://baike.baidu.com/item/NULL">NULL</a>。可调用<a href="https://baike.baidu.com/item/GetLastError">GetLastError</a>以获得更多错误信息。</p>
<p>若<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>成功,将至少分配所需内存.若实际分配量超过所需,则内存仍然能够充分利用之.可用函数 GlobalSize 来确定实际所分配的字节数。</p>
<p>可使用 GlobalFree 来释放内存。</p>
<h3 id="Globallock"><a href="#Globallock" class="headerlink" title="Globallock"></a>Globallock</h3><p>锁定内存中指定的内存块，并返回一个地址值，令其指向内存块的起始处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">GlobalLock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HGLOBAL hMem</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除非用 GlobalUnlock 函数将内存块解锁，否则地址会一直保持有效</p>
<p>参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in] hMem</span><br></pre></td></tr></table></figure>

<p>全局内存对象的句柄。此句柄由 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a>或 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a>函数返回</p>
<p>返回值</p>
<p>如果函数成功，则返回值是指向内存块第一个字节的指针。</p>
<p>如果函数失败，则返回值为<strong>NULL</strong>。</p>
<ol start="4">
<li></li>
</ol>
<h3 id="InternetOpenA"><a href="#InternetOpenA" class="headerlink" title="InternetOpenA"></a>InternetOpenA</h3><p> 初始化应用程序对 WinINet 函数的使用</p>
<p>该函数是第一个由应用程序调用的 WinINet 函数。它告诉 Internet DLL 初始化内部数据结构并准备接收应用程序之后的其他调用。当应用程序结束使用 Internet 函数时，应调用 InternetCloseHandle 函数来释放与之相关的资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HINTERNET <span class="title">InternetOpenA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpszAgent, <span class="comment">//exe调用WinINet函数的应用程序或入口</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD  dwAccessType, <span class="comment">//指定访问类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpszProxy, <span class="comment">//指定一个可选的主机名列表或IP地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpszProxyBypass,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD  dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<p>成功：返回一个有效的句柄，该句柄将由应用程序传递给接下来的WinINet函数。</p>
<p>失败：返回NULL。	</p>
<h3 id="InternetOpenUrl"><a href="#InternetOpenUrl" class="headerlink" title="InternetOpenUrl"></a>InternetOpenUrl</h3><p>打开由完整的 FTP 或 HTTP URL 指定的资源</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HINTERNET <span class="title">InternetOpenUrlA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HINTERNET hInternet, <span class="comment">//会话句柄,由InternetOpen 调用返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR    lpszUrl, <span class="comment">//指定读取的网址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR    lpszHeaders, <span class="comment">//指定发送到HTTP服务器的头信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD     dwHeadersLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD     dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD_PTR dwContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<p>如果连接成功建立，则返回 URL 的有效句柄；如果连接失败，则返回<strong>NULL 。</strong>要检索特定错误消息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。要确定拒绝访问服务的原因，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetgetlastresponseinfoa">InternetGetLastResponseInfo</a>。</p>
<h3 id="InternetReadFile-打开的句柄中读取数据。"><a href="#InternetReadFile-打开的句柄中读取数据。" class="headerlink" title="InternetReadFile 打开的句柄中读取数据。"></a>InternetReadFile 打开的句柄中读取数据。</h3><p>打开的句柄中读取数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InternetReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HINTERNET hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPVOID    lpBuffer, <span class="comment">//缓冲器指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD     dwNumberOfBytesToRead, <span class="comment">///欲读数据的字节量</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD   lpdwNumberOfBytesRead <span class="comment">//接收读取字节量的变量s</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in] hFile</span><br></pre></td></tr></table></figure>

<p>从先前调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopenurla">InternetOpenUrl</a>、 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-ftpopenfilea">FtpOpenFile</a>或 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-httpopenrequesta">HttpOpenRequest</a>返回的句柄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[out] lpBuffer</span><br></pre></td></tr></table></figure>

<p>指向接收数据的缓冲区的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in] dwNumberOfBytesToRead</span><br></pre></td></tr></table></figure>

<p>要读取的字节数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[out] lpdwNumberOfBytesRead</span><br></pre></td></tr></table></figure>

<p>指向接收读取字节数的变量的指针。 <strong>InternetReadFile</strong>在进行任何工作或错误检查之前将此值设置为零。</p>
<p> 返回值</p>
<p>如果成功则返回<strong>TRUE ，否则返回****FALSE</strong>。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p>
<h3 id="KeyboardProc"><a href="#KeyboardProc" class="headerlink" title="KeyboardProc"></a>KeyboardProc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRESULT CALLBACK KeyboardProc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code,</span><br><span class="line">    WPARAM wParam,</span><br><span class="line">    LPARAM lParam</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nCode: 根据这个数值决定怎样处理消息</p>
<p>​			如果 code 小于0，则 必须让KeyboardProc()函数返回CallNextHookEx()</p>
<p>​			code可以是下列值：</p>
<p>​			HC_ACTION：wParam和lParam包含按键消息</p>
<p>​			HC_NOREMOVE：wParam和lParam包含按键消息,并且按键消息不能从<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>中移除（一个被PeekMessage<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的请求，指定   			PM_NOREMOVE标志）</p>
<p>wParam: 按键的虚拟键值消息，例如:VK_F1</p>
<p>lParam: 根据不同的位数具有多种不同的含义</p>
<p>LRESULT是一个数据类型，指的是从窗口程序或者回调函数返回的32位值。</p>
<p>CALLBACK是由用户设计却由windows系统呼叫的函数，统称为callback函数。某些API函数要求以callback作为你参数之一。</p>
<h3 id="lstrcat"><a href="#lstrcat" class="headerlink" title="lstrcat"></a>lstrcat</h3><p>字符串衔接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPSTR <span class="title function_">lstrcat</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, out] LPSTR  lpString1, <span class="comment">//S</span></span></span><br><span class="line"><span class="params">  [in]      LPCSTR lpString2 <span class="comment">//D</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in, out] lpString1</span><br></pre></td></tr></table></figure>

<p>类型：<strong>LPTSTR</strong></p>
<p>第一个以 null 结尾的字符串。此缓冲区必须足够大以包含两个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in] lpString2</span><br></pre></td></tr></table></figure>

<p>类型：<strong>LPTSTR</strong></p>
<p>要附加到<em>lpString1</em>参数中指定的字符串的空终止字符串。</p>
<p>返回值</p>
<p>如果函数成功，则返回值是指向缓冲区的指针。</p>
<p>如果函数失败，则返回值为<strong>NULL</strong> ，并且<em>lpString1</em>可能不是以 null 结尾的。</p>
<h3 id="LookupPrivilegeValueA"><a href="#LookupPrivilegeValueA" class="headerlink" title="LookupPrivilegeValueA"></a>LookupPrivilegeValueA</h3><p>函数查看系统权限的特权值，返回信息到一个LUID结构体里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">LookupPrivilegeValueA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpSystemName, <span class="comment">//表示所要查看的系统，本地系统直接用NULL</span></span></span><br><span class="line"><span class="params">  [in]           LPCSTR lpName, <span class="comment">//指定特权的名称</span></span></span><br><span class="line"><span class="params">  [out]          PLUID  lpLuid <span class="comment">//接收所返回的制定特权名称的信息接收所返回的制定特权名称的信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>一个指向变量的指针，该变量接收由<em>lpSystemName</em>参数指定的系统上的权限已知的 LUID。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LUID</span> &#123;</span><br><span class="line">    DWORD LowPart;</span><br><span class="line">    LONG HighPart;</span><br><span class="line">&#125; LUID, *PLUID;</span><br></pre></td></tr></table></figure>



<p>返回值</p>
<p>函数调用成功后，信息存入第三个类型为LUID的结构体中，并且函数返回非0</p>
<h3 id="UnhookWindowsHookEx"><a href="#UnhookWindowsHookEx" class="headerlink" title="UnhookWindowsHookEx"></a>UnhookWindowsHookEx</h3><p>通过UnhookWindowsHookEx函数删除安装在挂钩链中的挂钩过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">UnhookWindowsHookEx</span><span class="params">(</span></span><br><span class="line"><span class="params">   HHOOK hhk</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>类型：<strong>HHOOK</strong></p>
<p>要移除的挂钩的handle。此参数是通过先前调用SetWindowsHookEx获得的挂钩句柄。</p>
<p>返回值</p>
<p>如果函数成功，则返回值非零。</p>
<p>如果函数失败，则返回值为零。</p>
<h3 id="OutputDebugString"><a href="#OutputDebugString" class="headerlink" title="OutputDebugString"></a>OutputDebugString</h3><p>类似于printf,将字符串发送到调试器进行显示。</p>
<h3 id="OpenProcessToken-以某种访问权限打开一个进程"><a href="#OpenProcessToken-以某种访问权限打开一个进程" class="headerlink" title="OpenProcessToken 以某种访问权限打开一个进程"></a>OpenProcessToken 以某种访问权限打开一个进程</h3><p>用来打开与进程相关联的访问令牌</p>
<p>OpenProcessToken函数用来打开与进程相关联的访问令牌</p>
<p><code>得到指定进程的访问令牌，而第三个参数定义设置不正确可能导致该函数调用失败</code></p>
<p>要对一个任意进程（包括系统安全进程和服务进程）进行指定了写相关的访问权的OpenProcess操作，只要当前进程具有<code>SeDeDebug</code>权限就可以了。要是一个用户是Administrator或是被给予了相应的权限，就可以具有该权限。</p>
<p>可是，就算我们用Administrator帐号对一个系统安全进程执行OpenProcess(PROCESS_ALL_ACCESS,FALSE, dwProcessID)还是会遇到“访问拒绝”的错误。什么原因呢？原来在<code>默认的情况下进程的一些访问权限是没有被启用（Enabled）</code>的，所以我们要做的首先是启用这些权限。</p>
<p>《WINDOWS核心编程》!</p>
<p><a href="https://blog.csdn.net/stonesharp/article/details/7709674">https://blog.csdn.net/stonesharp/article/details/7709674</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  ProcessHandle,<span class="comment">//要修改访问权限的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   DesiredAccess, <span class="comment">//你要进行的操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE TokenHandle 	<span class="comment">//返回的访问令牌指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>如果函数成功，则返回值非零。</p>
<p>如果函数失败，则返回值为零</p>
<h3 id="ShellExecute-Dev环境"><a href="#ShellExecute-Dev环境" class="headerlink" title="ShellExecute -Dev环境"></a>ShellExecute -Dev环境</h3><p>对指定文件执行操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">ShellExecuteA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND   hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpOperation,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           INT    nShowCmd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数2</p>
<p>这个参数可以是<code>&quot;edit&quot;</code> <code>&quot;explore&quot;</code> <code>&quot;open&quot;</code> <code>&quot;print&quot;</code> <code>&quot;runas&quot;</code> <code>NULL</code>，分别可以打开编辑器、在文件资源管理器中查看、打开、屏幕输出和 <strong>以管理员身份运行</strong> 。</p>
<p>最后一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW_HIDE 隐藏窗口，活动状态给令一个窗口 </span><br><span class="line"></span><br><span class="line">SW_MINIMIZE 最小化窗口，活动状态给令一个窗口 </span><br><span class="line"></span><br><span class="line">SW_RESTORE 用原来的大小和位置显示一个窗口，同时令其进入活动状态 </span><br><span class="line"></span><br><span class="line">SW_SHOW 用当前的大小和位置显示一个窗口，同时令其进入活动状态 </span><br><span class="line"></span><br><span class="line">SW_SHOWMAXIMIZED 最大化窗口，并将其激活 </span><br><span class="line"></span><br><span class="line">SW_SHOWMINIMIZED 最小化窗口，并将其激活 </span><br><span class="line"></span><br><span class="line">SW_SHOWMINNOACTIVE 最小化一个窗口，同时不改变活动窗口 </span><br><span class="line"></span><br><span class="line">SW_SHOWNA 用当前的大小和位置显示一个窗口，不改变活动窗口 </span><br><span class="line"></span><br><span class="line">SW_SHOWNOACTIVATE 用最近的大小和位置显示一个窗口，同时不改变活动窗口 </span><br><span class="line"></span><br><span class="line">SW_SHOWNORMAL 与SW_RESTORE相同 </span><br></pre></td></tr></table></figure>



<p>返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值大于32表示执行成功</span><br><span class="line">返回值小于32表示执行错误</span><br><span class="line">返回值可能的错误有: = 0 &#123;内存不足&#125;</span><br><span class="line">ERROR_FILE_NOT_FOUND = 2; &#123;文件名错误&#125;</span><br><span class="line">ERROR_PATH_NOT_FOUND = 3; &#123;路径名错误&#125;</span><br><span class="line">ERROR_BAD_FORMAT = 11; &#123;EXE 文件无效&#125;</span><br><span class="line">SE_ERR_SHARE = 26; &#123;发生共享错误&#125;</span><br><span class="line">SE_ERR_ASSOCINCOMPLETE = 27; &#123;文件名不完全或无效&#125;</span><br><span class="line">SE_ERR_DDETIMEOUT = 28; &#123;超时&#125;</span><br><span class="line">SE_ERR_DDEFAIL = 29; &#123;DDE 事务失败&#125;</span><br><span class="line">SE_ERR_DDEBUSY = 30; &#123;正在处理其他 DDE 事务而不能完成该 DDE 事务&#125;</span><br><span class="line">SE_ERR_NOASSOC = 31; &#123;没有相关联的应用程序&#125;</span><br></pre></td></tr></table></figure>



<p>开始一个新的应用程序 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShellExecute(NULL, &quot;open&quot;, &quot;notepad.exe&quot;, NULL, NULL, SW_SHOWNORMAL); </span><br></pre></td></tr></table></figure>

<p>打开记事本，并打开一个文件(系统能识别记事本应用程序的路径，因此我们不必使用绝对路径） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res=ShellExecute(NULL, &quot;open&quot;, &quot;notepad.exe&quot;, &quot;C:\\Users\\0x9D\\Desktop\\Test\\Work_Now.cpp&quot;, NULL, SW_SHOWNORMAL);</span><br></pre></td></tr></table></figure>

<p>打印一个文档 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShellExecute(Handle, &#x27;print&#x27;, PChar(&#x27;c:/test/test.doc&#x27;), nil, nil, SW_SHOW); </span><br></pre></td></tr></table></figure>

<p>注意：可能你会看到word暂时的被打开，但它会自动关闭。 </p>
<p>打开一个HTML页面 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;http://wus20.com&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line"><span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;</span>, <span class="string">&quot;bilibili.com&quot;</span>, <span class="literal">NULL</span>, SW_SHOWNORMAL);</span><br></pre></td></tr></table></figure>

<p>你能通过一个已经注册的文件类型来打开应用程序 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　ShellExecute(Handle, &#x27;open&#x27;, PChar(&#x27;c:/test/readme.txt&#x27;), nil, nil, SW_SHOW); </span><br></pre></td></tr></table></figure>

<p>用windows Explorer 打开一个目录 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　ShellExecute(Handle, &#x27;explore&#x27;, PChar(&#x27;c:/windows)&#x27;, nil, nil, SW_SHOW); </span><br></pre></td></tr></table></figure>

<p>运行一个DOS命令并立即返回 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　ShellExecute(Handle, &#x27;open&#x27;, PChar(&#x27;command.com&#x27;), PChar(&#x27;/c copy file1.txt file2.txt&#x27;), nil, SW_SHOW); </span><br></pre></td></tr></table></figure>

<p>运行一个DOS命令并保持DOS窗口存在 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res=ShellExecute(NULL, &quot;open&quot;, &quot;cmd&quot;, &quot;/k dir&quot;, NULL, SW_SHOW); </span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SHELLEXECUTEINFO dqx = &#123; <span class="built_in">sizeof</span>(SHELLEXECUTEINFO) &#125;;</span><br><span class="line">	dqx.lpVerb = <span class="built_in">TEXT</span>(<span class="string">&quot;runas&quot;</span>);</span><br><span class="line">	dqx.lpFile = <span class="built_in">TEXT</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">	dqx.nShow = SW_SHOWNORMAL;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">ShellExecuteEx</span>(&amp;dqx))</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwStatus = <span class="built_in">GetLastError</span>();</span><br><span class="line">		<span class="keyword">if</span> (dwStatus == ERROR_CANCELLED)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;提升权限被用户拒绝\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dwStatus == ERROR_FILE_NOT_FOUND)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;所要执行的文件没有找到\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause nul&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>建立一个网页</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HINSTANCE ret=<span class="number">0</span>;</span><br><span class="line">	ret=<span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;http://wus20.com&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line">	<span class="keyword">if</span>(ret&lt;(HINSTANCE)<span class="number">32</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsProcessRunAsAdmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;</span><br><span class="line">    PSID AdministratorsGroup;</span><br><span class="line">    BOOL b = <span class="built_in">AllocateAndInitializeSid</span>(</span><br><span class="line">        &amp;NtAuthority,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        SECURITY_BUILTIN_DOMAIN_RID,</span><br><span class="line">        DOMAIN_ALIAS_RID_ADMINS,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        &amp;AdministratorsGroup);</span><br><span class="line">    <span class="keyword">if</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CheckTokenMembership</span>(<span class="literal">NULL</span>, AdministratorsGroup, &amp;b);</span><br><span class="line">        <span class="built_in">FreeSid</span>(AdministratorsGroup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b == TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">GetAdmin</span><span class="params">(LPCSTR Param, <span class="type">int</span> Showcmd)</span><span class="comment">//一个参数是程序运行时的参数，另一个是启动窗口的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsProcessRunAsAdmin</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TCHAR Path[MAX_PATH];</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(Path, MAX_PATH);</span><br><span class="line">    ::<span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, Path, MAX_PATH);           <span class="comment">//获取程序路径</span></span><br><span class="line">    HINSTANCE res;</span><br><span class="line">    res = <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">&quot;runas&quot;</span>, Path, <span class="literal">NULL</span>, <span class="literal">NULL</span>, Showcmd);</span><br><span class="line">    <span class="keyword">if</span>(res &gt; (HINSTANCE)<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">short</span> ret=<span class="number">0</span>; </span><br><span class="line">	ret=<span class="built_in">GetAdmin</span>(<span class="string">&quot;calc&quot;</span>,SW_SHOW);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;wrong&quot;</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,argv[<span class="number">1</span>]); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="SetWindowsHookExW-钩取流程"><a href="#SetWindowsHookExW-钩取流程" class="headerlink" title="SetWindowsHookExW - 钩取流程"></a>SetWindowsHookExW - 钩取流程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HHOOK <span class="title function_">SetWindowsHookExW</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span>       idHook, <span class="comment">//处理的类型?键盘类型</span></span></span><br><span class="line"><span class="params">  HOOKPROC  lpfn, <span class="comment">//自定义的KeyboardProc函数</span></span></span><br><span class="line"><span class="params">  HINSTANCE hmod, <span class="comment">//是装载dll还是卸载dll</span></span></span><br><span class="line"><span class="params">  DWORD     dwThreadId  <span class="comment">//是钩取某个线程还是hook所有的线程</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>int hook——指定事件的钩子ID，如键盘事件WH_KEYBOARD。设置后只对键盘输入起反应。</li>
<li>HOOKPROC lpfn——钩子的处理函数，若设置的是键盘输入钩子，必须是微软定义的一个叫KeyboardProc的函数。</li>
<li>HINSTANCE hmod——模块句柄，因此一般设置钩子的地方在DLL中。</li>
<li>DWORD dwThreadId——需要设置钩子的线程ID，倘若为0则为全局钩子（所有程序都钩）。</li>
</ol>
<h3 id="TOKEN-PRIVILEGES"><a href="#TOKEN-PRIVILEGES" class="headerlink" title="TOKEN_PRIVILEGES"></a>TOKEN_PRIVILEGES</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TOKEN_PRIVILEGES</span> &#123;</span><br><span class="line">  DWORD               PrivilegeCount; <span class="comment">///下一个数组元素的个数</span></span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];  <span class="comment">//数组.类型为LUID_AND_ATTRIBUTES</span></span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure>





<h3 id="URLDownloadToFile"><a href="#URLDownloadToFile" class="headerlink" title="URLDownloadToFile"></a>URLDownloadToFile</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">URLDownloadToFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">             LPUNKNOWN            pCaller,<span class="comment">//如果调用应用程序不是 ActiveX 组件，则可以将此值设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">             LPCTSTR              szURL, <span class="comment">//指向包含要下载的 URL 的字符串值的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    									<span class="comment">//不能设置为NULL。如果 URL 无效，则返回 INET_E_DOWNLOAD_FAILURE</span></span></span></span><br><span class="line"><span class="params"><span class="function">             LPCTSTR              szFileName,<span class="comment">//指向字符串值的指针，该字符串值包含要为下载创建的文件的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    										<span class="comment">//或完整路径。如果szFileName包含路径，则目标目录必须已经存在</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Reserved_ DWORD                dwReserved,<span class="comment">//保留。必须设置为 0。</span></span></span></span><br><span class="line"><span class="params"><span class="function">             LPBINDSTATUSCALLBACK lpfnCB</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数可以返回这些值之一。</p>
<table>
<thead>
<tr>
<th align="left">返回码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>S_OK</strong></td>
<td align="left">下载成功开始。</td>
</tr>
<tr>
<td align="left"><strong>E_OUTOFMEMORY</strong></td>
<td align="left">缓冲区长度无效，或内存不足，无法完成操作。</td>
</tr>
<tr>
<td align="left"><strong>INET_E_DOWNLOAD_FAILURE</strong></td>
<td align="left">指定的资源或回调接口无效。</td>
</tr>
</tbody></table>
<h1 id="字节转化"><a href="#字节转化" class="headerlink" title="字节转化"></a>字节转化</h1><p>WideCharToMultiByte 宽字节到多字节</p>
<p>将 UTF-16（宽字符）字符串映射到新字符串。新字符串不一定来自多字节字符集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WideCharToMultiByte</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            UINT                               CodePage,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD                              dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            _In_NLS_string_(cchWideChar)LPCWCH lpWideCharStr,  <span class="comment">//指向将被转换的unicode字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            <span class="type">int</span>                                cchWideChar,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//指定由参数lpWideCharStr指向的缓冲区的字符个数。如果这个值为-1，字符串将被设定为以NULL为结束符的字符串，并且自动计算长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPSTR                              lpMultiByteStr, <span class="comment">//指向接收被转换字符串的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            <span class="type">int</span>                                cbMultiByte,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//指定由参数lpMultiByteStr指向的缓冲区最大值（用字节来计量）。若此值为零，函数返回lpMultiByteStr指向的目标缓冲区所必需的字节数，在这种情况下，lpMultiByteStr参数通常为NULL。  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  LPCCH                              lpDefaultChar,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPBOOL                             lpUsedDefaultChar</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>多字节到宽字节MultiByteToWideChar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MultiByteToWideChar(CP_ACP, 0, filename, strlen(filename) + 1, name, sizeof(name) / sizeof(name[0]));</span><br><span class="line">//把filename字符串转换到name字符串</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编 CRT标准库</title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/32/%E5%B0%8F%E4%B8%93%E9%A2%98/CRT%E6%A0%87%E5%87%86%E5%BA%93/language/</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/huangxy10/article/details/8310087">https://blog.csdn.net/huangxy10/article/details/8310087</a></p>
<p><a href="https://www.cnblogs.com/cloudeman/archive/2012/04/09/2439438.html">https://www.cnblogs.com/cloudeman/archive/2012/04/09/2439438.html</a></p>
<p>其实也就是我们在汇编语言中,可以调用很多C语言的函数</p>
<p>比如下面涉及的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stdio.h</span><br><span class="line">stdlib.h</span><br><span class="line">string.h</span><br></pre></td></tr></table></figure>



<p>常用的CRT函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crt_memcpy</span><br><span class="line">crt_memset</span><br><span class="line">crt_strcpy</span><br><span class="line">crt_system</span><br><span class="line">crt_printf</span><br><span class="line">crt_scanf</span><br><span class="line">crt_fopen</span><br><span class="line">crt_gets</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>其实涉及的很多的函数例子你就都可以加上<code>crt_</code>前缀,然后尝试一下可不可以正常使用该函数</p>
<p>能用,当然就万事大吉啦</p>
<p>实践</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">;sub2   proto   StdCall,:DWORD,:DWORD</span><br><span class="line">; small_check proto uses esi ebx ecx,:DWORD</span><br><span class="line">; numToDec    proto :DWORD,:DWORD ,:DWORD</span><br><span class="line">; weclome     proto </span><br><span class="line">; f_Out       proto </span><br><span class="line">; f_In        proto </span><br><span class="line">; Ymain       proto </span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include msvcrt.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line"> </span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">sz_1  db &quot;--------------------------------------------&quot;,0Ah,00h</span><br><span class="line">sz_2  db &quot;convert xx from xx to xx&quot;,0Ah,00h</span><br><span class="line">sz_3  db &quot;if you want convert 100 from 10 to 16&quot;,0Ah,00h</span><br><span class="line">sz_4  db &quot;than input like below&quot;,0Ah,00h</span><br><span class="line">sz_5  db &quot;In [0]: 64 16 10&quot;,0Ah,00h</span><br><span class="line">sz_6  db &quot;Out[0]: 100&quot;,0Ah,00h</span><br><span class="line">sz_7  db &quot;In [1]: c&quot;,0Ah,00h</span><br><span class="line">sz_8  db &quot;Out[1]: clear screen...&quot;,0Ah,00h</span><br><span class="line">sz_9  db &quot;In [2]: q&quot;,0Ah,00h</span><br><span class="line">sz_10 db &quot;Out[2]: good byte...&quot;,0Ah,00h</span><br><span class="line">sz_11 db &quot;--------------------------------------------&quot;,0Ah,00h</span><br><span class="line"></span><br><span class="line">sz_info1        db &quot;In [&quot;,00H</span><br><span class="line">sz_info2        db &quot;Out[&quot;,00H</span><br><span class="line">sz_format1      db &quot;%s%d]: &quot;,00H</span><br><span class="line">sz_format2      db &quot;%s&quot;,0AH,0AH,00H</span><br><span class="line">sz_Pause        db &quot;pause&quot;,00h</span><br><span class="line">sz_Cls          db &quot;cls&quot;,00h</span><br><span class="line">sz_goodbye      db &quot;good byte...&quot;,00h</span><br><span class="line">sz_inputwrong   db &quot;input wrong&quot;,00H</span><br><span class="line">sz_Hex          db &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXZ&quot;,00H</span><br><span class="line">sz_input db 128 dup(0)</span><br><span class="line">h_Output dd 0</span><br><span class="line">cnt_step dd 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">f_inputWrong proc</span><br><span class="line">    invoke crt_memset,offset sz_input,0,128</span><br><span class="line">    invoke crt_strcpy,offset sz_input,offset sz_inputwrong</span><br><span class="line">    ret</span><br><span class="line">f_inputWrong endp</span><br><span class="line"></span><br><span class="line">small_check proc uses esi ebx ecx,lp_cur:DWORD</span><br><span class="line"></span><br><span class="line">    LOCAL @bool_check1:DWORD</span><br><span class="line">    LOCAL @bool_check2:DWORD</span><br><span class="line">    LOCAL @bool_check3:DWORD</span><br><span class="line"></span><br><span class="line">    mov @bool_check1,0</span><br><span class="line">    mov @bool_check2,0</span><br><span class="line">    mov @bool_check3,0</span><br><span class="line"></span><br><span class="line">    mov esi,lp_cur</span><br><span class="line">    movzx eax,byte ptr [esi]</span><br><span class="line">    mov ebx,eax</span><br><span class="line"></span><br><span class="line">    mov eax,ebx</span><br><span class="line">    sub eax,030H</span><br><span class="line">    .if  eax &gt;=0</span><br><span class="line">        .if eax&lt;10</span><br><span class="line">            mov @bool_check1,1</span><br><span class="line">        .endif</span><br><span class="line">    .endif    </span><br><span class="line"></span><br><span class="line">    mov eax,ebx</span><br><span class="line">    sub eax,041H</span><br><span class="line">    .if  eax  &gt;=0</span><br><span class="line">        .if eax &lt;6</span><br><span class="line">            mov @bool_check2,1</span><br><span class="line">        .endif</span><br><span class="line">     .endif  </span><br><span class="line">     mov eax,ebx</span><br><span class="line">     sub eax,061H</span><br><span class="line">    .if  eax &gt;=0</span><br><span class="line">        .if eax &lt;6</span><br><span class="line">            mov @bool_check3,1</span><br><span class="line">        .endif</span><br><span class="line">    .endif</span><br><span class="line">    mov eax,@bool_check1</span><br><span class="line">    shl eax,2</span><br><span class="line">    mov ebx,@bool_check2</span><br><span class="line">    shl ebx,1</span><br><span class="line">    mov ecx,@bool_check3</span><br><span class="line">    or eax,ebx</span><br><span class="line">    or eax,ecx </span><br><span class="line">    ret</span><br><span class="line">small_check endp</span><br><span class="line"></span><br><span class="line">numToDec proc in_sz_param:DWORD , in_dw_base:DWORD , out_dw_Param:DWORD</span><br><span class="line">    LOCAL @sz_tmp[128]:BYTE</span><br><span class="line"></span><br><span class="line">    lea eax,@sz_tmp</span><br><span class="line">    invoke crt_memset,eax,0,128;memset(sz_tmp, 0, 128);</span><br><span class="line">    mov ebx,out_dw_Param</span><br><span class="line">    mov dword ptr [ebx],0 ; *out_dw_Param = 0;</span><br><span class="line">    </span><br><span class="line">    mov esi,in_sz_param</span><br><span class="line">    mov ecx,0</span><br><span class="line">    .while byte ptr [esi+ecx]!=0</span><br><span class="line">        mov ebx,esi </span><br><span class="line">        add ebx,ecx </span><br><span class="line">        invoke small_check,ebx </span><br><span class="line">        mov ebx,eax</span><br><span class="line"></span><br><span class="line">        mov eax,ebx</span><br><span class="line">        and eax,4 </span><br><span class="line">        .if eax !=0 ;数字</span><br><span class="line">            movzx eax,byte ptr [esi+ecx] </span><br><span class="line">            sub eax,030H</span><br><span class="line">            mov byte ptr [esi+ecx],al</span><br><span class="line">            jmp L4</span><br><span class="line">        .endif</span><br><span class="line"></span><br><span class="line">        mov eax,ebx</span><br><span class="line">        and eax,2</span><br><span class="line">        .if eax !=0 ;大字母</span><br><span class="line">            movzx eax,byte ptr [esi+ecx] </span><br><span class="line">            sub eax,037H</span><br><span class="line">            mov byte ptr [esi+ecx],al</span><br><span class="line">            jmp L4</span><br><span class="line">        .endif</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        mov eax,ebx</span><br><span class="line">        and eax,1</span><br><span class="line">        .if eax !=0 ;小写字谜</span><br><span class="line">            movzx eax,byte ptr [esi+ecx] </span><br><span class="line">            sub eax,057H</span><br><span class="line">            mov byte ptr [esi+ecx],al</span><br><span class="line">            jmp L4</span><br><span class="line">        .endif</span><br><span class="line">   </span><br><span class="line">   L4:</span><br><span class="line">        mov ebx,in_dw_base</span><br><span class="line">        .if eax&gt;=ebx</span><br><span class="line">            invoke f_inputWrong</span><br><span class="line">            ret </span><br><span class="line">        .endif</span><br><span class="line">        inc ecx</span><br><span class="line">    .endw</span><br><span class="line"></span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edx,edx</span><br><span class="line">    .while eax&lt;ecx</span><br><span class="line">        movzx ebx,byte ptr [esi+eax]</span><br><span class="line">        push eax</span><br><span class="line">        xor eax,eax</span><br><span class="line">        mov eax,edx</span><br><span class="line">        add eax,ebx</span><br><span class="line">        mov ebx,in_dw_base</span><br><span class="line">        mul ebx</span><br><span class="line">        mov edx,eax</span><br><span class="line">        pop eax </span><br><span class="line">        inc eax </span><br><span class="line">    .endw</span><br><span class="line">    mov eax,edx </span><br><span class="line">    xor edx,edx </span><br><span class="line">    div in_dw_base</span><br><span class="line">    mov ebx,out_dw_Param</span><br><span class="line">    mov dword ptr [ebx],eax </span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">numToDec endp</span><br><span class="line">;ExitProcess PROTO, dwExitCode:DWORD    </span><br><span class="line"></span><br><span class="line">DecToNum proc in_sz_param:DWORD, dw_src_base:DWORD,dw_dst_base:DWORD</span><br><span class="line"></span><br><span class="line">    LOCAL @sz_tmp[128]:BYTE</span><br><span class="line">    LOCAL @dw_tmp:DWORD</span><br><span class="line">    lea eax,@sz_tmp</span><br><span class="line">    invoke crt_memset, eax,0,128 ; memset(sz_tmp, 0, 128);</span><br><span class="line">    lea eax,@dw_tmp</span><br><span class="line">    invoke numToDec , in_sz_param,dw_src_base, eax ;numToDec(in_sz_param, dw_src_base, &amp;dw_tmp);//把第一个东西转化为10进制</span><br><span class="line">    .if @dw_tmp==0</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor ecx,ecx </span><br><span class="line">    mov edx,@dw_tmp</span><br><span class="line">    mov esi,offset sz_Hex</span><br><span class="line">    lea edi ,@sz_tmp</span><br><span class="line">    .while edx!=0</span><br><span class="line">        mov eax,edx</span><br><span class="line">        push edx</span><br><span class="line">        xor edx,edx</span><br><span class="line">        mov ebx,dw_dst_base </span><br><span class="line">        div ebx ;eax..edx</span><br><span class="line">        mov bl,byte ptr [esi+edx]</span><br><span class="line">        mov byte ptr [edi+ecx],bl</span><br><span class="line">        pop edx</span><br><span class="line">        mov edx,eax</span><br><span class="line">        inc ecx </span><br><span class="line">    .endw</span><br><span class="line">    push ecx</span><br><span class="line">    invoke crt_memset,offset sz_input ,0,128 ;memset(input, 0, 128);</span><br><span class="line">    pop ecx</span><br><span class="line">    lea esi ,@sz_tmp</span><br><span class="line">    mov edi ,offset sz_input</span><br><span class="line">    mov eax,0</span><br><span class="line">    .while eax&lt;ecx </span><br><span class="line">        mov ebx,ecx</span><br><span class="line">        dec ebx</span><br><span class="line">        sub ebx,eax</span><br><span class="line">        mov dl,byte ptr [esi+ebx] </span><br><span class="line">        mov ebx,eax</span><br><span class="line">        mov byte ptr [edi+eax],dl</span><br><span class="line">        inc eax</span><br><span class="line">    .endw</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">DecToNum endp</span><br><span class="line"></span><br><span class="line">weclome proc</span><br><span class="line"></span><br><span class="line">    invoke SetConsoleTextAttribute ,h_Output , 0DH</span><br><span class="line"></span><br><span class="line">    invoke crt_printf , offset sz_1</span><br><span class="line">    invoke crt_printf , offset sz_2</span><br><span class="line">    invoke crt_printf , offset sz_3</span><br><span class="line">    invoke crt_printf , offset sz_4</span><br><span class="line">    invoke crt_printf , offset sz_5</span><br><span class="line">    invoke crt_printf , offset sz_6</span><br><span class="line">    invoke crt_printf , offset sz_7</span><br><span class="line">    invoke crt_printf , offset sz_8</span><br><span class="line">    invoke crt_printf , offset sz_9</span><br><span class="line">    invoke crt_printf , offset sz_10</span><br><span class="line">    invoke crt_printf , offset sz_11</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">weclome endp</span><br><span class="line"></span><br><span class="line">f_Out proc</span><br><span class="line">    mov esi,offset sz_input</span><br><span class="line">    mov edi ,offset cnt_step</span><br><span class="line">    .if byte ptr [esi] != 00H</span><br><span class="line">        invoke SetConsoleTextAttribute,h_Output,0AH ;SetConsoleTextAttribute(h_Output, 0xA);</span><br><span class="line">        invoke crt_printf , offset sz_format1 , offset sz_info2, cnt_step ;printf(&quot;%s%d]: &quot;, sz_info2, cnt_step);</span><br><span class="line">        ;cnt_step++;</span><br><span class="line">        mov eax , dword ptr [edi]</span><br><span class="line">        inc eax</span><br><span class="line">        mov dword ptr [edi],eax</span><br><span class="line">        invoke SetConsoleTextAttribute,h_Output,0FH ;SetConsoleTextAttribute(h_Output, 0xF);</span><br><span class="line">        invoke crt_printf , offset sz_format2,offset sz_input ;printf(&quot;%s\n\n&quot;, input);</span><br><span class="line">    .endif</span><br><span class="line">    ret</span><br><span class="line">f_Out endp</span><br><span class="line"></span><br><span class="line">f_In proc</span><br><span class="line">    LOCAL @cnt:dword</span><br><span class="line"></span><br><span class="line">    LOCAL @num:dword</span><br><span class="line">    LOCAL @src_base:dword</span><br><span class="line">    LOCAL @dst_base:dword</span><br><span class="line"></span><br><span class="line">    LOCAL @lp_src_base:dword</span><br><span class="line">    LOCAL @lp_dst_base:dword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    invoke SetConsoleTextAttribute ,h_Output , 0AH ;SetConsoleTextAttribute(h_Output, 0xA);</span><br><span class="line">    invoke crt_printf , offset sz_format1, offset sz_info1, cnt_step ;printf(&quot;%s%d]: &quot;, sz_info1, cnt_step);</span><br><span class="line">    invoke SetConsoleTextAttribute ,h_Output , 0FH ;SetConsoleTextAttribute(h_Output, 0xF);</span><br><span class="line">    invoke crt_gets ,offset sz_input ;  fgets(input, 128, stdin);</span><br><span class="line"></span><br><span class="line">    mov esi,offset sz_input</span><br><span class="line">    .if  byte ptr [esi] == 071H ; q</span><br><span class="line">        invoke crt_memset,offset sz_input,0,128 ;memset(input, 0, 128);</span><br><span class="line">        invoke crt_strcpy ,offset sz_input ,offset sz_goodbye;strcpy(input, &quot;good bye...&quot;);</span><br><span class="line">        invoke f_Out;f_Out();</span><br><span class="line">        invoke SetConsoleTextAttribute ,h_Output , 0FH ;SetConsoleTextAttribute(h_Output, 0xF);</span><br><span class="line">        invoke crt_exit,0;exit(0);</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">    .if  byte ptr [esi] == 063H ; c</span><br><span class="line">        invoke crt_system ,offset sz_Cls;system(&quot;cls&quot;);</span><br><span class="line">        invoke crt_memset ,offset sz_input,0,128 ;memset(input, 0, 128);</span><br><span class="line">        invoke weclome;weclome();</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">    mov @cnt,1 ;mov     dword ptr [ebp-4], 1</span><br><span class="line">    mov ecx,0  </span><br><span class="line">    .while ecx&lt;128</span><br><span class="line">        mov ebx,esi </span><br><span class="line">        add ebx,ecx </span><br><span class="line"></span><br><span class="line">        invoke small_check,ebx</span><br><span class="line">        push eax</span><br><span class="line">        inc ebx</span><br><span class="line">        invoke small_check,ebx</span><br><span class="line">        push eax</span><br><span class="line"></span><br><span class="line">        mov ebx,esi </span><br><span class="line">        add ebx,ecx </span><br><span class="line">        inc ebx</span><br><span class="line"></span><br><span class="line">        mov eax,dword ptr [esp+4]</span><br><span class="line">        .if eax!=0</span><br><span class="line">            mov eax,dword ptr [esp]</span><br><span class="line">            .if eax==0</span><br><span class="line">                mov byte ptr [ebx],0 </span><br><span class="line">                .if @cnt==3</span><br><span class="line">                    .break</span><br><span class="line">                .endif</span><br><span class="line">            .endif</span><br><span class="line">        .endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mov eax,dword ptr [esp+4]</span><br><span class="line">        .if eax==0</span><br><span class="line">            mov eax,dword ptr [esp]</span><br><span class="line">            .if eax!=0</span><br><span class="line">                .if @cnt==1</span><br><span class="line">                    mov @lp_src_base,ebx</span><br><span class="line">                    mov ebx,@cnt </span><br><span class="line">                    inc ebx</span><br><span class="line">                    mov @cnt,ebx</span><br><span class="line">                    jmp L3</span><br><span class="line">                .endif</span><br><span class="line"></span><br><span class="line">                .if @cnt==2</span><br><span class="line">                    mov @lp_dst_base,ebx</span><br><span class="line">                    mov ebx,@cnt </span><br><span class="line">                    inc ebx</span><br><span class="line">                    mov @cnt,ebx</span><br><span class="line">                    jmp L3</span><br><span class="line">                .endif</span><br><span class="line">            .endif</span><br><span class="line">        .endif</span><br><span class="line">L3:</span><br><span class="line">        add esp,8</span><br><span class="line">        inc ecx</span><br><span class="line">    .endw</span><br><span class="line"></span><br><span class="line">    mov eax,0</span><br><span class="line">    .if @lp_dst_base ==0</span><br><span class="line">        jmp L1</span><br><span class="line">    .endif</span><br><span class="line">    .if @lp_src_base ==0</span><br><span class="line">        jmp L1 </span><br><span class="line">    .endif</span><br><span class="line">    jmp L2</span><br><span class="line">L1:</span><br><span class="line">    mov eax,1</span><br><span class="line">L2:</span><br><span class="line">    .if eax==1</span><br><span class="line">        invoke f_inputWrong</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    lea eax,@src_base</span><br><span class="line">    invoke numToDec ,@lp_src_base,10,eax;numToDec(lp_src_base, 10,&amp;src_base);</span><br><span class="line">    lea eax,@dst_base</span><br><span class="line">    invoke numToDec ,@lp_dst_base,10,eax;numToDec(lp_dst_base, 10,&amp;dst_base);</span><br><span class="line"></span><br><span class="line">    ;下面操作不是&amp;</span><br><span class="line">    .if @src_base &gt; 1</span><br><span class="line">        .if @src_base &lt;35</span><br><span class="line">            .if @dst_base &gt;1</span><br><span class="line">                .if @dst_base &lt;35</span><br><span class="line">                    invoke DecToNum , offset sz_input,@src_base,@dst_base</span><br><span class="line">                .endif</span><br><span class="line">            .endif</span><br><span class="line">        .endif</span><br><span class="line">    .else</span><br><span class="line">        invoke f_inputWrong</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">f_In endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ymain proc</span><br><span class="line">    invoke  GetStdHandle ,STD_OUTPUT_HANDLE</span><br><span class="line">    mov h_Output,eax</span><br><span class="line">    invoke  weclome</span><br><span class="line">    .while 1</span><br><span class="line">        invoke f_In</span><br><span class="line">        invoke f_Out</span><br><span class="line">    .endw</span><br><span class="line">    ret</span><br><span class="line">Ymain endp</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    invoke Ymain </span><br><span class="line">    ret</span><br><span class="line">end START</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>x86汇编语言实践部分</title>
    <url>/re4mile/2023/01/11/language/Asm/windwos/32/%E5%AE%9E%E8%B7%B5/language/</url>
    <content><![CDATA[<h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><h2 id="8086-exe"><a href="#8086-exe" class="headerlink" title="8086.exe"></a>8086.exe</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">;数据源S</span><br><span class="line">        data segment</span><br><span class="line">                        db 128 dup(&#x27;x&#x27;) </span><br><span class="line">        data ends  </span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">;栈段</span><br><span class="line">        stack segment stack</span><br><span class="line">                        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">        stack ends</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;main code  </span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">;数据源S</span><br><span class="line">						;为数据来源source分配大小</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax       </span><br><span class="line">;数据地D</span><br><span class="line">						;数据的目的地destation</span><br><span class="line">                        mov ax,7e00h</span><br><span class="line">                        mov es,ax        </span><br><span class="line">;栈</span><br><span class="line">						;申请了一段栈空间</span><br><span class="line">                        mov ax,stack</span><br><span class="line">                        mov ss,ax</span><br><span class="line">                        mov sp,128</span><br><span class="line">               </span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx       </span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">                        mov ax,4c00h;初始化内中段的参数</span><br><span class="line">                        int 21h;调用内中段</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx       </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">           </span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>对于上面的数据它是一个顺序结构的存储</p>
<p>也就是你的源代码数据怎么写,那么你的数据就怎么存储,好比你的data写在了code上面,那么的话IDA里面看到的也是</p>
<p>data在code上面</p>
<h2 id="386-exe"><a href="#386-exe" class="headerlink" title="386.exe"></a>386.exe</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib		user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib		kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">	A_Title			db	&#x27;My_First_Box !&#x27;,0</span><br><span class="line">	A_Text			db	&#x27;Hello,World !&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">;栈断分配一些数据</span><br><span class="line">.stack 1024</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">start:</span><br><span class="line">		invoke	MessageBox,	\</span><br><span class="line">		NULL,				\</span><br><span class="line">		offset A_Text,		\</span><br><span class="line">		offset A_Title,		\</span><br><span class="line">		MB_OK</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">    .386</span><br><span class="line">    .model flat,stdcall</span><br><span class="line">    option casemap:none</span><br><span class="line"></span><br><span class="line">include    windows.inc</span><br><span class="line">include    user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include    kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">szText		db  &#x27;HelloWorld&#x27;,0</span><br><span class="line">    .code</span><br><span class="line">start:</span><br><span class="line">    invoke	MessageBox,NULL,offset szText,NULL,MB_OK</span><br><span class="line">    invoke	ExitProcess,NULL</span><br><span class="line">    end		start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml -c -coff Helloworld.asm</span><br><span class="line">link -subsystem:windows He1loworld.obj</span><br></pre></td></tr></table></figure>

<p>-c 独立编译,而不进行链接</p>
<p>-coff 生产obj文件</p>
<p>movsx 有符号的复制语句,带一个符号的扩展</p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20221211234519517.png"></p>
<p><img src="https://re4mile.gitee.io/res/photo/language/image-20221211235222689.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"> </span><br><span class="line">.data</span><br><span class="line">szText1 db &quot;hello world&quot;,0Ah,00h</span><br><span class="line">szPause db &quot;pause&quot;,0Ah</span><br><span class="line">.code</span><br><span class="line"> </span><br><span class="line">testdd:</span><br><span class="line">	push offset szText1</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp,4</span><br><span class="line">	push offset szPause</span><br><span class="line">	call crt_system</span><br><span class="line">	add esp,4</span><br><span class="line">	ret</span><br><span class="line">end testdd</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="x86-ELF"><a href="#x86-ELF" class="headerlink" title="x86_ELF"></a>x86_ELF</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data		</span><br><span class="line">		A_str 	db	&quot;I am Dqx_Gh0st&quot;,10,0</span><br><span class="line">		format	db	&quot;%s&quot;,0</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .bss</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .text</span><br><span class="line">	</span><br><span class="line">extern		printf		</span><br><span class="line">;extern		func</span><br><span class="line">					</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line"></span><br><span class="line">			push	rbp</span><br><span class="line">			mov 	rbp,rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			mov		rax, 0	</span><br><span class="line">			mov   	rsi, A_str</span><br><span class="line">			mov		rdi, format	</span><br><span class="line">			call   	printf	         </span><br><span class="line">			       </span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">			leave</span><br><span class="line">			ret</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line"></span><br><span class="line">;func</span><br><span class="line">;参数</span><br><span class="line">;返回值</span><br><span class="line">;注意事项</span><br><span class="line"></span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public _start</span><br><span class="line">_start proc near</span><br><span class="line">; __unwind &#123;</span><br><span class="line">endbr64</span><br><span class="line">xor     ebp, ebp</span><br><span class="line">mov     r9, rdx         ; rtld_fini</span><br><span class="line">pop     rsi             ; argc</span><br><span class="line">mov     rdx, rsp        ; ubp_av</span><br><span class="line">and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">push    rax</span><br><span class="line">push    rsp             ; stack_end</span><br><span class="line">mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">mov     rdi, offset $_53_1_ ; main			//你自己函数入口是一以rdi的形式给了函数cs:__libc_start_main_ptr</span><br><span class="line">call    cs:__libc_start_main_ptr</span><br><span class="line">hlt</span><br><span class="line">; &#125; // starts at 401040</span><br><span class="line">_start endp</span><br></pre></td></tr></table></figure>









<h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>寻址公式一:[立即数]</p>
<p>寻址公式二:[reg] reg代表寄存器可以是8个通用寄存器中的任意一个</p>
<p>寻址公式三:[reg+立即数]</p>
<p>寻址公式四: [reg1+reg2*{1,2,4,8}]</p>
<p>寻址公式五:[reg1+reg2*{1,2,4,8}+立即数]</p>
<h1 id="子函数调用"><a href="#子函数调用" class="headerlink" title="子函数调用"></a>子函数调用</h1><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  SS:SP		数据			说明	</span><br><span class="line">0019FF54  12345678  立即数-局部变量</span><br><span class="line">0019FF58  00403000  .data:aSsssssssss-局部变量</span><br><span class="line">0019FF5C  41530000  字符串3-局部变量</span><br><span class="line">0019FF60  41414141  字符串2-局部变量</span><br><span class="line">0019FF64  45414141  字符串1-局部变量</span><br><span class="line">------------------------------------在子函数分配栈空间之前</span><br><span class="line">0019FF68  0019FF84  Stack[00003F3C]:0019FF84	|| EBP</span><br><span class="line">0019FF6C  00401009  start+9||IP</span><br><span class="line">0019FF70  0000000A  参数2-main变量</span><br><span class="line">0019FF74  00000064  参数1-main变量</span><br></pre></td></tr></table></figure>





<p>一个main函数栈的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">这里就是子函数栈的部分</span><br><span class="line"></span><br><span class="line">[esp+0]</span><br><span class="line"></span><br><span class="line">在这之间的栈是用来传递参数的</span><br><span class="line"></span><br><span class="line">[esp+40]:40个字节的字符串</span><br><span class="line">[esp+80]:float的浮点数</span><br><span class="line">[esp+84]:float计算结果</span><br><span class="line">[esp+88]:计算的的字符串长度</span><br><span class="line">[esp+92]:字符串的大小</span><br><span class="line">然而C语言的函数声明,我还不知道他怎么分配栈空间的</span><br><span class="line">    float weight, volume;</span><br><span class="line">    int   size, letters;</span><br><span class="line">    char  name[40];  </span><br></pre></td></tr></table></figure>





<h3 id="栈数据的获取-不是非要去pop来获取"><a href="#栈数据的获取-不是非要去pop来获取" class="headerlink" title="栈数据的获取(不是非要去pop来获取)"></a>栈数据的获取(不是非要去pop来获取)</h3><p>每次push一下</p>
<p>sp就会向上移动减少</p>
<p>如果你取栈数据</p>
<p>[sp]其实他会向下的方向获取一个type的数据</p>
<p>栈里的数据是取出时从低位到高位拿出</p>
<p>好比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ax</span><br><span class="line">mov  bp,sp</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">mov bx,ss:[bp]</span><br></pre></td></tr></table></figure>

<p>这样的话,你是可以获取数据ax的</p>
<p>这里的bp也给你记录了位置</p>
<p>但是我们通常不会去改变ebp的值</p>
<h3 id="不要随性的push-与-pop"><a href="#不要随性的push-与-pop" class="headerlink" title="不要随性的push 与 pop"></a>不要随性的push 与 pop</h3><p>你一定要记住,不要随性的push</p>
<p>push的东西也是有讲究的</p>
<p>你要用它,你要临时保存它,你才会去push</p>
<p>否者的话,当你要用的时候,pop的东西,又不是你想要的</p>
<h3 id="联合使用push与pop"><a href="#联合使用push与pop" class="headerlink" title="联合使用push与pop"></a>联合使用push与pop</h3><p>数据的传递</p>
<p>通常是</p>
<p>mov ax,ds:[si]</p>
<p>mov es:[di],ax</p>
<p>我们也可以这样</p>
<p>push ax:[si]</p>
<p>pop   es:[di]</p>
<h3 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h3><p>16位栈指针sp&#x2F;bp</p>
<p>32位指针esp&#x2F;ebp</p>
<p>64位rsp&#x2F;rbp</p>
<h4 id="push-x2F-pop"><a href="#push-x2F-pop" class="headerlink" title="push&#x2F;pop"></a>push&#x2F;pop</h4><p>esp指向了当前的数据,</p>
<p>如果再push</p>
<p>数据会放在esp的下一个</p>
<p>esp然后-4</p>
<p>不是说x86的sp一定是+或-4</p>
<p>当push 16位数据就sp-2</p>
<p>当push 32位数据就是sp-4</p>
<p>当push 立即数,默认就是sp-4</p>
<p>不能push 8位数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax                                                                                                                                                                                        </span><br><span class="line">;mov al,10</span><br><span class="line">;push al</span><br><span class="line">mov  ax,10</span><br><span class="line">push ax</span><br><span class="line">mov eax,10</span><br><span class="line">push eax</span><br><span class="line"></span><br><span class="line">pop eax</span><br><span class="line">pop ax</span><br></pre></td></tr></table></figure>







<p>一些异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push eax</span><br><span class="line">pop  ax</span><br></pre></td></tr></table></figure>

<p>push 进一个32位,esp-&#x3D;4</p>
<p>pop  出一个16位,esp+&#x3D;2</p>
<p>这导致堆栈不平衡</p>
<h4 id="pushfd-x2F-popfd"><a href="#pushfd-x2F-popfd" class="headerlink" title="pushfd&#x2F;popfd"></a>pushfd&#x2F;popfd</h4><p>可以对比一下8086的pushf与popf..然后就明白了</p>
<p>它到底push了啥????</p>
<p>EFL有些啥????</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">0</th>
<th align="center"></th>
<th align="center">0</th>
<th align="center"></th>
<th align="center">1</th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">高位左边</td>
<td align="center">IF</td>
<td align="center">TF</td>
<td align="center">SF</td>
<td align="center">ZF</td>
<td align="center">0</td>
<td align="center">AF</td>
<td align="center">0</td>
<td align="center">PF</td>
<td align="center">1</td>
<td align="center">CF</td>
<td align="center">低位右边</td>
</tr>
</tbody></table>
<p>如何用专门的变量保存EFL以供使用?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">recive dd 0</span><br><span class="line">.code</span><br><span class="line">	pushfd</span><br><span class="line">	pop recive;得是一个32位的接收者</span><br></pre></td></tr></table></figure>





<h4 id="pushad-x2F-popad-x2F-pusha-x2F-popa"><a href="#pushad-x2F-popad-x2F-pusha-x2F-popa" class="headerlink" title="pushad&#x2F;popad&#x2F;pusha&#x2F;popa"></a>pushad&#x2F;popad&#x2F;pusha&#x2F;popa</h4><p>把所有寄存器入栈出栈</p>
<p>对于pusha&#x2F;popa是针对16位数据的寄存器</p>
<p>push什么? AX,CX,DX,BX,.SP,BP,SI,DI</p>
<p>pop就是一个逆序</p>
<p>对于pushad是针对32位数据的寄存器</p>
<p>push&#x2F;pop同理</p>
<p>使用的注意事项,一个函数的返回值用一个寄存器来作为接收者,你用了pushad&#x2F;popad会把返回值给覆盖了,返回无效</p>
<h4 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h4><p>我们之前会有一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,20</span><br><span class="line">....</span><br><span class="line">然后leave</span><br></pre></td></tr></table></figure>



<p>首先我们要明确,函数栈的开辟我们不一定会把局部变量给全部使用完..所以esp要回到起点!也就是恢复到进来的时候!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>



<p>进来push ebp,mov ebp,esp</p>
<p>出去 mov esp,ebp,pop ebp</p>
<p>进来,ebp要发生变化,esp要指向新的栈顶</p>
<p>出去,esp要恢复,ebp要还原</p>
<p>如果在x86的模式下,我们源码用ret</p>
<p>在IDA就会生成leave</p>
<p>如果源码写为</p>
<p>mov esp,epb</p>
<p>pop ebp</p>
<p>retn</p>
<p>就不会出现leave</p>
<h4 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h4><p>与leave相对应</p>
<p>enter出现在子函数的开头部分</p>
<p>enter有2个参数,都是立即数</p>
<p>参数一时开辟的字节数,得是4的倍数,有利于寻址</p>
<p>参数二,就写0,以后遇到再说吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter 12,0</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov esp,ebp</span><br><span class="line">sub ebp,12</span><br></pre></td></tr></table></figure>



<p>关于enter与leave的应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	call	my</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">	my	proc</span><br><span class="line">		enter	12,0</span><br><span class="line"></span><br><span class="line">		mov	dword ptr [ebp-4],10</span><br><span class="line">		mov	dword ptr [ebp-8],20</span><br><span class="line">		mov	esp,ebp</span><br><span class="line"></span><br><span class="line">		leave</span><br><span class="line">		ret</span><br><span class="line">	my	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun proc near</span><br><span class="line"></span><br><span class="line">var_8= dword ptr -8</span><br><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">enter   0Ch, 0</span><br><span class="line">mov     [ebp+var_4], 0Ah</span><br><span class="line">mov     [ebp+var_8], 14h</span><br><span class="line">mov     esp, ebp</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">fun endp</span><br></pre></td></tr></table></figure>





<h4 id="8086栈指令"><a href="#8086栈指令" class="headerlink" title="8086栈指令"></a>8086栈指令</h4><h5 id="pushf-x2F-popf"><a href="#pushf-x2F-popf" class="headerlink" title="pushf&#x2F;popf"></a>pushf&#x2F;popf</h5><p>就是对所有的flag寄存器给push一下或者pop一下</p>
<p>它会把8位的二进制寄存器合成2位的16进制然后出入栈</p>
<h5 id="pusha-x2F-popa"><a href="#pusha-x2F-popa" class="headerlink" title="pusha&#x2F;popa"></a>pusha&#x2F;popa</h5><p>x86说16位可以pusha&#x2F;popa,但是我试了一下,好像不可以</p>
<h3 id="栈维护"><a href="#栈维护" class="headerlink" title="栈维护"></a>栈维护</h3><h4 id="用uses临时创建变量"><a href="#用uses临时创建变量" class="headerlink" title="用uses临时创建变量"></a>用uses临时创建变量</h4><p>关于uses和[ebp+8]</p>
<p>uses指令的顺序先于push ebp,mov ebp,esp</p>
<p>所以的话,</p>
<p>你的[ebp+8]就不再是传入的第一个参数</p>
<p>[ebp+8+N],N是你是你传入的那些参数,具体遇到再说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;func proto	:byte,:byte</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line">start:</span><br><span class="line">	call	func</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">func PROC	uses	eax ebx</span><br><span class="line">		mov	eax,1</span><br><span class="line">		mov	ebx,2</span><br><span class="line">		ret</span><br><span class="line">func ENDP</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<p>关于uses的变量内部入栈,他在内部平衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func proc near</span><br><span class="line">push    eax</span><br><span class="line">push    ebx</span><br><span class="line">mov     eax, 1</span><br><span class="line">mov     ebx, 2</span><br><span class="line">pop     ebx</span><br><span class="line">pop     eax</span><br><span class="line">retn</span><br><span class="line">func endp</span><br></pre></td></tr></table></figure>



<h4 id="用local创建变量"><a href="#用local创建变量" class="headerlink" title="用local创建变量"></a>用local创建变量</h4><p>它的特点就是</p>
<p>栈空间的申请是内部<code>add esp,负数</code></p>
<p>然后栈的平衡内部是mov esp,ebp,pop ebp</p>
<p>也就是一个leave就解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line">arr1	db	16 dup(&#x27;s&#x27;)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line">start:	</span><br><span class="line">	call	func</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">func	proc</span><br><span class="line">	local	x[10]:byte</span><br><span class="line">	local	y:ptr byte</span><br><span class="line">	mov	byte ptr x[9],6</span><br><span class="line">	mov	byte ptr x[0],3</span><br><span class="line">	mov	y,offset arr1</span><br><span class="line">	ret</span><br><span class="line">func	endp</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Attributes: bp-based frame</span><br><span class="line"></span><br><span class="line">fun proc near</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">add     esp, 0FFFFFFF0h</span><br><span class="line">mov     byte ptr [ebp-1], 6</span><br><span class="line">mov     byte ptr [ebp-10], 3</span><br><span class="line">mov     dword ptr [ebp-16], offset aSsssssssssssss ; &quot;ssssssssssssssss&quot;</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">fun endp</span><br></pre></td></tr></table></figure>

<p>可以看到,我创建了14字节</p>
<p>它给我分配了16字节</p>
<p>关于local建立的变量,他的本质是一个push,先push谁,取决于你先写谁</p>
<h4 id="invoke-和调用约定"><a href="#invoke-和调用约定" class="headerlink" title="invoke 和调用约定"></a>invoke 和调用约定</h4><p>都是实现push,然后call</p>
<p>参数的传递在子函数栈空间的下方</p>
<p>内部平衡就<code>retn xx</code></p>
<p>外部平衡就<code>add esp,xx</code></p>
<table>
<thead>
<tr>
<th>调用约定</th>
<th>参数压栈顺序</th>
<th>平衡堆栈</th>
</tr>
</thead>
<tbody><tr>
<td>__cdecl</td>
<td>从右至左入栈</td>
<td>调用者清理栈</td>
</tr>
<tr>
<td>__stdcall</td>
<td>从右至左入栈</td>
<td>自身清理堆栈</td>
</tr>
<tr>
<td>__fastcall</td>
<td>ECX&#x2F;EDX传送前两个剩下:从右至左入栈</td>
<td>自身清理堆栈</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl Plus(int a, int b)				</span><br><span class="line">&#123;				</span><br><span class="line">	return a+b;			</span><br><span class="line">&#125;				</span><br><span class="line">				</span><br><span class="line">push        2				</span><br><span class="line">push        1				</span><br><span class="line">call        @ILT+15(Plus) (00401014)				</span><br><span class="line">add         esp,8				</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、int __stdcall Plus(int a, int b)				</span><br><span class="line">&#123;				</span><br><span class="line">	return a+b;			</span><br><span class="line">&#125;				</span><br><span class="line">				</span><br><span class="line">push        2				</span><br><span class="line">push        1				</span><br><span class="line">call        @ILT+10(Plus) (0040100f)				</span><br><span class="line">				</span><br><span class="line">函数内部：				</span><br><span class="line">				</span><br><span class="line">ret         8				</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">					</span><br><span class="line">3、int __fastcall Plus(int a, int b)					</span><br><span class="line">&#123;					</span><br><span class="line">	return a+b;				</span><br><span class="line">&#125;					</span><br><span class="line">					</span><br><span class="line">mov         edx,2					</span><br><span class="line">mov         ecx,1					</span><br><span class="line">call        @ILT+0(Plus) (00401005)					</span><br><span class="line">					</span><br><span class="line">函数内部：					</span><br><span class="line">					</span><br><span class="line">ret </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   4、int __fastcall Plus4(int a, int b,int c,int d)					</span><br><span class="line">&#123;					</span><br><span class="line">	return a+b+c+d;				</span><br><span class="line">&#125;					</span><br><span class="line">					</span><br><span class="line">push        4					</span><br><span class="line">push        3					</span><br><span class="line">mov         edx,2					</span><br><span class="line">mov         ecx,1					</span><br><span class="line">call        @ILT+5(Plus) (0040100a)					</span><br><span class="line">					</span><br><span class="line">函数内部：					</span><br><span class="line">					</span><br><span class="line">ret         8					</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>所以,如果根据<code>ret 8</code>是无法直接判断有几个参数</p>
<p>因为可能是fastcall</p>
<p>如果你直接看出了一个函数有几个参数,</p>
<p>那些参数也有可能不是当前call</p>
<p>也可能是内嵌call的</p>
<p>所以如何看一个函数用了多少个参数?</p>
<p>(0).不用管是什么调用约定</p>
<p>(1). 看函数内部用了哪些对应的内存和寄存器</p>
<p>(2). 结合最后ret n的n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">;c_var1		dd	10</span><br><span class="line">;c_var2		dd	20</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line"></span><br><span class="line">		sub1	proto	C,:DWORD,:DWORD</span><br><span class="line">		sub2	proto	StdCall,:DWORD,:DWORD</span><br><span class="line">		sub3	proto	sysCall,:DWORD,:DWORD</span><br><span class="line">		sub4	proto	PASCAl,:DWORD,:DWORD</span><br><span class="line">		sub5	proto	BASIC,:DWORD,:DWORD</span><br><span class="line">		sub6	proto	fortran,:DWORD,:DWORD</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		xor eax,eax</span><br><span class="line"></span><br><span class="line">		invoke  sub1,1,2</span><br><span class="line">		invoke  sub2,1,2</span><br><span class="line">		invoke  sub3,1,2</span><br><span class="line">		invoke  sub4,1,2</span><br><span class="line">		invoke  sub5,1,2</span><br><span class="line">		invoke  sub6,1,2</span><br><span class="line"></span><br><span class="line">		push 0</span><br><span class="line">		call ExitProcess</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		sub1	proc	C,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub1	endp</span><br><span class="line">		</span><br><span class="line">		sub2	proc	StdCall,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub2	endp;在内部 retn 8,他们是在外部add esp,8</span><br><span class="line">		</span><br><span class="line">		sub3	proc	sysCall,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub3	endp</span><br><span class="line"></span><br><span class="line">		sub4	proc	PASCAl,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub4	endp</span><br><span class="line"></span><br><span class="line">		sub5	proc	BASIC,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub5	endp</span><br><span class="line"></span><br><span class="line">		sub6	proc	fortran,c_var1,c_var2</span><br><span class="line">				mov	eax,c_var1</span><br><span class="line">				mov	ebx,c_var2</span><br><span class="line">				ret</span><br><span class="line">		sub6	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>







<h4 id="x64栈对齐"><a href="#x64栈对齐" class="headerlink" title="x64栈对齐"></a>x64栈对齐</h4><p>栈帧是一个过程</p>
<p>好比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push pbp</span><br><span class="line">mov  rbp,rsp</span><br><span class="line"></span><br><span class="line">mov rsp,rbp</span><br><span class="line">pop rbp</span><br></pre></td></tr></table></figure>

<p>为什么需要这2个东西</p>
<p>我们得知道一个函数栈的建立是不会触及栈底rbp的修改的,那为什么还要push rbp呢????</p>
<p>这就是一个16字节的栈对齐了</p>
<p>一些函数的约定或者是个啥要求栈的地址必须是16的倍数</p>
<p>对于x64而言,push一下就是8字节</p>
<p>对于一个函数的调用</p>
<p>call一下8字节</p>
<p>push rbp 8字节</p>
<p>这几构成了16字节,达到了16字节对齐</p>
<p>还有一种栈对齐的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and rsp , 0xfffffffffffffff0 ; 16 byte align the stack</span><br></pre></td></tr></table></figure>





<h2 id="堆栈图"><a href="#堆栈图" class="headerlink" title="堆栈图"></a>堆栈图</h2><p><img src="F:\5008\GItee\res\photo\language\image-20230109154923684.png" alt="image-20230109154923684"></p>
<p>就代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP ,ESP</span><br><span class="line">SUB ESP,4B</span><br><span class="line">------这3个push是保护现场的</span><br><span class="line">PUSH EBX</span><br><span class="line">PUSH ESI</span><br><span class="line">PUSH EDI </span><br><span class="line">LEA EDI,DwoRD PTR SS: [EBP一40]</span><br><span class="line">mov Ecx,10</span><br><span class="line">mov EAx,ccccccCc ;之所以写0xCC,是为了防止缓冲区溢出,跑去0xcc那里执行</span><br><span class="line">REP Stos DwORD PTR ES:[EDI]</span><br><span class="line"></span><br><span class="line">----------------------------------------------上面的操作好比以炒菜前的准备</span><br><span class="line"></span><br><span class="line">MOV EAx,DwORD PTR SS: [ EBp+8 ]</span><br><span class="line">ADD EAx, DwoRD PTR SS:[EBP+C]</span><br><span class="line"></span><br><span class="line">----------------------------------------------下面的操作就像是炒菜后的刷锅</span><br><span class="line">PoP EDI</span><br><span class="line">POP ESI</span><br><span class="line">POP EBx</span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>



<p>所以你把char给传递进去,其实是被扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func(char x,char y)</span><br></pre></td></tr></table></figure>

<p>所以传递1&#x2F;2个字节的参数都会被转化为4字节</p>
<p>为什么要扩展?因为效率的原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char i 他会分配4个字节给i</span><br><span class="line">char o[2] 他会分配4个字节</span><br><span class="line">char p[7] 他会分配8个字节</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><p>它只是属于masm32的伪指令,不具有移植性</p>
<p>用法</p>
<p>invoke 函数名 参数1 参数2 参数3</p>
<p>&#x2F;&#x2F;参数的个数由函数确定</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br></pre></td></tr></table></figure>

<p>假设是stdcall的调用方式</p>
<p>你在invoke写的正序</p>
<p>入栈的时候是逆序</p>
<p>invoke 不能用addr,只能offset,为什么????</p>
<p>注意事项</p>
<p>如果你的参数是小于32位的寄存器eax&#x2F;edx,最后invoke会有一个扩展到32位,使得数据的丢失</p>
<p>如果数据重要,你就把他保存一下</p>
<p>还有一个东西巨坑,我们之前说过,我们不能push一个8位的数据,所以你不能传入一个字节的东西,除非强制类型转化</p>
<p>于是invoke是不能带有8位的参数的,否则就无法识别</p>
<h3 id="addr"><a href="#addr" class="headerlink" title="addr"></a>addr</h3><p>取地址的操作</p>
<p>对于全局变量</p>
<p>addr会转化为offset</p>
<p>对于局部变量</p>
<p>addr会转化为lea指令</p>
<p>addr怎么用,我好不懂</p>
<p>见&lt;&lt;琢石成器&gt;&gt;.Page76</p>
<p>addr&#x3D;&#x3D;只能和invoke&#x3D;&#x3D;一起用</p>
<p>addr的参数只能是常熟,不能是变量?????</p>
<h3 id="proc-x2F-endp-函数声明"><a href="#proc-x2F-endp-函数声明" class="headerlink" title="proc &#x2F;endp 函数声明"></a>proc &#x2F;endp 函数声明</h3><p>在8086里面,我们定义一个函数直接是标号就🆗</p>
<p>在x86下,我们是定义一个函数的是定义一个过程,称之为函数的声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数的名字 	 proc [ 距离] [ 调用方式 ] [可视区域] [uses 寄存器列表] [参数名称:参数类型,参数名称:参数类型] [vararg]</span><br><span class="line">		 	local 局部变量</span><br></pre></td></tr></table></figure>

<p>请写明参数的类型,否则将无法识别,或者偷鸡摸狗耍小聪明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main proc</span><br><span class="line">				call func1</span><br><span class="line">                push    0       </span><br><span class="line">                call    j_ExitProcess</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">fucn1 proc</span><br><span class="line">				ret</span><br><span class="line">func1 endp</span><br></pre></td></tr></table></figure>









<h3 id="proto-函数声明"><a href="#proto-函数声明" class="headerlink" title="proto 函数声明"></a>proto 函数声明</h3><p>类比C语言,它是一个函数的声明</p>
<p>用法 ,参考proc</p>
<p>好比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageBox Proto :dword, :dword,:dword,:dword,</span><br></pre></td></tr></table></figure>

<p>通常这样写是的等价的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageBox Proto hwnd:dword, text:dword,title:dword,Type:dword,</span><br></pre></td></tr></table></figure>



<p>使用例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub2	proto	StdCall,:DWORD,:DWORD</span><br><span class="line">invoke  sub2,1,2</span><br><span class="line">sub2	proc	StdCall,c_var1:DWORD,c_var2:DWORD</span><br><span class="line">mov	eax,c_var1</span><br><span class="line">mov	ebx,c_var2</span><br><span class="line">ret</span><br><span class="line">sub2	endp;在内部 retn 8,他们是在外部add esp,8</span><br></pre></td></tr></table></figure>



<p>作用1:外部声明</p>
<p>作用2:检查参数列表,proc与proto是否一致</p>
<h3 id="extern-函数声明"><a href="#extern-函数声明" class="headerlink" title="extern 函数声明"></a>extern 函数声明</h3><p>怎么用,遇到再说</p>
<h3 id="inlcudelib-导入库"><a href="#inlcudelib-导入库" class="headerlink" title="inlcudelib 导入库"></a>inlcudelib 导入库</h3><p>8086的汇编,在调用中断时,我们只需要int一个编号就可以寻址</p>
<p>可能是因为中断不多,,,,</p>
<p>在win32-API中,类似的int很多,,,,我在这里称之为dll文件…根据不同的函数实现要求..我们的obj要选取不同的dll文件</p>
<p>此时就需要include来调用dll</p>
<h3 id="uses-伪指令-一个入栈的操作"><a href="#uses-伪指令-一个入栈的操作" class="headerlink" title="uses 伪指令,一个入栈的操作"></a>uses 伪指令,一个入栈的操作</h3><p>uses连接的东西是没有逗号的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func_sum PROC		uses ecx  esi</span><br><span class="line"></span><br><span class="line">					xor eax,eax</span><br><span class="line">	sum_loop:</span><br><span class="line">					add al,[esi]</span><br><span class="line">					add esi,type arr1</span><br><span class="line">					loop sum_loop</span><br><span class="line">					ret</span><br><span class="line">func_sum ENDP</span><br></pre></td></tr></table></figure>

<p>在IDA里面就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_0 proc near</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     ecx, 10</span><br><span class="line">mov     esi, offset unk_384000</span><br><span class="line">call    sub_382051</span><br><span class="line">mov     byte_38400A, al</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    j_ExitProcess</span><br><span class="line">start_0 endp</span><br></pre></td></tr></table></figure>





<p>你可以把这个C代码翻译为汇编看看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Dqx+Gh0st&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x2=<span class="number">4</span>,y2=<span class="number">5</span>,z2=<span class="number">6</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">10</span>]=<span class="string">&quot;Dqx&quot;</span>;</span><br><span class="line">	<span class="built_in">puts</span>(str); </span><br><span class="line"> 	func(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> w)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x3=<span class="number">1</span>,y3=<span class="number">2</span>,z3=<span class="number">3</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,x3,y3,z3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public _main</span><br><span class="line">_main proc near</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">sub     esp, 30h</span><br><span class="line">call    ___main</span><br><span class="line">mov     dword ptr [esp+44], 4</span><br><span class="line">mov     dword ptr [esp+40], 5</span><br><span class="line">mov     dword ptr [esp+36], 6</span><br><span class="line">//上面分别是你在main函数定义的变量</span><br><span class="line">mov     dword ptr [esp+26], 787144h</span><br><span class="line">//这是你在main函数定义的字符串,你的字符串是10个字节,前3个字节被初始化了,也就是787144h</span><br><span class="line">//它用4字节的dword装下了你的3字节字符串</span><br><span class="line">//剩下了6字节,用了dword与word来初始化为0</span><br><span class="line">mov     dword ptr [esp+30], 0</span><br><span class="line">mov     word ptr [esp+34], 0</span><br><span class="line">mov     dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot;</span><br><span class="line">//对于全局变量他用offset取地址</span><br><span class="line">//mov     dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot;==push dword ptr [esp]</span><br><span class="line">call    _puts</span><br><span class="line">mov     dword ptr [esp], 64h ; &#x27;d&#x27; ; w</span><br><span class="line">/方式对[esp]操作的都==push xxxx</span><br><span class="line">call    _func</span><br><span class="line">mov     eax, 0</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">_main endp</span><br></pre></td></tr></table></figure>

<p>进入子函数,前面已经传入参数了,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public _func</span><br><span class="line">_func proc near</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     esp, 28h</span><br><span class="line">mov     dword ptr [ebp-12], 1</span><br><span class="line">mov     dword ptr [ebp-16], 2</span><br><span class="line">mov     eax, [ebp+8]</span><br><span class="line">mov     [esp+12], eax</span><br><span class="line">mov     eax, [ebp-16]</span><br><span class="line">mov     [esp+8], eax</span><br><span class="line">mov     eax, [ebp-12]</span><br><span class="line">mov     [esp+4], eax</span><br><span class="line">mov     dword ptr [esp], offset Format ; &quot;%d %d %d&quot;</span><br><span class="line">call    _printf</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">_func endp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下级函数栈</span><br><span class="line">//EBP</span><br><span class="line">//IP</span><br><span class="line">//------------上级函数栈</span><br><span class="line">//参数1</span><br><span class="line">//参数2</span><br></pre></td></tr></table></figure>

<p>所以的话,传入的参数都是通过ebp+8开始,是第一个参数</p>
<h3 id="local-定义局部变量"><a href="#local-定义局部变量" class="headerlink" title="local 定义局部变量"></a>local 定义局部变量</h3><p>local创建的变量是不可传递的参数,只能在函数内部使用</p>
<p>另外局部变量不能和形式参数同名</p>
<p>local定义的类型在函数声明proc后,在程序执行CS:IP之前</p>
<p>local在win32模式下,默认数据的长度是32位的dd,如果主观的定义一个32位的的数据长度,我们是不需要指出数据长度的</p>
<p>local不支持和dup指令一起使用…</p>
<p>local变量肯定不是在data区,它是在栈区</p>
<p>相比于proc的函数参数列表声明,它可以在invoke的时候传入参数的</p>
<p>现在有个问题,如果invoke只是一个call与push,那么我们是可以通过local来接受传递过来的参数的</p>
<p>也就是好比这个意思</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> y=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是局部变量y就接受了传递过来的参数</p>
<p>local 是enter与leave的高级版</p>
<p>用local会自动在最后使用leave指令,就不用你去手动的释放,最后再ret</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func proc</span><br><span class="line">	local arr[16]:byte</span><br><span class="line">	local Num</span><br><span class="line">	;local unk:WNDCLASS</span><br><span class="line">	xor eax,eax</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>



<p>然后利用local变量得到的数据不适用于一些指令</p>
<p>对于上面的代码在IDA的显示是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">add     esp, 0FFFFFFECh</span><br><span class="line">mov     eax, [ebp+var_14]</span><br></pre></td></tr></table></figure>

<p>0FFFFFFECh的绝对值是20,也就是16+4的长度</p>
<p>其实我们用<code>sub esp,20</code>会更加的形象</p>
<p>注意不可对局部变量取地址,我也不知道为什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func proc</span><br><span class="line"></span><br><span class="line">	local arr[16]:byte</span><br><span class="line">	local Num	</span><br><span class="line">	;mov	esi,offset arr</span><br><span class="line">	;mov	esi,lea arr</span><br><span class="line">	;mov	esi,arr</span><br><span class="line">	mov eax,Num</span><br></pre></td></tr></table></figure>



<p>上面被注释的指令都是不合法的!!!!!!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	call	my</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">	my	proc</span><br><span class="line">		local	arr[10]:word</span><br><span class="line">		ret</span><br><span class="line">	my	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>

<p>在IDA里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Attributes: bp-based frame</span><br><span class="line"></span><br><span class="line">fun proc near</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">add     esp, 0FFFFFFECh</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">fun endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="lahf-x2F-sahf"><a href="#lahf-x2F-sahf" class="headerlink" title="lahf&#x2F;sahf"></a>lahf&#x2F;sahf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lahf 把寄存器的低8位给了ah</span><br><span class="line">sahf 把ah给了寄存器的低8位</span><br></pre></td></tr></table></figure>



<h2 id="变量声明与初始化-x2F-存储位置"><a href="#变量声明与初始化-x2F-存储位置" class="headerlink" title="变量声明与初始化&#x2F;存储位置"></a>变量声明与初始化&#x2F;存储位置</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量在data区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00403004                 public _str</span><br><span class="line">.data:00403004 ; char str[]</span><br><span class="line">.data:00403004 _str            db &#x27;Dqx+Gh0st&#x27;,0        ; DATA XREF: _main+26↑o</span><br><span class="line">.data:0040300E                 align 10h			</span><br><span class="line">.data:00403010                 public __charmax</span><br><span class="line">.data:00403010 ; int _charmax</span><br><span class="line">.data:00403010 __charmax       dd 255</span><br></pre></td></tr></table></figure>

<p>可以看到.数据在data区域</p>
<p>我定义的数组长度是10,然后它<code> align 10h</code>进行了10字节对齐</p>
<p>main函数定义的变量只能在main区域使用,也叫局部变量</p>
<p>在函数外定义的变量才叫全局变量,不知道说对了没有</p>
<p>全局变量的调用,一是去data区取地址,用esp把地址放在栈区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     dword ptr [esp], offset _str ; &quot;Dqx+Gh0st&quot;</span><br></pre></td></tr></table></figure>

<h3 id="main变量"><a href="#main变量" class="headerlink" title="main变量"></a>main变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">4</span>,y=<span class="number">5</span>,z=<span class="number">6</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">15</span>]=<span class="string">&quot;Dqx-20019&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>32位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//int的初始化</span><br><span class="line">mov     dword ptr [esp+44], 4</span><br><span class="line">mov     dword ptr [esp+40], 5</span><br><span class="line">mov     dword ptr [esp+36], 6</span><br><span class="line">//字符串初始化</span><br><span class="line">mov     dword ptr [esp+21], 2D787144h</span><br><span class="line">mov     dword ptr [esp+25], 31303032h</span><br><span class="line">mov     dword ptr [esp+29], 39h ; &#x27;9&#x27;</span><br><span class="line">mov     word ptr [esp+33], 0</span><br><span class="line">mov     byte ptr [esp+35], 0</span><br><span class="line">//可以看到数据放在了.text区域</span><br><span class="line">//然后放在了esp高栈位</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea     eax, [esp+21]</span><br><span class="line">mov     [esp], eax      ; Format</span><br><span class="line">call    _printf</span><br><span class="line">//数据的使用就放在了低栈位</span><br></pre></td></tr></table></figure>

<p>64位</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>[ebp-n]的为局部变量</p>
<h3 id="x64的局部变量声明"><a href="#x64的局部变量声明" class="headerlink" title="x64的局部变量声明"></a>x64的局部变量声明</h3><p>好比这样一个子函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">circle:</span><br><span class="line"></span><br><span class="line">	section .data</span><br><span class="line">		.fmt_area	db	&quot;The area is %f&quot;,10,0</span><br><span class="line">		.fmt_circum	db	&quot;The circumference is %f&quot;,10,0</span><br><span class="line">		</span><br><span class="line">	section .text</span><br><span class="line">	</span><br><span class="line">	push rbp</span><br><span class="line">	mov rbp, rsp	</span><br><span class="line">	</span><br><span class="line">		call area	</span><br><span class="line">		mov	rdi,.fmt_area</span><br><span class="line">		mov	rax,1			; area in xmm0</span><br><span class="line">		call printf</span><br><span class="line">		call circum</span><br><span class="line">		mov	rdi,.fmt_circum</span><br><span class="line">		mov	rax,1			; circumference in xmm0</span><br><span class="line">		call printf</span><br><span class="line">		</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>局部变量的名字带有一个点<code>.</code></p>
<p>在section .data声明</p>
<p>然后不要忘记section .text写代码</p>
<h2 id="子函数的使用"><a href="#子函数的使用" class="headerlink" title="子函数的使用"></a>子函数的使用</h2><h3 id="为什么有子函数这个东西"><a href="#为什么有子函数这个东西" class="headerlink" title="为什么有子函数这个东西"></a>为什么有子函数这个东西</h3><p>使用子程序</p>
<p>为什么使用子程序?就好比为什么使用函数一样?</p>
<p>当一个过程..</p>
<p>①,比较繁琐</p>
<p>②.需要移植到很多处地方重复使用</p>
<p>那么我们就把它封装为一个函数</p>
<p>一个简单的函数栈建立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	call	my</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">	my	proc</span><br><span class="line">		push	ebp</span><br><span class="line">		mov	ebp,esp</span><br><span class="line">		sub	esp,8</span><br><span class="line">		mov	dword ptr [ebp-4],10</span><br><span class="line">		mov	dword ptr [ebp-8],20</span><br><span class="line">		mov	esp,ebp</span><br><span class="line">		;add	esp,8</span><br><span class="line">		;add 和这里的 mov 的效果是一样的</span><br><span class="line">		pop	ebp</span><br><span class="line">		ret</span><br><span class="line">	my	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<p>写汇编的时候,局部变量使用符号…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x	equ	dword ptr [ebp-4]</span><br><span class="line">y	equ	dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">	my	proc</span><br><span class="line">		push	ebp</span><br><span class="line">		mov		ebp,esp</span><br><span class="line">		sub		esp,8</span><br><span class="line">		mov		x,10</span><br><span class="line">		mov		y,20</span><br><span class="line">		mov		esp,ebp</span><br><span class="line">		pop		ebp</span><br><span class="line">		ret</span><br><span class="line">	my	endp</span><br></pre></td></tr></table></figure>



<p>有些离谱的传入参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     dword ptr [esp+4], 3</span><br><span class="line">mov     dword ptr [esp], 2</span><br><span class="line">call    func</span><br></pre></td></tr></table></figure>

<p>其实上面2菊花等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 3</span><br><span class="line">push 2</span><br></pre></td></tr></table></figure>

<p>push 3可以让dword ptr [esp+4]&#x3D;3</p>
<p>push 2可以让dword ptr [esp+0],&#x3D;2</p>
<h3 id="为什么会有ebp的寻址"><a href="#为什么会有ebp的寻址" class="headerlink" title="为什么会有ebp的寻址"></a>为什么会有ebp的寻址</h3><p>ebp获取的数据都是传入的参数,而参数的使用需要转移到esp中</p>
<p>我还不知道为什么要这么复杂</p>
<p>调用子函数前我们push 了2次,push 2,push 3</p>
<table>
<thead>
<tr>
<th>假设函数开辟了3*4字节.push ebp,mov ebp,esp,sub esp,12</th>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>esp+0&#x2F;&#x2F;<code>sub esp,12</code></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>esp+4</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>esp+8</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>ebp&#x2F;<code>/push ebp</code></td>
<td align="center">A old ebp</td>
<td></td>
</tr>
<tr>
<td>Next IP&#x2F;&#x2F;<code>cal func</code></td>
<td align="center">0xbalablalbla</td>
<td></td>
</tr>
<tr>
<td>A old esp+4&#x2F;&#x2F;<code>push3</code></td>
<td align="center">3</td>
<td></td>
</tr>
<tr>
<td>A old esp&#x2F;&#x2F;<code>push 2</code></td>
<td align="center">2</td>
<td></td>
</tr>
<tr>
<td>所以的话要传递2,3的话</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<p>就用[ebp+8]和[ebp+12]来获取,传入函数栈用eax媒介,然后使用esp来最终的使用</p>
<h3 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h3><h4 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h4><p>参数传递的本质</p>
<p>把原来的数据复制一份到堆栈,然后对堆栈里面的数据进行操作</p>
<p>所以这就解决了形参和实参的问题</p>
<p>在masm32中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub3	proc	sysCall,c_var1,c_var2</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		push 1</span><br><span class="line">		push 2</span><br><span class="line">		call sub3</span><br><span class="line">		;invlok sub3 C,var1,var2//不知道为什么这样写不可以</span><br></pre></td></tr></table></figure>

<p>在栈中传递参数</p>
<p>①.push到栈里面</p>
<p>②.直接mov [esp+xxx],num,向栈里面直接写入数据.其实它等价于第一种</p>
<p>③. 通过寄存器传递参数</p>
<blockquote>
<p> 如何在32位下传入一个64位的参数???</p>
</blockquote>
<p>Way-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp,8</span><br><span class="line">fld xxx</span><br><span class="line">fstp qword ptr [esp]</span><br><span class="line">call func</span><br><span class="line">add esp,8</span><br></pre></td></tr></table></figure>

<p>把栈顶指针做一些修改就可以了</p>
<p>Way-2</p>
<p>先把高4字节入栈</p>
<p>再把低4字节入栈</p>
<blockquote>
<p>如何在32位环境下,返回一个64位的值</p>
</blockquote>
<p>将结果拆分为2个32位的,然后分别放在eax,edx</p>
<p>在外面的时候,把eax,edx整合在栈中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov [ebp-4],eax</span><br><span class="line">mov [ebp-8],edx</span><br></pre></td></tr></table></figure>



<h4 id="传递的规律"><a href="#传递的规律" class="headerlink" title="传递的规律"></a>传递的规律</h4><p>参数是从           ebp+8开始</p>
<p>局部变量是从    ebp-4开始的</p>
<p>参数的传递是放在了堆栈里面</p>
<p>是4个字节放一个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于缓冲区溢出的HelloWorld</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x1 = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> x3 = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">3</span>] = &#123; <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	<span class="type">int</span> x4 = <span class="number">4</span>;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最先声明的 离 ebp最近</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0019FE90  CCCCCCCC  </span><br><span class="line">0019FE94  07070709  str[0,3]</span><br><span class="line">0019FE98  07070707  str[4,7]</span><br><span class="line">0019FE9C  CCCC0A07  str[8,9] 余下2位是CC</span><br><span class="line">0019FEA0  CCCCCCCC  </span><br><span class="line">0019FEA4  CCCCCCCC  </span><br><span class="line">0019FEA8  00000004  x4</span><br><span class="line">0019FEAC  CCCCCCCC  </span><br><span class="line">0019FEB0  CCCCCCCC  </span><br><span class="line">0019FEB4  00000006  arr[0]</span><br><span class="line">0019FEB8  00000007  arr[1]</span><br><span class="line">0019FEBC  00000008  arr[2]</span><br><span class="line">0019FEC0  CCCCCCCC  </span><br><span class="line">0019FEC4  CCCCCCCC  </span><br><span class="line">0019FEC8  00000003  x3</span><br><span class="line">0019FECC  CCCCCCCC  </span><br><span class="line">0019FED0  CCCCCCCC  </span><br><span class="line">0019FED4  00000002  x2</span><br><span class="line">0019FED8  CCCCCCCC  </span><br><span class="line">0019FEDC  CCCCCCCC  </span><br><span class="line">0019FEE0  00000001  x1</span><br><span class="line">0019FEE4  CCCCCCCC  </span><br><span class="line">0019FEE8  0019FF08  Stack[000027E0]:0     ebp</span><br><span class="line">0019FEEC  00411F23  invoke_main+33        eip</span><br></pre></td></tr></table></figure>













<h3 id="子函数的定义"><a href="#子函数的定义" class="headerlink" title="子函数的定义"></a>子函数的定义</h3><p>子程序的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数的声明</span><br><span class="line">函数名字	proto	[距离][调用方式][可视区域][uses 寄存器列表][参数名称:参数类型,参数名称:参数类</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//函数的定义</span><br><span class="line">函数的名字 	 proc [距离][调用方式][可视区域][uses 寄存器列表][参数名称:参数类型,参数名称:参数类型][vararg]</span><br><span class="line">		 	local 局部变量</span><br><span class="line">		 </span><br><span class="line">		 	 指令</span><br><span class="line">		 </span><br><span class="line">函数的名字  	 endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//函数的调用</span><br><span class="line">			push xx</span><br><span class="line">			call yy</span><br><span class="line">			或者用invoke指令</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;			</span><br></pre></td></tr></table></figure>

<p>详情见&lt;&lt;琢式成器&gt;&gt;.Page-75</p>
<p>距离:	…决定了最后的ret的指令是哪种类型,好比retf,retn..????</p>
<p>调用方式:	好比stdcall,子函数的调用方式一般是缺省的,与源代码前面的option保持一致</p>
<p>可视化区域;	…可能就是什么私有公开权限啥的</p>
<p>uses寄存器:	可以以查看一下uses的伪指令</p>
<p>参数名称与参数列表:	现在还不会用…</p>
<p>vararg:一个参数的扩展</p>
<p>子程序的声明</p>
<p>联想一下C语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不声明一下函数的话,main函数的fun()是无法使用的…除非你把fun()函数写在了main()之前</p>
<p>对于win32的函数同样如此</p>
<p>win32的报错会是<code>error a2006:undefined symbol:找不到程序名</code></p>
<p>于是此刻你要像C语言一样函数声明,那你就要用到proto指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageBox Proto hwnd:dword, text:dword,title:dword,Type:dword,</span><br></pre></td></tr></table></figure>



<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>若是32位的程序,一般通过eax寄存器返回</p>
<p>若是64位,一般通过edx和eax寄存器返回</p>
<p>若是浮点数,用st(0)返回</p>
<p>如果函数不写return的话</p>
<p>计算的临时结果就hi放弃在栈里面</p>
<p>写了return ,计算的结果就会存入eax</p>
<h2 id="x64的函数调用"><a href="#x64的函数调用" class="headerlink" title="x64的函数调用"></a>x64的函数调用</h2><p>首先参数的不是靠栈的传递</p>
<p>对于内置函数,他又一套专门的寄存器传参</p>
<p>对DIY的函数,你的传的参数取决与你子函数要用哪个寄存器</p>
<p>非浮点数</p>
<p>6个参数以内</p>
<p>参数传递的顺序 rdi,rsi,rdx,rcx,r8,r9</p>
<p>第7个参数以外,假设有10个,从右边往左边压入</p>
<p>压入第10个,压入第9个….压入第7个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi,fmt1	</span><br><span class="line">mov rsi, first		; the correct registers</span><br><span class="line">mov rdx, second</span><br><span class="line">mov rcx, third			</span><br><span class="line">mov r8, fourth</span><br><span class="line"> 	mov r9, fifth</span><br><span class="line"></span><br><span class="line"> 	push tenth		; now start pushing in</span><br><span class="line">  	push ninth		; reverse order</span><br><span class="line"> 	push eighth</span><br><span class="line">	push seventh</span><br><span class="line">push sixth</span><br><span class="line">mov rax, 0</span><br><span class="line">call printf</span><br></pre></td></tr></table></figure>



<p>浮点数</p>
<p>通过xmm寄存器传递</p>
<p>第一个是xmm0</p>
<p>第二个是xmm1</p>
<p>依次类推</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov  ecx,6	; count = 10</span><br><span class="line">	mov  eax,0	; holds the sum</span><br><span class="line">	;------------------------------------------</span><br><span class="line">	;传入的参数ecx,eax</span><br><span class="line">	;功能,实现6一直加到1</span><br><span class="line">	;eax是累加值</span><br><span class="line">	;-------------------------------------------</span><br><span class="line">	call CalcSum</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">CalcSum PROC</span><br><span class="line">	cmp  ecx,0	</span><br><span class="line">	jz   L2		</span><br><span class="line">	add  eax,ecx	</span><br><span class="line">	dec  ecx		</span><br><span class="line">	call CalcSum</span><br><span class="line">    ;每次调用都会不断的push IP of ret</span><br><span class="line">    ;一旦pop 出去就会返回一个函数</span><br><span class="line">L2:	ret</span><br><span class="line">CalcSum ENDP</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<p>看一下函数栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0019FF5C  | 00401023  | sub_401016:locret_401023</span><br><span class="line">0019FF60  | 00401023  | sub_401016:locret_401023</span><br><span class="line">0019FF64  | 00401023  | sub_401016:locret_401023</span><br><span class="line">0019FF68  | 00401023  | sub_401016:locret_401023</span><br><span class="line">0019FF6C  | 00401023  | sub_401016:locret_401023</span><br><span class="line">0019FF70  | 00401023  | sub_401016:locret_401023</span><br></pre></td></tr></table></figure>

<p>你会发现栈里面的数据都是ret的地址,一旦达到函数的返回条件,他就不断的把ret的地址pop 到IP</p>
<h4 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h4><p>我的阶乘.有点简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov	eax,5</span><br><span class="line">	mov	ebx,eax</span><br><span class="line">	call	func</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">func PROC</span><br><span class="line">	dec	ebx</span><br><span class="line">	cmp	ebx,0</span><br><span class="line">	jz	over</span><br><span class="line">	mul	ebx</span><br><span class="line">	call	func</span><br><span class="line">over:</span><br><span class="line">	ret</span><br><span class="line">func ENDP</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<p>整体实现的一个流程是</p>
<p>eax–,然后不断的push eax</p>
<p>直到eax&#x3D;0,就让eax&#x3D;1,开始在栈里面取数据做乘法</p>
<p>对书上的理解,我又写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	push	5</span><br><span class="line">	call	func</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">func PROC</span><br><span class="line">	push	ebp</span><br><span class="line">	mov	ebp,esp</span><br><span class="line">	mov	eax,[ebp+8]</span><br><span class="line">	cmp	eax,1</span><br><span class="line">	jz	q1</span><br><span class="line">	dec	eax</span><br><span class="line">	push	eax</span><br><span class="line">	call	func</span><br><span class="line">	mov	ebx,[ebp+8]</span><br><span class="line">	mul	ebx</span><br><span class="line">q1:	</span><br><span class="line">	pop	ebp</span><br><span class="line">	retn	4</span><br><span class="line">	;为什么pop </span><br><span class="line">	;ebp?为了让eip指向返回地址</span><br><span class="line">	;为什么ebx,[ebp+8]</span><br><span class="line">	;因为完全进入了一个完整的函数,参数的获取</span><br><span class="line">	;怎么保持的栈平衡?让eip指向了正确的地址</span><br><span class="line">	;为什么是retn 4</span><br><span class="line">	;为了让esp指ebp的位置</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">func ENDP</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>

<p>书上的方法,很妙’很复杂</p>
<p>‘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	push	5</span><br><span class="line">	call	func</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">func PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov  ebp,esp</span><br><span class="line">	mov  eax,[ebp+8]	</span><br><span class="line">	cmp  eax,0		</span><br><span class="line">	ja   break_up			</span><br><span class="line">	mov  eax,1		</span><br><span class="line">	jmp  ok</span><br><span class="line">break_up:</span><br><span class="line">	dec  eax</span><br><span class="line">	push eax			</span><br><span class="line">	call func</span><br><span class="line">begin_mul:</span><br><span class="line">	mov  ebx,[ebp+8]   	</span><br><span class="line">	mul  ebx</span><br><span class="line">	</span><br><span class="line">ok:	pop  ebp			</span><br><span class="line">	ret  4</span><br><span class="line">	;pop ip</span><br><span class="line">	;esp+=4</span><br><span class="line">func ENDP</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">	end	start</span><br></pre></td></tr></table></figure>



<h3 id="x64-计数圆的周长-x2F-面积"><a href="#x64-计数圆的周长-x2F-面积" class="headerlink" title="x64 计数圆的周长&#x2F;面积"></a>x64 计数圆的周长&#x2F;面积</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section .data		</span><br><span class="line">		</span><br><span class="line">		radius	dq	10.0	</span><br><span class="line">					</span><br><span class="line">		</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">section .text</span><br><span class="line">	</span><br><span class="line">extern		printf		</span><br><span class="line">extern		area</span><br><span class="line">extern		circum</span><br><span class="line">extern		circle	</span><br><span class="line">					</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">    mov rbp, rsp; for correct debugging</span><br><span class="line">;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	</span><br><span class="line">           mov  rbp, rsp;</span><br><span class="line">	push rbp</span><br><span class="line">	mov  rbp, rsp</span><br><span class="line">	</span><br><span class="line">	call circle</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line">	ret			       		</span><br><span class="line">;------------------------------------------------------	</span><br><span class="line">circle:</span><br><span class="line"></span><br><span class="line">	section .data</span><br><span class="line">		.fmt_area	db	&quot;The area is %f&quot;,10,0</span><br><span class="line">		.fmt_circum	db	&quot;The circumference is %f&quot;,10,0</span><br><span class="line">	section .text</span><br><span class="line">	</span><br><span class="line">	push rbp</span><br><span class="line">	mov rbp, rsp	</span><br><span class="line">	</span><br><span class="line">		call area	</span><br><span class="line">		mov	rdi,.fmt_area</span><br><span class="line">		mov	rax,1			; area in xmm0</span><br><span class="line">		call printf</span><br><span class="line">		call circum</span><br><span class="line">		mov	rdi,.fmt_circum</span><br><span class="line">		mov	rax,1			; circumference in xmm0</span><br><span class="line">		call printf</span><br><span class="line">		</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">;----------------------------------------------------</span><br><span class="line">;function name:area</span><br><span class="line">；no var get in</span><br><span class="line">；proc: calc PI x R^2</span><br><span class="line">；return xmm0</span><br><span class="line"></span><br><span class="line">area:</span><br><span class="line">	section .data</span><br><span class="line">		.pi	dq	3.141592654	; local to area</span><br><span class="line">	section .text </span><br><span class="line">	</span><br><span class="line">	push rbp</span><br><span class="line">	mov rbp, rsp</span><br><span class="line">	</span><br><span class="line">		movsd xmm0, [radius]</span><br><span class="line">		mulsd xmm0, [radius]</span><br><span class="line">		mulsd xmm0, [.pi]</span><br><span class="line">		</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">;----------------------------------------------------</span><br><span class="line">;fuction name:circum</span><br><span class="line">;no var get in</span><br><span class="line">;proc: 2*PI*R</span><br><span class="line">;return xmm0</span><br><span class="line"></span><br><span class="line">circum:</span><br><span class="line">	section .data</span><br><span class="line">		.pi	dq	3.14		; local to circum</span><br><span class="line">	section .text</span><br><span class="line">	</span><br><span class="line">	push rbp</span><br><span class="line">	mov rbp, rsp	</span><br><span class="line"></span><br><span class="line">		movsd xmm0, [radius]</span><br><span class="line">		addsd xmm0, [radius]</span><br><span class="line">		mulsd xmm0, [.pi]</span><br><span class="line">		</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">;----------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>





<h1 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) Function()  				</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;				</span><br><span class="line"></span><br><span class="line">上面的函数调用时，为什么会出错？				</span><br><span class="line"></span><br><span class="line">void __declspec(naked) Function()  				</span><br><span class="line">&#123;				</span><br><span class="line"></span><br><span class="line">	__asm ret			</span><br><span class="line">&#125;										</span><br></pre></td></tr></table></figure>

<p>对于第一种裸函数的写法,编译器不会给你生成任何东西,就连ret都不会给你生成</p>
<p>所以对于空的裸函数,你要写上<code>ret</code></p>
<h2 id="无参数和返回值的裸函数"><a href="#无参数和返回值的裸函数" class="headerlink" title="无参数和返回值的裸函数"></a>无参数和返回值的裸函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) Function()  					</span><br><span class="line">&#123;					</span><br><span class="line">	__asm				</span><br><span class="line">	&#123;				</span><br><span class="line">		push ebp			</span><br><span class="line">		mov ebp,esp			</span><br><span class="line">		sub esp,0x40			</span><br><span class="line">		push ebx			</span><br><span class="line">		push esi			</span><br><span class="line">		push edi			</span><br><span class="line">		lea edi,dword ptr ds:[ebp-0x40]			</span><br><span class="line">		mov eax,0xCCCCCCCC			</span><br><span class="line">		mov ecx,0x10			</span><br><span class="line">		rep stosd			</span><br><span class="line">					</span><br><span class="line">		pop edi			</span><br><span class="line">		pop esi			</span><br><span class="line">		pop ebx			</span><br><span class="line">		mov esp,ebp			</span><br><span class="line">		pop ebp			</span><br><span class="line">					</span><br><span class="line">		ret			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;					</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="有参数和返回值"><a href="#有参数和返回值" class="headerlink" title="有参数和返回值"></a>有参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __declspec(naked) Function(int x,int y)  	//实现x+y				</span><br><span class="line">&#123;					</span><br><span class="line">	__asm				</span><br><span class="line">	&#123;				</span><br><span class="line">		push ebp			</span><br><span class="line">		mov ebp,esp			</span><br><span class="line">		sub esp,0x40			</span><br><span class="line">		push ebx			</span><br><span class="line">		push esi			</span><br><span class="line">		push edi			</span><br><span class="line">		lea edi,dword ptr ds:[ebp-0x40]			</span><br><span class="line">		mov eax,0xCCCCCCCC			</span><br><span class="line">		mov ecx,0x10			</span><br><span class="line">		rep stosd			</span><br><span class="line">					</span><br><span class="line">		mov eax,dword ptr ds:[ebp+8]			</span><br><span class="line">		add eax,dword ptr ds:[ebp+0xC]			</span><br><span class="line">					</span><br><span class="line">		pop edi			</span><br><span class="line">		pop esi			</span><br><span class="line">		pop ebx			</span><br><span class="line">		mov esp,ebp			</span><br><span class="line">		pop ebp			</span><br><span class="line">					</span><br><span class="line">		ret			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;					</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="带局部变量的裸函数"><a href="#带局部变量的裸函数" class="headerlink" title="带局部变量的裸函数"></a>带局部变量的裸函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">					</span><br><span class="line">int __declspec(naked) Function(int x,int y)  					</span><br><span class="line">&#123;					</span><br><span class="line">	__asm				</span><br><span class="line">	&#123;				</span><br><span class="line">		push ebp			</span><br><span class="line">		mov ebp,esp			</span><br><span class="line">		sub esp,0x40			</span><br><span class="line">		push ebx			</span><br><span class="line">		push esi			</span><br><span class="line">		push edi			</span><br><span class="line">		lea edi,dword ptr ds:[ebp-0x40]			</span><br><span class="line">		mov eax,0xCCCCCCCC			</span><br><span class="line">		mov ecx,0x10			</span><br><span class="line">		rep stosd			</span><br><span class="line">		mov dword ptr ds:[ebp-4],2			</span><br><span class="line">		mov dword ptr ds:[ebp-8],3			</span><br><span class="line">					</span><br><span class="line">		mov eax,dword ptr ds:[ebp+8]			</span><br><span class="line">		add eax,dword ptr ds:[ebp+0xC]			</span><br><span class="line">					</span><br><span class="line">		pop edi			</span><br><span class="line">		pop esi			</span><br><span class="line">		pop ebx			</span><br><span class="line">		mov esp,ebp			</span><br><span class="line">		pop ebp			</span><br><span class="line">					</span><br><span class="line">		ret			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;					</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="MS-Windows"><a href="#MS-Windows" class="headerlink" title="MS-Windows"></a>MS-Windows</h1><p>可以对比一下你8086学的int21h的ah&#x3D;9,或者其它之类的中断……</p>
<p>8086的中断比较晦涩难懂</p>
<p>win32的API就比较好理解一些</p>
<p>有的API是有返回值的</p>
<p>如果返回值是32位寄存器放得下的,那么一定放在eax中,如果放不下</p>
<p>情况1,eax放一个返回值的指针</p>
<p>情况2,返回值到了buff区域</p>
<h2 id="数据类型表"><a href="#数据类型表" class="headerlink" title="数据类型表"></a>数据类型表</h2><table>
<thead>
<tr>
<th>MS-Windows 类型</th>
<th>MASM类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BOOL, BOOLEAN</td>
<td>DWORD</td>
<td>布尔值 (TRUE 或 FALSE)</td>
</tr>
<tr>
<td>BYTE</td>
<td>BYTE</td>
<td>8 位无符号整数</td>
</tr>
<tr>
<td>CHAR</td>
<td>BYTE</td>
<td>8 位 Windows ANSI 字符</td>
</tr>
<tr>
<td>COLORREF</td>
<td>DWORD</td>
<td>作为颜色值的 32 位数值</td>
</tr>
<tr>
<td>DWORD</td>
<td>DWORD</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>HANDLE</td>
<td>DWORD</td>
<td>对象句柄</td>
</tr>
<tr>
<td>HFILE</td>
<td>DWORD</td>
<td>用 OpenFile 打开的文件的句柄</td>
</tr>
<tr>
<td>INT</td>
<td>SDWORD</td>
<td>32 位有符号整数</td>
</tr>
<tr>
<td>LONG</td>
<td>SDWORD</td>
<td>32 位有符号整数</td>
</tr>
<tr>
<td>LPARAM</td>
<td>DWORD</td>
<td>消息参数，由窗口过程和回调函数使用</td>
</tr>
<tr>
<td>LPCSTR</td>
<td>PTR BYTE</td>
<td>32 位指针，指向由 8 位 Windows (ANSI)字符组成的空字节结束的字符串常量</td>
</tr>
<tr>
<td>LPCVOID</td>
<td>DWORD</td>
<td>指向任何类型的常量</td>
</tr>
<tr>
<td>LPSTR</td>
<td>PTR BYTE</td>
<td>32 位指针，指向由 8 位 Windows (ANSI) 字符组成的空字节结束的字符串</td>
</tr>
<tr>
<td>LPCTSTR</td>
<td>PTR WORD</td>
<td>32 位指针，指向对 Unicode 和双字节字符集可移植的字符串常量</td>
</tr>
<tr>
<td>LPTSTR</td>
<td>PTR WORD</td>
<td>32 位指针，指向对 Unicode 和双字节字符集可移植的字符串</td>
</tr>
<tr>
<td>LPVOID</td>
<td>DWORD</td>
<td>32 位指针，指向未指定类</td>
</tr>
<tr>
<td>LRESULT</td>
<td>DWORD</td>
<td>窗口过程和回调函数返回的 32 位数值</td>
</tr>
<tr>
<td>SIZE_T</td>
<td>DWORD</td>
<td>一个指针可以指向的最大字节数</td>
</tr>
<tr>
<td>UNIT</td>
<td>DWORD</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>WNDPROC</td>
<td>DWORD</td>
<td>32 位指针，指向窗口过程</td>
</tr>
<tr>
<td>WORD</td>
<td>WORD</td>
<td>16 位无符号整数</td>
</tr>
<tr>
<td>WPARAM</td>
<td>DWORD</td>
<td>作为参数传递给窗口过程或回调函数的 32 位数值</td>
</tr>
</tbody></table>
<h2 id="函数一览表"><a href="#函数一览表" class="headerlink" title="函数一览表"></a>函数一览表</h2><p>下表为所有 Win32 控制台函数的一览表。在 <a href="http://www.msdn.microsoft.com/">www.msdn.microsoft.com</a> 上可以找到 MSDN 库中每个函数的完整描述。</p>
<blockquote>
<p>提示：Win32 API 函数不保存 EAX、EBX、ECX 和 EDX，因此程序员需自己完成这些寄存器的入栈和出栈操作。</p>
<p>所以你会发现,一个函数使用,你的寄存器会发生一些改变</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AllocConsole</td>
<td>为调用进程分配一个新控制台</td>
</tr>
<tr>
<td>CreateConsoleScreenBuffer</td>
<td>创建控制台屏幕缓冲区</td>
</tr>
<tr>
<td>ExitProcess</td>
<td>结束进程及其所有线程</td>
</tr>
<tr>
<td>FillConsoleOutputAttribute</td>
<td>为指定数量的字符单元格设置文本和背景颜色属性</td>
</tr>
<tr>
<td>FillConsoleOutputCharacter</td>
<td>按指定次数将一个字符写入屏幕缓冲区</td>
</tr>
<tr>
<td>FlushConsoleInputBuffer</td>
<td>刷新控制台输入缓冲区</td>
</tr>
<tr>
<td>FreeConsole</td>
<td>将主调进程与其控制台分离</td>
</tr>
<tr>
<td>GenerateConsoleCtrlEvent</td>
<td>向控制台进程组发送指定信号，这些进程组共享与主调进程关联的控制台</td>
</tr>
<tr>
<td>GetConsoleCP</td>
<td>获取与主调进程关联的控制台使用的输入代码页</td>
</tr>
<tr>
<td>GetConsoleCursorInfo</td>
<td>获取指定控制台屏幕缓冲区光标大小和可见性的信息</td>
</tr>
<tr>
<td>GetConsoleMode</td>
<td>获取控制台输入缓冲区的当前输入模式或控制台屏幕缓冲区的当前输出模式</td>
</tr>
<tr>
<td>GetConsoleOutputCP</td>
<td>获取与主调进程关联的控制台使用的输出代码页</td>
</tr>
<tr>
<td>GetConsoleScreenBufferInfo</td>
<td>获取指定控制台屏幕缓冲区信息</td>
</tr>
<tr>
<td>GetConsoleTitle</td>
<td>获取当前控制台窗口的标题栏字符串</td>
</tr>
<tr>
<td>GetConsoleWindow</td>
<td>获取与主调进程关联的控制台使用的窗口句柄</td>
</tr>
<tr>
<td>GetLargestConsoleWindowSize</td>
<td>获取控制台窗口最大可能的大小</td>
</tr>
<tr>
<td>GetNumberOfConsoleInputEvents</td>
<td>获取控制台输入缓冲区中未读输入记录的个数</td>
</tr>
<tr>
<td>GetNumberOfConsoleMouseButtons</td>
<td>获取当前控制台使用的鼠标按钮数</td>
</tr>
<tr>
<td>GetStdHandle</td>
<td>获取标准输入、标准输出或标准错误设备的句柄</td>
</tr>
<tr>
<td>HandlerRoutine</td>
<td>与 SetConsoleCtrlHandler 函数一起使用的应用程序定义的函数</td>
</tr>
<tr>
<td>PeekConsoleInput</td>
<td>从指定控制台输入缓冲区读取数据，且不从缓冲区删除该数据</td>
</tr>
<tr>
<td>ReadConsole</td>
<td>从控制台输入缓冲区读取并删除输入字符</td>
</tr>
<tr>
<td>ReadConsoleInput</td>
<td>从控制台输入缓冲区读取并删除该数据</td>
</tr>
<tr>
<td>ReadConsoleOutput</td>
<td>从控制台屏幕缓冲区的矩形字符单元格区域读取字符和颜色属性数据</td>
</tr>
<tr>
<td>ReadConsoleOutputAttribute</td>
<td>从控制台屏幕缓冲区的连续单元格复制指定数量的前景和背景颜色属性</td>
</tr>
<tr>
<td>ReadConsoleOutputCharacter</td>
<td>从控制台屏幕缓冲区的连续单元格复制若干字符</td>
</tr>
<tr>
<td>ScrollConsoleScreenBuffer</td>
<td>移动屏幕缓冲区内的一个数据块</td>
</tr>
<tr>
<td>SetConsoleActiveScreenBuffer</td>
<td>设置指定屏幕缓冲区为当前显示的控制台屏幕缓冲区</td>
</tr>
<tr>
<td>SetConsoleCP</td>
<td>设置主调过程的控制台输入代码页</td>
</tr>
<tr>
<td>SetConsoleCtrlHandler</td>
<td>为主调过程从处理函数列表中添加或删除应用程序定义的 HandlerRoutine</td>
</tr>
<tr>
<td>SetConsoleCursorInfo</td>
<td>设置指定控制台屏幕缓冲区光标的大小和可见度</td>
</tr>
<tr>
<td>SetConsoleCursorPosition</td>
<td>设置光标在指定控制台屏幕缓冲区中的位置</td>
</tr>
<tr>
<td>SetConsoleMode</td>
<td>设置控制台输入缓冲区的输入模式或者控制台屏幕缓冲区的输出模式</td>
</tr>
<tr>
<td>SetConsoleOntputCP</td>
<td>设置主调过程的控制台输出代码页</td>
</tr>
<tr>
<td>SetConsoleScreenBufferSize</td>
<td>修改指定控制台屏幕缓冲区的大小</td>
</tr>
<tr>
<td>SetConsoleTextAttribute</td>
<td>设置写入屏幕缓冲区的字符的前景（文本）和背景颜色属性</td>
</tr>
<tr>
<td>SetConsoleTitle</td>
<td>为当前控制台窗口设置标题栏字符串</td>
</tr>
<tr>
<td>SetConsoleWindowInfo</td>
<td>设置控制台屏幕缓冲区窗口当前的大小和位置</td>
</tr>
<tr>
<td>SetStdHandle</td>
<td>设置标准输入、输出和标准错误设备的句柄.</td>
</tr>
<tr>
<td>WriteConsole</td>
<td>向由当前光标位置标识开始的控制台屏幕缓冲区写一个字符串</td>
</tr>
<tr>
<td>WriteConsoleInput</td>
<td>直接向控制台输入缓冲区写数据</td>
</tr>
<tr>
<td>WriteConsoleOutput</td>
<td>向控制台屏幕缓冲区内指定字符单元格的矩形块写字符和颜色属性数据</td>
</tr>
<tr>
<td>WriteConsoleOutputAttribute</td>
<td>向控制台屏幕缓冲区的连续单元格复制一组前景和背景颜色属性</td>
</tr>
<tr>
<td>WriteConsoleOutputCharacter</td>
<td>向控制台屏幕缓冲区的连续单元格复制一组字符</td>
</tr>
</tbody></table>
<h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>他只是用来表示各种资源的编号</p>
<p>书上说了这么一句话,不是很理解</p>
<p>加入你把句柄&#x3D;11给了应用程序,应用程序不知道他是什么</p>
<p>你把句柄&#x3D;11给了windows,windows就知道去查找哪个窗口</p>
<p>可能他说了句柄也有分类,线程局部,窗口句柄,文件句柄……..</p>
<p>他还说,如果以前有10个窗口,你给了windows11号窗口</p>
<p>当原来的10个窗口关闭,留下5个,那么你的11号窗口就变了6号窗口</p>
<p>他说我们不需要关系句柄的值,用就对了</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>一个模块代表了&#x3D;&#x3D;运行中&#x3D;&#x3D;的exe或者dll文件,用来代表这个文件中所有的&#x3D;&#x3D;代码与资源&#x3D;&#x3D;</p>
<p>每个不同的模块都有唯一的的模块句柄来标识,&#x3D;&#x3D;利用这个句柄我们可以访问文件的资源…&#x3D;&#x3D;</p>
<p>很多的API函数都要用到都要用到模块的句柄,以便利用程序的各种资源</p>
<p>在win32上,模块句柄的值&#x3D;&#x3D;程序在内存中载入的启示地址</p>
<h2 id="Messagebox-A-x2F-W"><a href="#Messagebox-A-x2F-W" class="headerlink" title="Messagebox A&#x2F;W"></a>Messagebox A&#x2F;W</h2><p>Messagebox一般默认为MessageboxA</p>
<p>MessageboxA一般用于ANSI标准,这个标准你之前也是遇到过的,不能显示中文,</p>
<p>ANSI规定字符占一个字节,我们就用MessageboxA</p>
<p>Unicode码规定字符占2个字节,我们就用MessageboxW</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageBoxA PROTO,</span><br><span class="line">  hWnd:DWORD,          ;窗口句柄（可以为空）</span><br><span class="line">  lpText:PTR BYTE,         ;字符串，对话框内</span><br><span class="line">  lpCaption:PTR BYTE,      ;字符串，对话框标题</span><br><span class="line">  uType:DWORD          ;内容和行为</span><br></pre></td></tr></table></figure>

<p>hwnd 基于控制台的应用程序可以将 hWnd 设置为空，表示该消息框没有相关的包含窗口或父窗口。</p>
<p>lpText 消息框内容的指针</p>
<p>lpCaption 消息框标题的指针</p>
<p>uType 指定对话框的内容和行为</p>
<h3 id="内容和行为"><a href="#内容和行为" class="headerlink" title="内容和行为"></a>内容和行为</h3><p>uType 参数包含的位图整数组合了三种选项：显示按钮、图标和默认按钮选择。几种可能的按钮组合如下：</p>
<ul>
<li>MB_OK</li>
<li>MB_OKCANCEL</li>
<li>MB_YESNO</li>
<li>MB_YESNOCANCEL</li>
<li>MB_RETRYCANCEL</li>
<li>MB_ABORTRETRYIGNORE</li>
<li>MB_CANCELTRYCONTINUE</li>
</ul>
<h3 id="默认按钮"><a href="#默认按钮" class="headerlink" title="默认按钮"></a>默认按钮</h3><p>可以选择按钮作为用户点击 Enter 键时的自动选项。选项包括</p>
<p> MB_DEFBUTTON1（默认）、MB_DEFBUTTON2、MB_DEFBUTTON3 和 MB_DEFBUTTON4。</p>
<p>按钮从左到右，从 1 开始编号。</p>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>有四个图标可用。有时多个常数会产生相同的图标：</p>
<ul>
<li>停止符：MB_ICONSTOP. MB_ICONHAND 或 MB_ICONERROR</li>
<li>问号（?）：MB_ICONQUESTION</li>
<li>信息符（i）：MB_ICONINFORMATION、MB_ICONASTERISK</li>
<li>感叹号（!）：MB_ICONEXCLAMATION、MB_ICONWARNING</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果 MessageBoxA 失败，则返回零；</p>
<p>否则，它将返回一个整数以表示用户在关闭对话框时点击的按钮。</p>
<p>选项包括 IDABORT、IDCANCEL、IDCONTINUE、IDIGNORE、IDNO、IDOK、IDRETRY、IDTRYAGAIN，以及 IDYES。</p>
<p>。</p>
<p>如果想要消息框窗口浮动于桌面所有其他窗口之上，就在传递的最后一个参数（uType 参数）值上添加 MB_SYSTEMMODAL 选项</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line"></span><br><span class="line">captionW        BYTE &quot;Warning&quot;,0</span><br><span class="line">warningMsg		BYTE &quot;The current operation may take years &quot;</span><br><span class="line">                BYTE &quot;to complete.&quot;,0</span><br><span class="line"></span><br><span class="line">captionQ        BYTE &quot;Question&quot;,0</span><br><span class="line">questionMsg		BYTE &quot;A matching user account was not found.&quot;</span><br><span class="line">                BYTE 0dh,0ah,&quot;Do you wish to continue?&quot;,0   </span><br><span class="line"></span><br><span class="line">captionC        BYTE &quot;Information&quot;,0</span><br><span class="line">infoMsg			BYTE &quot;Select Yes to save a backup file &quot;</span><br><span class="line">                BYTE &quot;before continuing,&quot;,0dh,0ah</span><br><span class="line">                BYTE &quot;or click Cancel to stop the operation&quot;,0</span><br><span class="line"></span><br><span class="line">captionH        BYTE &quot;Cannot View User List&quot;,0</span><br><span class="line">haltMsg			BYTE &quot;This operation not supported by your &quot;</span><br><span class="line">                BYTE &quot;user account.&quot;,0               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		; 显示感叹号图标和 OK 按钮</span><br><span class="line">		INVOKE MessageBoxA, </span><br><span class="line">			NULL, </span><br><span class="line">			ADDR warningMsg,</span><br><span class="line">			ADDR captionW,</span><br><span class="line">			MB_OK + MB_ICONEXCLAMATION</span><br><span class="line"></span><br><span class="line">		; 显示问号图标和 Yes/No 按钮</span><br><span class="line">		INVOKE MessageBoxA, </span><br><span class="line">			NULL, </span><br><span class="line">			ADDR questionMsg,</span><br><span class="line">			ADDR captionQ, </span><br><span class="line">			MB_YESNO + MB_ICONQUESTION</span><br><span class="line">       </span><br><span class="line">		; 解释用户点击的按钮  </span><br><span class="line">		cmp    eax,IDYES        ; YES button clicked?</span><br><span class="line"></span><br><span class="line">		; 显示信息图标和 Yes/No/Cancel 按钮</span><br><span class="line">		INVOKE MessageBoxA, </span><br><span class="line">			NULL, </span><br><span class="line">			ADDR infoMsg,</span><br><span class="line">			ADDR captionC, </span><br><span class="line">			MB_YESNOCANCEL + MB_ICONINFORMATION + MB_DEFBUTTON2</span><br><span class="line"></span><br><span class="line">		; 显示停止图标和 OK 按钮</span><br><span class="line">		INVOKE MessageBoxA, </span><br><span class="line">			NULL, </span><br><span class="line">			ADDR haltMsg,</span><br><span class="line">			ADDR captionH,</span><br><span class="line">			MB_OK + MB_ICONSTOP</span><br><span class="line"></span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>





<h2 id="窗口输入"><a href="#窗口输入" class="headerlink" title="窗口输入"></a>窗口输入</h2><h3 id="ReadConsole-读取输入"><a href="#ReadConsole-读取输入" class="headerlink" title="ReadConsole 读取输入"></a>ReadConsole 读取输入</h3><p>函数 ReadConsole 为读取文本输入并将其送入缓冲区提供了便捷的方法。其原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReadConsole PROTO,</span><br><span class="line">hConsoleInput: HANDLE z            ;输入句柄</span><br><span class="line">lpBuffer:PTR BYTE,                  ;缓冲区指针</span><br><span class="line">nNumberOfCharsToRead:DWORD,     ;读取的字符数</span><br><span class="line">lpNumberOfCharsRead:PTR DWORD,   ;指向读取字节数的指针</span><br><span class="line">lpReserved:DWORD                 ;未使用</span><br></pre></td></tr></table></figure>

<p>hConsoleInput 是函数 GetStdHandle 返回的可用控制台输入句柄。</p>
<p> lpBuffer 是字符数组的偏移量。</p>
<p>nNumberOfCharsToRead 是一个 32 位整数，指明读取的最大字符数。</p>
<p>lpNumberOfCharsRead 是一个允许函数填充的双字指针，当函数返回时，字符数的计数值将被放入缓冲区。</p>
<p>最后一个参数未使用，因此传递的值为 0。</p>
<p>在调用 ReadConsole 时，输入缓冲区还要包含两个额外的字节用来保存行结束字符。</p>
<p>如果希望输入缓冲区里是空字节结束字符串，则用空字节来代替内容为 ODh 的字节。Irvine32.lib 的过程 ReadString 就是这样操作的。</p>
<blockquote>
<p>注意：Win32 API 函数不会保存 EAX、EBX、ECX 和 EDX 寄存器。</p>
</blockquote>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">			.data	</span><br><span class="line">max			= 80</span><br><span class="line">Input_Buff		BYTE max DUP(?),0,0</span><br><span class="line">An_Input_Handle		HANDLE ?</span><br><span class="line">len			DWORD ?</span><br><span class="line">captionC		byte &quot;Gh0st&quot;,0</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		        ; 获取标准输入句柄</span><br><span class="line">	INVOKE	GetStdHandle, STD_INPUT_HANDLE</span><br><span class="line">	mov	An_Input_Handle,eax</span><br><span class="line"></span><br><span class="line">    ; 等待用户输入</span><br><span class="line">	INVOKE	ReadConsole, </span><br><span class="line">		An_Input_Handle	, </span><br><span class="line">		ADDR Input_Buff,</span><br><span class="line">		max, </span><br><span class="line">		ADDR len, </span><br><span class="line">		0</span><br><span class="line"></span><br><span class="line">	INVOKE MessageBoxA, </span><br><span class="line">	NULL, </span><br><span class="line">	ADDR Input_Buff,</span><br><span class="line">	ADDR captionC, </span><br><span class="line">	MB_YESNOCANCEL + MB_ICONINFORMATION + MB_DEFBUTTON2</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>它并没有等待我的输入,我根本就没啥输入的地方,以后慢慢解决</p>
<p>解决办法就是修改编译方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LINK_FLAG = /subsystem:console</span><br></pre></td></tr></table></figure>



<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I am here !</span><br><span class="line">然后回车</span><br></pre></td></tr></table></figure>

<p>得到长度13&#x3D;2+11</p>
<p>IDA-data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aIAmHere db &#x27;I am here !&#x27;,0Dh,0Ah,0</span><br></pre></td></tr></table></figure>

<p>所以会有11个</p>
<h2 id="GetLastError-x2F-FormatMessage-获取错误消息"><a href="#GetLastError-x2F-FormatMessage-获取错误消息" class="headerlink" title="GetLastError&#x2F;FormatMessage 获取错误消息"></a>GetLastError&#x2F;FormatMessage 获取错误消息</h2><p>GetLastError没有参数</p>
<p>FormatMessage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FormatMessage PROTO,         ;格式化消息</span><br><span class="line">    dwFlags:DWORD,                ;格式化选项</span><br><span class="line">    lpSource:DWORD,               ;消息定义的位置</span><br><span class="line">    dwMsgID:DWORD,              ;消息标识符</span><br><span class="line">    dwLanguageID:DWORD,     ;语言标识符</span><br><span class="line">    lpBuffer:PTR BYTE,               ;缓冲区接收字符串指针</span><br><span class="line">    nSize:DWORD,                     ;缓冲区大小</span><br><span class="line">    va_list: DWORD                   ;参数列表指针</span><br></pre></td></tr></table></figure>

<p>下面简要列出了最常用的参数值。除了 lpBuffer 是输出参数外，其他都是输入参数</p>
<ol>
<li>dwFlags</li>
</ol>
<p>保存格式化选项的双字整数，包括如何解释参数 lpSource。</p>
<p>它规定怎样处理换行，以及格式化输出行的最大宽度.</p>
<p>建议值为 FORMAT_MESSAGE_ALLOCATE_BUFFER 和 FORMAT_MESSAGE_FROM_SYSTEM。</p>
<ol start="2">
<li>lpSource</li>
</ol>
<p>消息定义位置的指针。若按照建议值设置 dwFlags，则 lpSource 设置为 NULL(0)。</p>
<ol start="3">
<li>dwMsgID</li>
</ol>
<p>调用 GetLastError 后返回的双字整数。</p>
<ol start="4">
<li>dwLanguageID</li>
</ol>
<p>语言标识符。若将其设置为 0，则消息为语言无关，否则将对应于用户的默认语言环境。</p>
<ol start="5">
<li>lpBuffer( 输出参数 )</li>
</ol>
<p>接收空字节结束消息字符串的缓冲区指针。如果使用了 FORMAT_MESSAGE_ALLOCATE_BUFFER 选项，则会自动分配缓冲区。</p>
<ol start="6">
<li>nSize</li>
</ol>
<p>用于指定一个缓冲区来保存消息字符串。如果 dwFlags 使用了上述建议选项，则该参数可以设置为 0。</p>
<ol start="7">
<li>va_list</li>
</ol>
<p>数组指针，该数组包含了可以插入到格式化消息的值。由于没有格式化错误消息，这个参数可以为 NULL(0)。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data	</span><br><span class="line">	</span><br><span class="line">	messageId DWORD ?</span><br><span class="line">	pErrorMsg DWORD ?            ;指向错误消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">		       </span><br><span class="line"></span><br><span class="line">	.code</span><br><span class="line">	call GetLastError</span><br><span class="line">	mov messageId,eax</span><br><span class="line">	INVOKE	FormatMessage,</span><br><span class="line">		FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_FROM_SYSTEM, </span><br><span class="line">		NULL, </span><br><span class="line">		messageId, </span><br><span class="line">		0,</span><br><span class="line">		ADDR pErrorMsg, </span><br><span class="line">		0, </span><br><span class="line">		NULL</span><br><span class="line">	INVOKE LocalFree, pErrorMsg	</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="ReadChar-x2F-ReadKey-获取当前按键"><a href="#ReadChar-x2F-ReadKey-获取当前按键" class="headerlink" title="ReadChar&#x2F;ReadKey 获取当前按键"></a>ReadChar&#x2F;ReadKey 获取当前按键</h3><ul>
<li><p>ReadChar：等待键盘输入一个 ASCII 字符，并用 AL 返回该字符。</p>
</li>
<li><p>ReadKey：过程执行无等待键盘检查。</p>
<p>  如果控制台输入缓冲区中没有等待的按键，则ZF &#x3D; 1。</p>
<p>  如果发现有按键，则ZF&#x3D;0且 AL 等于零或 ASCII 码。EAX 和 EDX 的高 16 位被覆盖。</p>
</li>
</ul>
<p>​		如果  AL 等于 0，那么用户可能按下了特殊键（功能键、光标箭头等）。</p>
<p>​		AH 寄存器为键盘扫描码。DX 为虚拟键	码，EBX 为键盘控制键状态信息。</p>
<p>下表为控制键值列表。调用 ReadKey 之后，可以用 TEST 指令检查各种键值。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CAPSLOCK_ON</td>
<td>CAPSLOCK 指示灯亮</td>
<td>RIGHT_ALT_PRESSED</td>
<td>右 ALT 键被按下</td>
</tr>
<tr>
<td>ENHANCED_KEY</td>
<td>被按下增强的</td>
<td>RIGHT_CTRL_PRESSED</td>
<td>右 CTRL 键被按下</td>
</tr>
<tr>
<td>LEFT_ALT_PRESSED</td>
<td>该键是左 ALT 键</td>
<td>SCROLLLOCL_ON</td>
<td>SCROLLLOCK 指示灯亮</td>
</tr>
<tr>
<td>LEFT_CTRL_PRESSED</td>
<td>左 CTRL 键被按下</td>
<td>SHIFT_PRESSED</td>
<td>SHIFT 键被按下</td>
</tr>
<tr>
<td>NUMLOCK_ON</td>
<td>NUMLOCK 指示灯亮</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="GetKeyState-获取当前按下的键"><a href="#GetKeyState-获取当前按下的键" class="headerlink" title="GetKeyState 获取当前按下的键"></a>GetKeyState 获取当前按下的键</h3><p>通过测试单个键盘按键可以发现当前按下的是哪个键。方法是调用 API 函数 GetKeyState。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetKeyState PROTO, nVirtKey:DWORD</span><br></pre></td></tr></table></figure>

<p>向该函数传递如下表所示的虚拟键值。测试程序必须按照同一个表来测试 EAX 里面的返回值。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>虚拟键符号</th>
<th>EAX 中被测试的位</th>
</tr>
</thead>
<tbody><tr>
<td>NumLock</td>
<td>VK_NUMLOCK</td>
<td>0</td>
</tr>
<tr>
<td>Scroll Lock</td>
<td>VK_SCROLL</td>
<td>0</td>
</tr>
<tr>
<td>Left Shift</td>
<td>VK_LSHIFT</td>
<td>15</td>
</tr>
<tr>
<td>Right Shift</td>
<td>VK_tRSHIFT</td>
<td>15</td>
</tr>
<tr>
<td>Left Ctrl</td>
<td>VK_LCONTROL</td>
<td>15</td>
</tr>
<tr>
<td>Right Ctrl</td>
<td>VK_RCONTROL</td>
<td>15</td>
</tr>
<tr>
<td>Left Menu</td>
<td>VK_LMENU</td>
<td>15</td>
</tr>
<tr>
<td>Right Menu</td>
<td>VK_RMENU</td>
<td>15</td>
</tr>
</tbody></table>
<h2 id="窗口输出"><a href="#窗口输出" class="headerlink" title="窗口输出"></a>窗口输出</h2><h3 id="WriteConsole-输出"><a href="#WriteConsole-输出" class="headerlink" title="WriteConsole 输出"></a>WriteConsole 输出</h3><p>函数 WriteConsole 在控制台窗口的当前光标所在位置写一个字符串，并将光标留着字符串末尾右边的字符位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteConsole PROTO,</span><br><span class="line">  hConsoleOutput:HANDLE,</span><br><span class="line">  lpBuffer:PTR BYTE,</span><br><span class="line">  nNumberOfCharsToWrite:DWORD,</span><br><span class="line">  lpNumberOfCharsWritten:PTR DWORD,</span><br><span class="line">  lpReserved:DWORD</span><br></pre></td></tr></table></figure>

<p>hConsoleOutput 是控制台输出流句柄；</p>
<p>lpBuffer 是输出字符数组的指针；</p>
<p>nNumberOfCharsToWrite 是数组长度；</p>
<p>lpNumberOfCharsWritten 是函数返回时实际输出字符数量的整数指针。</p>
<p>最后一个参数未使用，因此将其设置为 0。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">			.data	</span><br><span class="line">endl EQU &lt;0dh,0ah&gt;</span><br><span class="line"></span><br><span class="line">b_str label byte</span><br><span class="line">	BYTE &quot;hello I am here&quot;,0Ah</span><br><span class="line">	BYTE &quot;I have no friends &quot;,0Ah</span><br><span class="line">	BYTE &quot;This is my friend.&quot;, endl</span><br><span class="line">len	DWORD ($-b_str)</span><br><span class="line"></span><br><span class="line">A_Output_Handle	HANDLE 0     ; 标准输出设备句柄</span><br><span class="line">how_much	DWORD ?      ; 输出字节数</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	</span><br><span class="line">		INVOKE GetStdHandle, STD_OUTPUT_HANDLE</span><br><span class="line">		mov A_Output_Handle,eax</span><br><span class="line"></span><br><span class="line">		INVOKE WriteConsole,</span><br><span class="line">		A_Output_Handle,        ; 控制台输出句柄</span><br><span class="line">		ADDR b_str,		; 字符串指针</span><br><span class="line">		len,			; 字符长度</span><br><span class="line">		ADDR how_much,		; 返回输出字节数</span><br><span class="line">		0                       ; 未使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="WriteConsoleOutputCharacter"><a href="#WriteConsoleOutputCharacter" class="headerlink" title="WriteConsoleOutputCharacter"></a>WriteConsoleOutputCharacter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteConsoleOutputCharacter PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,                         		 ;控制台输出句柄</span><br><span class="line">    lpCharacter :PTR BYTE,                               ;缓冲区指针</span><br><span class="line">    nLength: DWORD,                                      ;缓冲区大小</span><br><span class="line">    dwWriteCoord: COORD,                             	 ;第一个单元格的坐标</span><br><span class="line">    lpNumberOfCharsWritten: PTR DWORD   				 ;输出计数器</span><br></pre></td></tr></table></figure>



<p>下面是一个失败的例子</p>
<p>还要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">			.data	</span><br><span class="line">endl EQU &lt;0dh,0ah&gt;</span><br><span class="line"></span><br><span class="line">b_str label byte</span><br><span class="line">	BYTE &quot;hello I am here&quot;,0Ah</span><br><span class="line">	BYTE &quot;I have no friends &quot;,0Ah</span><br><span class="line">	BYTE &quot;This is my friend.&quot;, endl</span><br><span class="line">len	DWORD ($-b_str)</span><br><span class="line"></span><br><span class="line">A_Output_Handle	HANDLE 0     ; 标准输出设备句柄</span><br><span class="line">how_much	DWORD ?      ; 输出字节数</span><br><span class="line">dwWriteCoord	COORD	&lt;0,0&gt;</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">.code</span><br><span class="line">start:		</span><br><span class="line">	</span><br><span class="line">		INVOKE GetStdHandle, STD_OUTPUT_HANDLE</span><br><span class="line">		mov A_Output_Handle,eax</span><br><span class="line"></span><br><span class="line">		INVOKE WriteConsoleOutputCharacter,</span><br><span class="line">		A_Output_Handle,        ; 控制台输出句柄</span><br><span class="line">		ADDR b_str,		; 字符串指针</span><br><span class="line">		len,			; 字符长度</span><br><span class="line">		dwWriteCoord,		; 返回输出字节数</span><br><span class="line">		ADDR how_much                 ; 未使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h2 id="文件-处理"><a href="#文件-处理" class="headerlink" title="文件 处理"></a>文件 处理</h2><h3 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h3><p>函数 CreateFile 可以创建一个新文件或者打开一个已有文件。</p>
<p>如果调用成功，函数返回打开文件的句柄；</p>
<p>否则，返回特殊常数 INVALID_HANDLE_VALUEO</p>
<p> 原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateFile PROTO,                           ;创建新文件</span><br><span class="line">    lpFilename:PTR BYTE,                    ;文件名指针</span><br><span class="line">    dwDesiredAccess:DWORD,              	;访问模式</span><br><span class="line">    dwShareMode:DWORD,                  	;共享模式</span><br><span class="line">    lpSecurityAttributes:DWORD,          	;安全属性指针</span><br><span class="line">    dwCreationDisposition:DWORD,     		;文件创建选项</span><br><span class="line">    dwFlagsAndAttributes:DWORD,      		;文件属性</span><br><span class="line">    hTemplateFile:DWORD                    	;文件模板句柄</span><br></pre></td></tr></table></figure>



<p>下表对参数进行了说明。如果函数调用失败则返回值为零。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lpFileName</td>
<td>指向一个<code>0</code>空字节结束字符串，该串为部分或全部合格的文件名  例如（C:\path\filename）</td>
</tr>
<tr>
<td>dwDesiredAccess</td>
<td>指定文件访问方式（读或写）</td>
</tr>
<tr>
<td>dwShareMode</td>
<td>控制多个程序对打开文件的访问能力</td>
</tr>
<tr>
<td>lpSecurityAttributes</td>
<td>指向安全结构，该结构控制安全权限</td>
</tr>
<tr>
<td>dwCreationDisposition</td>
<td>指定文件存在或不存在时的操作</td>
</tr>
<tr>
<td>dwFlagsAndAttributes</td>
<td>包含位标志指定文件属性，如存档、加密、隐藏、普通、系统和临时</td>
</tr>
<tr>
<td>hTemplateFile</td>
<td>包含一个可选的文件模板句柄，该文件为已创建的文件提供文件属性和扩展属性；如果不使用该参数，就将其设置为 0</td>
</tr>
</tbody></table>
<p>关于上面说到的参数</p>
<p> dwDesiredAccess</p>
<p>参数 dwDesiredAccess 允许指定对文件进行读访问、写访问、读&#x2F;写访问，或者设备查询访问。</p>
<p>可以从下表列出的值中选择，也可以从表中未列出的更多特定标志值选择。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>为对象指定设备查询访问。应用程序可以查询设备属性而无需访问设备，也可以检查文件是否存在</td>
</tr>
<tr>
<td>GENERIC_READ</td>
<td>读访问。可以从文件中读取数据，文件指针可以移动。与 GENERIC_WRITE 一起使用为读&#x2F;写访问</td>
</tr>
<tr>
<td>GENERIC_WRITE</td>
<td>写访问。可以向文件中写入数据，文件指针可以移动。与 GENERIC_READ 一起使用为读&#x2F;写访问</td>
</tr>
</tbody></table>
<p>dwCreationDisposition</p>
<p>参数 dwCreationDisposition 指定当文件存在或不存在时应采取怎样的操作。可从下表中选择一个值。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE_NEW</td>
<td>创建一个新文件。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件已经存在，则函数调用失败</td>
</tr>
<tr>
<td>CREATE_ALWAYS</td>
<td>创建一个新文件。如果文件已存在，则函数会覆盖原文件，清除现有属性，并合并文件 属性与预定义的常数 FILE_ATTRIBUTES_ARCHIVE 中属性参数指定的标志。要求将参数 dwDesiredAccess 设置为 GENERIC WRITE</td>
</tr>
<tr>
<td>OPEN_EXISTING</td>
<td>打开文件。如果文件不存在，则函数调用失败。可用于读取和&#x2F;或写入文件</td>
</tr>
<tr>
<td>OPEN_ALWAYS</td>
<td>如果文件存在，则打开文件。如果不存在，则函数创建文件，就好像CreateDisposition 的值为 CREATE NEW</td>
</tr>
<tr>
<td>TRUNCATE_EXISTING</td>
<td>打开文件。一旦打开，文件将被截断，使其大小为零。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件不存在，则函数调用失败</td>
</tr>
</tbody></table>
<p>下表列出了参数 dwFlagsAndAttributes 比较常用的值。</p>
<p>允许任意属性组合，除了 FILE_ATTRIBUTE_NORMAL 会被其他 所有属性覆盖。</p>
<p>这些值能映射为 2 的幂，因此可以用汇编时 OR 运算符或 + 运算符将它们组 合为一个参数：</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE_ATTRIBUTE_HIDDEN OR FILE_ATTRIBUTE_READONLY</span><br><span class="line">FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_READONLY</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ATTRIBUTE_ARCHIVE</td>
<td>文件存档。应用程序使用这个属性标记文件以便备份或移动</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_HIDDEN</td>
<td>文件隐藏。不包含在普通目录列表中</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_NORMAL</td>
<td>文件没有其他属性设置。该属性只在单独使用时有效</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_READONLY</td>
<td>文件只读。应用程序可以读文件但不能写或删除文件</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_TEMPORARY</td>
<td>文件被用于临时存储</td>
</tr>
</tbody></table>
<p>打开并读取（输入）已存在文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE CreateFile,</span><br><span class="line">    ADDR filename,            ;文件名指针</span><br><span class="line">    GENERIC_READ,             ;读文件</span><br><span class="line">    DO_NOT_SHARE,             ;共享模式</span><br><span class="line">    NULL,                     ;安全属性指针</span><br><span class="line">    OPEN_EXISTING,            ;打开已存在文件</span><br><span class="line">    FILE_ATTRIBUTE_NORMALA    ;普通文件属性</span><br><span class="line">    0                         ;未使用</span><br></pre></td></tr></table></figure>





<p>打开并写入（输出）已存在文件。</p>
<p>文件打开后，可以通过写入覆盖当前数据，</p>
<p>或者将文件指针移到末尾，向文件添加新数据（参见11.1.6节的SetFilePointer）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE CreateFile,</span><br><span class="line">    ADDR filename,</span><br><span class="line">    GENERIC_WRITEZ,      ;写文件</span><br><span class="line">    DO_NOT_SHARE,			;共享模式</span><br><span class="line">    NULL,				;安全属性指针</span><br><span class="line">    OPEN_EXISTIN,       ;文件必须存在</span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">    0					 ;未使用</span><br></pre></td></tr></table></figure>



<p>创建有普通属性的新文件，并删除所有已存在的同名文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE CreateFile,</span><br><span class="line">    ADDR filename,</span><br><span class="line">    GENERIC_WRITE,       ;写文件</span><br><span class="line">    DO _NOT_SHARE,</span><br><span class="line">    NULL,</span><br><span class="line">    CREATE_ALWAYS,       ;覆盖已存在的文件</span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>



<p>若文件不存在，则创建文件；否则打开并输出现有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE CreateFile,</span><br><span class="line">    ADDR filename,</span><br><span class="line">    GENERIC_WRITE,         ;写文件</span><br><span class="line">    DO_NOT_SHARE,</span><br><span class="line">    NULL,</span><br><span class="line">    CREATE_NEW,            ;不删除已存在文件</span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>



<h3 id="CloseHandle"><a href="#CloseHandle" class="headerlink" title="CloseHandle"></a>CloseHandle</h3><p> 函数 CloseHandle 关闭一个打开的对象句柄。其原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CloseHandle PROTO,</span><br><span class="line">    hObject: HANDLE ;对象句柄</span><br></pre></td></tr></table></figure>



<h3 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h3><p>函数 ReadFile 从输入文件中读取文本。其原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReadFile PROTO,</span><br><span class="line">    hFile:HANDLE,                                           ;输入句柄</span><br><span class="line">    lpBuffer:PTR BYTE,                                     	;缓冲区指针</span><br><span class="line">    nNumberOfBytesToRead:DWORD,           					;读取的字节数</span><br><span class="line">    lpNumberOfBytesRead:PTR DWORD,       					;实际读出的 字节数</span><br><span class="line">    lpOverlapped:PTR DWORD                       			;异步信息指针</span><br></pre></td></tr></table></figure>



<p>其中：</p>
<ul>
<li>hFile 是由 CreateFile 返回的打开文件的句柄；</li>
<li>lpBuffer 指向的缓冲区接收从该文件读取的数据；</li>
<li>nNumberOfBytesToRead 定义从该文件读取的最大字节数；</li>
<li>lpNumberOfBytesRead 指向的整数为函数返回时实际读取的字节数；</li>
<li>lpOverlapped 应被设置为 NULL(0)。若函数调用失败，则返回值为零。</li>
</ul>
<p>如果对同一个打开文件的句柄进行多次调用，那么 ReadFile 就会记住最后一次读取的位置，并从这个位置开始读。换句话说，函数有一个内部指针指向文件内的当前位置。</p>
<h3 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h3><p>函数 WriteFile 用输出句柄向文件写入数据。</p>
<p>句柄可以是屏幕缓冲区句柄，</p>
<p>也可以是分配给文本文件的句柄。</p>
<p>函数从文件内部位置指针所指向的位置开始写数据。</p>
<p>写操作完成后，文件位置指针按照实际写入的字节数进行调整。函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteFile PROTO,</span><br><span class="line">    hFile:HANDLE,                                           ;输出句柄</span><br><span class="line">    lpBuffer:PTR BYTE,                                     	;缓冲区指针</span><br><span class="line">    nNumberOfBytesToWrite:DWORD,           					;缓冲区大小</span><br><span class="line">    lpNumberOfBytesWritten:PTR DWORD,   					;写入字节数</span><br><span class="line">    lpOverlapped:PTR DWORD                       			;异步信息指针</span><br></pre></td></tr></table></figure>



<p>中：</p>
<ul>
<li>hFile 是已打开文件的句柄；</li>
<li>lpBuffer 指向的缓冲区包含了写入到文件的数据；</li>
<li>nNumberOfBytesToWrite 指定向文件写入多少字节；</li>
<li>lpNumberOfBytesWritten 指向的整数为函数执行后实际写入的字节数；</li>
<li>若为同步操作，则 lpOverlapped 应被设置为 NULL。若函数调用失败，则返回值为零。</li>
</ul>
<h3 id="SetFilePointer"><a href="#SetFilePointer" class="headerlink" title="SetFilePointer"></a>SetFilePointer</h3><p>函数 SetFilePointer 移动打开文件的位置指针。该函数可以用于向文件添加数据，或是执行随机访问记录处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetFilePointer PROTO,</span><br><span class="line">    hFile:HANDLE,                                          ;文件句柄</span><br><span class="line">    lpDistanceToMove:SDWORD,                  				;指针移动 字节数</span><br><span class="line">    lpDistanceToMoveHigh:PTR SDWORD,   						;指针移动字节数，高双字</span><br><span class="line">    dwMoveMethod:DWORD                        				;起点</span><br></pre></td></tr></table></figure>



<p>lpDistance移动距离本身为 64 位有符号整数值，分为两个部分：</p>
<ul>
<li>lpDistanceToMove：低 32 位</li>
<li>lpDistanceToMoveHigh：含有高 32 位的变量指针</li>
<li></li>
</ul>
<p>dwMoveMode 指定文件指针移动的起点，选择项为 3 个预定义符号：FILE_BEGIN、FILE_CURRENT 和 FILE_END。</p>
<p>若函数调用失败，则返回值为零。</p>
<p>如果 lpDistanceToMoveHigh 为空，则只用 lpDistanceToMove 的值来移动文件指针。例如，下面的代码准备添加到一个文件末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE SetFilePointer,</span><br><span class="line">  fileHandle,    ;文件句柄</span><br><span class="line">  0,           ;距离低32位</span><br><span class="line">  0,           ;距离高32位</span><br><span class="line">  FILE_END     ;移动模式</span><br></pre></td></tr></table></figure>





<h2 id="控制台窗口操作"><a href="#控制台窗口操作" class="headerlink" title="控制台窗口操作"></a>控制台窗口操作</h2><p>下列函数影响的是控制台窗口及其相对于屏幕缓冲区的位置：</p>
<ul>
<li>SetConsoleWindowInfo：设置控制台窗口相对于屏幕缓冲区的大小和位置。</li>
<li>GetConsoleScreenBufferInfo：返回（还包括其他一些信息）控制台窗口相对于屏幕缓冲区的矩形坐标。</li>
<li>SetConsoleCursorPosition：将光标设置在屏幕缓冲区内的任何位置；如果区域不可见，则移动控制台窗口直到光标可见。</li>
<li>ScrollConsoleScreenBuffer：移动屏幕缓冲区中的一些或全部文本，本函数会影响控制台窗口显示的文本。</li>
</ul>
<h3 id="SetConsoleTitle"><a href="#SetConsoleTitle" class="headerlink" title="SetConsoleTitle"></a>SetConsoleTitle</h3><p>改变控制台窗口的标题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">.titleStr BYTE &quot;Console title&quot;, 0</span><br><span class="line">.code</span><br><span class="line">INVOKE SetConsoleTitle, ADDR titleStr</span><br></pre></td></tr></table></figure>



<h3 id="GetConsoleScreenBufferInfo"><a href="#GetConsoleScreenBufferInfo" class="headerlink" title="GetConsoleScreenBufferInfo"></a>GetConsoleScreenBufferInfo</h3><p>函数 GetConsoleScreenBufferInfo 返回控制台窗口的当前状态信息。它有两个参数：控制台屏幕的句柄和指向该函数填充的结构的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetConsoleScreenBufferInfo PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,</span><br><span class="line">    lpConsoleScreenBufferInfo:PTR CONSOLE_SCREEN_BUFFER_INFO</span><br></pre></td></tr></table></figure>





<p>函数示例调用如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">consoleInfo CONSOLE_SCREEN_BUFFER_INFO &lt;&gt;</span><br><span class="line">outHandle HANDLE ?</span><br><span class="line">.code</span><br><span class="line">INVOKE GetConsoleScreenBufferInfo, outHandle,</span><br><span class="line">  ADDR consoleInfo</span><br></pre></td></tr></table></figure>



<p>CONSOLE_SCREEN_BUFFER_INFO 结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSOLE_SCREEN_BUFFER_INFO STRUCT</span><br><span class="line">    dwSize COORD &lt;&gt;</span><br><span class="line">    dwCursorPosition COORD &lt;&gt;</span><br><span class="line">    wAttributes WORD ?</span><br><span class="line">    srWindow SMALL_RECT &lt;&gt;</span><br><span class="line">    dwMaximumWindowSize COORD &lt;&gt;</span><br><span class="line">CONSOLE_SCREEN_BUFFER_INFO ENDS</span><br></pre></td></tr></table></figure>

<p>dwSize 按字符行列数返回屏幕缓冲区大小。</p>
<p>dwCursorPosition 返回光标的位置。这两个字段都是 COORD 结构。</p>
<p>wAttributes 返回字符的前景色和背景色，字符由诸如 WriteConsole 和 WriteFile 等函数写到控制台。</p>
<p>srWindow 返回控制台窗口相对于屏幕缓冲区的坐标。</p>
<p>dwMaximumWindowSize 以当前屏幕缓冲区的大小、字体和视频显示大小为基础，返回控制台窗口的最大尺寸。</p>
<h3 id="SetConsoleWindowInfo"><a href="#SetConsoleWindowInfo" class="headerlink" title="SetConsoleWindowInfo"></a>SetConsoleWindowInfo</h3><p>函数 SetConsoleWindowInfo 可以设置控制台窗口相对于其屏幕缓冲区的大小和位置。函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetConsoleWindowInfo PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,                  ;屏幕缓冲区句柄</span><br><span class="line">    bAbsolute:DWORD,                             ;坐标类型</span><br><span class="line">    lpConsoleWindow:PTR SMALL_RECT  ;矩形窗口指针</span><br></pre></td></tr></table></figure>



<p>bAbsolute 说明如何使用结构中由 lpConsoleWindow 指出的坐标。</p>
<p>如果 bAbsolute 为真，则坐标定义控制台窗口新的左上角和右下角。</p>
<p>如果 bAbsolute 为假，则坐标与当前窗口坐标相加。</p>
<p>什么叫真真假假????写一个1,他也是32位的BOOL值</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">; Appending to a File                   (AppendFile.asm)</span><br><span class="line"></span><br><span class="line">; This program appends text to an existing file.</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">message		BYTE &quot;:  This line of text was written &quot;</span><br><span class="line">		BYTE &quot;I am Dqx_Gh0st!&quot;,0dh,0ah</span><br><span class="line"></span><br><span class="line">messageSize	DWORD ($-message)</span><br><span class="line">outHandle	HANDLE 0                     ; 标准输出句柄</span><br><span class="line">bytesWritten	DWORD ?                      ; 已写入字节数</span><br><span class="line">lineNum		DWORD 0</span><br><span class="line">windowRect	SMALL_RECT &lt;0,0,60,11&gt;       ; 上，下，左，右</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">	INVOKE GetStdHandle, STD_OUTPUT_HANDLE</span><br><span class="line">	mov outHandle,eax</span><br><span class="line"></span><br><span class="line">	.REPEAT</span><br><span class="line">                  </span><br><span class="line">	INVOKE WriteConsole,</span><br><span class="line">	outHandle,                           ; 控制台输出句柄</span><br><span class="line">	ADDR message,                        ; 字符串指针</span><br><span class="line">	messageSize,                         ; 字符串长度</span><br><span class="line">	ADDR bytesWritten,                   ; 返回已写字节数</span><br><span class="line">	0                                    ; 未使用</span><br><span class="line">	inc  lineNum                         ; 下一行编号</span><br><span class="line">	.UNTIL lineNum &gt; 5</span><br><span class="line"></span><br><span class="line">	; 调整控制台窗口相对于屏幕缓冲区的大小和位置</span><br><span class="line">	INVOKE SetConsoleWindowInfo,</span><br><span class="line">	outHandle,</span><br><span class="line">	TRUE,</span><br><span class="line">	ADDR windowRect</span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="SetConsoleScreenBufferSize"><a href="#SetConsoleScreenBufferSize" class="headerlink" title="SetConsoleScreenBufferSize"></a>SetConsoleScreenBufferSize</h3><p>可以将屏幕缓冲区设置为 X 列 * Y 行。其原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetConsoleScreenBufferSize PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,                 			;屏幕缓冲区句柄</span><br><span class="line">    dwSize:COORD                                   ;新屏幕缓冲区大小</span><br></pre></td></tr></table></figure>



<h2 id="控制台光标设置函数"><a href="#控制台光标设置函数" class="headerlink" title="控制台光标设置函数"></a>控制台光标设置函数</h2><p>Win32 API 提供了函数用于设置控制台应用光标的大小、可见度和屏幕位置。</p>
<p>与这些函数相关的重要是 CONSOLE_CURSOR_INFO，其中包含了控制台光标的大小和可见度信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSOLE_CURSOR_INFO STRUCT</span><br><span class="line">    dwSize DWORD ?</span><br><span class="line">    bVisible DWORD ?</span><br><span class="line">CONSOLE_CURSOR_INFO ENDS</span><br></pre></td></tr></table></figure>

<p>wSize 为光标填充的字符单元格的百分比（从 1 到 100）。</p>
<p>如果光标可见，则 bVisible 等于 TRUE(1)。</p>
<h3 id="GetConsoleCursorInfo"><a href="#GetConsoleCursorInfo" class="headerlink" title="GetConsoleCursorInfo"></a>GetConsoleCursorInfo</h3><p>返回控制台光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetConsoleCursorInfo PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,</span><br><span class="line">    lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO</span><br></pre></td></tr></table></figure>

<p>默认情况下，光标大小为 25，这表示光标占据了 25% 的字符单元格</p>
<h3 id="SetConsoleCursorInfo"><a href="#SetConsoleCursorInfo" class="headerlink" title="SetConsoleCursorInfo"></a>SetConsoleCursorInfo</h3><p>设置光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetConsoleCursorInfo PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,</span><br><span class="line">    lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO</span><br></pre></td></tr></table></figure>



<h3 id="SetConsoleCursorPosition"><a href="#SetConsoleCursorPosition" class="headerlink" title="SetConsoleCursorPosition"></a>SetConsoleCursorPosition</h3><p>设置光标的 X、Y 位置。向其传递一个 COORD 结构和控制台输岀句柄：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetConsoleCursorPosition PROTO,</span><br><span class="line">    hConsoleOutput:DWORD,    ;输入模式句柄</span><br><span class="line">    dwCursorPosition:COORD    ;屏幕 X、Y 坐标</span><br></pre></td></tr></table></figure>



<h2 id="控制台文本颜色"><a href="#控制台文本颜色" class="headerlink" title="控制台文本颜色"></a>控制台文本颜色</h2><p>控制台窗口中的文本颜色有两种控制方法。</p>
<ul>
<li>通过调用 SetConsoleTextAttribute 来改变当前文本颜色，这种方法会影响控制台中所有后续输出文本。</li>
<li>调用 WriteConsoleOutputAttribute 来设置指定单元格的属性。函数 GetConsoleScreenBufferlnfo 返回当前屏幕的颜色以及其他控制台信息。</li>
</ul>
<h3 id="SetConsoleTextAttribute"><a href="#SetConsoleTextAttribute" class="headerlink" title="SetConsoleTextAttribute"></a>SetConsoleTextAttribute</h3><p>函数 SetConsoleTextAttribute 可以设置控制台窗口所有后续输出文本的前景色和背景色。原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetConsoleTextAttribute PROTO,</span><br><span class="line">    hConsoleOutput:HANDLE,           ;控制台输出句柄</span><br><span class="line">    wAttributes : WORD                     ;颜色属性</span><br></pre></td></tr></table></figure>

<p>颜色值保存在 wAttributes 参数的低字节中。</p>
<h3 id="WriteConsoleOutputAttribute"><a href="#WriteConsoleOutputAttribute" class="headerlink" title="WriteConsoleOutputAttribute"></a>WriteConsoleOutputAttribute</h3><p>函数 WriteConsoleOutputAttribute 从指定位置开始，向控制台屏幕缓冲区的连续单元格复制一组属性值。原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteConsoleOutputAttribute PROTO,</span><br><span class="line">    hConsoleOutput:DWORD,                               ;输出句柄</span><br><span class="line">    lpAttribute:PTR WORD,                                   ;写属性</span><br><span class="line">    nLength:DWORD,                                            ;单元格数</span><br><span class="line">    dwWriteCoord :COORD,                                  ;第一个单元格坐标</span><br><span class="line">    lpNumberOfAttrsWritten:PTR DWORD           ;输出计数</span><br></pre></td></tr></table></figure>



<p>其中：</p>
<ul>
<li>lpAttribute 指向属性数组，其中每个字节的低字节都包含了颜色值；</li>
<li>nLength 为数组长度；</li>
<li>dwWriteCoord 为接收属性的开始屏幕单元格；</li>
<li>lpNumberOfAttrsWritten 指向一个变量，其中保存的是已写单元格的数量。</li>
</ul>
<p>例子</p>
<p>这个例子有误,后续改进</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">outHandle    HANDLE ?</span><br><span class="line">cellsWritten DWORD ?</span><br><span class="line">xyPos COORD &lt;10,2&gt;</span><br><span class="line">; 字符编号数组</span><br><span class="line">buffer BYTE 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</span><br><span class="line">       BYTE 16,17,18,19.20</span><br><span class="line">BufSize DWORD ($ - buffer)</span><br><span class="line">; 属性数组</span><br><span class="line">attributes WORD 0Fh,0Eh,0Dh,0Ch,0Bh,0Ah,9,8,7,6</span><br><span class="line">           WORD 5,4,3,2,1,0F0h,0E0h,0D0h,0C0h,0B0h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">	; 获取控制台标准输出句柄</span><br><span class="line">	INVOKE GetStdHandle,STD_OUTPUT_HANDLE</span><br><span class="line">	mov outHandle,eax</span><br><span class="line">	; 设置相邻单元格颜色</span><br><span class="line">	INVOKE WriteConsoleOutputAttribute,</span><br><span class="line">	outHandle, ADDR attributes,</span><br><span class="line">	BufSize, xyPos,</span><br><span class="line">	ADDR cellsWritten</span><br><span class="line">	; 写 1 到 20 号字符</span><br><span class="line">	INVOKE WriteConsoleOutputCharacter,</span><br><span class="line">	outHandle, ADDR buffer, BufSize,</span><br><span class="line">	xyPos, ADDR cellsWritten</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">end start</span><br><span class="line">;-----------------------------------------------------</span><br></pre></td></tr></table></figure>



<h2 id="Win32时间与日期函数"><a href="#Win32时间与日期函数" class="headerlink" title="Win32时间与日期函数"></a>Win32时间与日期函数</h2><h3 id="函数一览表-1"><a href="#函数一览表-1" class="headerlink" title="函数一览表"></a>函数一览表</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CompareFileTime</td>
<td>比较两个 64 位的文件时间</td>
</tr>
<tr>
<td>DosDateTimeToFileTime</td>
<td>把 MS-DOS 日期和时间值转换为一个 64 位的文件时间</td>
</tr>
<tr>
<td>FileTimeToDosDateTime</td>
<td>把 64 位文件时间转换为 MS-DOS 日期和时间值</td>
</tr>
<tr>
<td>FileTimeToLocalFileTime</td>
<td>把 UTC（通用协调时间）文件时间转换为本地文件时间</td>
</tr>
<tr>
<td>FileTimeToSystemTime</td>
<td>把 64 位文件时间转换为系统时间格式</td>
</tr>
<tr>
<td>GetFileTime</td>
<td>检索文件创建、最后访问和最后修改的日期与时间</td>
</tr>
<tr>
<td>GetLocalTime</td>
<td>检索当前本地日期和时间</td>
</tr>
<tr>
<td>GetSystemTime</td>
<td>以 UTC 格式检索当前系统日期和时间</td>
</tr>
<tr>
<td>GetSystemTimeAdjustment</td>
<td>决定系统是否对其日历钟进行周期性时间调整</td>
</tr>
<tr>
<td>GetSystemTimeAsFileTime</td>
<td>以 UTC 格式检索当前系统日期和时间</td>
</tr>
<tr>
<td>GetTickCount</td>
<td>检索自系统启动后经过的毫秒数</td>
</tr>
<tr>
<td>GetTimeZoneInformation</td>
<td>检索当前时区参数</td>
</tr>
<tr>
<td>LocalFileTimeToFileTime</td>
<td>把本地文件时间转换为基于 UTC 的文件时间</td>
</tr>
<tr>
<td>SetFileTime</td>
<td>设置文件创建、最后访问和最后修改的日期与时间</td>
</tr>
<tr>
<td>SetLocalTime</td>
<td>设置当前本地时间与日期</td>
</tr>
<tr>
<td>SetSystemTime</td>
<td>设置当前系统时间与日期</td>
</tr>
<tr>
<td>SetSystemTimeAdjustment</td>
<td>启用或禁用对系统日历钟进行周期性时间调整</td>
</tr>
<tr>
<td>SetTimeZoneInformation</td>
<td>设置当前时区参数</td>
</tr>
<tr>
<td>SystemTimeToFileTime</td>
<td>把系统时间转换为文件时间</td>
</tr>
<tr>
<td>SystemTimeToTzSpecificLocalTime</td>
<td>把 UTC 时间转换为指定时区对应的本地时间</td>
</tr>
</tbody></table>
<h3 id="SYSTEMTIME-结构"><a href="#SYSTEMTIME-结构" class="headerlink" title="SYSTEMTIME 结构"></a>SYSTEMTIME 结构</h3><p>SYSTEMTIME 结构由 Windows API 的日期和时间函数使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYSTEMTIME STRUCT</span><br><span class="line">  wYear WORD ?          ;年（4 个数子）</span><br><span class="line">  wMonth WORD ?        ;月（1 ~ 12）</span><br><span class="line">  wDayOfWeek WORD ?   ;星期（0 ~ 6）</span><br><span class="line">  wDay WORD ?          ;日（1 ~ 31）</span><br><span class="line">  wHour WORD ?         ;小时（0 ~ 23）</span><br><span class="line">  wMinute WORD ?       ;分钟（0 ~ 59）</span><br><span class="line">  wSecond WORD ?       ;秒（0 ~ 59）</span><br><span class="line">  wMilliseconds WORD ?   ;毫秒（0 ~ 999）</span><br><span class="line">SYSTEMTIME ENDS</span><br></pre></td></tr></table></figure>

<p>字段 wDayOfWeek 的值依序为星期天 &#x3D; 0，星期一 &#x3D; 1，以此类推。wMilliseconds 中的值不确定，因为系统可以与时钟源同步周期性地刷新时间。</p>
<h3 id="FILETIME"><a href="#FILETIME" class="headerlink" title="FILETIME"></a>FILETIME</h3><p>FILETIME 结构把 64 位四字分割为两个双字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILETIME STRUCT</span><br><span class="line">    loDateTime DWORD ?</span><br><span class="line">    hiDateTime DWORD ?</span><br><span class="line">FILETIME ENDS</span><br></pre></td></tr></table></figure>



<h3 id="GetLocalTime-和-SetLocalTime"><a href="#GetLocalTime-和-SetLocalTime" class="headerlink" title="GetLocalTime 和 SetLocalTime"></a>GetLocalTime 和 SetLocalTime</h3><p>函数 GetLocalTime 根据系统时钟返回日期和当前时间。</p>
<p>时间要调整为本地时区。</p>
<p>调用该函数时，需向其传递一个指针指向 SYSTEMTIME 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetLocalTime PROTO,</span><br><span class="line">    lpSystemTime:PTR SYSTEMTIME</span><br></pre></td></tr></table></figure>

<p>函数 GetLocalTime 调用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">sysTime SYSTEMTIME &lt;&gt;</span><br><span class="line">.code</span><br><span class="line">INVOKE GetLocalTime, ADDR sysTime</span><br></pre></td></tr></table></figure>



<p>函数 SetLocalTime 设置系统的本地日期和时间。</p>
<p>调用时，需向其传递一个指针指向包含了期望日期和时间的 SYSTEMTIME 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetLocalTime PROTO,</span><br><span class="line">    lpSystemTime:PTR SYSTEMTIME</span><br></pre></td></tr></table></figure>

<p>如果函数执行成功，则返回非零整数；如果失败，则返回零</p>
<h3 id="GetTickCount"><a href="#GetTickCount" class="headerlink" title="GetTickCount"></a>GetTickCount</h3><p>返回从系统启动起经过的毫秒数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetTickCount PROTO               ; EAX 为返回值</span><br></pre></td></tr></table></figure>

<p>由于返回值为一个双字，因此当系统连续运行 49.7 天后，时间将会回绕归零</p>
<p>。可以使用这个函数监视循环经过的时间，并在达到时间限制时终止循环。</p>
<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><p>有些时候程序需要暂停或延迟一小段时间。虽然可以通过构造一个计算循环或忙循环来保持处理器工作，但是不同的处理器会使得执行时间不同</p>
<p>Win32 函数 Sleep 按照指定毫秒数暂停当前执行的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sleep PROTO,</span><br><span class="line">  dwMilliseconds:DWORD</span><br></pre></td></tr></table></figure>



<h3 id="GetDateTime"><a href="#GetDateTime" class="headerlink" title="GetDateTime"></a>GetDateTime</h3><p>GetDateTime 以 100 纳秒为间隔，返回从 1601 年 1 月 1 日起经过的时间间隔数。</p>
<p>如果想要为日期计算准备系统日期&#x2F;时间值，Win32 SDK 建议采用如下步骤：</p>
<ul>
<li>调用函数，如 GetLocalTime，填充 SYSTEMTIME 结构。</li>
<li>调用函数 SystemTimeToFileTime，将 SYSTEMTIME 结构转换为 FILETIME 结构。</li>
<li>将得到的 FILETIME 结构复制到 64 位的四字。</li>
</ul>
<h2 id="图形化的Windows应用程序"><a href="#图形化的Windows应用程序" class="headerlink" title="图形化的Windows应用程序"></a>图形化的Windows应用程序</h2><p>下表列出了编写该程序时需要的各种链接库和头文件。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WinApp.asm</td>
<td>程序源代码</td>
</tr>
<tr>
<td>GraphWin.asm</td>
<td>头文件，包含程序要使用的结构、常量和函数原型</td>
</tr>
<tr>
<td>kernel32.lib</td>
<td>本章前面使用的 MS-Windows API 链接库</td>
</tr>
<tr>
<td>user32.lib</td>
<td>其他 MS-Windows API 函数</td>
</tr>
</tbody></table>
<h3 id="必要的结构"><a href="#必要的结构" class="headerlink" title="必要的结构"></a>必要的结构</h3><p>结构 POINT 以像素为单位，定义屏幕上一个点的 X 坐标和 Y 坐标。它可以用于定位图形对象、窗口和鼠标点击：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POINT STRUCT</span><br><span class="line">  ptX DWORD ?</span><br><span class="line">  ptY DWORD ?</span><br><span class="line">POINT ENDS</span><br></pre></td></tr></table></figure>

<p>结构 RECT 定义矩形边界。成员 left 为矩形左边的 X 坐标，成员 top为矩形上边的 Y 坐标。成员 right 和 bottom 保存矩形类似的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECT STRUCT</span><br><span class="line">  left DWORD ?</span><br><span class="line">  top DWORD ?</span><br><span class="line">  right DWORD ?</span><br><span class="line">  bottom DWORD ?</span><br><span class="line">RECT ENDS</span><br></pre></td></tr></table></figure>





<p>结构 MSGStruct 定义 MS-Windows 需要的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSGStruct STRUCT</span><br><span class="line">    msgWnd DWORD ?</span><br><span class="line">    msgMessage DWORD ?</span><br><span class="line">    msgWparam DWORD ?</span><br><span class="line">    msgLparam DWORD ?</span><br><span class="line">    msgTime    DWORD ?</span><br><span class="line">    msgPt POINT &lt;&gt;</span><br><span class="line">MSGStruct ENDS</span><br></pre></td></tr></table></figure>



<p>结构 WNDCLASS 定义窗口类。</p>
<p>程序中的每个窗口都必须属于一个类，并且每个程序都必须为其主窗口定义一个窗口类。</p>
<p>在主窗口可以显示之前，这个类必须要注册到操作系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WNDCLASS STRUC</span><br><span class="line">    style DWORD ?                               ;窗口样式选项</span><br><span class="line">    lpfnWndProc DWORD ?                 ; winProc 函数指针</span><br><span class="line">    cbClsExtra DWORD ?                      ;共享内存</span><br><span class="line">    cbWndExtra DWORD ?                   ;附加字节数</span><br><span class="line">    hlnstance DWORD ?                       ;当前程序句柄</span><br><span class="line">    hlcon DWORD ?                              ;图标句柄</span><br><span class="line">    hCursor DWORD ?                          ;光标句柄</span><br><span class="line">    hbrBackground DWORD ?              ;背景刷句柄</span><br><span class="line">    IpszMenuName DWORD ?             ;菜单名指针</span><br><span class="line">    IpszClassName DWORD ?              ; WinCZLass 名指针</span><br><span class="line">WNDCLASS ENDS</span><br></pre></td></tr></table></figure>



<p>下面对WNDCLASS上述参数进行简单小结：</p>
<ul>
<li>style 是不同样式选项的集合，比如 WS_CAPTION 和 WS_BORDER，用于控制窗口外观和行为。</li>
<li>lpfnWndProc 是指向函数的指针，该函数接收并处理由用户触发的事件消息。</li>
<li>cbClsExtra 指向一个类中所有窗口使用的共享内存。可以为空。</li>
<li>cbWndExtra 指定分配给后面窗口实例的附加字节数。</li>
<li>hInstance 为当前程序实例的句柄。</li>
<li>hIcon 和 hCursor 分别为当前程序中图标资源和光标资源的句柄。</li>
<li>hbrBackground 为背景（颜色）刷的句柄。</li>
<li>lpszMenuName 指向一个菜单名。</li>
<li>lpszClassName 指向一个空字节结束的字符串，该字符串中包含了窗口的类名称。</li>
</ul>
<h3 id="WinMain过程"><a href="#WinMain过程" class="headerlink" title="WinMain过程"></a>WinMain过程</h3><p>每个 Windows 应用程序都需要一个启动过程，通常将其命名为 WinMain，该过程负责下述任务：</p>
<ul>
<li>得到当前程序的句柄。</li>
<li>加载程序的图标和光标。</li>
<li>注册程序的主窗口类，并标识处理该窗口事件消息的过程。</li>
<li>创建主窗口。</li>
<li>显示并更新主窗口。</li>
<li>开始接收和发送消息的循环，直到用户关闭应用程序窗口</li>
</ul>
<p>WinMain 包含一个名为 GetMessage 的消息处理循环，</p>
<p>从程序的消息队列中取出下一条可用消息。</p>
<p>如果 GetMessage 取出的消息是 WM_QUIT，则返回零，即通知 WinMain 暂停程序。</p>
<p>对于其他消息，WinMain 将它们传递给 DispatchMessage 函数，该函数再将消息传递给程序的 WinProc 过程。若</p>
<h3 id="WinProc过程"><a href="#WinProc过程" class="headerlink" title="WinProc过程"></a>WinProc过程</h3><p>WinProc 程接收并处理所有与窗口有关的事件消息。这些事件绝大多数是由用户通过点击和拖动鼠标、按下键盘按键等操作发起的。这个过程的工作就是解码每个消息，如果消息得以识别，则在应用程序中执行与该消息相关的任务</p>
<p>过程声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WinProc PROC,</span><br><span class="line">hWnd: DWORD,         ;窗口句柄</span><br><span class="line">localMsg: DWORD,    ;消息 ID</span><br><span class="line">wParam:DWORD,       ;参数 1 （可变）</span><br><span class="line">lParam: DWORD         ;参数 2 （可变）</span><br></pre></td></tr></table></figure>

<p>根据具体的消息 ID，</p>
<p>第三个和第四个参数的内容可变。</p>
<p>比如，若点击鼠标，那么 lParam 就为点击位置的 X 坐标和 Y 坐标。</p>
<p>在后面的示例程序中，WinProc 过程处理了三种特定的消息：</p>
<ul>
<li>WM_LBUTTONDOWN，用户按下鼠标左键时产生该消息</li>
<li>WM_CREATE，表示刚刚创建主窗口</li>
<li>WM_CLOSE，表示将要关闭应用程序主窗口</li>
</ul>
<h3 id="ErrorHandler"><a href="#ErrorHandler" class="headerlink" title="ErrorHandler"></a>ErrorHandler</h3><p>过程 ErrorHandler 是可选的，如果在注册和创建程序主窗口的过程中系统报错，则调用该过程。</p>
<p>比如，如果成功注册程序主窗口，则函数 RegisterClass 返回非零值。</p>
<p>但是，如果该函数返回值为零，那么就调用 ErrorHandler( 显示一条消息 ) 并退出程序</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE RegisterClass, ADDR MainWin</span><br><span class="line">.IF eax == 0</span><br><span class="line">    call ErrorHandler</span><br><span class="line">    jmp Exit_Program</span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure>



<p>过程 ErrorHandler 需要执行几个重要任务：</p>
<ul>
<li>调用 GetLastError 取得系统错误号。</li>
<li>调用 FormatMessage 取得合适的系统格式化的错误消息字符串。</li>
<li>调用 MessageBox 显示包含错误消息字符串的弹出消息框。</li>
<li>调用 LocalFree 释放错误消息字符串使用的内存空间。</li>
</ul>
<h3 id="又一个无法运行的例子"><a href="#又一个无法运行的例子" class="headerlink" title="又一个无法运行的例子"></a>又一个无法运行的例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Windows Application                   (WinApp.asm)</span><br><span class="line"></span><br><span class="line">; This program displays a resizable application window and</span><br><span class="line">; several popup message boxes.</span><br><span class="line">; Thanks to Tom Joyce for creating a prototype</span><br><span class="line">; from which this program was derived.</span><br><span class="line"></span><br><span class="line">INCLUDE Dqx.inc</span><br><span class="line">;==================== DATA =======================</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">AppLoadMsgTitle BYTE &quot;Application Loaded&quot;,0</span><br><span class="line">AppLoadMsgText  BYTE &quot;This window displays when the WM_CREATE &quot;</span><br><span class="line">	            BYTE &quot;message is received&quot;,0</span><br><span class="line"></span><br><span class="line">PopupTitle BYTE &quot;Popup Window&quot;,0</span><br><span class="line">PopupText  BYTE &quot;This window was activated by a &quot;</span><br><span class="line">	       BYTE &quot;WM_LBUTTONDOWN message&quot;,0</span><br><span class="line"></span><br><span class="line">GreetTitle BYTE &quot;Main Window Active&quot;,0</span><br><span class="line">GreetText  BYTE &quot;This window is shown immediately after &quot;</span><br><span class="line">	       BYTE &quot;CreateWindow and UpdateWindow are called.&quot;,0</span><br><span class="line"></span><br><span class="line">CloseMsg   BYTE &quot;WM_CLOSE message received&quot;,0</span><br><span class="line"></span><br><span class="line">ErrorTitle  BYTE &quot;Error&quot;,0</span><br><span class="line">WindowName  BYTE &quot;ASM Windows App&quot;,0</span><br><span class="line">className   BYTE &quot;ASMWin&quot;,0</span><br><span class="line"></span><br><span class="line">; Define the Application&#x27;s Window class structure.</span><br><span class="line">MainWin WNDCLASS &lt;NULL,WinProc,NULL,NULL,NULL,NULL,NULL, \</span><br><span class="line">	COLOR_WINDOW,NULL,className&gt;</span><br><span class="line"></span><br><span class="line">msg	      MSGStruct &lt;&gt;</span><br><span class="line">winRect   RECT &lt;&gt;</span><br><span class="line">hMainWnd  DWORD ?</span><br><span class="line">hInstance DWORD ?</span><br><span class="line"></span><br><span class="line">;=================== CODE =========================</span><br><span class="line">.code</span><br><span class="line">WinMain PROC</span><br><span class="line">; Get a handle to the current process.</span><br><span class="line">	INVOKE GetModuleHandle, NULL</span><br><span class="line">	mov hInstance, eax</span><br><span class="line">	mov MainWin.hInstance, eax</span><br><span class="line"></span><br><span class="line">; Load the program&#x27;s icon and cursor.</span><br><span class="line">	INVOKE LoadIcon, NULL, IDI_APPLICATION</span><br><span class="line">	mov MainWin.hIcon, eax</span><br><span class="line">	INVOKE LoadCursor, NULL, IDC_ARROW</span><br><span class="line">	mov MainWin.hCursor, eax</span><br><span class="line"></span><br><span class="line">; Register the window class.</span><br><span class="line">	INVOKE RegisterClass, ADDR MainWin</span><br><span class="line">	.IF eax == 0</span><br><span class="line">	  call ErrorHandler</span><br><span class="line">	  jmp Exit_Program</span><br><span class="line">	.ENDIF</span><br><span class="line"></span><br><span class="line">; Create the application&#x27;s main window.</span><br><span class="line">; Returns a handle to the main window in EAX.</span><br><span class="line">	INVOKE CreateWindowEx, 0, ADDR className,</span><br><span class="line">	  ADDR WindowName,MAIN_WINDOW_STYLE,</span><br><span class="line">	  CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,</span><br><span class="line">	  CW_USEDEFAULT,NULL,NULL,hInstance,NULL</span><br><span class="line">	mov hMainWnd,eax</span><br><span class="line"></span><br><span class="line">; If CreateWindowEx failed, display a message &amp; exit.</span><br><span class="line">	.IF eax == 0</span><br><span class="line">	  call ErrorHandler</span><br><span class="line">	  jmp  Exit_Program</span><br><span class="line">	.ENDIF</span><br><span class="line"></span><br><span class="line">; Show and draw the window.</span><br><span class="line">	INVOKE ShowWindow, hMainWnd, SW_SHOW</span><br><span class="line">	INVOKE UpdateWindow, hMainWnd</span><br><span class="line"></span><br><span class="line">; Display a greeting message.</span><br><span class="line">	INVOKE MessageBox, hMainWnd, ADDR GreetText,</span><br><span class="line">	  ADDR GreetTitle, MB_OK</span><br><span class="line"></span><br><span class="line">; Begin the program&#x27;s message-handling loop.</span><br><span class="line">Message_Loop:</span><br><span class="line">	; Get next message from the queue.</span><br><span class="line">	INVOKE GetMessage, ADDR msg, NULL,NULL,NULL</span><br><span class="line"></span><br><span class="line">	; Quit if no more messages.</span><br><span class="line">	.IF eax == 0</span><br><span class="line">	  jmp Exit_Program</span><br><span class="line">	.ENDIF</span><br><span class="line"></span><br><span class="line">	; Relay the message to the program&#x27;s WinProc.</span><br><span class="line">	INVOKE DispatchMessage, ADDR msg</span><br><span class="line">    jmp Message_Loop</span><br><span class="line"></span><br><span class="line">Exit_Program:</span><br><span class="line">	  INVOKE ExitProcess,0</span><br><span class="line">WinMain ENDP</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------</span><br><span class="line">WinProc PROC,</span><br><span class="line">	hWnd:DWORD, localMsg:DWORD, wParam:DWORD, lParam:DWORD</span><br><span class="line">; The application&#x27;s message handler, which handles</span><br><span class="line">; application-specific messages. All other messages</span><br><span class="line">; are forwarded to the default Windows message</span><br><span class="line">; handler.</span><br><span class="line">;-----------------------------------------------------</span><br><span class="line">	mov eax, localMsg</span><br><span class="line"></span><br><span class="line">	.IF eax == WM_LBUTTONDOWN		; mouse button?</span><br><span class="line">	  INVOKE MessageBox, hWnd, ADDR PopupText,</span><br><span class="line">	    ADDR PopupTitle, MB_OK</span><br><span class="line">	  jmp WinProcExit</span><br><span class="line">	.ELSEIF eax == WM_CREATE		; create window?</span><br><span class="line">	  INVOKE MessageBox, hWnd, ADDR AppLoadMsgText,</span><br><span class="line">	    ADDR AppLoadMsgTitle, MB_OK</span><br><span class="line">	  jmp WinProcExit</span><br><span class="line">	.ELSEIF eax == WM_CLOSE		; close window?</span><br><span class="line">	  INVOKE MessageBox, hWnd, ADDR CloseMsg,</span><br><span class="line">	    ADDR WindowName, MB_OK</span><br><span class="line">	  INVOKE PostQuitMessage,0</span><br><span class="line">	  jmp WinProcExit</span><br><span class="line">	.ELSE		; other message?</span><br><span class="line">	  INVOKE DefWindowProc, hWnd, localMsg, wParam, lParam</span><br><span class="line">	  jmp WinProcExit</span><br><span class="line">	.ENDIF</span><br><span class="line"></span><br><span class="line">WinProcExit:</span><br><span class="line">	ret</span><br><span class="line">WinProc ENDP</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------</span><br><span class="line">ErrorHandler PROC</span><br><span class="line">; Display the appropriate system error message.</span><br><span class="line">;---------------------------------------------------</span><br><span class="line">.data</span><br><span class="line">pErrorMsg  DWORD ?		; ptr to error message</span><br><span class="line">messageID  DWORD ?</span><br><span class="line">.code</span><br><span class="line">	INVOKE GetLastError	; Returns message ID in EAX</span><br><span class="line">	mov messageID,eax</span><br><span class="line"></span><br><span class="line">	; Get the corresponding message string.</span><br><span class="line">	INVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \</span><br><span class="line">	  FORMAT_MESSAGE_FROM_SYSTEM,NULL,messageID,NULL,</span><br><span class="line">	  ADDR pErrorMsg,NULL,NULL</span><br><span class="line"></span><br><span class="line">	; Display the error message.</span><br><span class="line">	INVOKE MessageBox,NULL, pErrorMsg, ADDR ErrorTitle,</span><br><span class="line">	  MB_ICONERROR+MB_OK</span><br><span class="line"></span><br><span class="line">	; Free the error message string.</span><br><span class="line">	INVOKE LocalFree, pErrorMsg</span><br><span class="line">	ret</span><br><span class="line">ErrorHandler ENDP</span><br><span class="line"></span><br><span class="line">END WinMain</span><br></pre></td></tr></table></figure>

























































<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h3 id="一些变量前缀"><a href="#一些变量前缀" class="headerlink" title="一些变量前缀"></a>一些变量前缀</h3><p>WS :Windows Style</p>
<p>WM:windows message</p>
<h3 id="函数-供查看"><a href="#函数-供查看" class="headerlink" title="函数(供查看)"></a>函数(供查看)</h3><h4 id="GetModuleHandle-获取句柄"><a href="#GetModuleHandle-获取句柄" class="headerlink" title="GetModuleHandle 获取句柄"></a>GetModuleHandle 获取句柄</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke  GetModuleHandle ,lpMouleName(含有模块的字符串指针)</span><br></pre></td></tr></table></figure>



<p>他的返回值放在了eax中(之前说过)</p>
<p>但是我们通常会用到这么一个返回值,于是我们要建立一个变量去保存它</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			.data</span><br><span class="line">str			db		&quot;user32.dll&quot;</span><br><span class="line">hInstance	dd		?</span><br><span class="line">			.code	</span><br><span class="line">.....</span><br><span class="line">			invoke  GetModuleHandle ,addr str</span><br><span class="line">			mov		hInstance,eax</span><br></pre></td></tr></table></figure>



<p>如果,lpMouleName&#x3D;NULL</p>
<p>表示调用自己</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="RegisterClassEx-窗口注册"><a href="#RegisterClassEx-窗口注册" class="headerlink" title="RegisterClassEx 窗口注册"></a>RegisterClassEx 窗口注册</h4><p>用于窗口的注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	RegisterClassEx, 窗口结构体类型的指针</span><br></pre></td></tr></table></figure>

<p>在这之前,那个窗口结构体要完成初始化</p>
<p>好比这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	@stWndClass.hCursor,		eax</span><br><span class="line">push	hInstance</span><br><span class="line">pop	@stWndClass.hInstance</span><br><span class="line">mov	@stWndClass.cbSize,		sizeof WNDCLASSEX</span><br><span class="line">mov	@stWndClass.style,		CS_HREDRAW or CS_VREDRAW</span><br><span class="line">mov	@stWndClass.lpfnWndProc,	offset _ProcWinMain</span><br><span class="line">mov	@stWndClass.hbr</span><br><span class="line">Background,	COLOR_WINDOW + 1</span><br><span class="line">mov	@stWndClass.lpszClassName,	offset szClassName</span><br><span class="line">invoke	RegisterClassEx,		addr @stWndClass</span><br></pre></td></tr></table></figure>



<p>关于窗口结构体的与成员介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wndclassex		struct    </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	hIcon;			dd	?	;窗口图标</span><br><span class="line">	hIconSm;		dd	?	;小图标</span><br><span class="line">	hCursor;		dd	?	;窗口光标</span><br><span class="line">	lpszMenuName;	dd	?	;窗口菜单</span><br><span class="line">	hInstance;		dd	?	;实例句柄</span><br><span class="line">	cbSize			dd	?	;结构体字节数,用sizeof计算</span><br><span class="line">	style;			dd	?	;类风格</span><br><span class="line">	hbrBackground;	dd	?	;背景色</span><br><span class="line">	lpszClassName;	dd	?	;Class_Name的字符串地址</span><br><span class="line">	cbClsExtra;		dd	?	;</span><br><span class="line">	cbWndExtra;		dd	?	;</span><br><span class="line">	lpfnWndProc;	dd	?	;窗口过程的地址</span><br><span class="line"></span><br><span class="line">wndclassex		ends</span><br></pre></td></tr></table></figure>





<h5 id="hIcon-dd-窗口图标"><a href="#hIcon-dd-窗口图标" class="headerlink" title="hIcon;			dd	?	;窗口图标"></a>hIcon;			dd	?	;窗口图标</h5><p>显示在窗口左上角的图标,</p>
<p>LoadIcon函数获取资源文件的图标,如果想自定义图标就去资源文件中定义</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="hCursor-dd-窗口光标"><a href="#hCursor-dd-窗口光标" class="headerlink" title="hCursor;		dd	?	;窗口光标"></a>hCursor;		dd	?	;窗口光标</h5><p>鼠标在窗口的样子</p>
<p>LoadCursor函数指定鼠标在窗口光标的形状,,如果想自定义光标就去资源文件中定义</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="lpszMenuName-dd-窗口菜单"><a href="#lpszMenuName-dd-窗口菜单" class="headerlink" title="lpszMenuName;	dd	?	;窗口菜单"></a>lpszMenuName;	dd	?	;窗口菜单</h5><p>详情见&lt;&lt;琢石成器&gt;Page.101</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="hInstance-dd-实例句柄"><a href="#hInstance-dd-实例句柄" class="headerlink" title="hInstance;		dd	?	;实例句柄"></a>hInstance;		dd	?	;实例句柄</h5><p>指定注册的窗口属于哪个模块</p>
<p>在书上的代码中是这样初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push	hInstance			;hinstance是已经被初始化的一个句柄</span><br><span class="line">pop	@stWndClass.hInstance	;这这是一个引用的</span><br></pre></td></tr></table></figure>



<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="cbSizedd-结构体字节数-用sizeof计算"><a href="#cbSizedd-结构体字节数-用sizeof计算" class="headerlink" title="cbSize			dd	?	;结构体字节数,用sizeof计算"></a>cbSize			dd	?	;结构体字节数,用sizeof计算</h5><p>详情见详情见&lt;&lt;琢石成器&gt;Page.101</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="style-dd"><a href="#style-dd" class="headerlink" title="style;			dd	?	;"></a>style;			dd	?	;</h5><p>窗口的风格,常见的参数,CS_HREADRAW与CS_VREDRAW</p>
<p>小写cs_hredraw,cs_vredraw</p>
<p>还有个CS_DBLCLKS,小写cs_dblclks,指定了它,windows才会把快速双击的鼠标的行为翻译为WM_LNUTTONDBLCLK发送给窗口过程</p>
<p>小写wm_lbuttondblclk,</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="hbrBackground-dd-背景色"><a href="#hbrBackground-dd-背景色" class="headerlink" title="hbrBackground;	dd	?	;背景色"></a>hbrBackground;	dd	?	;背景色</h5><p>br是brush的意思,h句柄</p>
<p>windows与预定义了一些刷子,用GetStockObject 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke GetStockObject,WHITE_BRUSH</span><br></pre></td></tr></table></figure>

<p>windows</p>
<p>预定义了一些颜色,如COLOR_MENU,使用类似的颜色要<code>+1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	@stWndClass.hbrBackground,	COLOR_WINDOW + 1</span><br></pre></td></tr></table></figure>



<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="lpszClassName-dd-Class-Name的字符串地址"><a href="#lpszClassName-dd-Class-Name的字符串地址" class="headerlink" title="lpszClassName;	dd	?	;Class_Name的字符串地址"></a>lpszClassName;	dd	?	;Class_Name的字符串地址</h5><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="cbClsExtra-x2F-cbWndExtra"><a href="#cbClsExtra-x2F-cbWndExtra" class="headerlink" title="cbClsExtra&#x2F;cbWndExtra"></a>cbClsExtra&#x2F;cbWndExtra</h5><pre><code>cbClsExtra;		dd	?	;
cbWndExtra;		dd	?
</code></pre>
<p>分别代表了windows内部保存的窗口结构体和类结构体给我们预留的内存大小</p>
<p>用于存放自定义的数据</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h5 id="lpfnWndProc-dd-窗口过程的地址"><a href="#lpfnWndProc-dd-窗口过程的地址" class="headerlink" title="lpfnWndProc;	dd	?	;窗口过程的地址"></a>lpfnWndProc;	dd	?	;窗口过程的地址</h5><p>信息的交互需要使用它</p>
<p>它好像是窗口的窗口的地址,就是procMain</p>
<p>有了它windows就知道DispatchMessage函数把窗口的信息发送到哪里去</p>
<h4 id="CreateWindowEx-建立窗口"><a href="#CreateWindowEx-建立窗口" class="headerlink" title="CreateWindowEx  建立窗口"></a>CreateWindowEx  建立窗口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke 	CreateWindowEx,\</span><br><span class="line">		dwExStyle,\</span><br><span class="line">		lpClassName,\</span><br><span class="line">		lpwindowName,\</span><br><span class="line">		dwStyle,\</span><br><span class="line">		x,y,\</span><br><span class="line">		nWidth,nHeight,\</span><br><span class="line">		hWndParent,\</span><br><span class="line">		hMenu,\</span><br><span class="line">		hInstance,\</span><br><span class="line">		lpParam</span><br></pre></td></tr></table></figure>



<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	CreateWindowEx,</span><br><span class="line">			WS_EX_CLIENTEDGE,</span><br><span class="line">			offset szClassName,</span><br><span class="line">			offset szCaptionMain,\</span><br><span class="line">			WS_OVERLAPPEDWINDOW,\</span><br><span class="line">			100,100,600,400,\</span><br><span class="line">			NULL,NULL,hInstance,NULL</span><br></pre></td></tr></table></figure>



<h5 id="lpClassName-之前注册的窗口类"><a href="#lpClassName-之前注册的窗口类" class="headerlink" title="lpClassName 之前注册的窗口类"></a>lpClassName 之前注册的窗口类</h5><p>初始化后目标是使用lpClassName类建立窗口</p>
<h5 id="lpwindowName-窗口标题栏字符串地址"><a href="#lpwindowName-窗口标题栏字符串地址" class="headerlink" title="lpwindowName 窗口标题栏字符串地址"></a>lpwindowName 窗口标题栏字符串地址</h5><p>是一个字符串的指针</p>
<h5 id="hMenu-菜单句柄"><a href="#hMenu-菜单句柄" class="headerlink" title="hMenu 菜单句柄"></a>hMenu 菜单句柄</h5><p>如果参数是NULL,就去使用之前在注册窗口时的menu句柄</p>
<p>如果参数是一个新的menu,就去使用新的句柄</p>
<p>如果注册窗口类是没有muen,这里也没有menu句柄,就啥也不显示</p>
<h5 id="lpParam"><a href="#lpParam" class="headerlink" title="lpParam"></a>lpParam</h5><p>见&lt;&lt;琢石成器&gt;&gt;.103</p>
<h5 id="hinstance"><a href="#hinstance" class="headerlink" title="hinstance"></a>hinstance</h5><p>指定窗口所属的程序模块</p>
<h5 id="hWndParent-窗口所属父窗口"><a href="#hWndParent-窗口所属父窗口" class="headerlink" title="hWndParent 窗口所属父窗口"></a>hWndParent 窗口所属父窗口</h5><p>主要用于在父窗口销毁时一同将子窗口销毁</p>
<h6 id="x-y"><a href="#x-y" class="headerlink" title="x,y"></a>x,y</h6><p>指定窗口左上角的位置</p>
<p>默认可指定CW_USEDEFAULT</p>
<h5 id="nWidth-nHeight"><a href="#nWidth-nHeight" class="headerlink" title="nWidth,nHeight"></a>nWidth,nHeight</h5><p>窗口的宽度高度</p>
<p>默认可指定CW_USEDEFAULT</p>
<h5 id="dwStyle-x2F-dwExStyle"><a href="#dwStyle-x2F-dwExStyle" class="headerlink" title="dwStyle&#x2F;dwExStyle"></a>dwStyle&#x2F;dwExStyle</h5><p>详情见见&lt;&lt;琢石成器&gt;&gt;.104</p>
<h4 id="Showwindows-显示窗口"><a href="#Showwindows-显示窗口" class="headerlink" title="Showwindows 显示窗口"></a>Showwindows 显示窗口</h4><p>主要用于窗口的显示状态(显示&#x2F;隐藏)</p>
<p>大小控制</p>
<p>是否激活(当前窗口还是背后窗口)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	ShowWindow,hWinMain,SW_SHOWNORMAL</span><br></pre></td></tr></table></figure>

<p>第一个参数是窗口的句柄..啊?什么时候定义的句柄?</p>
<blockquote>
<p>在Crreatwindows的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	CreateWindowEx,WS_EX_OVERLAPPEDWINDOW,offset szClassName,offset szCaptionMain,\</span><br><span class="line">	WS_OVERLAPPEDWINDOW,\</span><br><span class="line">	100,100,600,400,\</span><br><span class="line">	NULL,NULL,hInstance,NULL</span><br><span class="line">mov	hWinMain,eax</span><br></pre></td></tr></table></figure>

<p>这里的eax是一个返回的窗口句柄</p>
</blockquote>
<p>第二个参数是显示方式的预定义值</p>
<p>详情见见&lt;&lt;琢石成器&gt;&gt;.106</p>
<h4 id="UpdateWindow-绘制客户区"><a href="#UpdateWindow-绘制客户区" class="headerlink" title="UpdateWindow 绘制客户区"></a>UpdateWindow 绘制客户区</h4><p>本质是向窗口发送WM_PAINT消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	UpdateWindow,hWinMain</span><br></pre></td></tr></table></figure>

<p>参数是窗口的句柄</p>
<h4 id="CreatewindowEx-建立子窗口"><a href="#CreatewindowEx-建立子窗口" class="headerlink" title="CreatewindowEx 建立子窗口"></a>CreatewindowEx 建立子窗口</h4><p>Windows有很多预定义的子窗口</p>
<p>好比Button&#x2F;Edit,要建立一个子窗口就把lpClassName指向”Button”或者啥的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">		.data</span><br><span class="line">szButton	db	&quot;button&quot;,0</span><br><span class="line">szButtonText	db	&quot;&amp;OK&quot;,0</span><br><span class="line">		...</span><br><span class="line">		invoke	CreateWindowEx,NULL,\</span><br><span class="line">			offset	szButton,offset szButtonText,\</span><br><span class="line">			WS_CHILD or WS_VISIBLE,\</span><br><span class="line">			10,10,65,22,\</span><br><span class="line">			hWnd,1,hInstance,NULL</span><br><span class="line">			;这里的1是ID</span><br></pre></td></tr></table></figure>



<h4 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h4><p>代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.while	TRUE</span><br><span class="line">	invoke	GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">	.break	.if eax	== 0</span><br><span class="line">	invoke	TranslateMessage,addr @stMsg</span><br><span class="line">	invoke	DispatchMessage,addr @stMsg</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure>



<p>消息循环用到的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSG	struct</span><br><span class="line">	hwnd	dd	?;消息要发送到哪里去,</span><br><span class="line">	message	dd	?;消息标识符,在头文件WM开头的有预定义值</span><br><span class="line">	wparam	dd	?</span><br><span class="line">	lParam	dd	?</span><br><span class="line">	time	dd	?</span><br><span class="line">	pt	POINT	?;一个POINT数据结构,表示消息放入消息队列的鼠标坐标</span><br><span class="line">MSG	ends</span><br></pre></td></tr></table></figure>



<p>hwnd:消息要发送到哪里去,</p>
<p>message:消息标识符,在头文件WM开头的有预定义值</p>
<p>wParam:消息参数之一</p>
<p>lParam:消息参数之二</p>
<p>time:消息放入消息队列的时间</p>
<p>pt:一个POINT数据结构,表示消息放入消息队列的鼠标坐标</p>
<h5 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke GetMessage,lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax</span><br></pre></td></tr></table></figure>

<p>lpMsg: 指向一个Msg结构,函数会在这里返回取到的消息</p>
<p>hWnd:指定获取哪个窗口的信息,如果是NULL,表示获取所拥有本程序所属窗口的信息(不太理解)</p>
<p>wMsgFilterMin,wMsgFilterMax:表示获取所拥有编号的信息</p>
<p>GetMessage函数会从消息队列里获取信息,填写好MSG结构并返回,如果获取信息是<code>MSG_QUIT</code></p>
<p>那么eax返回值是0,否者返回非零,</p>
<p>于是循环推出的条件就是<code>.if !eax .break</code></p>
<h5 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h5><p>他将MSG的结构体信息给windows,然后进行一些键盘信息的转换,</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>在windows小,你敲击键盘会有扫描码与断码,产生的消息队列是WM_KEYDOWN&#x2F;WM_KEYUP</p>
<p>或者WM_SYSKEYDOWN&#x2F;WM_YSYSKEYUP</p>
<p>windows对这个过程的处理很麻烦</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不怎么理解</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>TranslateMessage直接把你的扫描码转化为ASCII,并在消息队列中插入WM_CHAR或者WM_SYSCHAR</p>
<p>对于一些非键盘的输入,函数不做处理</p>
<h5 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h5><p>在上面2个函数下,DispatchMessage函数将消息发送到消息对应的窗口过程去处理,处理过程返回,DispatchMessage才返回</p>
<p>然后开始一轮新的循环</p>
<h4 id="其它形式的消息循环"><a href="#其它形式的消息循环" class="headerlink" title="其它形式的消息循环"></a>其它形式的消息循环</h4><p>例题的代码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.while	TRUE</span><br><span class="line">	invoke	GetMessage,		addr @stMsg,NULL,0,0</span><br><span class="line">	.break	.if eax	== 0</span><br><span class="line">	invoke	TranslateMessage,	addr @stMsg</span><br><span class="line">	invoke	DispatchMessage,	addr @stMsg</span><br><span class="line">	;获取</span><br><span class="line">	;翻译</span><br><span class="line">	;发送</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure>

<p>这让CPU一直在干3件事情,而这3件事情根本没有变化,这样浪费了CPU</p>
<blockquote>
<p>我很疑惑,什么叫有消息???????,什么叫消息队列有消息???</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke	CreateWindow,</span><br><span class="line">invoke	ShowWindow,</span><br><span class="line">invoke	UpdateWindows,</span><br><span class="line">.while	dwQuitFlag==0</span><br><span class="line">.endw</span><br><span class="line">invoke	ExitProcsee,0</span><br></pre></td></tr></table></figure>

<p>对于这种方式我不是特别的理解</p>
<p>他是如何GetMessage的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.while TRUE</span><br><span class="line">	invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE</span><br><span class="line">	.if	eax</span><br><span class="line">		.break .if @stMsg.message==WM_QUIT</span><br><span class="line">		invoke TranslateMessage,addr @stMsg</span><br><span class="line">		invoke	DispatchMessage,addr @stMsg</span><br><span class="line">	.else</span><br><span class="line">		invoke	MessageBox,NULL,offset szText1,offset szCaption1,MB_OK</span><br><span class="line">	.endif</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure>



<p>对于下面的代码我没有调试明白</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;</span><br><span class="line">; by 罗云彬, http://www.win32asm.com.cn</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; FirstWindow.asm</span><br><span class="line">; 窗口程序的模板代码</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff FirstWindow.asm</span><br><span class="line">; Link /subsystem:windows FirstWindow.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		gdi32.inc</span><br><span class="line">includelib	gdi32.lib</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib	user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data?</span><br><span class="line">hInstance	dd		?</span><br><span class="line">hWinMain	dd		?</span><br><span class="line"></span><br><span class="line">		.const</span><br><span class="line">szClassName	db	&#x27;MyClass&#x27;,0</span><br><span class="line">szCaptionMain	db	&#x27;My first Window !&#x27;,0</span><br><span class="line">szText		db	&#x27;Win32 Assembly, Simple and powerful !&#x27;,0</span><br><span class="line">szCaption1	db	&#x27;A MessageBox !&#x27;,0</span><br><span class="line">szText1		db	&#x27;Hello, World !&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 窗口过程</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">;程序的另一半</span><br><span class="line">_ProcWinMain	proc	uses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">		local	@stPs:PAINTSTRUCT</span><br><span class="line">		local	@stRect:RECT</span><br><span class="line">		local	@hDc</span><br><span class="line"></span><br><span class="line">		mov	eax,uMsg</span><br><span class="line">;********************************************************************</span><br><span class="line">		.if	eax ==	WM_PAINT</span><br><span class="line">			invoke	BeginPaint,hWnd,addr @stPs</span><br><span class="line">			mov	@hDc,eax</span><br><span class="line"></span><br><span class="line">			invoke	GetClientRect,hWnd,addr @stRect</span><br><span class="line">			invoke	DrawText,@hDc,addr szText,-1,\</span><br><span class="line">				addr @stRect,\</span><br><span class="line">				DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line"></span><br><span class="line">			invoke	EndPaint,hWnd,addr @stPs</span><br><span class="line">;********************************************************************</span><br><span class="line">		.elseif	eax ==	WM_CLOSE</span><br><span class="line">			invoke	DestroyWindow,hWinMain</span><br><span class="line">			invoke	PostQuitMessage,NULL</span><br><span class="line">;********************************************************************</span><br><span class="line">		.else</span><br><span class="line">			invoke	DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">			ret</span><br><span class="line">		.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">_ProcWinMain	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_WinMain	proc</span><br><span class="line">		;这个窗口的&quot;WNDCLASSEX&quot;结构体类型是已经被定义好的,现在在局部变量定义就好了</span><br><span class="line">		;这里还有一个MSG类型,wok!!</span><br><span class="line">		local	@stWndClass:WNDCLASSEX</span><br><span class="line">		local	@stMsg:MSG</span><br><span class="line">		;API-1	</span><br><span class="line">		invoke	GetModuleHandle,NULL</span><br><span class="line">		mov	hInstance,eax</span><br><span class="line">		;API-2</span><br><span class="line">		invoke	RtlZeroMemory,addr @stWndClass,sizeof @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 注册窗口类</span><br><span class="line">;********************************************************************</span><br><span class="line">		;LoadCursor指定鼠标在窗口光标的形状,这里的IDC_AERROW是预定义的</span><br><span class="line">		invoke	LoadCursor,0,IDC_ARROW</span><br><span class="line">		;初始化窗口类Class的成员</span><br><span class="line">		mov	@stWndClass.hCursor,		eax</span><br><span class="line">		push	hInstance</span><br><span class="line">		pop	@stWndClass.hInstance</span><br><span class="line">		mov	@stWndClass.cbSize,		sizeof WNDCLASSEX</span><br><span class="line">		mov	@stWndClass.style,		CS_HREDRAW or CS_VREDRAW</span><br><span class="line">		mov	@stWndClass.lpfnWndProc,	offset _ProcWinMain</span><br><span class="line">		mov	@stWndClass.hbrBackground,	COLOR_WINDOW + 1</span><br><span class="line">		mov	@stWndClass.lpszClassName,	offset szClassName</span><br><span class="line">		invoke	RegisterClassEx,		addr @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;********************************************************************</span><br><span class="line">		;上面的初始化是一些class共性的初始化,而DIY的初始化在这里</span><br><span class="line">		invoke	CreateWindowEx,WS_EX_OVERLAPPEDWINDOW,offset szClassName,offset szCaptionMain,\</span><br><span class="line">			WS_OVERLAPPEDWINDOW,\</span><br><span class="line">			100,100,600,400,\</span><br><span class="line">			NULL,NULL,hInstance,NULL</span><br><span class="line">		mov	hWinMain,eax</span><br><span class="line">		;eax传回来了窗口的句柄,用来备用</span><br><span class="line">		invoke	ShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">		;SHowWindos只会显示窗口,不会显示u内容</span><br><span class="line">		invoke	UpdateWindow,hWinMain</span><br><span class="line">		;Update才会先睡文本</span><br><span class="line">;********************************************************************</span><br><span class="line">; 消息循环</span><br><span class="line">;********************************************************************</span><br><span class="line">		</span><br><span class="line">		.while TRUE</span><br><span class="line">			invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE</span><br><span class="line">			.if	eax</span><br><span class="line">				.break .if @stMsg.message==WM_QUIT</span><br><span class="line">				invoke TranslateMessage,addr @stMsg</span><br><span class="line">				invoke	DispatchMessage,addr @stMsg</span><br><span class="line">			.else</span><br><span class="line">				pushad</span><br><span class="line">				invoke	MessageBox,NULL,offset szText1,offset szCaption1,MB_OK</span><br><span class="line">				popad</span><br><span class="line">			.endif</span><br><span class="line">		.endw</span><br><span class="line"></span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">_WinMain	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">start:</span><br><span class="line">		call	_WinMain</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不理解为什么他会进入那3个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.if	eax</span><br><span class="line">	.break .if @stMsg.message==WM_QUIT</span><br><span class="line">	invoke TranslateMessage,addr @stMsg</span><br><span class="line">	invoke	DispatchMessage,addr @stMsg</span><br></pre></td></tr></table></figure>

<p>或者为什么进入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.else</span><br><span class="line">	pushad</span><br><span class="line">	invoke	MessageBox,NULL,offset szText1,offset szCaption1,MB_OK</span><br><span class="line">	popad</span><br></pre></td></tr></table></figure>

<p>是什么东西在影响你的消息队列</p>
<h4 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My_ProcWinMain	proc	hWnd,uMsg,wParam,lParam</span><br></pre></td></tr></table></figure>

<p>hWnd:窗口回调要指明的操作窗口</p>
<p>uMsg:…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My_ProcWinMain	proc	uses ebx edi esi hWnd,uMsg,wParam,lParam</span><br></pre></td></tr></table></figure>



<p>关于那几个参数的入栈</p>
<p>uses ebx edi esi </p>
<p>为什么入栈?因为他们会被偷偷的改变,就像MessageBox修改ecx,eax..那样,他会对后面的判断做一些影响</p>
<p>uMsg参数有一定的范围,其他的不多说..这里会用到SendMesage参数来传递自定义的参数</p>
<p>….详情就在看书</p>
<p>wParam&#x2F;IParam参数是消息附带的,他们的职能会根据不同的调用而不同,详情见书</p>
<p>处理了不同的消息必须返回规定的值给windows,对于不同的过程会有不同的返回值</p>
<p>好比程序无法完成初始化就会返回-1</p>
<p>WM_CLOSE消息是按下窗口的<code>叉叉</code>按钮,主要负责释放内存,保存工作,提示用户是否需要保持</p>
<p>….</p>
<p>…上面很杂很多很难理解..主要是缺乏应用,对那些结构体的认识不够到位</p>
<p>…后面回来慢慢看</p>
<h4 id="收到消息的顺序"><a href="#收到消息的顺序" class="headerlink" title="收到消息的顺序"></a>收到消息的顺序</h4><p>收到消息不一定是从循环开始,而是在CreateWindow中开始了</p>
<p>显示和刷新窗口的函数ShowWindow和UpdateWindow</p>
<p>也向窗口过程发送信息</p>
<h3 id="窗口间的通信"><a href="#窗口间的通信" class="headerlink" title="窗口间的通信"></a>窗口间的通信</h3><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配 (dynamic memory allocation)，又被称为堆分配 (heap allocation)，</p>
<p>汇编语言程序有两种方法进行动态分配：</p>
<ul>
<li>方法一：通过系统调用从操作系统获得内存块。</li>
<li>方法二：实现自己的堆管理器来服务更小的对象提出的请求。</li>
</ul>
<h2 id="函数一览表-2"><a href="#函数一览表-2" class="headerlink" title="函数一览表"></a>函数一览表</h2><p>利用下表中的几个 Win32 API .表中所有的函数都会覆盖通用寄存器，因此程序实现重要寄存器的入栈和出栈操作。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GetProcessHeap</td>
<td>用 EAX 返回程序现存堆区域的 32 位整数句柄。如果函数成功，则 EAX 中的返回值为堆句柄。 如果函数失败，则 EAX 中的返回值为 NULL</td>
</tr>
<tr>
<td>HeapAlloc</td>
<td>从堆中分配内存块。如果成功，EAX 中的返回值就为内存块的地址。如果失败，则 EAX 中的返 回值为 NULL</td>
</tr>
<tr>
<td>HeapCreate</td>
<td>创建新堆，并使其对调用程序可用。如果函数成功，则 EAX 中的返回值为新创建堆的句柄。如果失败，则 EAX 的返回值为 NULL</td>
</tr>
<tr>
<td>HeapDestroy</td>
<td>销毁指定堆对象，并使其句柄无效。如果函数成功，则 EAX 中的返回值为非零</td>
</tr>
<tr>
<td>HeapFree</td>
<td>释放之前从堆中分配的内存块，该堆由其地址和堆句柄进行标识。如果内存块释放成功，则返回值为非零</td>
</tr>
<tr>
<td>HeapReAlloc</td>
<td>对堆中内存块进行再分配和调整大小。如果函数成功，则返回值为指向再分配内存块的指针。如果函数失败，且没有指定 HEAP GENERATE EXCEPTIONS，则返回值为 NULL</td>
</tr>
<tr>
<td>HeapSize</td>
<td>返回之前通过调用 HeapAlloc 或 HeapReAlloc 分配的内存块的大小。如果函数成功，则 EAX 包含被分配内存块的字节数。如果函数失败，则返回值为 SIZE_T-1 ( SIZE_T 等于指针能指向的最大字节数 )</td>
</tr>
</tbody></table>
<h2 id="GetProcessHeap-返回已用堆区的地址"><a href="#GetProcessHeap-返回已用堆区的地址" class="headerlink" title="GetProcessHeap 返回已用堆区的地址"></a>GetProcessHeap 返回已用堆区的地址</h2><p>没有参数</p>
<p>如果使用的是当前程序的默认堆，那么 GetProcessHeap 就足够了。这个函数没有参数，EAX 中的返回值就是堆句柄：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetProcessHeap PROTO</span><br></pre></td></tr></table></figure>



<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">hHeap HANDLE ?</span><br><span class="line">.code</span><br><span class="line">INVOKE GetProcessHeap</span><br><span class="line">.IF eax == NULL           ;不能获取句柄</span><br><span class="line">    jmp quit</span><br><span class="line">.ELSE</span><br><span class="line">    mov hHeap,eax         ;句柄 ok</span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure>



<h2 id="HeapCreate-创建堆区"><a href="#HeapCreate-创建堆区" class="headerlink" title="HeapCreate 创建堆区"></a>HeapCreate 创建堆区</h2><p>为当前程序创建一个新的私有堆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HeapCreate PROTO,</span><br><span class="line">    flOptions:DWORD,                    ;堆分配选项</span><br><span class="line">    dwInitialSize:DWORD,               ;按字节初始化堆大小</span><br><span class="line">    dwMaximumSize:DWORD        ;最大堆字节数</span><br></pre></td></tr></table></figure>

<p>flOptions 设置为 NULL。</p>
<p>dwInitialSize 设置为初始堆字节数，其值的上限为下一页的边界。</p>
<p>如果 HeapAlloc 的调用超过了初始堆大小，那么堆最大可以扩展到 dwMaximumSize 参数中指定的大小（上限为下一页的边界）。</p>
<p>调用后，EAX 中的返回值为空就表示堆未创建成 功。HeapCreate 的调用示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAP_START = 2000000 ; 2 MB</span><br><span class="line">HEAP_MAX = 400000000 ; 400 MB</span><br><span class="line">.data</span><br><span class="line">hHeap HANDLE ?       ; 堆句柄</span><br><span class="line">.code</span><br><span class="line">INVOKE HeapCreate, 0, HEAP_START, HEAP_MAX</span><br><span class="line">.IF eax == NULL      ; 堆未创建    call WriteWindowsMsg ; 显示错误消息</span><br><span class="line">    jmp quit</span><br><span class="line">.ELSE</span><br><span class="line">    mov hHeap,eax    ; 句柄 OK</span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure>



<h2 id="HeapDeatroy-销毁堆区"><a href="#HeapDeatroy-销毁堆区" class="headerlink" title="HeapDeatroy 销毁堆区"></a>HeapDeatroy 销毁堆区</h2><p>销毁一个已存在的私有堆（由 HeapCreate 创建）。需向其传递堆句柄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HeapDestroy PROTO,</span><br><span class="line">    hHeap:DWORD          ;堆句柄</span><br></pre></td></tr></table></figure>

<p>如果堆销毁失败，则 EAX 等于 NULL。下面为示例调用，其中使用了 WriteWindowsMsg 过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">hHeap HANDLE ?                ;堆句柄</span><br><span class="line">.code</span><br><span class="line">INVOKE HeapDestroy, hHeap</span><br><span class="line">.IF eax == NULL</span><br><span class="line">    call WriteWindowsMsg      ;显示错误消息</span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure>



<h2 id="HeapAlloc-堆区中分配内存块"><a href="#HeapAlloc-堆区中分配内存块" class="headerlink" title="HeapAlloc 堆区中分配内存块"></a>HeapAlloc 堆区中分配内存块</h2><p>从已存在堆中分配一个内存块：</p>
<p>为什么还要分配!!!!!!!!!!!!!!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HeapAlloc PROTO,</span><br><span class="line">    hHeap:HANDLE,       ;现有堆内存块的句柄</span><br><span class="line">    dwFlags :DWORD,    ;堆分配控制标志</span><br><span class="line">    dwBytes:DWORD     ;分配的字节数</span><br></pre></td></tr></table></figure>

<p>需传递下述参数：</p>
<ul>
<li>hHeap：32 位堆句柄，该堆由 GetProcessHeap 或 HeapCreate 初始化。</li>
<li>dwFlags：一个双字，包含了一个或多个标志值。可以选择将其设置为 HEAP_ZERO_MEMORY，即设置内存块为全零。</li>
<li>dwBytes：一个双字，表示堆分配的字节数。</li>
</ul>
<p>如果 HeapAlloc 成功，则 EAX 包含指向新存储区的指针；</p>
<p>如果失败，则 EAX 中的返回值为 NULL。</p>
<p>下面的代码用 hHeap 标识一个堆，从该堆中分配了一个 1000 字节的数组，并将数组初始化为全零：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">hHeap HANDLE ?    ;堆句柄</span><br><span class="line">pArray DWORD ?    ;数组指针</span><br><span class="line">.code</span><br><span class="line">INVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, 1000</span><br><span class="line">.IF eax == NULL</span><br><span class="line">    mWrite &quot;HeapAlloc failed&quot;</span><br><span class="line">    jmp quit</span><br><span class="line">.ELSE</span><br><span class="line">    mov pArray,eax</span><br><span class="line">.ENDI</span><br></pre></td></tr></table></figure>





<h2 id="HeapFree-释放在堆区分配的内存块"><a href="#HeapFree-释放在堆区分配的内存块" class="headerlink" title="HeapFree 释放在堆区分配的内存块"></a>HeapFree 释放在堆区分配的内存块</h2><p>函数 HeapFree 释放之前从堆中分配的一个内存块，该堆由其地址和堆句柄标识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HeapFree PROTO,</span><br><span class="line">    hHeap:HANDLE,</span><br><span class="line">    dwFlags:DWORD,</span><br><span class="line">    lpMem:DWORD</span><br></pre></td></tr></table></figure>

<p>第一个参数是包含该内存块的堆的句柄。</p>
<p>第二个参数通常为零，</p>
<p>第三个参数是指向将被释放内存块的指针。</p>
<p>如果内存块释放成功，则返回值非零。非0是多少?????</p>
<p>如果该块不能被释放，则函数返回零。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVOKE HeapFree, hHeap, 0, pArray</span><br></pre></td></tr></table></figure>



<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>若在调用 HeapCreate、HeapDestroy 或 GetProcessHeap 时遇到错误，可以通过调用 API 函数 GetLastError 来获得详细信息。</p>
<h1 id="内嵌汇编"><a href="#内嵌汇编" class="headerlink" title="内嵌汇编"></a>内嵌汇编</h1><h2 id="asm-源于vs-2010"><a href="#asm-源于vs-2010" class="headerlink" title="__asm 源于vs-2010"></a>__asm 源于vs-2010</h2><p>提示：在“asm”的前面有两个下划线。</p>
<p>编写内嵌汇编代码时允许：</p>
<ul>
<li>使用 x86 指令集内的大多数指令。</li>
<li>使用寄存器名作为操作数。</li>
<li>通过名字引用函数参数。</li>
<li>引用在 asm 块之外定义的代码标号和变量。（这点很重要，因为局部函数变量必须在 asm 块的外面定义。）</li>
<li>使用包含在汇编风格或 C 风格基数表示法中的数字常数。比如，0A26h 和 0xA26 是等价的，且都能使用。</li>
<li>在语句中使用 PTR 运算符，比如 inc BYTE PTR[esi]。</li>
<li>使用 EVEN 和 ALIGN 伪指令。</li>
</ul>
<p>限制</p>
<p>编写内嵌汇编代码时不允许：</p>
<ul>
<li>使用数据定义伪指令，如 DB（BYTE）和 DW（WORD）。</li>
<li>使用汇编运算符（除了 PTR 之外）。</li>
<li>使用 STRUCT、RECORD, WIDTH 和 MASK。</li>
<li>使用宏伪指令，包括 MACRO、REPT、IRC、IRP 和 ENDM，以及宏运算符（&lt;&gt;、!、&amp;、% 和 .TYPE）。</li>
<li>通过名字引用段。（但是，可以用段寄存器名作为操作数。）</li>
</ul>
<p>对于printf输出字符串,还是要传入字符串的地址,用addr,不能用数组名.woc</p>
<p>还有就是%d的操作对象是32位的数据</p>
<h2 id="asm-源于linux系统的nasm"><a href="#asm-源于linux系统的nasm" class="headerlink" title="_asm _ 源于linux系统的nasm"></a>_asm _ 源于linux系统的nasm</h2><p>每一行有不同的情况结束</p>
<h3 id="基本内联"><a href="#基本内联" class="headerlink" title="基本内联"></a>基本内联</h3><p>1️⃣</p>
<p>__ asm __();</p>
<p>2️⃣</p>
<p>汇编里面每一句都用<code>&quot;&quot;</code>括起来</p>
<p>最后一句不用分号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;mov rax,x;&quot;</span>	<span class="comment">//形式1</span></span><br><span class="line"><span class="string">&quot;mov rax,a \n&quot;</span> <span class="comment">//形式2</span></span><br><span class="line"><span class="string">&quot;mov prod,rax&quot;</span> <span class="comment">//最后一句</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=<span class="number">11</span>,y=<span class="number">12</span>,sum,prod;</span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The numbers are %d and %d\n&quot;</span>,x,y);</span><br><span class="line">	__asm__</span><br><span class="line">	(</span><br><span class="line">		<span class="string">&quot;.intel_syntax noprefix;&quot;</span>   </span><br><span class="line">		<span class="string">&quot;mov rax,x;&quot;</span></span><br><span class="line">		<span class="string">&quot;add rax,y;&quot;</span></span><br><span class="line">		<span class="string">&quot;mov sum,rax&quot;</span></span><br><span class="line">	);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The sum is %d.\n&quot;</span>,sum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The difference is %d.\n&quot;</span>,subtract());</span><br><span class="line">	multiply();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The product is %d.\n&quot;</span>,prod);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__</span><br><span class="line">	(</span><br><span class="line">		<span class="string">&quot;.intel_syntax noprefix;&quot;</span>   </span><br><span class="line">		<span class="string">&quot;mov rax,x;&quot;</span></span><br><span class="line">		<span class="string">&quot;sub rax,y&quot;</span>			<span class="comment">// return value in rax</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__</span><br><span class="line">	(</span><br><span class="line">		<span class="string">&quot;.intel_syntax noprefix;&quot;</span>   </span><br><span class="line">		<span class="string">&quot;mov rax,x;&quot;</span></span><br><span class="line">		<span class="string">&quot;imul rax,y;&quot;</span></span><br><span class="line">		<span class="string">&quot;mov prod,rax&quot;</span>			<span class="comment">//no return value, result in prod</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展内联"><a href="#扩展内联" class="headerlink" title="扩展内联"></a>扩展内联</h3><p>1️⃣.寄存器约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:&quot;=a&quot;(esum)</span><br><span class="line">:&quot;d&quot;(x), &quot;c&quot;(y)</span><br></pre></td></tr></table></figure>

<p>a-&gt;rax.eax.ax.al</p>
<p>b-&gt;rbx.ebx.bx.bl</p>
<p>c-&gt;rcx.ecx.cx.cl</p>
<p>d-&gt;rdx.edx.dx.dl</p>
<p>s-&gt;rsi.esi.si</p>
<p>d-&gt;rdi.edi.di</p>
<p>r-&gt;任意寄存器</p>
<p>2️⃣.</p>
<p>可选项以<code>:</code>开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:&quot;=a&quot;(eproduct)</span><br><span class="line">:&quot;d&quot;(x), &quot;c&quot;(y)</span><br><span class="line">:&quot;rbx&quot;</span><br><span class="line">//这里的rdx会被认为是被破坏的,将恢复原始值,但它不会引起崩溃</span><br></pre></td></tr></table></figure>

<p>3️⃣.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:&quot;=a&quot;(esum)</span><br><span class="line">:&quot;d&quot;(x), &quot;c&quot;(y)</span><br></pre></td></tr></table></figure>

<p>表示输出是rax,rax引用变量esum</p>
<p>输入是rdx,rcx,分别引用x,y</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inline2.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">12</span>;	<span class="comment">// global variables</span></span><br><span class="line">	<span class="type">int</span> b=<span class="number">13</span>;</span><br><span class="line">	<span class="type">int</span> bsum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global variables are %d and %d\n&quot;</span>,a,b);</span><br><span class="line">__asm__(</span><br><span class="line">	<span class="string">&quot;.intel_syntax noprefix\n&quot;</span></span><br><span class="line">	<span class="string">&quot;mov rax,a \n&quot;</span></span><br><span class="line">	<span class="string">&quot;add rax,b \n&quot;</span></span><br><span class="line">	<span class="string">&quot;mov bsum,rax \n&quot;</span></span><br><span class="line">	:::<span class="string">&quot;rax&quot;</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The extended inline sum of global variables is %d.\n\n&quot;</span>, bsum);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=<span class="number">14</span>,y=<span class="number">16</span>, esum, eproduct, edif;  <span class="comment">// local variables</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The local variables are %d and %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">__asm__( </span><br><span class="line">	<span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">	<span class="string">&quot;mov rax,rdx;&quot;</span></span><br><span class="line">	<span class="string">&quot;add rax,rcx;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=a&quot;</span>(esum)</span><br><span class="line">	:<span class="string">&quot;d&quot;</span>(x), <span class="string">&quot;c&quot;</span>(y)</span><br><span class="line">	);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The extended inline sum is %d.\n&quot;</span>, esum);</span><br><span class="line"></span><br><span class="line">__asm__(</span><br><span class="line">	<span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">	<span class="string">&quot;mov rbx,rdx;&quot;</span></span><br><span class="line">	<span class="string">&quot;imul rbx,rcx;&quot;</span></span><br><span class="line">	<span class="string">&quot;mov rax,rbx;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=a&quot;</span>(eproduct)</span><br><span class="line">	:<span class="string">&quot;d&quot;</span>(x), <span class="string">&quot;c&quot;</span>(y)</span><br><span class="line">	:<span class="string">&quot;rbx&quot;</span></span><br><span class="line">	);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The extended inline product is %d.\n&quot;</span>, eproduct);</span><br><span class="line"></span><br><span class="line">__asm__(</span><br><span class="line">	<span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">	<span class="string">&quot;mov rax,rdx;&quot;</span></span><br><span class="line">	<span class="string">&quot;sub rax,rcx;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=a&quot;</span>(edif)</span><br><span class="line">	:<span class="string">&quot;d&quot;</span>(x), <span class="string">&quot;c&quot;</span>(y)</span><br><span class="line">	);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The extended inline asm difference is %d.\n&quot;</span>, edif);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="中断程序"><a href="#中断程序" class="headerlink" title="中断程序"></a>中断程序</h1><h2 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h2><h3 id="①-内中断"><a href="#①-内中断" class="headerlink" title="①. 内中断"></a>①. 内中断</h3><p>就是CPU立刻需要一个程序去处理的中途发生的异常,好像类似于<code>C++异常</code></p>
<p>什么是内中断?就是程序运行后,你不去物理的碰它,它发生的中断</p>
<p>关于这本书讲的中断安装….什么意思??????</p>
<p>也就是说当你打开你的DOS-BOX,然后你运行了你的中断代码.你的程序就修改了系统的一下配置,</p>
<p>但你再运行你的DOS-BOX,前提是你没有关闭,你就可以再次运行,你的系统默认中断就已经被修改了</p>
<p>好比这个安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">                                   </span><br><span class="line">                                    mov ax,stack</span><br><span class="line">                                    mov ss,ax</span><br><span class="line">                                    mov sp,32</span><br><span class="line"></span><br><span class="line">                                    push cs</span><br><span class="line">                                    pop  ds</span><br><span class="line">                                    mov  si,offset int9</span><br><span class="line"></span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov di,204h</span><br><span class="line"> </span><br><span class="line">                                    mov cx,offset int9_end - offset int9</span><br><span class="line"></span><br><span class="line">                                    cld</span><br><span class="line">                                    rep movsb</span><br><span class="line"></span><br><span class="line">                                    push es:[9*4+0]</span><br><span class="line">                                    pop  es:[200h+0]</span><br><span class="line">                                    push es:[9*4+2]</span><br><span class="line">                                    pop  es:[200h+2]</span><br><span class="line"></span><br><span class="line">                                    cli</span><br><span class="line">                                    mov word ptr es:[9*4+0],204h</span><br><span class="line">                                    mov word ptr es:[9*4+2],0</span><br><span class="line">                                    sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    mov ax,4c00h</span><br><span class="line">                                    int 21h</span><br><span class="line"></span><br><span class="line">                           int9:</span><br><span class="line">                                    push ax</span><br><span class="line">                                    push bx</span><br><span class="line">                                    push cx</span><br><span class="line">                                    push es</span><br><span class="line"></span><br><span class="line">                                    in al,60h</span><br><span class="line">                                    pushf</span><br><span class="line">                                    call dword ptr cs:[200h];调用int 9的中断</span><br><span class="line"></span><br><span class="line">                                    cmp al,48h;F1--&gt;3bh         </span><br><span class="line">                                    jne int9ret</span><br><span class="line"></span><br><span class="line">                                    mov ax,0b800h</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov bx,1</span><br><span class="line">                                    mov cx,2000</span><br><span class="line">                                s:</span><br><span class="line">                                    inc byte ptr es:[bx]</span><br><span class="line">                                    add bx,2</span><br><span class="line">                                    loop s</span><br><span class="line"></span><br><span class="line">                          int9ret:  </span><br><span class="line">                                     pop es</span><br><span class="line">                                     pop cx</span><br><span class="line">                                     pop bx</span><br><span class="line">                                     pop ax</span><br><span class="line">                                     iret</span><br><span class="line">                          int9_end:  nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>

<p>当执行了这个代码后,你按一下<code>↑</code>就可以修改屏幕的颜色</p>
<p>关于写中断要注意什么????</p>
<p>你的中断不能影响原来寄存器的的状态…好比通用寄存器,标志寄存器..不是不可以动,,,只是不要动main的程序</p>
<h4 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h4><p>好比这样一个位置,中断向量表开始位置0000:0000</p>
<p>0000:4*0x7C</p>
<p>上面这个地址表示的是index&#x3D;0x7C的中断类型码</p>
<p>在位置0000:4*0x7C下</p>
<p>[0000:4*0x7C+0]&#x3D;某个中断例程的IP, 比如IP&#x3D;0x200</p>
<p>[0000:4*0x7C+2]&#x3D;某个中断例程的CS,比如CS&#x3D;0000</p>
<p>于是你调用中断</p>
<p><code>int 7ch</code></p>
<p>那么系统去0000:0000找到7ch</p>
<p>然后按去往IP&#x3D;[0000:4 * 0x7C+0],CS&#x3D;[0000:4 * 0x7C+2]的地址处执行中断例程</p>
<h4 id="中断的过程的入栈"><a href="#中断的过程的入栈" class="headerlink" title="中断的过程的入栈"></a>中断的过程的入栈</h4><p>调用<code>int index</code>就会<code>push 所有的寄存器,然后push cs,push ip</code></p>
<p>最后的出栈..它会调用<code>iret</code>把上面的东西都<code>pop 出去</code></p>
<p>调用了<code>int</code>,如果你想退出程序,就在初始化int函数时,写上下面的代码</p>
<p>这个代码什么意思?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>



<p>调用<code>int 21h</code>中断,在调用前,初始化<code>指向子函数ah=4c,然后配置al=0</code></p>
<p>push 寄存器???</p>
<p>标志寄存器有假设10个?</p>
<p>其中8个他们的状态是11001010,于是我们把它看作一个8位的数据,可以达到<code>11001010b</code>&#x3D;<code>0xCA</code>,于是我们就把<code>0xCA</code>入栈</p>
<p>然后我们再push <code>IF,TF</code>,他们与外中断的屏蔽有关,,调用内中断时,会让<code>IF=0</code>,屏蔽了可屏蔽的外中断</p>
<p>于是我们才会用入栈6字节的数据,<code>4字节是CS:IP,2字节是8个寄存器值和2个寄存器值</code></p>
<h4 id="如何DIY一个中断"><a href="#如何DIY一个中断" class="headerlink" title="如何DIY一个中断"></a>如何DIY一个中断</h4><p>把它封装为一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call init_do0</span><br><span class="line">//然后去写中断函数,安装中断函数</span><br></pre></td></tr></table></figure>

<p>书写中断函数</p>
<p>调用复制功能的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//调用代码复制函数,因为你无法直接向中断向量的地址处写入数据,只能复制过去</span><br><span class="line">初始化DS:[SI]</span><br><span class="line">初始化ES:[di]</span><br><span class="line">初始化CX//涉及到了offset的取地址</span><br><span class="line">//这里是依据把中断函数写好了然后去复制</span><br><span class="line">执行 </span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">然后初始化一下中断向量表指向那个地址</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov word ptr es:[0*4+0],200h</span><br><span class="line">                            mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure>

<p>这个代码的意思就是</p>
<p>初始化<code>0号</code>中断,让<code>0号中断</code>执行中断例程的地址0000:0200</p>
<p>代码一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                            mov ax,stack</span><br><span class="line">                            mov ss,ax;</span><br><span class="line">                            mov sp,128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            call init_do0;他只会push ip</span><br><span class="line">                            mov ax,1000h</span><br><span class="line">                            mov bh,1</span><br><span class="line">                            div bh</span><br><span class="line"></span><br><span class="line">                            mov ax,4c00h</span><br><span class="line">                            int 21h</span><br><span class="line">;-----------------------------------------------------------------------------------------------------------------</span><br><span class="line">                 </span><br><span class="line">                init_do0:</span><br><span class="line">                            ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的</span><br><span class="line">                            ;--------------------------------------------</span><br><span class="line">                            ;设置数据来源 S指-&gt;CS:[do0]</span><br><span class="line">                            mov ax,cs</span><br><span class="line">                            mov ds,ax</span><br><span class="line">                            mov si,offset do0;这样取地址就非常的妙..不想你之前根本想不到</span><br><span class="line">                            </span><br><span class="line">                            ;设置数据D-&gt;0000:[0200]</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov di,200h</span><br><span class="line"></span><br><span class="line">                            mov cx,offset do0end - offset do0;循环的次数</span><br><span class="line"></span><br><span class="line">                            cld</span><br><span class="line">                            rep movsb</span><br><span class="line">                            </span><br><span class="line">                           </span><br><span class="line">                            ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov word ptr es:[0*4+0],200h</span><br><span class="line">                            mov word ptr es:[0*4+2],0</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">                            ret  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ;--------------------------------------</span><br><span class="line">                    do0:</span><br><span class="line">                            jmp short do0start</span><br><span class="line">                            db &quot;over flow&quot;</span><br><span class="line">                    do0start:</span><br><span class="line">                            mov ax,cs;</span><br><span class="line">                            mov ds,ax</span><br><span class="line">                            mov si,202h;这里的si可能是在指向字符串的偏移地址,jmp占据2个字节,然后他后面的就是字符串数据</span><br><span class="line"></span><br><span class="line">                            ;y要显示的字符串</span><br><span class="line">                            mov ax,0b800h</span><br><span class="line">                            mov es,ax</span><br><span class="line"></span><br><span class="line">                            mov cx,2000</span><br><span class="line">                            mov dx,0700h</span><br><span class="line">                            mov bx,0        </span><br><span class="line">                clean_screen:</span><br><span class="line">                            mov es:[bx],dx</span><br><span class="line">                            add bx,2</span><br><span class="line">                            loop clean_screen</span><br><span class="line"></span><br><span class="line">                            mov di,12*160+36*2</span><br><span class="line"></span><br><span class="line">                            mov cx,9;字符串的长度</span><br><span class="line">                    S:</span><br><span class="line">                            mov al,ds:[si]</span><br><span class="line">                            mov ah,2</span><br><span class="line">                            mov es:[di],ax</span><br><span class="line">                            inc si</span><br><span class="line">                            add di,2</span><br><span class="line">                            loop S</span><br><span class="line"></span><br><span class="line">                            iret;他会pop ip,所以他就是类似于一个ret    </span><br><span class="line"></span><br><span class="line">                           </span><br><span class="line"></span><br><span class="line">                do0end:        </span><br><span class="line">                            nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>









<h4 id="怎么调用一个中断"><a href="#怎么调用一个中断" class="headerlink" title="怎么调用一个中断"></a>怎么调用一个中断</h4><ol>
<li>程序崩溃时调用</li>
<li>人为的直接int index 调用</li>
</ol>
<p>我自己写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack</span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">    db 32 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: </span><br><span class="line">                                ;栈的初始化,容易忘记出初始化sp</span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax</span><br><span class="line">                                mov sp,32</span><br><span class="line"></span><br><span class="line">                                ;初始化内中断实例</span><br><span class="line">                                call init_do7ch</span><br><span class="line"></span><br><span class="line">                                ;向显存写东西</span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,160*20+30</span><br><span class="line"></span><br><span class="line">                                ;初始化一些吸入什么东西</span><br><span class="line">                                mov ah,2</span><br><span class="line">                                mov al,&#x27;!&#x27;</span><br><span class="line">                                ;打印的个数</span><br><span class="line">                                mov cx,4</span><br><span class="line">                                ;安全的让bp=0</span><br><span class="line">                                mov bp,0</span><br><span class="line">                                ;待会ip要回走,所以需要一个地址的间隔</span><br><span class="line">                                mov bx,offset s0end -offset s0</span><br><span class="line">                        s0:</span><br><span class="line">                                ;开始写入显存</span><br><span class="line">                                mov es:[di],ax</span><br><span class="line">                                ;遍历</span><br><span class="line">                                add di,2</span><br><span class="line">                                ;调用</span><br><span class="line">                                int 7ch</span><br><span class="line">                        s0end:</span><br><span class="line">                                ;标志一下位置</span><br><span class="line">                                nop</span><br><span class="line"></span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">                        init_do7ch:</span><br><span class="line">                                ;source</span><br><span class="line">                                mov ax,cs</span><br><span class="line">                                mov ds,ax</span><br><span class="line">                                mov si,offset do7ch</span><br><span class="line">                                ;destaion</span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,200h</span><br><span class="line">                                ;复制多少字节</span><br><span class="line">                                mov cx,offset do7chend - offset do7ch</span><br><span class="line"></span><br><span class="line">                                cld</span><br><span class="line">                                rep movsb</span><br><span class="line">                                ;初始化向量表</span><br><span class="line">                                mov word ptr es:[7ch*4+0],200h</span><br><span class="line">                                mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">                                ret</span><br><span class="line"></span><br><span class="line">                        do7ch:</span><br><span class="line">                                ;判断是否结束</span><br><span class="line">                                dec cx</span><br><span class="line">                                jcxz lpret</span><br><span class="line">                                ;保存一下bp,因为bp=sp,在发生变化</span><br><span class="line">                                push bp</span><br><span class="line">                                mov bp,sp</span><br><span class="line">                                sub ss:[bp+2],bx;让栈了里里面的ip重新指向开始的地方</span><br><span class="line">                                pop bp</span><br><span class="line"></span><br><span class="line">                        lpret:</span><br><span class="line">                                iret</span><br><span class="line">                        do7chend:nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h4 id="int-10h-gt-ah-x3D-2-光标中断"><a href="#int-10h-gt-ah-x3D-2-光标中断" class="headerlink" title="int  10h-&gt;ah&#x3D;2 光标中断"></a>int  10h-&gt;ah&#x3D;2 光标中断</h4><p>int 10h-&gt;ah&#x3D;2置光标</p>
<p>bh-&gt;第几页</p>
<p>dh-&gt;第几行</p>
<p>dl-&gt;第几列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah,2; int 10h的子程序</span><br><span class="line">mov bh,0	;bh是di某页</span><br><span class="line">mov dh,5	;行号</span><br><span class="line">mov dl,12	;列号</span><br><span class="line">int  10h	;10h中断例程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>80x25的字符模式下</p>
<p>0~24共25行</p>
<p>0~79共80列</p>
<p>0~7共8页</p>
<p>在80x25的模式下,B800~BFFF有32kb默认显示第0页</p>
<h4 id="int-10h-gt-ah-x3D-9-显示一个字符"><a href="#int-10h-gt-ah-x3D-9-显示一个字符" class="headerlink" title="int 10h-&gt;ah&#x3D;9 显示一个字符"></a>int 10h-&gt;ah&#x3D;9 显示一个字符</h4><p>int 10h-&gt;ah&#x3D;9,在光标处显示字符</p>
<p>al-&gt;显示的字符</p>
<p>bl-&gt;颜色</p>
<p>bh-&gt;第几页</p>
<p>cx-&gt;重复显示的个数,往后挪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mov ah,9;调用子函数</span><br><span class="line">mov al,&#x27;?&#x27;;显示字符&#x27;?&#x27;</span><br><span class="line">mov bl,7;颜色的属性</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复的个数</span><br><span class="line">int 10h;调用中断</span><br></pre></td></tr></table></figure>





<h4 id="int-21h-gt-ah-x3D-9-输出以‘-’结尾的字符串"><a href="#int-21h-gt-ah-x3D-9-输出以‘-’结尾的字符串" class="headerlink" title="int 21h-&gt;ah&#x3D;9 输出以‘$’结尾的字符串"></a>int 21h-&gt;ah&#x3D;9 输出以‘$’结尾的字符串</h4><p>ds-&gt;数据来源的短地址</p>
<p>dx-&gt;数据来源的偏移地址</p>
<p>ah-&gt;9功能编号,输出字符串,遇到<code>$</code>结束</p>
<p>int 21h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">in 21h</span><br></pre></td></tr></table></figure>







<h3 id="②-外中断"><a href="#②-外中断" class="headerlink" title="②. 外中断"></a>②. 外中断</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>外中断-&gt;1.可以被屏蔽	2.不可以屏蔽(其中断类型码只能是<code>2</code>)</p>
<p>之前内中断我们初始化了IF</p>
<p>对于可屏蔽的中断,</p>
<p><code>IF=1,表示屏蔽中断,IF=0,表示不屏蔽中断</code></p>
<p>指令</p>
<blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sti,置IF=1</span><br><span class="line">cli 置IF=0</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="PC机I-x2F-O键盘处理过程"><a href="#PC机I-x2F-O键盘处理过程" class="headerlink" title="PC机I&#x2F;O键盘处理过程"></a>PC机I&#x2F;O键盘处理过程</h4><p>键盘主板寄存器的端口是<code>60h</code></p>
<p>按下一个键,芯片产生一个扫描码,叫<code>通码</code></p>
<p>松开一个键,芯片也会产生一个扫描码,叫<code>断码</code></p>
<p>断码&#x3D;通码+80h</p>
<p>80h&#x3D;&#x3D;1000 0000b</p>
<p>可见最开头那位是一个开关之类的东西</p>
<p><code>int 9</code>只是对你的键入做了一个判断与执行..至于你的键入后怎么操作..这就得看你怎么对<code>int 9</code>去DIY的配置</p>
<blockquote>
<p>   我还是不太明白<code>int9</code>到底有个啥用!!!!!!!!!!!!!!!!</p>
</blockquote>
<p>​                                                    </p>
<h4 id="int-9中断-打印ascii的abcef"><a href="#int-9中断-打印ascii的abcef" class="headerlink" title="int 9中断  打印ascii的abcef"></a>int 9中断  打印ascii的abcef</h4><p>键盘的输入达到<code>60h</code>端口时,芯片就会自动的向CPU发出<code>int 9</code>的中码断,如果CPU检测到<code>IF=1</code>则表示接受外界键入,然后去指向<code>int 9</code>中断过程如果<code>IF=0</code>,表述拒绝接受键入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">  db 128 dup(&#x27;D&#x27;)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                                        </span><br><span class="line">                                        mov ax,data</span><br><span class="line">                                        mov ds,ax</span><br><span class="line">                                        </span><br><span class="line">                                        mov ax,stack</span><br><span class="line">                                        mov ss,ax</span><br><span class="line">                                        mov sp,32</span><br><span class="line"></span><br><span class="line">                                        mov ax,0b800h</span><br><span class="line">                                        mov es,ax</span><br><span class="line"></span><br><span class="line">                                        call init_9h;专门成立一个函数去初始会化int9,而且更大程度的保障了寄存器不发生更多的变化</span><br><span class="line">                                ;===========================================================</span><br><span class="line"></span><br><span class="line">                                        mov cx,0</span><br><span class="line">                                        ;从感叹号开始显示</span><br><span class="line">                                        mov cl,&#x27;!&#x27;</span><br><span class="line">                                        ;颜色从2开始</span><br><span class="line">                                        mov ch,2</span><br><span class="line">                                        ;开始的地点是10行20列</span><br><span class="line">                                        mov di,160*10+20</span><br><span class="line"></span><br><span class="line">                                show:     </span><br><span class="line">                                        ;把配置输入到显存                           </span><br><span class="line">                                        mov es:[di],cx</span><br><span class="line">                                        ;加缓延时</span><br><span class="line">                                        call delay;delay函数不能与cmp与jne交叉,以为delay内部会有指令修改寄存器的操作  </span><br><span class="line">                                        ;指向下一个像素                           </span><br><span class="line">                                        add di,2</span><br><span class="line">                                        ;指向下一个字符</span><br><span class="line">                                        inc cl</span><br><span class="line">                                        ;重点是&#x27;~&#x27;</span><br><span class="line">                                        cmp cl,&#x27;~&#x27;</span><br><span class="line">                                        jna show</span><br><span class="line"></span><br><span class="line">                                        ;备份int9的原始向量</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov es,ax</span><br><span class="line">                                        </span><br><span class="line">                                        ;原始向量恢复到向量表,,,否者DOS系统运行完毕后键盘将屏蔽你的外中断</span><br><span class="line">                                        push ds:[0]</span><br><span class="line">                                        pop es:[9*4+0]</span><br><span class="line">                                        push ds:[2]</span><br><span class="line">                                        pop es:[9*4+2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                        mov ax,4c00h</span><br><span class="line">                                        int 21h</span><br><span class="line">                                ;============================================================</span><br><span class="line">                                 delay:</span><br><span class="line">                                        ;它的原理我不太懂</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov bx,1h</span><br><span class="line">                        delay_continue:</span><br><span class="line">                                        sub ax,1;它是控制速度的</span><br><span class="line">                                        sbb bx,0</span><br><span class="line">                                        cmp ax,0</span><br><span class="line">                                        jne delay_continue</span><br><span class="line">                                        cmp bx,0</span><br><span class="line">                                        jne delay_continue</span><br><span class="line"></span><br><span class="line">                                        ret</span><br><span class="line">                                ;============================================================</span><br><span class="line">                        init_9h:</span><br><span class="line">                                        push es</span><br><span class="line"></span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov es,ax</span><br><span class="line"></span><br><span class="line">                                        ;备份int 9的中断向量表</span><br><span class="line">                                        push es:[9*4+0]</span><br><span class="line">                                        pop ds:[0]</span><br><span class="line">                                        push es:[9*4+2] </span><br><span class="line">                                        pop ds:[2]</span><br><span class="line"></span><br><span class="line">                                        cli</span><br><span class="line">                                        mov word ptr es:[9*4+0],offset start_9h</span><br><span class="line">                                        mov es:[9*4+2],cs</span><br><span class="line">                                        sti</span><br><span class="line"></span><br><span class="line">                                        pop es</span><br><span class="line">                                        ret</span><br><span class="line">                            </span><br><span class="line">                              start_9h:</span><br><span class="line">                                        ;你键入的数据在端口60处</span><br><span class="line">                                        in al,60h;al从端口接收了你的键入</span><br><span class="line">                                        ;模拟int9的过程,push全部寄存器,然后push cs,IP</span><br><span class="line">                                        pushf</span><br><span class="line">                                        call dword ptr ds:[0];int9自己有iret</span><br><span class="line">                                        cmp al,48h;48h是 ↑</span><br><span class="line">                                        jne start_9h_end;如果不是上就跳过然后结束,如果这里用je会比较麻烦!!!!!!!!!!!!!!!!</span><br><span class="line">                                        inc ch</span><br><span class="line">                            start_9h_end:</span><br><span class="line">                                        iret</span><br><span class="line">                            ;=========================================================================</span><br><span class="line">                              </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><h3 id="printf-syscall"><a href="#printf-syscall" class="headerlink" title="printf_syscall"></a>printf_syscall</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov		rax,1</span><br><span class="line">mov		rdi,1</span><br><span class="line">mov 	rsi,str1</span><br><span class="line">mov 	rdx,len1</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>rax的1代表了写入</p>
<p>rdi的1代表了标准输出</p>
<p>rsi代表了字符串输出的地址</p>
<p>rdx代表了输出的长度,最后的0不计数</p>
<p>syscall调用系统内部的和中断</p>
<p>这些寄存器可否用于其他的用途</p>
<p>于是你封装函数的时候,就传递一些动态参数,初始化一些固定的参数</p>
<h3 id="scanf-syscall"><a href="#scanf-syscall" class="headerlink" title="scanf_syscall"></a>scanf_syscall</h3><p>rax&#x3D;0,表示读取</p>
<p>rdi&#x3D;1,表示标准输入</p>
<p>rsi&#x3D;输入字符串的地址</p>
<p>rdx&#x3D;输入字符串的长度</p>
<p>它没有格式化输入与输出</p>
<p>你的rsi是字符串,你就只能输入字符串???</p>
<p>你的rsi指向dd.你就只能输入数值??</p>
<h3 id="ret-syscall"><a href="#ret-syscall" class="headerlink" title="ret_syscall"></a>ret_syscall</h3><p>下面的代码等效于main函数的return,好比ret</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     rax, 60		; 60 = exit</span><br><span class="line">mov     rdi, 0		; 0 = success exit code</span><br><span class="line">syscall				; quit</span><br></pre></td></tr></table></figure>



<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>类比一下中断程序</p>
<p>因为书上没有怎么介绍..依次我就没有多多的解释</p>
<h2 id="一-读写指令"><a href="#一-读写指令" class="headerlink" title="(一). 读写指令"></a>(一). 读写指令</h2><p>从<code>右-&gt;左</code>看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(读) in 寄存器/数据,  端口				//端口S的数据读进D寄存器</span><br><span class="line">(写) out 端口,       寄存器/数据		//把S的数据写进</span><br></pre></td></tr></table></figure>



<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>从端口读入到接收者</p>
<p>端口是一个编号,也可以是装有编号的寄存器</p>
<p>写入的数据是8位就只能用AL</p>
<p>如果是16位就用AX</p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>把数据写入端口</p>
<p>端口是一个编号,也可以是装有编号的寄存器</p>
<p>写入的数据是8位就只能用AL</p>
<h2 id="二-CMOS-RAM-芯片端口"><a href="#二-CMOS-RAM-芯片端口" class="headerlink" title="(二). CMOS RAM 芯片端口"></a>(二). CMOS RAM 芯片端口</h2><h3 id="简要介绍-1"><a href="#简要介绍-1" class="headerlink" title="简要介绍"></a>简要介绍</h3><p>该芯片内部有2个端口,</p>
<p>端口地址</p>
<p>可以是70h,代表了地址写入的端口</p>
<p>可以是71h,代表了数据读取&#x2F;写入的端口</p>
<p>如何读取CMOS RAM的2号单元</p>
<p>①. 把2号写入71h <code>out 70h,2</code></p>
<p>②. 71h数据读入<code> in ax,71h</code></p>
<p>检测点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;i really love love you&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax</span><br><span class="line">                                mov sp,128</span><br><span class="line"></span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov al,2</span><br><span class="line"></span><br><span class="line">                                out 70h,al</span><br><span class="line">                                mov ax,0</span><br><span class="line">                                in  al,71h</span><br><span class="line">                        </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="CMOS下的时间单元"><a href="#CMOS下的时间单元" class="headerlink" title="CMOS下的时间单元"></a>CMOS下的时间单元</h3><h4 id="什么叫BCD码"><a href="#什么叫BCD码" class="headerlink" title="什么叫BCD码"></a>什么叫BCD码</h4><p><code>4位</code>的二进制就构成一个<code>BCD码</code></p>
<p>好比10进制的<code>26</code>就是由<code>0010</code>和<code>0110</code>构成</p>
<p><code>0010</code>代表<code>2</code></p>
<p><code>0110</code>代表<code>6</code></p>
<h4 id="时间单元"><a href="#时间单元" class="headerlink" title="时间单元"></a>时间单元</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>年</td>
<td>月</td>
<td>日</td>
<td>时</td>
<td>分</td>
<td>秒</td>
</tr>
<tr>
<td>9</td>
<td>8</td>
<td>7</td>
<td>4</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<h5 id="打印月份"><a href="#打印月份" class="headerlink" title="打印月份"></a>打印月份</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;i really love love you&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax</span><br><span class="line">                                mov sp,128</span><br><span class="line"></span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov al,8;把al写入数据端口</span><br><span class="line">                                out 70h,al;把对于单元的数据读取到al</span><br><span class="line">                                in  al,71h </span><br><span class="line"></span><br><span class="line">                                mov ah,al</span><br><span class="line">                                mov cl,4</span><br><span class="line">                                shr ah,cl</span><br><span class="line"></span><br><span class="line">                                and al,00001111b</span><br><span class="line"></span><br><span class="line">                                add al,30h</span><br><span class="line">                                add ah,30h</span><br><span class="line"></span><br><span class="line">                                push ax</span><br><span class="line"></span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,0</span><br><span class="line"></span><br><span class="line">                                mov cx,2000</span><br><span class="line">                                mov bx,0700h</span><br><span class="line">                            s:</span><br><span class="line">                                mov es:[di],bx</span><br><span class="line">                                add di,2</span><br><span class="line">                                loop s</span><br><span class="line"></span><br><span class="line">                                pop ax</span><br><span class="line">                                mov di,160*10+20</span><br><span class="line">                                mov cl,11001010b</span><br><span class="line"></span><br><span class="line">                                mov es:[di+0],ah</span><br><span class="line">                                mov es:[di+1],cl</span><br><span class="line">                                mov es:[di+2],al</span><br><span class="line">                                mov es:[di+3],cl</span><br><span class="line"></span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h5 id="打印年月日时分秒"><a href="#打印年月日时分秒" class="headerlink" title="打印年月日时分秒"></a>打印年月日时分秒</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">  db &quot;2000/00/00/00:00:00-TIME-Dqx-Ghost&quot;,&#x27;$&#x27;</span><br><span class="line">  db 9,8,7,4,2,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment  </span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax</span><br><span class="line">                                mov sp,128</span><br><span class="line"></span><br><span class="line">                                call clean_screen</span><br><span class="line"></span><br><span class="line">                                mov ax,data</span><br><span class="line">                                mov ds,ax</span><br><span class="line"></span><br><span class="line">                              k:                               </span><br><span class="line">                                call init_time                        </span><br><span class="line">                                call init_xy_and_show</span><br><span class="line">                                jmp k</span><br><span class="line"></span><br><span class="line">                                ;==========================================  </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                               </span><br><span class="line">                      </span><br><span class="line">;======================================================================================</span><br><span class="line">                  clean_screen:</span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,0</span><br><span class="line"></span><br><span class="line">                                mov cx,2000</span><br><span class="line">                                mov bx,0700h</span><br><span class="line">            clean_screen_start:</span><br><span class="line">                                mov es:[di],bx</span><br><span class="line">                                add di,2</span><br><span class="line">                                loop clean_screen_start</span><br><span class="line">                                ret</span><br><span class="line">;======================================================================================</span><br><span class="line">                init_time:</span><br><span class="line">                                ;数据源已经被初始化了                              </span><br><span class="line">                                ;循环6次</span><br><span class="line">                                mov cx,6</span><br><span class="line">                                ;初始化数据的指向</span><br><span class="line">                                mov si,35</span><br><span class="line">                                mov bx,2</span><br><span class="line">                                ;循环体部分                                </span><br><span class="line">                init_time_start:   </span><br><span class="line">                                push cx </span><br><span class="line">                                ;初始化端口编号  </span><br><span class="line">                                mov al,ds:[si]</span><br><span class="line">                                ;写入端口</span><br><span class="line">                                out 70h,al</span><br><span class="line">                                in  al,71h </span><br><span class="line"></span><br><span class="line">                                mov ah,al</span><br><span class="line">                                mov cl,4</span><br><span class="line">                                shr ah,cl</span><br><span class="line"></span><br><span class="line">                                and al,00001111b</span><br><span class="line"></span><br><span class="line">                                add al,30h</span><br><span class="line">                                add ah,30h</span><br><span class="line"></span><br><span class="line">                                mov byte ptr ds:[bx+0],ah</span><br><span class="line">                                mov byte ptr ds:[bx+1],al</span><br><span class="line"></span><br><span class="line">                                add bx,3</span><br><span class="line">                                inc si</span><br><span class="line">                                pop cx</span><br><span class="line">                                loop init_time_start</span><br><span class="line">                                </span><br><span class="line">                                ret</span><br><span class="line">;========================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              init_xy_and_show:</span><br><span class="line">                                mov ah,2</span><br><span class="line">                                mov bh,0</span><br><span class="line"></span><br><span class="line">                                mov dl,20</span><br><span class="line">                                mov dh,10</span><br><span class="line">                                int 10h</span><br><span class="line">                               </span><br><span class="line">                                ;数据源已经被初始化了</span><br><span class="line">                                mov dx,0</span><br><span class="line">                                mov ah,9</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">                                ret</span><br><span class="line">                        </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="利用BIOS进行键盘的读写"><a href="#利用BIOS进行键盘的读写" class="headerlink" title="利用BIOS进行键盘的读写"></a>利用BIOS进行键盘的读写</h3><p>这里涉及到一个<code>int 16h</code>中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">int 16h</span><br></pre></td></tr></table></figure>

<p>它的运行结果会是怎么样?</p>
<p>①.寄存器ax中会有一份值</p>
<p>ah:扫描码的通码</p>
<p>al:扫描码的ASCII码</p>
<p>②.键盘缓冲区中也会有一份值,高位通码,低位ASCII码,组成了一个字单元</p>
<p>这样的字单元会有15个</p>
<p>值得注意的是</p>
<p><code>int 16h</code>会从键盘缓冲区读取数据,,</p>
<p>如果键盘缓冲区有数据就读取一个字节<code>(至于读取谁,可以想象一下栈,它会读取最后进来那个)</code></p>
<p>如果没有数据,程序会一直等待你的输入..不会退出..直到键盘缓冲区有数据被它吃才会结束</p>
<p>核心的原理</p>
<p>读取键盘的输入,然后保存</p>
<p>如果输入back_space就让buff区那位置为0</p>
<p>如果输入enter,也是,然后那个位置置为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        Arr                             db      128 dup(&#x27;D&#x27;) </span><br><span class="line">        Table_A 			dw      Store_ascii,show_str,Delete_Ascii</span><br><span class="line">        which_one   			dw      0;函数指针的index</span><br><span class="line">        index                           dw      0;输入的ascii有多少个</span><br><span class="line">        input   			dw      0;你的每一个键入的ascii的缓冲区       </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                mov     ax,data</span><br><span class="line">                mov     ds,ax</span><br><span class="line"></span><br><span class="line">                mov     ax,stack</span><br><span class="line">                mov     ss,ax</span><br><span class="line">                mov     sp,128</span><br><span class="line"></span><br><span class="line">                mov     di,20*2;你的输入在第一行的[20][0]处开始</span><br><span class="line"></span><br><span class="line">                call    option</span><br><span class="line"></span><br><span class="line">                mov     ax,4c00h</span><br><span class="line">                int     21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------------------</span><br><span class="line">        option:</span><br><span class="line">                </span><br><span class="line">        option_start:</span><br><span class="line">                mov     ax,0</span><br><span class="line">                int     16h</span><br><span class="line"></span><br><span class="line">                cmp     al,20h;20h是最小的ASCII,之后的是不可见字符</span><br><span class="line">                jnb     main1     </span><br><span class="line">                cmp     al,08h;退格键</span><br><span class="line">                jz      back_space</span><br><span class="line">                cmp     al,0dh</span><br><span class="line">                jz      enter_A</span><br><span class="line"></span><br><span class="line">                jmp     option_start</span><br><span class="line"></span><br><span class="line">        option_ret:              </span><br><span class="line">                ret</span><br><span class="line">;-----------------------------------------------------------------------</span><br><span class="line">        main1:</span><br><span class="line">                mov     which_one,0*2;调用store函数</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]</span><br><span class="line"></span><br><span class="line">                mov     which_one,1*2</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]               </span><br><span class="line"></span><br><span class="line">                jmp     option_start</span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">        back_space:</span><br><span class="line">                mov     which_one,2*2</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]</span><br><span class="line">                </span><br><span class="line">                mov     which_one,1*2</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]</span><br><span class="line"></span><br><span class="line">                jmp     option_start</span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">        enter_A:</span><br><span class="line">                mov     which_one,2*2</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]</span><br><span class="line"></span><br><span class="line">                mov     which_one,1*2</span><br><span class="line">                mov     bx,which_one</span><br><span class="line">                call  	word ptr Table_A[bx]  </span><br><span class="line"></span><br><span class="line">                jmp     option_ret</span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Store_ascii:</span><br><span class="line"></span><br><span class="line">                mov     input,al</span><br><span class="line">                mov     bx,index </span><br><span class="line">                mov	byte ptr [bx],al</span><br><span class="line">                inc	word ptr index </span><br><span class="line">                ret</span><br><span class="line"></span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">        Delete_Ascii: </span><br><span class="line">                dec 	word ptr index</span><br><span class="line">                mov 	input,0</span><br><span class="line">                mov     bx,index </span><br><span class="line">                mov	word ptr [bx],0</span><br><span class="line">                </span><br><span class="line">                ;退格太多,不能退太多,要回到初始位置</span><br><span class="line">                cmp 	di,40</span><br><span class="line">                jb     	back </span><br><span class="line">                jnb     back_fail</span><br><span class="line">                back:		</span><br><span class="line">                mov 	di,40</span><br><span class="line">		back_fail:</span><br><span class="line">                ret</span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">        show_str:</span><br><span class="line">                push ax</span><br><span class="line">                push es</span><br><span class="line"></span><br><span class="line">                mov ax,0b800h</span><br><span class="line">                mov es,ax</span><br><span class="line">                mov ax,160</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                cmp input,0</span><br><span class="line">                jne  ok2</span><br><span class="line">                je   ok1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ok1:</span><br><span class="line">                        sub  di,2;把原来那个给删除了</span><br><span class="line">                        mov byte ptr es:[di],0</span><br><span class="line">                        jmp over</span><br><span class="line">                ok2:</span><br><span class="line">                        mov al,input</span><br><span class="line">                        mov ah,2</span><br><span class="line">                        mov es:[di],ax;初始化当前的</span><br><span class="line">                        add di,2	;然后指向下一个`		</span><br><span class="line"></span><br><span class="line">	over:</span><br><span class="line">                pop es</span><br><span class="line">                pop ax</span><br><span class="line">                ret</span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>我没看懂它的输出位置的原理,这么久输出在了di+50的地方</p>
<p>你也没有把它的push与pop给看懂,乱七八糟的push与pop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db 128 dup(&#x27;D&#x27;)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                mov ax,data</span><br><span class="line">                mov ds,ax</span><br><span class="line"></span><br><span class="line">                call func</span><br><span class="line"></span><br><span class="line">                mov ax,4c00h</span><br><span class="line">                int 21h</span><br><span class="line"></span><br><span class="line">        func:</span><br><span class="line">                push ax</span><br><span class="line">        option:</span><br><span class="line">                mov ah,0</span><br><span class="line">                int 16h</span><br><span class="line"></span><br><span class="line">                cmp al,20h</span><br><span class="line">                jb  nochar</span><br><span class="line"></span><br><span class="line">                mov ah,0</span><br><span class="line">                call main1</span><br><span class="line">                </span><br><span class="line">                mov ah,2</span><br><span class="line">                call main1</span><br><span class="line"></span><br><span class="line">                jmp option</span><br><span class="line">        nochar:</span><br><span class="line">                cmp ah,0eh</span><br><span class="line">                je backspace</span><br><span class="line">                cmp ah,1ch</span><br><span class="line">                je enter_</span><br><span class="line">                jmp option</span><br><span class="line">        backspace:</span><br><span class="line">                mov ah,1</span><br><span class="line">                call main1</span><br><span class="line">                mov ah,2</span><br><span class="line">                call main1</span><br><span class="line">                jmp option</span><br><span class="line">        enter_:</span><br><span class="line">                mov al,0</span><br><span class="line">                mov ah,0</span><br><span class="line">                call main1</span><br><span class="line">                mov ah,2</span><br><span class="line">                call main1</span><br><span class="line">                pop ax</span><br><span class="line">                ret</span><br><span class="line"></span><br><span class="line">        main1:</span><br><span class="line">                jmp short Begin</span><br><span class="line">        table_          dw  Store_Ascii,Delete_Ascii,show</span><br><span class="line">        check           dw 0</span><br><span class="line">        Begin:  </span><br><span class="line">                push bx</span><br><span class="line">                push dx</span><br><span class="line">                push di</span><br><span class="line">                push es </span><br><span class="line"></span><br><span class="line">                cmp ah,2</span><br><span class="line">                ja  main1_end</span><br><span class="line"></span><br><span class="line">                mov bl,ah</span><br><span class="line">                mov bh,0</span><br><span class="line">                add bx,bx;让bx翻倍</span><br><span class="line">                jmp word ptr table_[bx];为什么index一定是16位?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Store_Ascii:</span><br><span class="line">                mov bx,check</span><br><span class="line">                mov ds:[bx],al</span><br><span class="line">                inc check</span><br><span class="line">                jmp main1_end</span><br><span class="line">        Delete_Ascii:</span><br><span class="line">                cmp check,0</span><br><span class="line">                je main1_end</span><br><span class="line"></span><br><span class="line">                dec check</span><br><span class="line">                mov bx,check</span><br><span class="line">                jmp main1_end</span><br><span class="line">        show:</span><br><span class="line">                mov bx, 0b800h</span><br><span class="line">                mov es,bx</span><br><span class="line">                mov al,160</span><br><span class="line">                mov ah,0</span><br><span class="line">                mov di,ax</span><br><span class="line">				;下面这3行代码我真看不懂</span><br><span class="line">                ;add dl,dl</span><br><span class="line">                ;mov dh,0</span><br><span class="line">                ;add di,dx</span><br><span class="line">                mov bx,0</span><br><span class="line"></span><br><span class="line">        is_KG_or_not:</span><br><span class="line">                cmp bx,check</span><br><span class="line">                jne show_ascii</span><br><span class="line">				mov byte ptr es:[di-1],2</span><br><span class="line">                mov byte ptr es:[di+0],&#x27; &#x27;</span><br><span class="line">                jmp main1_end</span><br><span class="line">        show_ascii:</span><br><span class="line">                mov al,[bx]</span><br><span class="line">                mov es:[di],al</span><br><span class="line">                inc bx</span><br><span class="line">                add di,2</span><br><span class="line">                jmp is_KG_or_not</span><br><span class="line">        main1_end:</span><br><span class="line">                pop es</span><br><span class="line">                pop di</span><br><span class="line">                pop dx</span><br><span class="line">                pop bx</span><br><span class="line">                ret                                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>







<h3 id="利用BIOS进行磁盘的读写"><a href="#利用BIOS进行磁盘的读写" class="headerlink" title="利用BIOS进行磁盘的读写"></a>利用BIOS进行磁盘的读写</h3><p>软盘</p>
<p>分为2面</p>
<p>每面软盘80个磁道</p>
<p>每个磁道18个扇区</p>
<p>每个扇区512个字节</p>
<table>
<thead>
<tr>
<th align="center">使用参数</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">写入-&gt;几个面</td>
<td align="center">al</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">写入-&gt;背面还是反面</td>
<td align="center">dh&#x3D;(0或者1)</td>
</tr>
<tr>
<td align="center">写入-&gt;哪个磁道</td>
<td align="center">ch</td>
</tr>
<tr>
<td align="center">写入-&gt;哪个扇区</td>
<td align="center">cl(1开始计数)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">写入-&gt;哪个磁盘?A&#x2F;B&#x2F;C&#x2F;D</td>
<td align="center">dl</td>
</tr>
<tr>
<td align="center">数据S&#x2F;D的短地址</td>
<td align="center">ES</td>
</tr>
<tr>
<td align="center">数据S&#x2F;D的偏移地址</td>
<td align="center">BX</td>
</tr>
<tr>
<td align="center">使用哪个功能</td>
<td align="center">ah</td>
</tr>
<tr>
<td align="center">中断</td>
<td align="center">int 13h</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逻辑扇区<code>x</code></td>
<td align="center"><code>(80xdh+ch)x18+cl-1</code></td>
</tr>
<tr>
<td align="center">面号<code>dh</code></td>
<td align="center"><code>x/1440</code></td>
</tr>
<tr>
<td align="center">磁道号<code>ch</code></td>
<td align="center"><code>(x%1400)/18</code></td>
</tr>
<tr>
<td align="center">扇区号<code>cl</code></td>
<td align="center"><code>x%1400%18+1</code></td>
</tr>
</tbody></table>
<p>把显存的4000字节依次写入1号,2号…8号扇区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">			</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                mov     ax,data</span><br><span class="line">                mov     ds,ax</span><br><span class="line"></span><br><span class="line">                mov     ax,stack</span><br><span class="line">                mov     ss,ax</span><br><span class="line">                mov     sp,128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                mov     ax,0b800h;段地址</span><br><span class="line">                mov     es,ax</span><br><span class="line">                mov     bx,0;偏移地址</span><br><span class="line"></span><br><span class="line">                mov     al,8;写入8个扇区</span><br><span class="line">                mov     dl,0;在正面写入</span><br><span class="line">                </span><br><span class="line">                mov     dh,0;0面</span><br><span class="line">                mov     ch,0;0道</span><br><span class="line">                mov     cl,1;1扇区</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                mov     ah,3;读取</span><br><span class="line">                int     13h</span><br><span class="line"></span><br><span class="line">                mov     ax,4c00h</span><br><span class="line">                int     21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;&#x27;----------------------------------------------------------------------------&#x27;</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>我很疑惑它写入了多少?<br>以什么样的格式写入</p>
<p>写入的是db,dw???</p>
<p>ascii?</p>
<h1 id="x64的文件处理"><a href="#x64的文件处理" class="headerlink" title="x64的文件处理"></a>x64的文件处理</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; file.asm</span><br><span class="line">section .data</span><br><span class="line">;条件汇编表达式</span><br><span class="line">	CREATE 		equ 	1	;创建</span><br><span class="line">	OVERWRITE 	equ 	1	;重写</span><br><span class="line">	APPEND 		equ 	1	;追加</span><br><span class="line">	O_WRITE 	equ 	1	;二进制写入</span><br><span class="line">	READ 		equ 	1	;读取</span><br><span class="line">	O_READ 		equ 	1	;二进制读取</span><br><span class="line">	DELETE 		equ 	1	;删除</span><br><span class="line">			</span><br><span class="line">;系统调用符号</span><br><span class="line">	NR_read  	equ 	0 </span><br><span class="line">	NR_write 	equ 	1 </span><br><span class="line">	NR_open 	equ 	2 </span><br><span class="line">	NR_close 	equ 	3</span><br><span class="line">	NR_lseek 	equ 	8 </span><br><span class="line">	NR_create 	equ 	85</span><br><span class="line">	NR_unlink 	equ 	87</span><br><span class="line"></span><br><span class="line">;创建状态标志</span><br><span class="line">	O_CREAT 	equ 	00000100q	;二进制创建</span><br><span class="line">	O_APPEND 	equ 	00002000q	;二进制追加</span><br><span class="line"></span><br><span class="line">;访问模式   </span><br><span class="line">	O_RDONLY 	equ 	000000q </span><br><span class="line">	O_WRONLY 	equ 	000001q </span><br><span class="line">	O_RDWR 		equ 	000002q</span><br><span class="line"></span><br><span class="line">;创建权限</span><br><span class="line">	S_IRUSR 	equ 	00400q  ;user read permission</span><br><span class="line">	S_IWUSR 	equ 	00200q 	;user write permission</span><br><span class="line"> </span><br><span class="line">	NL	  		equ		0xa					</span><br><span class="line">	bufferlen  	equ 	64</span><br><span class="line">   </span><br><span class="line">	fileName db 	&quot;testfile.txt&quot;,0</span><br><span class="line">	FD 		 dq 	0	; 文件描述符号</span><br><span class="line"></span><br><span class="line">	text1	 db 	&quot;1. Hello...to everyone!&quot;,NL,0</span><br><span class="line">	len1     dq 	$-text1-1                  ;remove 0</span><br><span class="line">	text2    db 	&quot;2. Here I am!&quot;,NL,0</span><br><span class="line">	len2     dq 	$-text2-1                   ;remove 0</span><br><span class="line">	text3    db 	&quot;3. Alife and kicking!&quot;,NL,0</span><br><span class="line">	len3     dq 	$-text3-1                   ;remove 0</span><br><span class="line">	text4    db 	&quot;Adios !!!&quot;,NL,0</span><br><span class="line">	len4     dq 	$-text4-1</span><br><span class="line"></span><br><span class="line">	error_Create 	db &quot;error creating file&quot;,NL,0</span><br><span class="line">	error_Close 	db &quot;error closing file&quot;,NL,0</span><br><span class="line">	error_Write 	db &quot;error writing to file&quot;,NL,0</span><br><span class="line">	error_Open 	db &quot;error opening file&quot;,NL,0</span><br><span class="line">	error_Append 	db &quot;error appending to file&quot;,NL,0</span><br><span class="line">	error_Delete 	db &quot;error deleting file&quot;,NL,0</span><br><span class="line">	error_Read 	db &quot;error reading file&quot;,NL,0</span><br><span class="line">	error_Print 	db &quot;error printing string&quot;,NL,0</span><br><span class="line">	error_Position 	db &quot;error positioning in file&quot;,NL,0</span><br><span class="line"></span><br><span class="line">	success_Create 		db &quot;File created and opened&quot;,NL,0</span><br><span class="line">	success_Close 		db &quot;File closed&quot;,NL,NL,0</span><br><span class="line">	success_Write 		db &quot;Written to file&quot;,NL,0</span><br><span class="line">	success_Open 		db &quot;File opened for reading/(over)writing/updating&quot;,NL,0</span><br><span class="line">	success_Append 		db &quot;File opened for appending&quot;,NL,0</span><br><span class="line">	success_Delete 		db &quot;File deleted&quot;,NL,0</span><br><span class="line">	success_Read 		db &quot;Reading file&quot;,NL,0</span><br><span class="line">	success_Position	db &quot;Positioned in file&quot;,NL,0</span><br><span class="line">    </span><br><span class="line">section .bss							</span><br><span class="line">	buffer resb bufferlen</span><br><span class="line">section .text							</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">	push rbp</span><br><span class="line">	mov  rbp,rsp</span><br><span class="line"></span><br><span class="line">	%IF CREATE</span><br><span class="line">	;创建打开,然后关闭</span><br><span class="line">	mov 	rdi, fileName</span><br><span class="line">	call 	createFile</span><br><span class="line">	mov 	qword [FD], rax ; save descriptor</span><br><span class="line"></span><br><span class="line">	; write to file #1</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	mov 	rsi, text1</span><br><span class="line">	mov 	rdx, qword [len1]</span><br><span class="line">	call 	writeFile</span><br><span class="line">    </span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile</span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line">	%IF OVERWRITE</span><br><span class="line">	;OPEN AND OVERWRITE A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">	; open file </span><br><span class="line">	mov 	rdi, fileName </span><br><span class="line">	call 	openFile  </span><br><span class="line">	mov 	qword [FD], rax ; save file descriptor</span><br><span class="line"></span><br><span class="line">	; write to file #2 OVERWRITE!</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	mov 	rsi, text2</span><br><span class="line">	mov 	rdx, qword [len2]</span><br><span class="line">	call 	writeFile    </span><br><span class="line"></span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile    </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line">	%IF APPEND</span><br><span class="line">	;OPEN AND APPEND TO A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">	; open file to append</span><br><span class="line">	mov 	rdi, fileName </span><br><span class="line">	call 	appendFile  </span><br><span class="line">	mov 	qword [FD], rax ; save file descriptor</span><br><span class="line"></span><br><span class="line">	; write to file #3 APPEND!</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	mov 	rsi, text3</span><br><span class="line">	mov 	rdx, qword [len3]</span><br><span class="line">	call 	writeFile       </span><br><span class="line"></span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line">	%IF O_WRITE</span><br><span class="line">	;OPEN AND OVERWRITE AT AN OFFSET IN A FILE, THEN CLOSE -----------------------</span><br><span class="line">	; open file to write</span><br><span class="line">	mov 	rdi, fileName </span><br><span class="line">	call 	openFile  </span><br><span class="line">	mov 	qword [FD], rax ; save file descriptor</span><br><span class="line"></span><br><span class="line">	; position file at offset</span><br><span class="line">	mov 	rdi, qword[FD]</span><br><span class="line">	mov 	rsi, qword[len2] ;offset at this location</span><br><span class="line">	mov 	rdx, 0</span><br><span class="line">	call 	positionFile    </span><br><span class="line"></span><br><span class="line">	; write to file at offset</span><br><span class="line">	mov 	rdi, qword[FD]</span><br><span class="line">	mov 	rsi, text4</span><br><span class="line">	mov 	rdx, qword [len4]</span><br><span class="line">	call 	writeFile </span><br><span class="line"></span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	%IF READ</span><br><span class="line">	;OPEN AND READ FROM A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">	; open file to read</span><br><span class="line">	mov 	rdi, fileName </span><br><span class="line">	call 	openFile  </span><br><span class="line">	mov 	qword [FD], rax ; save file descriptor  </span><br><span class="line"></span><br><span class="line">	; read from file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	mov 	rsi, buffer</span><br><span class="line">	mov 	rdx, bufferlen    </span><br><span class="line">	call 	readFile</span><br><span class="line">	mov 	rdi,rax</span><br><span class="line">	call 	printString</span><br><span class="line"></span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line">	%IF O_READ</span><br><span class="line">	;OPEN AND READ AT AN OFFSET FROM A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">	; open file to read</span><br><span class="line">	mov 	rdi, fileName </span><br><span class="line">	call 	openFile  </span><br><span class="line">	mov 	qword [FD], rax ; save file descriptor  </span><br><span class="line"></span><br><span class="line">	; position file at offset</span><br><span class="line">	mov 	rdi, qword[FD]</span><br><span class="line">	mov 	rsi, qword[len2]		;skip the first line</span><br><span class="line">	mov 	rdx, 0</span><br><span class="line">	call 	positionFile          </span><br><span class="line"></span><br><span class="line">	; read from file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	mov 	rsi, buffer</span><br><span class="line">	mov 	rdx, 10    ;number of characters to read</span><br><span class="line">	call 	readFile</span><br><span class="line">	mov 	rdi,rax</span><br><span class="line">	call 	printString</span><br><span class="line"></span><br><span class="line">	; close file</span><br><span class="line">	mov 	rdi, qword [FD]</span><br><span class="line">	call 	closeFile </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line">	%IF DELETE</span><br><span class="line">	;DELETE A FILE --------------------------------------------------   </span><br><span class="line">	; delete file   UNCOMMENT NEXT LINES TO USE</span><br><span class="line">	mov 	rdi, fileName</span><br><span class="line">	call 	deleteFile                                      </span><br><span class="line">	%ENDIF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">; FILE MANIPULATION FUNCTIONS-------------------------------------</span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">	global readFile</span><br><span class="line">readFile:</span><br><span class="line">	mov 	rax, NR_read</span><br><span class="line">	syscall                         ; rax contains # of characters read</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		readerror</span><br><span class="line">	mov 	byte [rsi+rax],0	; add a terminating zero to the string</span><br><span class="line">	mov 	rax, rsi</span><br><span class="line"></span><br><span class="line">	mov 	rdi, success_Read</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">readerror:</span><br><span class="line">	mov 	rdi, error_Read </span><br><span class="line">	call 	printString</span><br><span class="line">	ret  </span><br><span class="line">	;-----------------------------------------------------------------</span><br><span class="line">global deleteFile</span><br><span class="line">deleteFile:</span><br><span class="line">	mov 	rax, NR_unlink</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		deleteerror</span><br><span class="line">	mov 	rdi, success_Delete</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">deleteerror:</span><br><span class="line">	mov 	rdi, error_Delete </span><br><span class="line">	call 	printString</span><br><span class="line">	ret  </span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">	global appendFile</span><br><span class="line">appendFile:</span><br><span class="line">	mov 	rax, NR_open </span><br><span class="line">	mov 	rsi,  O_RDWR|O_APPEND</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		appenderror</span><br><span class="line">	mov 	rdi, success_Append</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">appenderror:</span><br><span class="line">	mov 	rdi, error_Append </span><br><span class="line">	call 	printString</span><br><span class="line">	ret  </span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">global openFile</span><br><span class="line">openFile:</span><br><span class="line">	mov 	rax, NR_open </span><br><span class="line">	mov 	rsi, O_RDWR</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 	openerror</span><br><span class="line">	mov 	rdi, success_Open</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">openerror:</span><br><span class="line">	mov 	rdi, error_Open </span><br><span class="line">	call 	printString</span><br><span class="line">	ret  </span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">	global writeFile</span><br><span class="line">writeFile:</span><br><span class="line">	mov 	rax, NR_write</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		writeerror</span><br><span class="line">	mov 	rdi, success_Write</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">writeerror:</span><br><span class="line">	mov 	rdi, error_Write </span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">global positionFile</span><br><span class="line">positionFile:</span><br><span class="line">	mov 	rax, NR_lseek</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		positionerror</span><br><span class="line">	mov 	rdi, success_Position</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">positionerror:</span><br><span class="line">	mov 	rdi, error_Position </span><br><span class="line">	call 	printString</span><br><span class="line">	ret    </span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">	global closeFile</span><br><span class="line">closeFile:</span><br><span class="line">	mov 	rax, NR_close</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		closeerror</span><br><span class="line">	mov 	rdi, success_Close</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">closeerror:</span><br><span class="line">	mov 	rdi, error_Close </span><br><span class="line">	call 	printString</span><br><span class="line">	ret    </span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">	global createFile</span><br><span class="line">createFile:</span><br><span class="line">	mov 	rax, NR_create</span><br><span class="line">	mov 	rsi, S_IRUSR |S_IWUSR </span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 			; file descriptor in rax</span><br><span class="line">	jl 		createerror</span><br><span class="line">	mov 	rdi, success_Create</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">createerror:</span><br><span class="line">	mov 	rdi, error_Create </span><br><span class="line">	call 	printString</span><br><span class="line">	ret    </span><br><span class="line"></span><br><span class="line">	; PRINT FEEDBACK</span><br><span class="line">;-----------------------------------------------------------------</span><br><span class="line">global printString</span><br><span class="line">printString:</span><br><span class="line"></span><br><span class="line">; Count characters </span><br><span class="line">    mov 	r12, rdi</span><br><span class="line">    mov 	rdx, 0 </span><br><span class="line">strLoop:</span><br><span class="line">    cmp 	byte [r12], 0</span><br><span class="line">    je 		strDone</span><br><span class="line">    inc 	rdx                 ;length in rdx</span><br><span class="line">    inc 	r12</span><br><span class="line">    jmp 	strLoop</span><br><span class="line">strDone:</span><br><span class="line">    cmp 	rdx, 0              ; no string (0 length)</span><br><span class="line">    je 		prtDone</span><br><span class="line">    mov 	rsi,rdi</span><br><span class="line">    mov 	rax, 1 </span><br><span class="line">    mov 	rdi, 1</span><br><span class="line">    syscall</span><br><span class="line">prtDone:</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>注意一些寄存器调用约定</p>
<p>好比eax是返回值,那么的话,eax就不要被偷偷的修改掉</p>
<p>一个函数肯定会有返回值,只是你用不用返回值</p>
<p>当eax有用,你就push</p>
<p>当eax无用,你就随意了</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global printString</span><br><span class="line">;参数</span><br><span class="line">;rdi 字符串地址</span><br><span class="line">;功能</span><br><span class="line">;实现字节计数,放在rdx,然后syscall输出</span><br><span class="line">;</span><br><span class="line">printString:</span><br><span class="line"></span><br><span class="line">; Count characters </span><br><span class="line">    mov 	r12, rdi</span><br><span class="line">    mov 	rdx, 0 </span><br><span class="line">strLoop:</span><br><span class="line">    cmp 	byte [r12], 0</span><br><span class="line">    je 		strDone</span><br><span class="line">    inc 	rdx                 ;length in rdx</span><br><span class="line">    inc 	r12</span><br><span class="line">    jmp 	strLoop</span><br><span class="line">strDone:</span><br><span class="line">    cmp 	rdx, 0              ; no string (0 length)</span><br><span class="line">    je 		prtDone</span><br><span class="line">    mov 	rsi,rdi</span><br><span class="line">    mov 	rax, 1 </span><br><span class="line">    mov 	rdi, 1</span><br><span class="line">    syscall</span><br><span class="line">prtDone:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>



<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, fileName</span><br><span class="line">call 	createFile</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------</span><br><span class="line">global createFile</span><br><span class="line">;参数	    rdi:文件的名字</span><br><span class="line">;功能:	创建一个文件,成功就打印超过,失败就打印失败</span><br><span class="line">;返回值	rax</span><br><span class="line">;注意事项:	一些函数会默默地修改寄存器,我们得事先把它push一下</span><br><span class="line">createFile:</span><br><span class="line">   ;mov 	rdi, fileName</span><br><span class="line">    mov 	rsi, S_IRUSR | S_IWUSR  ;user read permission | user write permission</span><br><span class="line">    mov 	rax, NR_create	;85</span><br><span class="line">    syscall</span><br><span class="line">    cmp 	rax, 0 			</span><br><span class="line">    jl 		createerror</span><br><span class="line">    mov 	rdi, success_Create</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">    call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">    ret</span><br><span class="line">createerror:</span><br><span class="line">    mov 	rdi, error_Create </span><br><span class="line">    call 	printString</span><br><span class="line">    ret    </span><br><span class="line"></span><br><span class="line">; PRINT FEEDBACK</span><br><span class="line">;----------------------------------------------------------------</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	qword [FD], rax ; save descriptor</span><br></pre></td></tr></table></figure>



<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, text1</span><br><span class="line">mov 	rdx, qword [len1]</span><br><span class="line">call 	writeFile</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------</span><br><span class="line">;文件名 writeFile</span><br><span class="line">;参数</span><br><span class="line">;rdi 文件句柄</span><br><span class="line">;rsi 字符串地址</span><br><span class="line">;rdx 字符串长度</span><br><span class="line"></span><br><span class="line">;功能 把一个字符串写入文件</span><br><span class="line"></span><br><span class="line">;返回值 没用用到</span><br><span class="line">;注意事项 </span><br><span class="line">global writeFile</span><br><span class="line">writeFile:</span><br><span class="line"> 	;rdi 文件句柄</span><br><span class="line">    ;rsi 字符串地址</span><br><span class="line">    ;rdx 字符串长度</span><br><span class="line">    mov 	rax, NR_write	;1</span><br><span class="line">    syscall</span><br><span class="line">    cmp 	rax, 0 			;返回rax 写入失败就返回负数</span><br><span class="line">    jl 		writeerror</span><br><span class="line">    mov 	rdi, success_Write</span><br><span class="line">    call 	printString</span><br><span class="line">    ret</span><br><span class="line">    writeerror:</span><br><span class="line">    mov 	rdi, error_Write </span><br><span class="line">    call 	printString</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;函数名 关闭文件</span><br><span class="line">;参数 rdi, qword [FD],文件句柄</span><br><span class="line">;功能 关闭文件,失败就打印1失败,成功就打印成功</span><br><span class="line">;返回值: 未使用</span><br><span class="line">;注意事项:null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	global closeFile</span><br><span class="line">	closeFile:</span><br><span class="line">	mov 	rax, NR_close ;3</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		closeerror</span><br><span class="line">	mov 	rdi, success_Close</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">	closeerror:</span><br><span class="line">	mov 	rdi, error_Close </span><br><span class="line">	call 	printString</span><br><span class="line">	ret   </span><br></pre></td></tr></table></figure>



<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	openFile  </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;函数名 打开文件</span><br><span class="line">;参数   rdi, fileName </span><br><span class="line">;功能 打开文件</span><br><span class="line">;返回值 rax 文件句柄</span><br><span class="line">;注意事项 </span><br><span class="line">global openFile</span><br><span class="line">openFile:	</span><br><span class="line">	;rdi, fileName </span><br><span class="line">	mov 	rsi, O_RDWR	;访问模式</span><br><span class="line">	mov 	rax, NR_open ;系统调用符号</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		openerror</span><br><span class="line">	mov 	rdi, success_Open</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">	openerror:</span><br><span class="line">	mov 	rdi, error_Open </span><br><span class="line">	call 	printString</span><br><span class="line">	ret </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	qword [FD], rax ; save file descriptor</span><br></pre></td></tr></table></figure>

<h3 id="追加形式打开"><a href="#追加形式打开" class="headerlink" title="追加形式打开"></a>追加形式打开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	appendFile </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;;函数名 文件追加</span><br><span class="line">;参数 文件名rdi, fileName</span><br><span class="line">;功能</span><br><span class="line">;返回值 文件句柄</span><br><span class="line">;注意事项  文件指针的还原</span><br><span class="line">global appendFile</span><br><span class="line">appendFile:</span><br><span class="line">	;rdi, fileName</span><br><span class="line">	mov 	rsi,  O_RDWR|O_APPEND	;访问模式|追加状态标志</span><br><span class="line">	mov 	rax, NR_open 	        ;系统调用符号</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		appenderror</span><br><span class="line">	mov 	rdi, success_Append</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">appenderror:</span><br><span class="line">	mov 	rdi, error_Append </span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	qword [FD], rax ; save file descriptor</span><br></pre></td></tr></table></figure>





<h3 id="定位偏移量"><a href="#定位偏移量" class="headerlink" title="定位偏移量"></a>定位偏移量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; position file at offset</span><br><span class="line">mov 	rdi, qword[FD]</span><br><span class="line">mov 	rsi, qword[len2] ;offset at this location</span><br><span class="line">mov 	rdx, 0</span><br><span class="line">call 	positionFile </span><br></pre></td></tr></table></figure>



<p>它是怎么设置偏移量的???</p>
<p>为什么最后关闭文件的时候还是用了改变后的指针.?&#x2F;?&#x2F;?&#x2F;?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;函数名 定位文件偏移量</span><br><span class="line">;参数 </span><br><span class="line"></span><br><span class="line">;rdi, qword[FD] 文件句柄</span><br><span class="line">;rsi, qword[len2] ;偏移量</span><br><span class="line">;rdx, 0</span><br><span class="line"></span><br><span class="line">;功能 改变句柄?</span><br><span class="line">;注意事项 指针的还原</span><br><span class="line">;返回值</span><br><span class="line"></span><br><span class="line">global positionFile</span><br><span class="line">positionFile:</span><br><span class="line">	;rdi 文件句柄</span><br><span class="line">	;rsi 偏移量</span><br><span class="line">	;rdx 0</span><br><span class="line">	mov 	rax, NR_lseek</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		positionerror</span><br><span class="line">	mov 	rdi, success_Position</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">positionerror:</span><br><span class="line">	mov 	rdi, error_Position </span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>





<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, buffer</span><br><span class="line">mov 	rdx, bufferlen    </span><br><span class="line">call 	readFile</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;函数名 读取文件</span><br><span class="line">;参数   </span><br><span class="line">;rdi, qword [FD] 	文件指针</span><br><span class="line">;rsi, buffer		字符串缓冲区</span><br><span class="line">;rdx, bufferlen 	缓冲区长度;syscall读取长度</span><br><span class="line">;功能</span><br><span class="line">;返回值 字符串地址</span><br><span class="line"></span><br><span class="line">global readFile</span><br><span class="line">readFile:</span><br><span class="line">	;rdi, qword [FD]</span><br><span class="line">	;rsi, buffer</span><br><span class="line">	;rdx, bufferlen</span><br><span class="line">	mov 	rax, NR_read</span><br><span class="line">	syscall                         ; rax contains # of characters read</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	;返回值是一个文件字符串的长度</span><br><span class="line">	jl 		readerror</span><br><span class="line">	mov 	byte [rsi+rax],0	; add a terminating zero to the string</span><br><span class="line">	mov 	rax, rsi</span><br><span class="line"></span><br><span class="line">	mov 	rdi, success_Read</span><br><span class="line">	push	rax		; caller saved</span><br><span class="line">	call 	printString</span><br><span class="line">	pop		rax		; caller saved</span><br><span class="line">	ret</span><br><span class="line">readerror:</span><br><span class="line">	mov 	rdi, error_Read </span><br><span class="line">	call 	printString</span><br><span class="line">	ret </span><br></pre></td></tr></table></figure>



<p>返回字符串地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	rdi,rax</span><br><span class="line">call 	printString</span><br></pre></td></tr></table></figure>





<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;函数名 删除文件</span><br><span class="line">;参数 mov 	rdi, fileName</span><br><span class="line">global deleteFile</span><br><span class="line">deleteFile:</span><br><span class="line">	;mov 	rdi, fileName</span><br><span class="line">	mov 	rax, NR_unlink</span><br><span class="line">	syscall</span><br><span class="line">	cmp 	rax, 0 </span><br><span class="line">	jl 		deleteerror</span><br><span class="line">	mov 	rdi, success_Delete</span><br><span class="line">	call 	printString</span><br><span class="line">	ret</span><br><span class="line">deleteerror:</span><br><span class="line">	mov 	rdi, error_Delete </span><br><span class="line">	call 	printString</span><br><span class="line">	ret </span><br></pre></td></tr></table></figure>





<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="创建-x2F-写入-x2F-关闭"><a href="#创建-x2F-写入-x2F-关闭" class="headerlink" title="创建&#x2F;写入&#x2F;关闭"></a>创建&#x2F;写入&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF CREATE</span><br><span class="line">;创建打开,然后关闭</span><br><span class="line">mov 	rdi, fileName</span><br><span class="line">call 	createFile</span><br><span class="line">mov 	qword [FD], rax ; save descriptor</span><br><span class="line"></span><br><span class="line">; write to file #1</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, text1</span><br><span class="line">mov 	rdx, qword [len1]</span><br><span class="line">call 	writeFile</span><br><span class="line">   </span><br><span class="line">; close file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile</span><br><span class="line">%ENDIF</span><br></pre></td></tr></table></figure>









<h3 id="打开-x2F-覆盖-x2F-关闭"><a href="#打开-x2F-覆盖-x2F-关闭" class="headerlink" title="打开&#x2F;覆盖&#x2F;关闭"></a>打开&#x2F;覆盖&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF OVERWRITE</span><br><span class="line">;OPEN AND OVERWRITE A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">; open file </span><br><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	openFile  </span><br><span class="line">mov 	qword [FD], rax ; save file descriptor</span><br><span class="line"></span><br><span class="line">; write to file #2 OVERWRITE!</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, text2</span><br><span class="line">mov 	rdx, qword [len2]</span><br><span class="line">call 	writeFile    </span><br><span class="line"></span><br><span class="line">; close file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile    </span><br><span class="line">%ENDIF</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="追加-x2F-写入-x2F-关闭"><a href="#追加-x2F-写入-x2F-关闭" class="headerlink" title="追加&#x2F;写入&#x2F;关闭"></a>追加&#x2F;写入&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF APPEND</span><br><span class="line">;OPEN AND APPEND TO A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">; open file to append</span><br><span class="line">    mov 	rdi, fileName </span><br><span class="line">    call 	appendFile  </span><br><span class="line">    mov 	qword [FD], rax ; save file descriptor</span><br><span class="line">    </span><br><span class="line">; write to file #3 APPEND!</span><br><span class="line">    mov 	rdi, qword [FD]</span><br><span class="line">    mov 	rsi, text3</span><br><span class="line">    mov 	rdx, qword [len3]</span><br><span class="line">    call 	writeFile       </span><br><span class="line"></span><br><span class="line">; close file</span><br><span class="line">    mov 	rdi, qword [FD]</span><br><span class="line">    call 	closeFile </span><br><span class="line">%ENDIF</span><br></pre></td></tr></table></figure>









<h3 id="打开-x2F-定位偏移量-x2F-追加型覆盖写入-x2F-关闭"><a href="#打开-x2F-定位偏移量-x2F-追加型覆盖写入-x2F-关闭" class="headerlink" title="打开&#x2F;定位偏移量&#x2F;追加型覆盖写入&#x2F;关闭"></a>打开&#x2F;定位偏移量&#x2F;追加型覆盖写入&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF O_WRITE</span><br><span class="line">;OPEN AND OVERWRITE AT AN OFFSET IN A FILE, THEN CLOSE -----------------------</span><br><span class="line">; open file to write</span><br><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	openFile  </span><br><span class="line">mov 	qword [FD], rax ; save file descriptor</span><br><span class="line"></span><br><span class="line">; position file at offset</span><br><span class="line">mov 	rdi, qword[FD]</span><br><span class="line">mov 	rsi, qword[len2] ;offset at this location</span><br><span class="line">mov 	rdx, 0</span><br><span class="line">call 	positionFile    </span><br><span class="line"></span><br><span class="line">; write to file at offset</span><br><span class="line">mov 	rdi, qword[FD]</span><br><span class="line">mov 	rsi, text4</span><br><span class="line">mov 	rdx, qword [len4]</span><br><span class="line">call 	writeFile </span><br><span class="line"></span><br><span class="line">; close file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile </span><br><span class="line">%ENDIF</span><br></pre></td></tr></table></figure>













<h3 id="打开-x2F-读取-x2F-关闭"><a href="#打开-x2F-读取-x2F-关闭" class="headerlink" title="打开&#x2F;读取&#x2F;关闭"></a>打开&#x2F;读取&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF READ</span><br><span class="line">;OPEN AND READ FROM A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">; open file to read</span><br><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	openFile  </span><br><span class="line">mov 	qword [FD], rax ; save file descriptor  </span><br><span class="line"></span><br><span class="line">; read from file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, buffer</span><br><span class="line">mov 	rdx, bufferlen    </span><br><span class="line">call 	readFile</span><br><span class="line">mov 	rdi,rax</span><br><span class="line">call 	printString</span><br><span class="line"></span><br><span class="line">; close file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile </span><br><span class="line">%ENDIF</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="打开-x2F-定位偏移-x2F-读取-x2F-关闭"><a href="#打开-x2F-定位偏移-x2F-读取-x2F-关闭" class="headerlink" title="打开&#x2F;定位偏移&#x2F;读取&#x2F;关闭"></a>打开&#x2F;定位偏移&#x2F;读取&#x2F;关闭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF O_READ</span><br><span class="line">;OPEN AND READ AT AN OFFSET FROM A FILE, THEN CLOSE ---------------------------------------</span><br><span class="line">; open file to read</span><br><span class="line">mov 	rdi, fileName </span><br><span class="line">call 	openFile  </span><br><span class="line">mov 	qword [FD], rax ; save file descriptor  </span><br><span class="line"></span><br><span class="line">; position file at offset</span><br><span class="line">mov 	rdi, qword[FD]</span><br><span class="line">mov 	rsi, qword[len2]		;skip the first line</span><br><span class="line">mov 	rdx, 0</span><br><span class="line">call 	positionFile          </span><br><span class="line"></span><br><span class="line">; read from file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">mov 	rsi, buffer</span><br><span class="line">mov 	rdx, 10    ;number of characters to read</span><br><span class="line">call 	readFile</span><br><span class="line">mov 	rdi,rax</span><br><span class="line">call 	printString</span><br><span class="line"></span><br><span class="line">; close file</span><br><span class="line">mov 	rdi, qword [FD]</span><br><span class="line">call 	closeFile </span><br><span class="line">%ENDIF</span><br></pre></td></tr></table></figure>



<h3 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%IF DELETE</span><br><span class="line">;DELETE A FILE --------------------------------------------------   </span><br><span class="line">; delete file   UNCOMMENT NEXT LINES TO USE</span><br><span class="line">mov 	rdi, fileName</span><br><span class="line">call 	deleteFile                                      </span><br><span class="line">%ENDIF</span><br></pre></td></tr></table></figure>







<h1 id="汇编调用C库函数"><a href="#汇编调用C库函数" class="headerlink" title="汇编调用C库函数"></a>汇编调用C库函数</h1><p>调用C库函数会默认修改一些寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004012F1 push    rsi</span><br><span class="line">.text:00000000004012F2 push    rdx</span><br><span class="line">.text:00000000004012F3 push    rcx</span><br><span class="line">.text:00000000004012F4 push    rbp</span><br><span class="line">.text:00000000004012F5 call    _printf</span><br><span class="line">.text:00000000004012FA pop     rbp</span><br><span class="line">.text:00000000004012FB pop     rcx</span><br><span class="line">.text:00000000004012FC pop     rdx</span><br><span class="line">.text:00000000004012FD pop     rsi</span><br></pre></td></tr></table></figure>



<p>所以的话,见到这些代码也不要惊讶…</p>
<p>这些push不是传递参数</p>
<p>并且printf的参数rdi也没有被传递进去</p>
<p>这些push只不过是默默地保存一下参数</p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>首先在头文件引入库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">includelib		msvcrt.lib</span><br></pre></td></tr></table></figure>



<p>一个应用的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line"></span><br><span class="line">;对要用的函数做一些声明</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	n_input		byte &quot;%d %d&quot;,0</span><br><span class="line">	n_output	byte &quot;%d+%d=%d&quot;,10,0</span><br><span class="line">	s_output	BYTE &quot;%s&quot;,10,0</span><br><span class="line"></span><br><span class="line">	str1		byte &quot;welcome to my world&quot;,10</span><br><span class="line">			    byte &quot;please input 2 NUm&quot;,0</span><br><span class="line"></span><br><span class="line">	a		dd	0</span><br><span class="line">	b		dd	0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	invoke	printf,addr s_output,addr str1</span><br><span class="line">	invoke	scanf,addr n_input,addr a,addr b</span><br><span class="line">	mov	eax,0</span><br><span class="line">	add	eax,a</span><br><span class="line">	add	eax,b</span><br><span class="line">	invoke	printf,addr n_output,a,b,eax</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<p>1.对于参数的传递,他得是32位的数据长度</p>
<p>好比一个void fun(char ascii),函数的汇编会有一个强制类型的转化,把你传入的一个字节变为32位的长度</p>
<p>2.参数传递的顺序,参数会从右到左依次push或者mov [esp+4],,,,,</p>
<h2 id="x64-1"><a href="#x64-1" class="headerlink" title="x64"></a>x64</h2><p>仍然需要在外部声明</p>
<h3 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h3><h4 id="调用printf"><a href="#调用printf" class="headerlink" title="调用printf"></a>调用printf</h4><p>rax为0,表示0个非浮点数</p>
<p>rdi 格式化字符串的地址,第一个参数</p>
<p>rdx放第二个参数</p>
<p>rsi 数值&#x2F;字符串地址, 数值好比[var],字符串地址就用数组的名字</p>
<p>遇到浮点数</p>
<p>rax&#x3D;3,表示你传入3个浮点数参数,</p>
<p>于是函数依次把xmm0,xmm1,xmm2,作为参数</p>
<p>movq传入当精度浮点数,</p>
<p>movsd传入当精度浮点数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	rax,1</span><br><span class="line">movq xmm0,[f_Num]</span><br><span class="line">mov rdi,fmat</span><br><span class="line">call printf</span><br></pre></td></tr></table></figure>



<p>问题来了,它怎么知道我有几个参数????<br>我传入rdi,一个字符串的地址,可是它会不会读取其它的寄存器呢???</p>
<p>rdi,第一个参数,xmm0第二个参数????</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; hello2.asm </span><br><span class="line">	</span><br><span class="line">section .data</span><br><span class="line">	str1	db      &quot;welcome to my world&quot;,10,0		;中断调用没有换行,这里手动添加一个</span><br><span class="line">	len1	equ		$-str1-1</span><br><span class="line">	str2	db		&quot;I am Dqx_Ghost&quot;,0</span><br><span class="line">	len2	equ		$-str2-1</span><br><span class="line">	</span><br><span class="line">	num		dq		2001</span><br><span class="line">	pi		dq		3.14</span><br><span class="line">	</span><br><span class="line">	fmt_int 	db		&quot;%d&quot;,10,0</span><br><span class="line">	fmt_double	db		&quot;%lf&quot;,10,0</span><br><span class="line">	fmt_str		db		&quot;%s&quot;,10,0</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line">section .text</span><br><span class="line">extern		printf	</span><br><span class="line">	global main</span><br><span class="line">main:</span><br><span class="line"></span><br><span class="line">	push	rbp</span><br><span class="line">	mov		rbp,rsp</span><br><span class="line">	</span><br><span class="line">	mov		rax,1</span><br><span class="line">	mov		rdi,1</span><br><span class="line">	mov 	rsi,str1</span><br><span class="line">	mov 	rdx,len1</span><br><span class="line">	syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mov		rax,0</span><br><span class="line">	mov 	rsi,str2</span><br><span class="line">	mov 	rdi,fmt_str</span><br><span class="line">	call	printf</span><br><span class="line">	</span><br><span class="line">	mov 	rax,0</span><br><span class="line">	mov 	rsi,[num]</span><br><span class="line">	mov 	rdi,fmt_int</span><br><span class="line">	call	printf</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	mov		rax,1</span><br><span class="line">	movq	xmm0,[pi]</span><br><span class="line">	mov 	rdi,fmt_double</span><br><span class="line">	call	printf</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	mov 	rsp,rbp</span><br><span class="line">	pop		rbp</span><br><span class="line"></span><br><span class="line">	mov     rax, 60		; 60 = exit</span><br><span class="line">	mov     rdi, 0		; 0 = success exit code</span><br><span class="line">	syscall				; quit</span><br></pre></td></tr></table></figure>

<h3 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h3><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><p>rcx是第一个参数</p>
<h3 id="堆栈对齐"><a href="#堆栈对齐" class="headerlink" title="堆栈对齐"></a>堆栈对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004012F1 push    rsi</span><br><span class="line">.text:00000000004012F2 push    rdx</span><br><span class="line">.text:00000000004012F3 push    rcx</span><br><span class="line">.text:00000000004012F4 push    rbp</span><br><span class="line">.text:00000000004012F5 call    _printf</span><br><span class="line">.text:00000000004012FA pop     rbp</span><br><span class="line">.text:00000000004012FB pop     rcx</span><br><span class="line">.text:00000000004012FC pop     rdx</span><br><span class="line">.text:00000000004012FD pop     rsi</span><br></pre></td></tr></table></figure>

<p>其实他没有必要push那么多的东西</p>
<p>但是一定要堆栈对齐</p>
<p>于是他就push了一些没有的东西用于了堆栈对齐</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="8086-课程设计"><a href="#8086-课程设计" class="headerlink" title="8086 课程设计"></a>8086 课程设计</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">data segment</span><br><span class="line">;年份</span><br><span class="line">                    db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;</span><br><span class="line">                    db &#x27;1982&#x27;,&#x27;1983&#x27;,&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;</span><br><span class="line">                    db &#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;,&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line">    </span><br><span class="line">;收入</span><br><span class="line">                    dd  16,22,382,1356,2398,8000,16000</span><br><span class="line">                    dd  24486,50065,97479,140417,197514,345980,590827</span><br><span class="line">                    dd  803528,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line">    </span><br><span class="line">;员工数量</span><br><span class="line">                    dw  3,7,9,13,28,38,130</span><br><span class="line">                    dw  220,476,778,1001,1442,2258,2793</span><br><span class="line">                    dw  4037,5635,8226,11542,14438,15257,17800</span><br><span class="line">data ends  </span><br><span class="line"></span><br><span class="line">                    table segment</span><br><span class="line">                        db 21 dup (&#x27;0123456789ABCDEF&#x27;)</span><br><span class="line">                    table ends</span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">                         db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">string segment</span><br><span class="line">                        db 10 dup(&#x27;0&#x27;)</span><br><span class="line">string ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;main code  </span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax       </span><br><span class="line">;数据地D</span><br><span class="line">                        mov ax,7e00h</span><br><span class="line">                        mov es,ax        </span><br><span class="line">;栈</span><br><span class="line">                        mov ax,stack</span><br><span class="line">                        mov ss,ax</span><br><span class="line">                        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">                        call input_table</span><br><span class="line">                        call clear_screen</span><br><span class="line">                        call output_table</span><br><span class="line"></span><br><span class="line">over:    </span><br><span class="line">                        mov ax,4c00h</span><br><span class="line">                        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">input_table:</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax</span><br><span class="line"></span><br><span class="line">                        mov ax,table</span><br><span class="line">                        mov es,ax</span><br><span class="line"></span><br><span class="line">                        mov si,0</span><br><span class="line">                        mov di,21*4*2</span><br><span class="line">                        mov bx,0</span><br><span class="line">                        mov cx,21</span><br><span class="line"></span><br><span class="line">inputtable:</span><br><span class="line">                        ;year </span><br><span class="line">                        ;这个push与pop非常的妙,把4个字节,巧妙的传送</span><br><span class="line">                        push ds:[si]</span><br><span class="line">                        pop  es:[bx]</span><br><span class="line">                        push ds:[si+2]</span><br><span class="line">                        pop  es:[bx+2]</span><br><span class="line"></span><br><span class="line">                        ;x</span><br><span class="line">                        mov ax,ds:[si+21*4+0]</span><br><span class="line">                        mov dx,ds:[si+21*4+2]</span><br><span class="line">                        mov es:[bx+5],ax</span><br><span class="line">                        mov es:[bx+7],dx</span><br><span class="line">                        ;y</span><br><span class="line">                        push ds:[di]</span><br><span class="line">                        pop  es:[bx+10]</span><br><span class="line">                        ;z</span><br><span class="line">                        div word ptr es:[bx+10]</span><br><span class="line"></span><br><span class="line">                        mov es:[bx+13],ax</span><br><span class="line"></span><br><span class="line">                        add si,4</span><br><span class="line">                        add di,2</span><br><span class="line">                        add bx,16</span><br><span class="line">                        loop inputtable</span><br><span class="line">                        </span><br><span class="line">                        ret</span><br><span class="line">clear_screen:</span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line">                        mov bx,0</span><br><span class="line">                        mov dx,0700h</span><br><span class="line">                        mov cx,2000</span><br><span class="line">clearscreen:</span><br><span class="line">                        mov es:[bx],dx</span><br><span class="line">                        add bx,2</span><br><span class="line">                        loop clearscreen</span><br><span class="line">                    </span><br><span class="line">                        ret                        </span><br><span class="line">output_table:</span><br><span class="line">                        mov ax,table</span><br><span class="line">                        mov ds,ax</span><br><span class="line"></span><br><span class="line">                        mov ax,string </span><br><span class="line">                        mov es,ax</span><br><span class="line"></span><br><span class="line">                        mov si,0</span><br><span class="line">                        mov cx,21</span><br><span class="line">                        mov di,160*3</span><br><span class="line">                        mov bx,9</span><br><span class="line">                        ;[9]是10个当中最后一个位置</span><br><span class="line">outputtable:</span><br><span class="line">                        call show_year</span><br><span class="line">                        call show_x</span><br><span class="line">                        call show_y</span><br><span class="line">                        call show_z</span><br><span class="line"></span><br><span class="line">                        add di,160</span><br><span class="line">                        add si,16</span><br><span class="line">                        loop outputtable</span><br><span class="line"></span><br><span class="line">                        ret</span><br><span class="line">show_year:</span><br><span class="line">                        push ax</span><br><span class="line">                        push bx</span><br><span class="line">                        push cx</span><br><span class="line">                        push dx</span><br><span class="line">                        push ds</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line"></span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line"></span><br><span class="line">                        add di,3*2</span><br><span class="line">                        mov cx,4</span><br><span class="line">showyear:                        </span><br><span class="line">                        mov ah,2</span><br><span class="line">                        mov al,ds:[si]</span><br><span class="line">                        mov es:[di],ax</span><br><span class="line">                        inc si</span><br><span class="line">                        add di,2</span><br><span class="line">                        loop showyear</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop dx</span><br><span class="line">                        pop cx</span><br><span class="line">                        pop bx</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret                                   </span><br><span class="line">show_x:</span><br><span class="line">                        push ax</span><br><span class="line">                        push bx</span><br><span class="line">                        push cx</span><br><span class="line">                        push dx</span><br><span class="line">                        push ds</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line">                        </span><br><span class="line">                        mov ax,ds:[si+5]</span><br><span class="line">                        mov dx,ds:[si+7]</span><br><span class="line"></span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call init_reg</span><br><span class="line">                        add di,10*2</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop dx</span><br><span class="line">                        pop cx</span><br><span class="line">                        pop bx</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret</span><br><span class="line">show_y:</span><br><span class="line">                        push ax</span><br><span class="line">                        push bx</span><br><span class="line">                        push cx</span><br><span class="line">                        push dx</span><br><span class="line">                        push ds</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line">                        </span><br><span class="line">                        mov ax,ds:[si+10]</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call init_reg</span><br><span class="line">                        add di,2*20</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop dx</span><br><span class="line">                        pop cx</span><br><span class="line">                        pop bx</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret</span><br><span class="line">show_z:</span><br><span class="line">                        push ax</span><br><span class="line">                        push bx</span><br><span class="line">                        push cx</span><br><span class="line">                        push dx</span><br><span class="line">                        push ds</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line">                        </span><br><span class="line">                        mov ax,ds:[si+13]</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call init_reg</span><br><span class="line">                        add di,2*40</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop dx</span><br><span class="line">                        pop cx</span><br><span class="line">                        pop bx</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret</span><br><span class="line"></span><br><span class="line">is_short_div:</span><br><span class="line">                        mov cx,dx</span><br><span class="line">                        jcxz short_div</span><br><span class="line">                        call long_div</span><br><span class="line">                        jmp is_short_div</span><br><span class="line">div_ret:                       </span><br><span class="line">                        ret</span><br><span class="line">short_div:</span><br><span class="line">                        mov cx,10</span><br><span class="line">                        div cx</span><br><span class="line">                        add dx,30h</span><br><span class="line">                        mov es:[bx],dl</span><br><span class="line">                        mov cx,ax</span><br><span class="line">                        jcxz div_ret</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        dec bx</span><br><span class="line">                        jmp short_div                      </span><br><span class="line">long_div:</span><br><span class="line">                        mov cx,10</span><br><span class="line">                        push ax</span><br><span class="line">                        mov bp,sp</span><br><span class="line">                        mov ax,dx</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        div cx</span><br><span class="line">                        push ax</span><br><span class="line">                        mov ax,ss:[bp]</span><br><span class="line">                        div cx</span><br><span class="line">                        mov cx,dx</span><br><span class="line">                        add cx,30h</span><br><span class="line">                        mov es:[bx],cl</span><br><span class="line">                        dec bx</span><br><span class="line">                        pop dx</span><br><span class="line">                        add sp,2</span><br><span class="line"></span><br><span class="line">                        ret</span><br><span class="line">init_reg:</span><br><span class="line">                        push ax</span><br><span class="line">                        mov ax,string</span><br><span class="line">                        mov ds,ax</span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret</span><br><span class="line">show_string:</span><br><span class="line">                        push ax</span><br><span class="line">                        push bx</span><br><span class="line">                        push cx</span><br><span class="line">                        push dx</span><br><span class="line">                        push ds</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line">showstring:</span><br><span class="line">                        mov cx,0</span><br><span class="line">                        mov cl,ds:[bx]</span><br><span class="line">                        jcxz show_ret</span><br><span class="line">                        mov ch,2</span><br><span class="line">                        mov es:[di],cx</span><br><span class="line">                        add di,2</span><br><span class="line">                        inc bx</span><br><span class="line">                        jmp showstring</span><br><span class="line">show_ret:</span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop dx</span><br><span class="line">                        pop cx</span><br><span class="line">                        pop bx</span><br><span class="line">                        pop ax</span><br><span class="line">                        ret</span><br><span class="line"></span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>



<p>又写了一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">data segment</span><br><span class="line">;年份</span><br><span class="line">                    db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;</span><br><span class="line">                    db &#x27;1982&#x27;,&#x27;1983&#x27;,&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;</span><br><span class="line">                    db &#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;,&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line">    </span><br><span class="line">;收入</span><br><span class="line">                    dd  16,22,382,1356,2398,8000,16000</span><br><span class="line">                    dd  24486,50065,97479,140417,197514,345980,590827</span><br><span class="line">                    dd  803528,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line">    </span><br><span class="line">;员工数量</span><br><span class="line">                    dw  3,7,9,13,28,38,130</span><br><span class="line">                    dw  220,476,778,1001,1442,2258,2793</span><br><span class="line">                    dw  4037,5635,8226,11542,14438,15257,17800</span><br><span class="line">data ends  </span><br><span class="line"></span><br><span class="line">                    table segment</span><br><span class="line">                        db 21 dup (&#x27;0123456789ABCDEF&#x27;)</span><br><span class="line">                    table ends</span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">                         db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">string segment</span><br><span class="line">                         db 16 dup(0)</span><br><span class="line">string ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;main code  </span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax       </span><br><span class="line">;数据地D</span><br><span class="line">                        mov ax,7e00h</span><br><span class="line">                        mov es,ax        </span><br><span class="line">;栈</span><br><span class="line">                        mov ax,stack</span><br><span class="line">                        mov ss,ax</span><br><span class="line">                        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line"></span><br><span class="line">                        call clean_screen</span><br><span class="line">                        call init_table</span><br><span class="line">                        call work      </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">                        mov ax,4c00h</span><br><span class="line">                        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">clean_screen:</span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line">                        mov bx,0</span><br><span class="line">                        mov cx,2000</span><br><span class="line">                        mov dx,0700h                        </span><br><span class="line">clean:</span><br><span class="line">                        mov es:[bx],dx</span><br><span class="line">                        add bx,2</span><br><span class="line">                        loop clean</span><br><span class="line">                        </span><br><span class="line">                        ret                        </span><br><span class="line">init_table:</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax</span><br><span class="line">                        mov ax,table</span><br><span class="line">                        mov es,ax</span><br><span class="line"></span><br><span class="line">                        mov cx,21</span><br><span class="line">                        mov si,0</span><br><span class="line">                        mov di,21*4*2</span><br><span class="line">                        mov bx,0</span><br><span class="line">init_small:             </span><br><span class="line">                        ;0123456789ABCDEF</span><br><span class="line">                        push ds:[si+0]</span><br><span class="line">                        pop  es:[bx]</span><br><span class="line">                        push ds:[si+2]</span><br><span class="line">                        pop  es:[bx+2]</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line"></span><br><span class="line">                        push ds:[si+21*4+0]</span><br><span class="line">                        pop  es:[bx+5]</span><br><span class="line">                        push ds:[si+21*4+2]</span><br><span class="line">                        pop  es:[bx+7]</span><br><span class="line"></span><br><span class="line">                        push ds:[di]</span><br><span class="line">                        pop  es:[bx+10]</span><br><span class="line"></span><br><span class="line">                        mov ax,es:[bx+5]</span><br><span class="line">                        mov dx,es:[bx+7]</span><br><span class="line">                        div word ptr es:[bx+10]</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                        mov es:[bx+13],ax</span><br><span class="line"></span><br><span class="line">                        mov al,58        ;:</span><br><span class="line">                        mov es:[bx+4],al</span><br><span class="line">                        mov al,47        ;/</span><br><span class="line">                        mov es:[bx+9],al</span><br><span class="line">                        mov al,61        ;=</span><br><span class="line">                        mov es:[bx+12],al</span><br><span class="line"></span><br><span class="line">                        add bx,16</span><br><span class="line">                        add si,4</span><br><span class="line">                        add di,2</span><br><span class="line">                        loop init_small</span><br><span class="line"> </span><br><span class="line">                        ret          </span><br><span class="line">work:</span><br><span class="line">                        mov ax,table</span><br><span class="line">                        mov ds,ax</span><br><span class="line">                        mov ax,string</span><br><span class="line">                        mov es,ax</span><br><span class="line"></span><br><span class="line">                        mov cx,21</span><br><span class="line">                        mov bx,0</span><br><span class="line">                        mov si,0</span><br><span class="line">                        mov di,160*3</span><br><span class="line"></span><br><span class="line">work_small:</span><br><span class="line">                        call show_year</span><br><span class="line">                        call show_x</span><br><span class="line">                        call show_y</span><br><span class="line">                        call show_z</span><br><span class="line"></span><br><span class="line">                        add  di,160</span><br><span class="line">                        add  si,16</span><br><span class="line">                        loop work_small</span><br><span class="line">                        ret</span><br><span class="line">show_year:</span><br><span class="line">                        push si</span><br><span class="line">                        push es</span><br><span class="line">                        push di</span><br><span class="line">                        push cx</span><br><span class="line">                        add di,10</span><br><span class="line"></span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line">                        mov cx,4</span><br><span class="line">year_small:</span><br><span class="line">                        mov al,ds:[si]</span><br><span class="line">                        mov es:[di],al</span><br><span class="line">                        inc si</span><br><span class="line">                        add di,2</span><br><span class="line">                        loop year_small</span><br><span class="line">                        </span><br><span class="line">                        mov al,ds:[4]</span><br><span class="line">                        mov es:[di],al</span><br><span class="line"></span><br><span class="line">                        mov al,ds:[9]</span><br><span class="line">                        mov es:[di+30],al</span><br><span class="line"></span><br><span class="line">                        mov al,ds:[12]</span><br><span class="line">                        mov es:[di+50],al</span><br><span class="line"></span><br><span class="line">                        pop cx</span><br><span class="line">                        pop di</span><br><span class="line">                        pop es</span><br><span class="line">                        pop si</span><br><span class="line">                        ret</span><br><span class="line"></span><br><span class="line">                        ;0123456789ABCDEF</span><br><span class="line">show_x:</span><br><span class="line">                        push cx</span><br><span class="line">                        push di</span><br><span class="line">                        add di,40</span><br><span class="line">                        mov ax,ds:[si+5]</span><br><span class="line">                        mov dx,ds:[si+7]</span><br><span class="line">                        mov bx,15</span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop cx</span><br><span class="line">                        ret</span><br><span class="line"></span><br><span class="line">show_y:</span><br><span class="line">                        push cx</span><br><span class="line">                        push di</span><br><span class="line">                        add di,60</span><br><span class="line">                        mov ax,ds:[si+10]</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        mov bx,15</span><br><span class="line"></span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop cx</span><br><span class="line">                        ret</span><br><span class="line">show_z:</span><br><span class="line">                        push cx</span><br><span class="line">                        push di</span><br><span class="line">                        add di,80</span><br><span class="line">                        mov ax,ds:[si+13]</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        mov bx,15</span><br><span class="line">                        call is_short_div</span><br><span class="line">                        call show_string</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop cx</span><br><span class="line">                        ret                                                  </span><br><span class="line">is_short_div:           </span><br><span class="line">                        mov cx,dx</span><br><span class="line">                        jcxz short_div</span><br><span class="line">                        call long_div</span><br><span class="line">                        jmp is_short_div                       </span><br><span class="line">div_ret:                        </span><br><span class="line">                        ret</span><br><span class="line">short_div:</span><br><span class="line">                        mov cx,10</span><br><span class="line">                        div cx</span><br><span class="line">                        add dl,30h</span><br><span class="line">                        mov es:[bx],dl</span><br><span class="line">                        mov dl,0</span><br><span class="line">                        mov es:[bx-1],dl</span><br><span class="line">                        dec bx</span><br><span class="line">                        mov cx,ax</span><br><span class="line">                        jcxz div_ret</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        jmp short_div</span><br><span class="line">long_div:</span><br><span class="line">                        push ax</span><br><span class="line">                        mov bp,sp</span><br><span class="line">                        mov ax,dx</span><br><span class="line">                        mov dx,0</span><br><span class="line">                        mov cx,10</span><br><span class="line">                        div cx</span><br><span class="line">                        push ax</span><br><span class="line">                        mov ax,ss:[bp]</span><br><span class="line">                        div cx</span><br><span class="line">                        add dx,30h</span><br><span class="line">                        mov es:[bx],dl</span><br><span class="line">                        mov dl,0</span><br><span class="line">                        mov es:[bx-1],dl</span><br><span class="line">                        dec bx</span><br><span class="line"></span><br><span class="line">                        pop dx</span><br><span class="line">                        add sp,2</span><br><span class="line">                        ret                                                </span><br><span class="line"></span><br><span class="line">show_string:</span><br><span class="line">                        push es</span><br><span class="line">                        push ds</span><br><span class="line">                        push di</span><br><span class="line"></span><br><span class="line">                        mov bx,15</span><br><span class="line"></span><br><span class="line">                        mov ax,string</span><br><span class="line">                        mov ds,ax</span><br><span class="line">                        mov ax,0b800h</span><br><span class="line">                        mov es,ax</span><br><span class="line">show_str:</span><br><span class="line">                        mov ah,2</span><br><span class="line">                        mov al,ds:[bx]</span><br><span class="line">                        mov es:[di],ax</span><br><span class="line"></span><br><span class="line">                        sub di,2</span><br><span class="line">                        dec bx</span><br><span class="line"></span><br><span class="line">                        mov cx,0</span><br><span class="line">                        mov cl,ds:[bx]</span><br><span class="line">                        jcxz show_ret</span><br><span class="line">                        jmp show_str</span><br><span class="line">show_ret:                       </span><br><span class="line">                        pop di</span><br><span class="line">                        pop ds</span><br><span class="line">                        pop es</span><br><span class="line">                        ret                       </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>出现的问题</p>
<ol>
<li>push的保存没注意先后顺序,也就是临时保存无效</li>
<li>对结构的化编程不是很清晰,老是走一步看一步</li>
<li>一个小小的寄存器错误,就导致中断,程序崩溃</li>
<li>如果数据溢出是会中断的,而不是报错</li>
</ol>
<h2 id="8086-课后实验"><a href="#8086-课后实验" class="headerlink" title="8086 课后实验"></a>8086 课后实验</h2><h3 id="模拟jcxz"><a href="#模拟jcxz" class="headerlink" title="模拟jcxz"></a>模拟jcxz</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">data segment</span><br><span class="line">    db 256 dup(&#x27;A&#x27;)    </span><br><span class="line">data ends  </span><br><span class="line">;=======================================================</span><br><span class="line">stack segment stack</span><br><span class="line">    db 128 dup(&#x27;w&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line"> start:  </span><br><span class="line"> ;=======================================================</span><br><span class="line">            ;栈</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            </span><br><span class="line">            ;数据段</span><br><span class="line">            mov ax,2000h</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0</span><br><span class="line">            </span><br><span class="line"> ;=======================================================       </span><br><span class="line">            </span><br><span class="line">             mov cx,10</span><br><span class="line">             mov al,1</span><br><span class="line">init:       mov byte ptr ds:[bx], al</span><br><span class="line">             inc bx</span><br><span class="line">             inc al</span><br><span class="line">             loop init</span><br><span class="line">             </span><br><span class="line">             mov bx,0</span><br><span class="line">fun:       mov cl,byte ptr ds:[bx]</span><br><span class="line">             jcxz over</span><br><span class="line">             inc bx</span><br><span class="line">             jmp fun</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">;=======================================================  </span><br><span class="line">over:    mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">;=======================================================</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>还是要注意数据的初始化</p>
<p>另外要注意循环是哪里开始的,不要乱循环</p>
<h3 id="关于loop与cx去检索数据段中0的位置"><a href="#关于loop与cx去检索数据段中0的位置" class="headerlink" title="关于loop与cx去检索数据段中0的位置"></a>关于loop与cx去检索数据段中0的位置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:</span><br><span class="line">mov cl,ds:[bx]</span><br><span class="line">mov ch,0</span><br><span class="line">inc cx</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line">ok:</span><br><span class="line">dec bx</span><br><span class="line">mov dx,bx</span><br></pre></td></tr></table></figure>

<p>它的检索,是靠bx++的来依次检索</p>
<p>但是又靠cx!&#x3D;0来推动检索</p>
<p>所以才达到避免cx单一化,又推动了片段的检索</p>
<p>代码要求是得到位置</p>
<p>因此最后会有一个</p>
<p>dec bx</p>
<p>mov dx,bx</p>
<h3 id="一个经典的指令复制实验-jmp指令的本质"><a href="#一个经典的指令复制实验-jmp指令的本质" class="headerlink" title="一个经典的指令复制实验-jmp指令的本质"></a>一个经典的指令复制实验-jmp指令的本质</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code </span><br><span class="line">;=======================================================</span><br><span class="line"> </span><br><span class="line"> ;=======================================================</span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line"> </span><br><span class="line"> ;=======================================================</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">start: </span><br><span class="line">        mov ax,0</span><br><span class="line">s:</span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        </span><br><span class="line">        mov di,offset s</span><br><span class="line">        mov si,offset s2</span><br><span class="line">        mov ax,cs:[si]</span><br><span class="line">        mov cs:[di],ax</span><br><span class="line">        </span><br><span class="line">s0:</span><br><span class="line">        jmp short s</span><br><span class="line">        </span><br><span class="line">no_use:</span><br><span class="line">        mov ax,0</span><br><span class="line">        int 21h</span><br><span class="line">        mov ax,0</span><br><span class="line">        </span><br><span class="line">        s2:</span><br><span class="line">        jmp short no_use</span><br><span class="line">        nop</span><br><span class="line">        </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">        </span><br><span class="line">;=======================================================       </span><br><span class="line"> ;main code</span><br><span class="line"> </span><br><span class="line">;=======================================================  </span><br><span class="line">;fun area            </span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">;=======================================================  </span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>假如我们有指令</p>
<p>jmp s1</p>
<p>在复制jmp s1的时候</p>
<p>它不是复制jmp s1</p>
<p>而是复制他的汇编指令</p>
<p>加入它的指令是EBF6</p>
<p>F6-然后1111 0110然后取反0000 1001然后+1为然后0000 1010然后10进制为10</p>
<p>说明它以前往后面跳了10个位移</p>
<p>debug那个代码</p>
<p>以前的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp short no_use</span><br></pre></td></tr></table></figure>

<p>它的汇编就是EBF6,于是就复制了EBF6</p>
<p><img src="https://s2.loli.net/2022/02/26/J6SBkol3NjqODnb.png" alt="image-20220204172011883"></p>
<p>可以看到,以前的nop,nop</p>
<p>变为了EBF6</p>
<p>那么的话</p>
<p>因为我们复制的是EBF6</p>
<p>不是复制jmp short ptr no_use</p>
<p>所以的话</p>
<p>出现jmp 0000也不要诧异</p>
<p>为什么是0000</p>
<p>因为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">076A:0008    EBF6 jmp 0000</span><br><span class="line">076A:000A    BF0800	 mov di,0008 </span><br></pre></td></tr></table></figure>

<p>于是从000A处往上面从0开始数到10</p>
<p>就可以得到地址 0000</p>
<p>同时我们事先就安排好了,0000处是程序的结束位置</p>
<h3 id="在屏幕中央显示带颜色的字符串‘welcome-to-masm’"><a href="#在屏幕中央显示带颜色的字符串‘welcome-to-masm’" class="headerlink" title="在屏幕中央显示带颜色的字符串‘welcome to masm’"></a>在屏幕中央显示带颜色的字符串‘welcome to masm’</h3><p>DOS窗口的</p>
<p>一行有160个字节</p>
<p>一共有25行</p>
<p>一页有4000个字节</p>
<p>一共有8页</p>
<p>偶数地址存放ASCII字符</p>
<p>基数地址存放字符的颜色</p>
<p><img src="https://s2.loli.net/2022/02/26/4oS3IPbOpQ5uKT9.png" alt="image-20220204192938719"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">data segment</span><br><span class="line"></span><br><span class="line">        db  &#x27;welcome to masm!&#x27;</span><br><span class="line">        db  00000010b</span><br><span class="line">        db  00100100b</span><br><span class="line">        db  01110001b</span><br><span class="line">        </span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">stack segment stack</span><br><span class="line">        db 128 dup(&#x27;m&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line"> ;=======================================================</span><br><span class="line">        ;栈</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">        ;数据源</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov bx,16</span><br><span class="line">        </span><br><span class="line">        ;数据目的地</span><br><span class="line">        mov ax,0B800h;显存的地址0xB800</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,160*12+30*2;第[12]行第[60]字节处</span><br><span class="line">;=======================================================       </span><br><span class="line"> ;main code</span><br><span class="line">        </span><br><span class="line">        jmp show</span><br><span class="line">    </span><br><span class="line">over:    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">;=======================================================  </span><br><span class="line">;fun area            </span><br><span class="line">show:</span><br><span class="line">        mov cx,3;大循环3次</span><br><span class="line">        </span><br><span class="line">point:       </span><br><span class="line">        push cx</span><br><span class="line">        push di</span><br><span class="line">        mov cx,16;初始化小循环16次</span><br><span class="line">        mov si,0</span><br><span class="line">        mov dh,ds:[bx]</span><br><span class="line">        ;规律是高位修改color颜色,低位修改ASCII字符,dh是奇数位,al是偶数位,连续地址 [00] [01] 中,在dx的排布是[01] [00]</span><br><span class="line">show_str:</span><br><span class="line">        ;把ASCII与颜色依次打入显存</span><br><span class="line">        mov dl,ds:[si]</span><br><span class="line">        mov es:[di],dx</span><br><span class="line">        ;检索下一个字符</span><br><span class="line">        add di,2;传输是字符与颜色的共同传输</span><br><span class="line">        inc si;字符的检索</span><br><span class="line">        loop show_str</span><br><span class="line">                </span><br><span class="line">        pop di;还原di</span><br><span class="line">        pop cx;还原大循环cx的次数</span><br><span class="line">        add di,160;把下行打入显存</span><br><span class="line">        inc bx;配置下一个颜色</span><br><span class="line">        loop point;再一次循环</span><br><span class="line"></span><br><span class="line">        jmp over           </span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>我自己再写一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">        db  &#x27;welcome to masm!&#x27;</span><br><span class="line">        db  00000010b</span><br><span class="line">        db  00100100b</span><br><span class="line">        db  01110001b</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">        ;数据源S</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0        ;si=0;si&lt;16;si++</span><br><span class="line">        mov bx,16     ;bx=0;bx&lt;3;bx++</span><br><span class="line">        </span><br><span class="line">        ;数据地D</span><br><span class="line">        mov ax,0B800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,160*12+30*2 ;di=160*12+30*2;di&lt;xx+160*3;di+=160</span><br><span class="line">        </span><br><span class="line">        ;栈</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">        </span><br><span class="line">        ;把颜色,ascii打入字符串当中</span><br><span class="line">        ;颜色在cx=3大循环中打入,ASCII在小循环cx=16中打入</span><br><span class="line">        ;用bx寻颜色</span><br><span class="line">        ;用si,di寻ASCII</span><br><span class="line">        </span><br><span class="line">        mov cx,3</span><br><span class="line">big:</span><br><span class="line">        </span><br><span class="line">        push cx;cx=3,在小循环cx=16,会用到</span><br><span class="line">        push di</span><br><span class="line">        </span><br><span class="line">        mov dh,ds:[bx]</span><br><span class="line">        mov cx, 16</span><br><span class="line">        mov si,0</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">small:</span><br><span class="line">        mov dl,ds:[si]</span><br><span class="line">        mov es:[di],dx</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop small</span><br><span class="line">        </span><br><span class="line">        pop di                </span><br><span class="line">        pop cx</span><br><span class="line">        </span><br><span class="line">        add di,160</span><br><span class="line">        inc bx</span><br><span class="line">        loop big</span><br><span class="line"> over:    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>出现的问题</p>
<p>没注意数据的长度,体现在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">small:</span><br><span class="line">        mov dl,ds:[si]</span><br><span class="line">        mov es:[di],dx</span><br><span class="line">        inc si</span><br><span class="line">        inc di</span><br><span class="line">        loop small</span><br></pre></td></tr></table></figure>

<p>这里的话</p>
<p>应该是</p>
<p>add di,2</p>
<p>不是</p>
<p>di++</p>
<h3 id="复制的脚本"><a href="#复制的脚本" class="headerlink" title="复制的脚本"></a>复制的脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,16   </span><br><span class="line"></span><br><span class="line">func:     </span><br><span class="line">        mov ax,0FFFFh</span><br><span class="line">        mov ds,ax           </span><br><span class="line">        mov dl,ds:[bx]      ;dl=[0xFFFF:bx]</span><br><span class="line">        </span><br><span class="line">        mov ax,0020h</span><br><span class="line">        mov ds,ax           </span><br><span class="line">        mov ds:[bx],dl       ;[0020:bx]=dl</span><br><span class="line">        </span><br><span class="line">        inc bx      </span><br><span class="line">        loop func       </span><br><span class="line"></span><br><span class="line">	   mov ax,4c00h</span><br><span class="line">	   int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>另外一种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        mov ax,0ffffh</span><br><span class="line">        mov ds,ax           ;ds 数据从哪里来</span><br><span class="line">        </span><br><span class="line">        mov ax,0020h</span><br><span class="line">        mov es,ax           ;es 数据给到哪里去</span><br><span class="line">        </span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,16</span><br><span class="line">     </span><br><span class="line">func:</span><br><span class="line">        mov dl,ds:[bx]      ;取出来</span><br><span class="line">        mov es:[bx],dl      ;放进去</span><br><span class="line">        inc bx              ;遍历</span><br><span class="line">        loop func</span><br><span class="line">        </span><br><span class="line">	   mov ax,4c00h</span><br><span class="line">	   int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h3 id="指令复制"><a href="#指令复制" class="headerlink" title="指令复制"></a>指令复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 256 dup(&#x27;A&#x27;)    </span><br><span class="line">data ends  </span><br><span class="line"></span><br><span class="line">stack segment stack</span><br><span class="line">    db 128 dup(&#x27;w&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">            ;ss初始化</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">           </span><br><span class="line">            s:</span><br><span class="line">            mov ax,bx</span><br><span class="line">            mov si,offset s</span><br><span class="line">            mov di, offset s0</span><br><span class="line">            </span><br><span class="line">            mov dx,cs:[si]</span><br><span class="line">            mov cs:[di],dx</span><br><span class="line">            </span><br><span class="line">            s0:</span><br><span class="line">            nop</span><br><span class="line">            nop</span><br><span class="line">            </span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">            end:</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这里只是复制了一条指令</p>
<p>把指令 17行的指令 mov ax,bx占2个字节</p>
<p>复制到 29行处 mov ax,bx</p>
<p>你也可以通过循环复制多条指令</p>
<p>但是,指令的长度,你必须要好好考虑一下</p>
<h3 id="打印小写与大写字符串"><a href="#打印小写与大写字符串" class="headerlink" title="打印小写与大写字符串"></a>打印小写与大写字符串</h3><p>类型一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">        db &#x27;dengquxiang are&#x27;,0</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">        ;数据源S</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        </span><br><span class="line">        ;数据地D</span><br><span class="line">        mov ax,7e00h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,0</span><br><span class="line">        </span><br><span class="line">        ;栈</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">        call init_reg</span><br><span class="line">        call clean_screen</span><br><span class="line">        call show_small</span><br><span class="line">        call init_big</span><br><span class="line">        call show_big</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> over:    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">init_reg:</span><br><span class="line">        mov bx,data</span><br><span class="line">        mov ds,bx</span><br><span class="line">        </span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        ret</span><br><span class="line">clean_screen:</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov dx,0700h</span><br><span class="line">        mov cx,2000</span><br><span class="line">cleanscreen:       </span><br><span class="line">        mov es:[bx],dx</span><br><span class="line">        add bx,2</span><br><span class="line">        loop cleanscreen</span><br><span class="line">        ret</span><br><span class="line">show_small:</span><br><span class="line">        mov si,0</span><br><span class="line">        mov di,160*10+30*2</span><br><span class="line">        </span><br><span class="line">        call show_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ret                       </span><br><span class="line">show_str:</span><br><span class="line">        push cx</span><br><span class="line">        push ds</span><br><span class="line">        push es</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        </span><br><span class="line">        mov cx,0</span><br><span class="line">showstr:</span><br><span class="line">         mov cl,ds:[si]</span><br><span class="line">         jcxz show_ret</span><br><span class="line">         mov es:[di],cl</span><br><span class="line">         add di,2</span><br><span class="line">         inc si</span><br><span class="line">         jmp showstr</span><br><span class="line">           ret           </span><br><span class="line">show_ret:</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop es</span><br><span class="line">        pop ds</span><br><span class="line">        pop cx</span><br><span class="line">        ret</span><br><span class="line">init_big:</span><br><span class="line">        mov si,0</span><br><span class="line">        call capital</span><br><span class="line">        ret</span><br><span class="line">capital:</span><br><span class="line">        push cx</span><br><span class="line">        push ds</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        mov cx,0</span><br><span class="line">point:</span><br><span class="line">        mov cl,ds:[si]</span><br><span class="line">        jcxz capital_ret</span><br><span class="line">        and byte ptr ds:[si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp point</span><br><span class="line">        </span><br><span class="line">capital_ret: </span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop ds</span><br><span class="line">        pop cx      </span><br><span class="line">        ret</span><br><span class="line">show_big:</span><br><span class="line">        mov si,0</span><br><span class="line">        mov di,160*11+30*2</span><br><span class="line">        call show_str</span><br><span class="line">        </span><br><span class="line">        ret</span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>我写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">        db &#x27;tinyxiangxiangs&#x27;,0</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">        ;数据源S</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        </span><br><span class="line">        ;数据地D</span><br><span class="line">        mov ax,7e00h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,0</span><br><span class="line">        </span><br><span class="line">        ;栈</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">;初始化指向</span><br><span class="line">;显示数据</span><br><span class="line">;修改数据</span><br><span class="line">;显示数据</span><br><span class="line">;数据显示是一个函数</span><br><span class="line">        call init_reg</span><br><span class="line">        call init_screen</span><br><span class="line">        call show_small</span><br><span class="line">        call show_big</span><br><span class="line"> over:    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function </span><br><span class="line">;0700h是默认颜色 160*10+30*2是显示的位置,显存的地址0b800h</span><br><span class="line"></span><br><span class="line">init_reg:</span><br><span class="line">        ;指向的地址</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov si,0;si+=1</span><br><span class="line">        mov di,160*10+30*2;di+=2</span><br><span class="line">        ret</span><br><span class="line">init_screen:</span><br><span class="line">        mov cx,2000</span><br><span class="line">        mov ax,0 </span><br><span class="line">        push di</span><br><span class="line">        mov di,0</span><br><span class="line">loop1:</span><br><span class="line">        mov es:[di],ax</span><br><span class="line">        add di,2</span><br><span class="line">        loop loop1</span><br><span class="line">        pop di</span><br><span class="line">        ret            </span><br><span class="line">show_small:</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        mov cx,16</span><br><span class="line">        mov ah,11011111b</span><br><span class="line">loop2:</span><br><span class="line">        mov al,ds:[si]</span><br><span class="line">        mov es:[di],ax</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop loop2</span><br><span class="line">        pop di</span><br><span class="line">        pop si    </span><br><span class="line">        ret </span><br><span class="line">show_big:</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        mov di,160*11+30*2</span><br><span class="line">        mov cx,16</span><br><span class="line">        mov ah,11011111b</span><br><span class="line">loop3:</span><br><span class="line">        mov al,ds:[si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov es:[di],ax</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop loop3</span><br><span class="line">        pop di</span><br><span class="line">        pop di    </span><br><span class="line">        ret        </span><br><span class="line">          </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>



<p>类型2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">        db &#x27;wind&#x27;,0</span><br><span class="line">        db &#x27;good&#x27;,0</span><br><span class="line">        db &#x27;word&#x27;,0</span><br><span class="line">        db &#x27;unix&#x27;,0</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">        ;数据源S</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        </span><br><span class="line">        ;数据地D</span><br><span class="line">        mov ax,7e00h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,0</span><br><span class="line">        </span><br><span class="line">        ;栈</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">        call init_reg</span><br><span class="line">        call clean_screen</span><br><span class="line">        call make_big</span><br><span class="line">black:       </span><br><span class="line">        mov ax,1000h</span><br><span class="line">        jmp black</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> over:    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">init_reg:</span><br><span class="line">        mov bx,data</span><br><span class="line">        mov ds,bx</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        ret</span><br><span class="line">clean_screen:</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov dx,0700h</span><br><span class="line">        mov cx,2000</span><br><span class="line">cleanscreen:</span><br><span class="line">        mov es:[bx],dx</span><br><span class="line">        add bx,2</span><br><span class="line">        loop cleanscreen </span><br><span class="line">        ret                       </span><br><span class="line">make_big:</span><br><span class="line">        mov si,0</span><br><span class="line">        mov di,160*10+30*2</span><br><span class="line">        mov cx,4</span><br><span class="line">makebig:       </span><br><span class="line">        call show_str</span><br><span class="line">        call capital_letter</span><br><span class="line">        call show_word</span><br><span class="line">        add di,160</span><br><span class="line">        add si,5</span><br><span class="line">        loop makebig</span><br><span class="line">        </span><br><span class="line">        ret</span><br><span class="line">show_str:</span><br><span class="line">        push cx</span><br><span class="line">        push ds</span><br><span class="line">        push es</span><br><span class="line">        push di</span><br><span class="line">        push si</span><br><span class="line">        </span><br><span class="line">        mov cx,0</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">showstr:</span><br><span class="line">        mov cl,ds:[si]</span><br><span class="line">        jcxz show_str_ret</span><br><span class="line">        mov es:[di],cl</span><br><span class="line">        add di,2</span><br><span class="line">        inc si</span><br><span class="line">        jmp showstr</span><br><span class="line"></span><br><span class="line">show_str_ret:</span><br><span class="line">        pop si</span><br><span class="line">        pop di</span><br><span class="line">        pop es</span><br><span class="line">        pop ds</span><br><span class="line">        pop cx</span><br><span class="line">        </span><br><span class="line">        ret  </span><br><span class="line">capital_letter:</span><br><span class="line">        push cx</span><br><span class="line">        push ds</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        </span><br><span class="line">        mov cx,0</span><br><span class="line">capitalletter:</span><br><span class="line">        mov cl,ds:[si]</span><br><span class="line">        jcxz capital_ret</span><br><span class="line">        and byte ptr ds:[si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp capitalletter</span><br><span class="line">        </span><br><span class="line">capital_ret:</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop ds</span><br><span class="line">        pop cx</span><br><span class="line">        ret   </span><br><span class="line">show_word:</span><br><span class="line">        push di</span><br><span class="line">        add di,10*2</span><br><span class="line">        call show_str</span><br><span class="line">        pop di</span><br><span class="line">        ret </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================  </span><br></pre></td></tr></table></figure>

<p>我写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">        db &#x27;wind&#x27;,0</span><br><span class="line">        db &#x27;good&#x27;,0</span><br><span class="line">        db &#x27;word&#x27;,0</span><br><span class="line">        db &#x27;unix&#x27;,0</span><br><span class="line">        db  0,0,0,0,0</span><br><span class="line">        ;5个5个的循环,160++的显示</span><br><span class="line">data ends </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">    </span><br><span class="line">    call init_reg</span><br><span class="line">    call clean_screen</span><br><span class="line">    call show_small</span><br><span class="line">    call show_big</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">init_reg:</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,160*10+30*2</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">;=======================================================</span><br><span class="line">clean_screen:</span><br><span class="line">    </span><br><span class="line">    mov cx,2000</span><br><span class="line">    mov ax,0700h</span><br><span class="line">    push di</span><br><span class="line">    mov di,0</span><br><span class="line">lop1:</span><br><span class="line">    mov es:[di],ax</span><br><span class="line">    add di,2</span><br><span class="line">    loop lop1</span><br><span class="line"></span><br><span class="line">    pop di</span><br><span class="line">    ret</span><br><span class="line">;=======================================================</span><br><span class="line">show_small:   </span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,si</span><br><span class="line">    ;大循环</span><br><span class="line">    push di</span><br><span class="line">lop3:</span><br><span class="line">    mov cx,0</span><br><span class="line">    mov cl,ds:[bx]</span><br><span class="line">    jcxz small_ret</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line">    ;小循环</span><br><span class="line">lop2:    </span><br><span class="line">    mov cl,0</span><br><span class="line">    mov cl,ds:[si]</span><br><span class="line">  </span><br><span class="line">    jcxz lop2_out</span><br><span class="line">    mov es:[di],cl</span><br><span class="line">    mov byte ptr es:[di+1],11011111b</span><br><span class="line">    inc si</span><br><span class="line">    add di,2</span><br><span class="line">    jmp lop2</span><br><span class="line"></span><br><span class="line">lop2_out:</span><br><span class="line">    pop di</span><br><span class="line">    add di,160</span><br><span class="line">    add bx,5</span><br><span class="line">    inc si  ;容易忽略</span><br><span class="line">    jmp lop3</span><br><span class="line">small_ret:</span><br><span class="line">    pop di</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">show_big:</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,0</span><br><span class="line">    mov si,0</span><br><span class="line">    mov di,160*10+30*2+12;本身就存在10个字节的长度,ASCII+颜色,就是2个字节,并且di的位置起点必须还是偶数,否则后面的数据会错位填补</span><br><span class="line">    mov bx,si</span><br><span class="line">    ;大循环</span><br><span class="line">    push di</span><br><span class="line">lop5:</span><br><span class="line">    mov cx,0</span><br><span class="line">    mov cl,ds:[bx]</span><br><span class="line">    jcxz big_ret</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line">    ;小循环</span><br><span class="line">lop4:    </span><br><span class="line">    mov cl,0</span><br><span class="line">    mov cl,ds:[si]</span><br><span class="line">    </span><br><span class="line">    jcxz lop4_out</span><br><span class="line">    and cl,11011111b</span><br><span class="line">    mov es:[di],cl</span><br><span class="line">    mov byte ptr es:[di+1],11011111b</span><br><span class="line">    inc si</span><br><span class="line">    add di,2</span><br><span class="line">    jmp lop4</span><br><span class="line"></span><br><span class="line">lop4_out:</span><br><span class="line">    pop di</span><br><span class="line">    add di,160</span><br><span class="line">    add bx,5</span><br><span class="line">    inc si  ;容易忽略</span><br><span class="line">    jmp lop5</span><br><span class="line">big_ret:</span><br><span class="line">    pop di</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>没有去注意数据的位置有何意义,也没有注意数据的长度</p>
<h3 id="打印一个字符串"><a href="#打印一个字符串" class="headerlink" title="打印一个字符串"></a>打印一个字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">     db &#x27;welcome to masm!&#x27;,0 </span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line"></span><br><span class="line">    call init_reg</span><br><span class="line">    call show</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">init_reg:</span><br><span class="line">    mov dh,23</span><br><span class="line">    mov dl,3</span><br><span class="line">    mov cl,2</span><br><span class="line">    </span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov al,dh</span><br><span class="line">    mov bx, 160</span><br><span class="line">    mul bx</span><br><span class="line">    mov di,ax</span><br><span class="line"></span><br><span class="line">    mov al,dl</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov bl,2</span><br><span class="line">    mul bl</span><br><span class="line">    add di,ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">show:</span><br><span class="line"></span><br><span class="line">    mov cx,0</span><br><span class="line">    mov cl,ds:[si]</span><br><span class="line">    jcxz show_ret</span><br><span class="line">    mov ch,2</span><br><span class="line">    mov es:[di],cx</span><br><span class="line">    add di,2</span><br><span class="line">    inc si</span><br><span class="line">    jmp show</span><br><span class="line"></span><br><span class="line">show_ret:</span><br><span class="line">    ret</span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>出现的问题</p>
<p>对于cx中带颜色,jcxz怎么办</p>
<p>jcxz中jmp的位置不对</p>
<p>jcxz发现cx一直不为0,woc</p>
<p>直接用</p>
<p>mov di,160*23+6</p>
<p>这样更快</p>
<h3 id="源代码-gt-ASCII的打印"><a href="#源代码-gt-ASCII的打印" class="headerlink" title="源代码-&gt;ASCII的打印"></a>源代码-&gt;ASCII的打印</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">     dd 0ffffh,5678,65535,0</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">    call init_reg</span><br><span class="line">    call show_number</span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">init_reg:</span><br><span class="line">    </span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">Break_Up_Digit:         ;将数字, 好比1234, 利用%的方法去分解为 ,1 2, 3, 4, 然后打入显存</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push si</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line">    ;初始化 被除数 / 除数 = ?</span><br><span class="line">    mov ax,ds:[si]</span><br><span class="line">    mov dx,ds:[si+2]</span><br><span class="line">    mov bx,10</span><br><span class="line"></span><br><span class="line">lp1:</span><br><span class="line">    div bx </span><br><span class="line">    mov dh,2</span><br><span class="line">    add dl,30h          ;余数-&gt;ASCII </span><br><span class="line">    mov es:[di],dx      ;ASCII-显存</span><br><span class="line">    sub di,2            ;右往左依次填补</span><br><span class="line">    mov cx,ax           ;取商到 cx               </span><br><span class="line">    jcxz fun_ret        ;如果商为0,就退出-&gt;当数据本身就是0,也不影响它的输出</span><br><span class="line">    mov dx,0            ;清空dx,它本身用来装东西的</span><br><span class="line">    jmp lp1</span><br><span class="line"></span><br><span class="line">fun_ret:</span><br><span class="line">    pop di</span><br><span class="line">    pop si</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line">    pop dx</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">show_number:</span><br><span class="line">    mov si,0        </span><br><span class="line">    mov di,160*10+40*2</span><br><span class="line">    mov cx,4            ;我们有4行数据</span><br><span class="line">shownumber:</span><br><span class="line">    call Break_Up_Digit</span><br><span class="line">    add si,4            ;指向数据段的下一个word数据</span><br><span class="line">    add di,160          ;显示在下一行</span><br><span class="line">    loop shownumber     ;循环往复</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>里面用到了看数的分解</p>
<p>用32位除法的余数dx去有效的代替%,那么就可以自动的判断了</p>
<p>我自己写的</p>
<p>怎么处理 over_flow 除法??????</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">     db 01,02,03,04,05,06,07,08,09,10</span><br><span class="line">     ;所以要10次?</span><br><span class="line">     </span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">    call Init_Reg       </span><br><span class="line">    call Show_Data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">Init_Reg:</span><br><span class="line">    </span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,10*160+30*2</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">Show_Data:</span><br><span class="line">    ;采用数分解的方式</span><br><span class="line"></span><br><span class="line">    mov cx,10</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">    </span><br><span class="line">lp2:</span><br><span class="line">    push cx</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov ah,0</span><br><span class="line">    mov al,ds:[si]</span><br><span class="line"></span><br><span class="line">    mov dx,0</span><br><span class="line">    mov bx,10</span><br><span class="line">    ;余数在dx中</span><br><span class="line">lp1:</span><br><span class="line">    div bx</span><br><span class="line">    add dl,30h</span><br><span class="line">    mov dh,2</span><br><span class="line">    mov es:[di],dx</span><br><span class="line">    mov cx,ax</span><br><span class="line">    jcxz continue_x</span><br><span class="line">    sub di,2</span><br><span class="line">    mov dx,0</span><br><span class="line">    jmp lp1</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">continue_x:</span><br><span class="line">    pop di</span><br><span class="line">    pop cx</span><br><span class="line">    add di,160</span><br><span class="line">    inc si</span><br><span class="line">    loop lp2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现的问题</p>
<blockquote>
<p>  对循环而言,不知道那些指令是要循环的,哪些指令它是不需要循环的</p>
</blockquote>
<blockquote>
<p>  对数据经不起考验,也就是代码不严谨</p>
<p>  好比对于除法,每一次它的计算,你最好要去初始化一下,否者很容易数据错位而算出奇奇怪怪的东西</p>
</blockquote>
<ol start="4">
<li></li>
</ol>
<h3 id="屏幕复制"><a href="#屏幕复制" class="headerlink" title="屏幕复制"></a>屏幕复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">        data segment</span><br><span class="line">                        db 128 dup(&#x27;x&#x27;) </span><br><span class="line">        data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">        stack segment stack</span><br><span class="line">                        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">        stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;main code  </span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax       </span><br><span class="line">;数据地D</span><br><span class="line">                        mov ax,7e00h</span><br><span class="line">                        mov es,ax        </span><br><span class="line">;栈</span><br><span class="line">                        mov ax,stack</span><br><span class="line">                        mov ss,ax</span><br><span class="line">                        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">        </span><br><span class="line">                        call init_reg</span><br><span class="line"></span><br><span class="line">                        call cpy_screen</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">                        mov ax,4c00h</span><br><span class="line">                        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line">init_reg:</span><br><span class="line">                        </span><br><span class="line">                        mov bx,0b800h</span><br><span class="line">                        mov ds,bx</span><br><span class="line">                        mov es,bx</span><br><span class="line">                        ret</span><br><span class="line">cpy_screen:</span><br><span class="line">                        </span><br><span class="line">                        mov cx,24</span><br><span class="line">                        mov si,160</span><br><span class="line">                        mov di,0</span><br><span class="line">cpy_screen_cmd:</span><br><span class="line">                        push cx</span><br><span class="line">                        push si</span><br><span class="line">                        push di</span><br><span class="line">                        mov cx,80</span><br><span class="line"></span><br><span class="line">                        cld</span><br><span class="line">                        rep movsw</span><br><span class="line"></span><br><span class="line">                        pop di</span><br><span class="line">                        pop si</span><br><span class="line">                        pop cx</span><br><span class="line">                        add si,160</span><br><span class="line">                        add di,160</span><br><span class="line">                        loop cpy_screen_cmd                        </span><br><span class="line"></span><br><span class="line">                        ret</span><br><span class="line">                        </span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>



<h3 id="指令复制-1"><a href="#指令复制-1" class="headerlink" title="指令复制"></a>指令复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">        data segment</span><br><span class="line">                        db 128 dup(&#x27;x&#x27;) </span><br><span class="line">        data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">        stack segment stack</span><br><span class="line">                        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">        stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;main code  </span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">                        mov ax,data</span><br><span class="line">                        mov ds,ax       </span><br><span class="line">;数据地D</span><br><span class="line">                        mov ax,7e00h</span><br><span class="line">                        mov es,ax        </span><br><span class="line">;栈</span><br><span class="line">                        mov ax,stack</span><br><span class="line">                        mov ss,ax</span><br><span class="line">                        mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">                        call copy_cmd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">over:    </span><br><span class="line">                        mov ax,4c00h</span><br><span class="line">                        int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">cmd:                    mov ax,10</span><br><span class="line">                        mov ax,10</span><br><span class="line">                        mov ax,10</span><br><span class="line">                        mov ax,10</span><br><span class="line">                        mov ax,10</span><br><span class="line">cmd_end:                nop</span><br><span class="line"></span><br><span class="line">copy_cmd:</span><br><span class="line">                        mov bx,cs</span><br><span class="line">                        mov ds,bx</span><br><span class="line">                        mov si,offset cmd</span><br><span class="line"></span><br><span class="line">                        mov bx,0</span><br><span class="line">                        mov es,bx</span><br><span class="line">                        mov di,7e00h</span><br><span class="line"></span><br><span class="line">                        mov cx,offset cmd_end-cmd</span><br><span class="line">                        cld</span><br><span class="line">                        rep movsb</span><br><span class="line">                        </span><br><span class="line">                        ret</span><br><span class="line">                        </span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>







<h3 id="Copy-Code函数"><a href="#Copy-Code函数" class="headerlink" title="Copy_Code函数"></a>Copy_Code函数</h3><p>用到了几个参数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CX</span><br></pre></td></tr></table></figure>

<p>:代表了循环的次数</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cld </span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>

<p>代表了复制的功能</p>
<p>sb就是byte的一种复制</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ds:[si]</span><br><span class="line">es:[di]</span><br></pre></td></tr></table></figure>

<p>要复制什么代码</p>
<p>复制到哪里去</p>
</blockquote>
<h3 id="用中断模拟没有loop-的的loop"><a href="#用中断模拟没有loop-的的loop" class="headerlink" title="用中断模拟没有loop 的的loop"></a>用中断模拟没有loop 的的loop</h3><p>它的原理是修改栈里的IP</p>
<p>然后pop出去被修改的IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack</span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">    db 32 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax;</span><br><span class="line">                                mov sp,32</span><br><span class="line"></span><br><span class="line">                                call init_do7ch;他只会push ip</span><br><span class="line"></span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,160*12</span><br><span class="line"></span><br><span class="line">                                mov bx,offset s - offset send</span><br><span class="line">                                mov cx,8</span><br><span class="line">                        s:</span><br><span class="line">                                </span><br><span class="line">                                mov byte ptr es:[di+0],&#x27;!&#x27;</span><br><span class="line">                                mov byte ptr es:[di+1],2 </span><br><span class="line">                                add di,2   </span><br><span class="line">                                int 7ch</span><br><span class="line">                        send:</span><br><span class="line">                                nop</span><br><span class="line"></span><br><span class="line">                            mov ax,4c00h</span><br><span class="line">                            int 21h</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------------------------------------------</span><br><span class="line">                 </span><br><span class="line">                init_do7ch:</span><br><span class="line">                            ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的</span><br><span class="line">                            ;--------------------------------------------</span><br><span class="line">                            ;设置数据来源 S指-&gt;CS:[do7ch]</span><br><span class="line">                            mov ax,cs</span><br><span class="line">                            mov ds,ax</span><br><span class="line">                            mov si,offset do7ch;这样取地址就非常的妙..不想你之前根本想不到</span><br><span class="line">                            </span><br><span class="line">                            ;设置数据D-&gt;0000:[0200]</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov di,200h</span><br><span class="line"></span><br><span class="line">                            mov cx,offset do7chend - offset do7ch;循环的次数</span><br><span class="line"></span><br><span class="line">                            cld</span><br><span class="line">                            rep movsb</span><br><span class="line">                            </span><br><span class="line">                           </span><br><span class="line">                            ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov word ptr es:[7ch*4+0],200h</span><br><span class="line">                            mov word ptr es:[7ch*4+2],0</span><br><span class="line">                            </span><br><span class="line">                            ret  </span><br><span class="line"></span><br><span class="line">                            ;--------------------------------------</span><br><span class="line">                do7ch:</span><br><span class="line">                            push bp</span><br><span class="line">                            mov bp,sp;因为这里让bp发生了改变...所以我们要保存bp的初始化值</span><br><span class="line">                            dec cx</span><br><span class="line">                            jcxz lpret</span><br><span class="line">                            add ss:[bp+2],bx;woc,这里不是默认的ds:</span><br><span class="line">                lpret:</span><br><span class="line">                            pop bp    </span><br><span class="line">                            iret    </span><br><span class="line">                            </span><br><span class="line">                do7chend:        </span><br><span class="line">                            nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="在一定的光标位置显示字符"><a href="#在一定的光标位置显示字符" class="headerlink" title="在一定的光标位置显示字符"></a>在一定的光标位置显示字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax</span><br><span class="line">                                mov sp,128</span><br><span class="line"></span><br><span class="line">                                ;bh 总 是 代 表 着 页 数</span><br><span class="line">                                ;ah总 是 代 表 着 编 号</span><br><span class="line"> </span><br><span class="line">                                mov ah,2</span><br><span class="line">                                mov bh,0</span><br><span class="line">                                mov dh,5</span><br><span class="line">                                mov dl,2</span><br><span class="line">                                int 10h</span><br><span class="line"></span><br><span class="line">                                mov ah,9</span><br><span class="line">                                mov al,&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">                                mov bl,11001010b</span><br><span class="line">                                mov bh,0</span><br><span class="line">                                mov cx,6</span><br><span class="line">                                int 10h</span><br><span class="line">                        </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



























<h3 id="int-7ch-计算sqrt"><a href="#int-7ch-计算sqrt" class="headerlink" title="int 7ch 计算sqrt"></a>int 7ch 计算sqrt</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                            mov ax,stack</span><br><span class="line">                            mov ss,ax;</span><br><span class="line">                            mov sp,128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            call init_do7ch;他只会push ip</span><br><span class="line">                            mov ax,8</span><br><span class="line">                            int 7ch</span><br><span class="line">                            add ax,ax</span><br><span class="line">                            adc dx,dx</span><br><span class="line">                            </span><br><span class="line">                            mov ax,4c00h</span><br><span class="line">                            int 21h  </span><br><span class="line">;-----------------------------------------------------------------------------------------------------------------</span><br><span class="line">                 </span><br><span class="line">                init_do7ch:</span><br><span class="line">                            ;先是修改数据的指向,然后是复制中断代码到中断区,中断区域的调用是自动的</span><br><span class="line">                            ;--------------------------------------------</span><br><span class="line">                            ;设置数据来源 S指-&gt;CS:[do7ch]</span><br><span class="line">                            mov ax,cs</span><br><span class="line">                            mov ds,ax</span><br><span class="line">                            mov si,offset do7ch;这样取地址就非常的妙..不想你之前根本想不到</span><br><span class="line">                            </span><br><span class="line">                            ;设置数据D-&gt;0000:[0200]</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov di,200h</span><br><span class="line"></span><br><span class="line">                            mov cx,offset do7chend - offset do7ch;循环的次数</span><br><span class="line"></span><br><span class="line">                            cld</span><br><span class="line">                            rep movsb</span><br><span class="line">                            </span><br><span class="line">                           </span><br><span class="line">                            ;数据指向完成后,初始化一下中断向量表,第[0]个向量表的地址0000:0200</span><br><span class="line">                            mov ax,0</span><br><span class="line">                            mov es,ax</span><br><span class="line">                            mov word ptr es:[7ch*4+0],200h</span><br><span class="line">                            mov word ptr es:[7ch*4+2],0</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">                            ret  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ;--------------------------------------</span><br><span class="line">                    do7ch:</span><br><span class="line">                            mul ax </span><br><span class="line">                            iret    </span><br><span class="line">                           </span><br><span class="line"></span><br><span class="line">                do7chend:        </span><br><span class="line">                            nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="int-7ch-大小写转化"><a href="#int-7ch-大小写转化" class="headerlink" title="int 7ch 大小写转化"></a>int 7ch 大小写转化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax;</span><br><span class="line">                                mov sp,16</span><br><span class="line">                                </span><br><span class="line">                                </span><br><span class="line">                                ;只是设置一个光标</span><br><span class="line">                                mov ah,2</span><br><span class="line"></span><br><span class="line">                                mov bh,0</span><br><span class="line"></span><br><span class="line">                                mov dh,5</span><br><span class="line">                                mov dl,12</span><br><span class="line"></span><br><span class="line">                                int 10h</span><br><span class="line"></span><br><span class="line">                                ;只修改颜色配置的属性然后输出对应的字符串</span><br><span class="line">                                mov ah,9</span><br><span class="line">                                mov al,&#x27;&amp;&#x27;</span><br><span class="line">                                mov bl,11001010b</span><br><span class="line">                                mov bh,0</span><br><span class="line">                                mov cx,3</span><br><span class="line">                                int 10h</span><br><span class="line"></span><br><span class="line">                                ;call int_7ch</span><br><span class="line">                                </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="手写实现-int21h的ah-x3D-9"><a href="#手写实现-int21h的ah-x3D-9" class="headerlink" title="手写实现 int21h的ah&#x3D;9"></a>手写实现 int21h的ah&#x3D;9</h3><p>打印字符串的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack ,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &quot;hello! I am Dqx-Gh0st...weclome to my world&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax </span><br><span class="line">                                mov sp,16</span><br><span class="line">                                </span><br><span class="line">                                call init_do7ch                               </span><br><span class="line">                                ;行号</span><br><span class="line">                                mov dh,10</span><br><span class="line">                                ;列好</span><br><span class="line">                                mov dl,10</span><br><span class="line">                                ;颜色</span><br><span class="line">                                mov cl,11001010b</span><br><span class="line">                                ;数据源</span><br><span class="line">                                mov ax,data</span><br><span class="line">                                mov ds,ax</span><br><span class="line">                                mov si,0</span><br><span class="line">                                </span><br><span class="line">                                int 7ch</span><br><span class="line">                                                             </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        init_do7ch:</span><br><span class="line"></span><br><span class="line">                                mov ax,cs</span><br><span class="line">                                mov ds,ax</span><br><span class="line">                                mov si, offset do7ch_start</span><br><span class="line"></span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,200h</span><br><span class="line"></span><br><span class="line">                                mov cx,offset do7ch_end - offset do7ch_start</span><br><span class="line"></span><br><span class="line">                                cld</span><br><span class="line">                                rep movsb</span><br><span class="line"></span><br><span class="line">                                mov word ptr es:[7ch*4+0],200h</span><br><span class="line">                                mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">                                ret</span><br><span class="line"></span><br><span class="line">                        do7ch_start:</span><br><span class="line">                                </span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line"></span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov al,160</span><br><span class="line">                                mul dh</span><br><span class="line">                                ;结果放在ax中</span><br><span class="line">                                </span><br><span class="line">                                mov di,ax</span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov al,2</span><br><span class="line">                                mul dl</span><br><span class="line">                                ;又得到数据放在了ax中</span><br><span class="line">                                add di,ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        s:        </span><br><span class="line">                                push cx</span><br><span class="line">                                mov cx,0</span><br><span class="line">                                mov cl,ds:[si]</span><br><span class="line">                                jcxz retend</span><br><span class="line">                                pop cx;还原那个颜色属性的配置...cl</span><br><span class="line">                                mov ch,ds:[si];再次赋予数据</span><br><span class="line">                                mov byte ptr es:[di+0],ch</span><br><span class="line">                                mov byte ptr es:[di+1],cl</span><br><span class="line"></span><br><span class="line">                                add di,2</span><br><span class="line">                                inc si</span><br><span class="line">                                jmp s</span><br><span class="line"></span><br><span class="line">                        retend:</span><br><span class="line"></span><br><span class="line">                                add sp,2;这里会比较容易的去忘记.....只管跑...东西都忘记了拿</span><br><span class="line">                                iret</span><br><span class="line"></span><br><span class="line">                        do7ch_end:nop</span><br><span class="line">                                 </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>









<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack ,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &quot;123456789&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                     </span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax </span><br><span class="line">                                mov sp,16</span><br><span class="line">                                </span><br><span class="line">                                call init_do7ch</span><br><span class="line"></span><br><span class="line">                                mov ax,0b800h</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,160*12</span><br><span class="line">                                mov bx, offset send - offset s</span><br><span class="line">                                mov cx,10</span><br><span class="line"></span><br><span class="line">                            s:</span><br><span class="line">                                mov byte ptr es:[di+0],&#x27;?&#x27;</span><br><span class="line">                                mov byte ptr es:[di+1],2</span><br><span class="line">                                add di,2</span><br><span class="line">                                int 7ch</span><br><span class="line">                            send:nop                                                          </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        init_do7ch:</span><br><span class="line"></span><br><span class="line">                                mov ax,cs</span><br><span class="line">                                mov ds,ax</span><br><span class="line">                                mov si, offset do7ch_start</span><br><span class="line"></span><br><span class="line">                                mov ax,0</span><br><span class="line">                                mov es,ax</span><br><span class="line">                                mov di,200h</span><br><span class="line"></span><br><span class="line">                                mov cx,offset do7ch_end - offset do7ch_start</span><br><span class="line"></span><br><span class="line">                                cld</span><br><span class="line">                                rep movsb</span><br><span class="line"></span><br><span class="line">                                mov word ptr es:[7ch*4+0],200h</span><br><span class="line">                                mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">                                ret</span><br><span class="line"></span><br><span class="line">                        do7ch_start:</span><br><span class="line">                                dec cx</span><br><span class="line">                                jcxz retend</span><br><span class="line">                                mov bp,0</span><br><span class="line">                                push bp</span><br><span class="line">                                mov bp,sp</span><br><span class="line">                                sub ss:[bp+2],bx</span><br><span class="line">                                pop bp</span><br><span class="line">                        retend:                             </span><br><span class="line">                                iret</span><br><span class="line"></span><br><span class="line">                        do7ch_end:nop</span><br><span class="line">                                 </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h3 id="输出4句诗"><a href="#输出4句诗" class="headerlink" title="输出4句诗"></a>输出4句诗</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code ,  ss:stack </span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(&#x27;0&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    s1:     db  &quot;Good,better,best&quot;,&#x27;,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s2:     db  &quot;Never let it rest&quot;,&#x27;,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s3:     db  &quot;Till good is bettre&quot;,&#x27;,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s4:     db  &quot;And better ,best.&quot;,&#x27;,&#x27;,&#x27;$&#x27;</span><br><span class="line">    s:      dw   offset s1, offset s2,  offset s3,  offset s4</span><br><span class="line">    row:    db  2,4,6,8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:                     </span><br><span class="line">                                mov ax,stack</span><br><span class="line">                                mov ss,ax </span><br><span class="line">                                mov sp,16</span><br><span class="line">                                </span><br><span class="line"></span><br><span class="line">                                mov ax,cs</span><br><span class="line">                                mov ds,ax</span><br><span class="line">                                mov bx,offset s</span><br><span class="line">                                mov si,offset row</span><br><span class="line">                                mov cx,4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ok:</span><br><span class="line">                                mov ah,2;2函数</span><br><span class="line"></span><br><span class="line">                                mov bh,0;0页</span><br><span class="line">                                ;mov dh,byte ptr ds:[si] ;si+=2;第某某行</span><br><span class="line">                                mov dh,cs:[si]</span><br><span class="line">                                mov dl,10                                </span><br><span class="line">                                int 10h</span><br><span class="line"></span><br><span class="line">                                ;mov dx,bx</span><br><span class="line">                                mov dx,cs:[bx]</span><br><span class="line">                                mov ah,9</span><br><span class="line">                                int 21h</span><br><span class="line"></span><br><span class="line">                                add bx,2</span><br><span class="line">                                inc si</span><br><span class="line">                                loop ok</span><br><span class="line"></span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                                </span><br><span class="line">                                mov ax,4c00h</span><br><span class="line">                                int 21h</span><br><span class="line">                                 </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h3 id="用int9打印一首五颜六色的情诗"><a href="#用int9打印一首五颜六色的情诗" class="headerlink" title="用int9打印一首五颜六色的情诗"></a>用int9打印一首五颜六色的情诗</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">      db 16 dup(&#x27;D&#x27;)</span><br><span class="line">      db &quot;How do I love you? Let me count the ways.&quot;,0</span><br><span class="line">      db &quot;I love you to the depth and breath and height.&quot;,0</span><br><span class="line">      db &quot;My soul can reach ,when feeling out sight.&quot;,0</span><br><span class="line">      db &quot;For the ends of being and ideal Grace.&quot;,0</span><br><span class="line">      db &quot;I love you to the level of ideal everyday&#x27;s.&quot;,0</span><br><span class="line">      db &quot;Most quiet need,by sun and candlelight.&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">row:  db 10,11,12,13,14,15</span><br><span class="line">start:</span><br><span class="line">                                    mov ax,data</span><br><span class="line">                                    mov ds,ax</span><br><span class="line">                                    </span><br><span class="line">                                    mov ax,stack</span><br><span class="line">                                    mov ss,ax</span><br><span class="line">                                    mov sp,32</span><br><span class="line"></span><br><span class="line">                                    mov ax,0b800h</span><br><span class="line">                                    mov es,ax  </span><br><span class="line">                                  ;---------------------------------------</span><br><span class="line">                                    call init_9h</span><br><span class="line">                                  ;---------------------------------------  </span><br><span class="line">                                    mov cx,6;有6句诗</span><br><span class="line">                                    mov si,16;si指向字符串开始位置</span><br><span class="line">                                    mov bx,offset row;记住bx指针,而不是指向的值</span><br><span class="line">                                    mov dh,2;它是颜色,因为dx很少用,避免冲突,我们就取dx</span><br><span class="line"></span><br><span class="line">                                  ;--------------------------------============ </span><br><span class="line">                              k:      </span><br><span class="line">                                    call show_str;</span><br><span class="line">                                    loop k</span><br><span class="line">                                  ;----------------把键盘的控制权还给int9  </span><br><span class="line"></span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    </span><br><span class="line">                                    push ds:[0]</span><br><span class="line">                                    pop es:[9*4+0]</span><br><span class="line">                                    push ds:[2]</span><br><span class="line">                                    pop es:[9*4+2]</span><br><span class="line">                                  ;------------------------------------</span><br><span class="line">                                    mov ax,4c00h</span><br><span class="line">                                    int 21h</span><br><span class="line">                                </span><br><span class="line"></span><br><span class="line">                        init_9h:    </span><br><span class="line">                                    ;修改的位置指向0000:9*4</span><br><span class="line">                                    push es</span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line"></span><br><span class="line">                                    ;保存一下以前的int9,后面我们还要调用</span><br><span class="line">                                    push es:[9*4+0]</span><br><span class="line">                                    pop  ds:[0]</span><br><span class="line">                                    push es:[9*4+2]</span><br><span class="line">                                    pop ds:[2]</span><br><span class="line">                                    ;DIY一下int9,让它的中断向量表发生一些变化</span><br><span class="line">                                    mov word ptr es:[9*4+0],offset start_9h</span><br><span class="line">                                    mov es:[9*4+2],cs</span><br><span class="line"></span><br><span class="line">                                    pop es</span><br><span class="line">                                    ret</span><br><span class="line"></span><br><span class="line">                                  ;DIY的int9长这样</span><br><span class="line">                        start_9h:</span><br><span class="line">                                    in al,60h;呼叫端口,我们的键入都在端口那里,al接收了我们的键入</span><br><span class="line">                                    pushf;模拟int9的入栈</span><br><span class="line">                                    call dword ptr ds:[0];模拟int9的入栈</span><br><span class="line">                                    cmp al,48h;如果键入是 ↑</span><br><span class="line">                                    jne start_9h_end;不是就退出</span><br><span class="line">                                    inc dh;就修改颜色</span><br><span class="line">                        start_9h_end:</span><br><span class="line">                                    iret   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        show_str:</span><br><span class="line">                                    mov al,160;每一行160</span><br><span class="line">                                    mul byte ptr cs:[bx];每一行x那个行数,bx是指针,bx+=2</span><br><span class="line">                                    mov di,ax;然目的地址接收结果</span><br><span class="line">                                    add di,20*2;指向20列</span><br><span class="line">                show_str_sontinue:                                           </span><br><span class="line">                                    mov dl,ds:[si];si指针指针指向了字符串</span><br><span class="line">                                    cmp dl,0;如果是0,就退出,然后+1,跳过0,指向下一个字符串</span><br><span class="line">                                    je show_end</span><br><span class="line">                                    call delay;缓冲一下</span><br><span class="line">                                    mov es:[di],dx</span><br><span class="line">                                    add di,2;指向下一个像素</span><br><span class="line">                                    inc si;指向下一个字符</span><br><span class="line">                                    jmp show_str_sontinue;继续循环</span><br><span class="line"></span><br><span class="line">                        show_end:   inc bx;指向下一行</span><br><span class="line">                                    inc si;跳过0</span><br><span class="line">                                    ret</span><br><span class="line"></span><br><span class="line">                        delay:</span><br><span class="line">                                    push ax</span><br><span class="line">                                    push bx</span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov bx,01h</span><br><span class="line">                      delay_continue:            </span><br><span class="line">                                    sub ax,1</span><br><span class="line">                                    sbb bx,0</span><br><span class="line">                                    cmp ax,0</span><br><span class="line">                                    jne delay_continue</span><br><span class="line">                                    cmp bx,0</span><br><span class="line">                                    jne delay_continue</span><br><span class="line"></span><br><span class="line">                                    pop bx</span><br><span class="line">                                    pop ax</span><br><span class="line">                                    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>



<h3 id="在代码据放data-segment的坏处"><a href="#在代码据放data-segment的坏处" class="headerlink" title="在代码据放data segment的坏处"></a>在代码据放data segment的坏处</h3><p>好处?</p>
<p>就是寻址很方便,因为代码区,你可以用指令<code>offset</code>来寻址,</p>
<p>但就问题就存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bx,offset s1</span><br><span class="line">mov si,offset s2</span><br><span class="line">...</span><br><span class="line">mov dx,cs:[bx]</span><br><span class="line">...</span><br><span class="line">mov dh,cs:[si]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以在上面看到其实也没啥&#x2F;…</p>
<p>但是cs:[<del>],你&#96;</del><code>只能用</code>纯数字,bx寄存器,ip,si,di&#96;,,…si,di有重要的用途,,,,,ip无法用…..bx有太少</p>
<h3 id="安装DIY的int9中断-然后运行-可以修改屏幕的颜色"><a href="#安装DIY的int9中断-然后运行-可以修改屏幕的颜色" class="headerlink" title="安装DIY的int9中断,然后运行,,,可以修改屏幕的颜色"></a>安装DIY的int9中断,然后运行,,,可以修改屏幕的颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">                                   </span><br><span class="line">                                    mov ax,stack</span><br><span class="line">                                    mov ss,ax</span><br><span class="line">                                    mov sp,32</span><br><span class="line"></span><br><span class="line">                                    push cs</span><br><span class="line">                                    pop  ds</span><br><span class="line">                                    mov  si,offset int9</span><br><span class="line"></span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov di,204h</span><br><span class="line"> </span><br><span class="line">                                    mov cx,offset int9_end - offset int9</span><br><span class="line"></span><br><span class="line">                                    cld</span><br><span class="line">                                    rep movsb</span><br><span class="line"></span><br><span class="line">                                    push es:[9*4+0]</span><br><span class="line">                                    pop  es:[200h+0]</span><br><span class="line">                                    push es:[9*4+2]</span><br><span class="line">                                    pop  es:[200h+2]</span><br><span class="line"></span><br><span class="line">                                    cli</span><br><span class="line">                                    mov word ptr es:[9*4+0],204h</span><br><span class="line">                                    mov word ptr es:[9*4+2],0</span><br><span class="line">                                    sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    mov ax,4c00h</span><br><span class="line">                                    int 21h</span><br><span class="line"></span><br><span class="line">                           int9:</span><br><span class="line">                                    push ax</span><br><span class="line">                                    push bx</span><br><span class="line">                                    push cx</span><br><span class="line">                                    push es</span><br><span class="line"></span><br><span class="line">                                    in al,60h</span><br><span class="line">                                    pushf</span><br><span class="line">                                    call dword ptr cs:[200h];调用int 9的中断</span><br><span class="line"></span><br><span class="line">                                    cmp al,48h;F1--&gt;3bh         </span><br><span class="line">                                    jne int9ret</span><br><span class="line"></span><br><span class="line">                                    mov ax,0b800h</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov bx,1</span><br><span class="line">                                    mov cx,2000</span><br><span class="line">                                s:</span><br><span class="line">                                    inc byte ptr es:[bx]</span><br><span class="line">                                    add bx,2</span><br><span class="line">                                    loop s</span><br><span class="line"></span><br><span class="line">                          int9ret:  </span><br><span class="line">                                     pop es</span><br><span class="line">                                     pop cx</span><br><span class="line">                                     pop bx</span><br><span class="line">                                     pop ax</span><br><span class="line">                                     iret</span><br><span class="line">                          int9_end:  nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>



<p>运行之后你就可以按一下</p>
<h3 id="自己写了一遍-发现了很多的问题"><a href="#自己写了一遍-发现了很多的问题" class="headerlink" title="自己写了一遍..发现了很多的问题"></a>自己写了一遍..发现了很多的问题</h3><p>①. 程序没有不接收.你没有<code>mov ax,4c00h;int 21h</code></p>
<p>②. 对原有的中断向量表做了保存却不去修改原有的向量表</p>
<p>③. 我们是先键入,再调用int9去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 128 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">  db 128 dup(&#x27;D&#x27;)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">                                   </span><br><span class="line">                                    mov ax,stack</span><br><span class="line">                                    mov ss,ax </span><br><span class="line">                                    mov sp,128</span><br><span class="line"></span><br><span class="line">                                    mov ax,cs</span><br><span class="line">                                    mov ds,ax</span><br><span class="line">                                    mov si,offset init_int9</span><br><span class="line"></span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov di,204h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    mov cx , offset init_int9_end - offset init_int9                                  </span><br><span class="line">                                    cld</span><br><span class="line">                                    rep movsb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    push es:[9*4+0] </span><br><span class="line">                                    pop  es:[200h+0]</span><br><span class="line">                                    push es:[9*4+2]</span><br><span class="line">                                    pop  es:[200h+2] </span><br><span class="line">                                    </span><br><span class="line"></span><br><span class="line">                                    cli </span><br><span class="line">                                    mov word ptr es:[9*4],204h</span><br><span class="line">                                    mov word ptr es:[9*4+2],0</span><br><span class="line">                                    sti</span><br><span class="line"></span><br><span class="line">                                    mov ax,4c00h</span><br><span class="line">                                    int 21h</span><br><span class="line">                                  </span><br><span class="line">                          init_int9:</span><br><span class="line">                                    push ax</span><br><span class="line">                                    push es</span><br><span class="line">                                    push bx</span><br><span class="line">                                    push cx</span><br><span class="line">                                    </span><br><span class="line">                                    in al,60h</span><br><span class="line">                              </span><br><span class="line">                                    ;是先发生键入,再调用外中断</span><br><span class="line">                                    pushf</span><br><span class="line">                                    call dword ptr cs:[200h];这里有个问题,如果mov ax,0 mov ds,ax  call word ptr ds:[200h]就没有用</span><br><span class="line"></span><br><span class="line">                                    cmp al,48h</span><br><span class="line">                                    jne int9_ret</span><br><span class="line"></span><br><span class="line">                                    mov ax,0b800h</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov bx,1</span><br><span class="line">                                    mov cx,2000</span><br><span class="line">                    change_screen: </span><br><span class="line">                                    inc byte ptr es:[bx]</span><br><span class="line">                                    add bx,2</span><br><span class="line">                                    loop change_screen            </span><br><span class="line">                                    </span><br><span class="line">                          int9_ret:</span><br><span class="line">                                    pop cx</span><br><span class="line">                                    pop bx</span><br><span class="line">                                    pop es</span><br><span class="line">                                    pop ax</span><br><span class="line">                                    iret     </span><br><span class="line">                          init_int9_end:nop         </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>



<p>教材实验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">  db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">                                   </span><br><span class="line">                                    mov ax,stack</span><br><span class="line">                                    mov ss,ax</span><br><span class="line">                                    mov sp,32</span><br><span class="line"></span><br><span class="line">                                    push cs</span><br><span class="line">                                    pop  ds</span><br><span class="line">                                    mov  si,offset int9</span><br><span class="line"></span><br><span class="line">                                    mov ax,0</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov di,204h</span><br><span class="line"> </span><br><span class="line">                                    mov cx,offset int9_end - offset int9</span><br><span class="line"></span><br><span class="line">                                    cld</span><br><span class="line">                                    rep movsb</span><br><span class="line"></span><br><span class="line">                                    push es:[9*4+0]</span><br><span class="line">                                    pop  es:[200h+0]</span><br><span class="line">                                    push es:[9*4+2]</span><br><span class="line">                                    pop  es:[200h+2]</span><br><span class="line"></span><br><span class="line">                                    cli</span><br><span class="line">                                    mov word ptr es:[9*4+0],204h</span><br><span class="line">                                    mov word ptr es:[9*4+2],0</span><br><span class="line">                                    sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    mov ax,4c00h</span><br><span class="line">                                    int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                           int9:</span><br><span class="line">                                    push ax</span><br><span class="line">                                    push bx</span><br><span class="line">                                    push cx</span><br><span class="line">                                    push es</span><br><span class="line"></span><br><span class="line">                                    ;in al,60h</span><br><span class="line">                                    ;pushf</span><br><span class="line">                                    ;call dword ptr cs:[200h];调用int 9的中断</span><br><span class="line"></span><br><span class="line">                                    ;cmp al,3bh;F1--&gt;3bh         </span><br><span class="line">                                    ;jne int9ret</span><br><span class="line">                                    ;它探测的是你的断码..不是同码....因此就不用再去2次call int9</span><br><span class="line"></span><br><span class="line">                                    in al,60h</span><br><span class="line">                                    pushf</span><br><span class="line">                                    call dword ptr cs:[200h]</span><br><span class="line">                                    cmp al,3bh+80h</span><br><span class="line">                                    jne int9ret</span><br><span class="line">                              show:      </span><br><span class="line">                                    mov ax,0b800h</span><br><span class="line">                                    mov es,ax</span><br><span class="line">                                    mov bx,1</span><br><span class="line">                                    mov cx,1000</span><br><span class="line">                                s:</span><br><span class="line">                                    inc byte ptr es:[bx]</span><br><span class="line">                                    mov byte ptr es:[bx-1],&#x27;?&#x27;</span><br><span class="line">                                    add bx,2</span><br><span class="line">                                    loop s</span><br><span class="line"></span><br><span class="line">                          int9ret:  </span><br><span class="line">                                     pop es</span><br><span class="line">                                     pop cx</span><br><span class="line">                                     pop bx</span><br><span class="line">                                     pop ax</span><br><span class="line">                                     iret</span><br><span class="line">                          int9_end:  nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start      </span><br></pre></td></tr></table></figure>



<h3 id="DIY中断安装-执行4个函数的功能"><a href="#DIY中断安装-执行4个函数的功能" class="headerlink" title="DIY中断安装,执行4个函数的功能"></a>DIY中断安装,执行4个函数的功能</h3><p>出了很多的错</p>
<p>还是那些问题</p>
<p>①.</p>
<p>对整个代码的思路不是很清晰….老师写了一半发现自己写乱了..思路不明确</p>
<p>②.</p>
<p>提取了原有的中断到一定的位置去,却不修改原有的中断&#x3D;&#x3D;没有修改中断</p>
<p>③.</p>
<p>call far ptr但是错用ret..导致堆栈错误….不平衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 32 dup(&#x27;D&#x27;)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                                     </span><br><span class="line">                                        mov ax,stack</span><br><span class="line">                                        mov ss,ax</span><br><span class="line">                                        ;对整个代码的思路不是很清晰….老师写了一半发现自己写乱了..思路不明确</span><br><span class="line">                                        call init_int9</span><br><span class="line"></span><br><span class="line">                                        mov ax,4c00h</span><br><span class="line">                                        int 21h    </span><br><span class="line"></span><br><span class="line">                                init_int9:</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov ds,ax</span><br><span class="line"></span><br><span class="line">                                        push ds:[4*9+0]</span><br><span class="line">                                        pop  ds:[200h]</span><br><span class="line">                                        push ds:[4*9+2]</span><br><span class="line">                                        pop  ds:[202h]</span><br><span class="line"></span><br><span class="line">										;提取了原有的中断到一定的位置去,却不修改原有的中断==没有修改中断</span><br><span class="line">                                        cli</span><br><span class="line">                                        mov word ptr ds:[4*9+0],200h </span><br><span class="line">                                        mov word ptr ds:[4*9+2],0</span><br><span class="line">                                        sti</span><br><span class="line">                                        </span><br><span class="line">                                        ;源地址</span><br><span class="line">                                        push cs</span><br><span class="line">                                        pop ds</span><br><span class="line">                                        mov si,offset copy_start</span><br><span class="line">										;目的地址</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov es,ax</span><br><span class="line">                                        mov di,204h</span><br><span class="line">										;循环次数</span><br><span class="line">                                        mov cx,offset copy_end - offset copy_start</span><br><span class="line"></span><br><span class="line">                                        cld</span><br><span class="line">                                        rep movsb                                     </span><br><span class="line">                                        ret</span><br><span class="line">                                </span><br><span class="line">                                copy_start:</span><br><span class="line">                                            ;担心害怕就把所有的寄存器给备份</span><br><span class="line">                                            pushf</span><br><span class="line">                                            push ax</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push dx</span><br><span class="line">                                            push ds</span><br><span class="line">                                            push si</span><br><span class="line">                                            push es</span><br><span class="line">                                            push di</span><br><span class="line"></span><br><span class="line">											;获取扫描码</span><br><span class="line">                                            in al,60h</span><br><span class="line"></span><br><span class="line">                                            pushf</span><br><span class="line">                                            call dword ptr cs:[200h]</span><br><span class="line"></span><br><span class="line">                                            cmp al,2h;把扫描码与通码比较</span><br><span class="line">                                            je  set0</span><br><span class="line"></span><br><span class="line">                                            cmp al,3h;</span><br><span class="line">                                            je  set1</span><br><span class="line"></span><br><span class="line">                                            cmp al,4h;2</span><br><span class="line">                                            je  set2</span><br><span class="line"></span><br><span class="line">                                            cmp al,5h;3</span><br><span class="line">                                            je  set3</span><br><span class="line"></span><br><span class="line">                                            jmp real_ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    set0:   mov ah,0</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set1:   mov ah,1</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set2:   mov ah,2</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set3:   mov ah,3</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    do9_ret:</span><br><span class="line">                                            call setscreen</span><br><span class="line">                                            ;call far ptr但是错用ret..导致堆栈错误….不平衡</span><br><span class="line">                                    real_ret:</span><br><span class="line">                    </span><br><span class="line">                                            pop di</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop si</span><br><span class="line">                                            pop ds</span><br><span class="line">                                            pop dx</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            pop ax</span><br><span class="line">                                            popf</span><br><span class="line"></span><br><span class="line">                                            iret</span><br><span class="line"></span><br><span class="line">                                        ;做一个屏幕的清理 ------------------ </span><br><span class="line">                                        ;初始会配置</span><br><span class="line">                                        setscreen:</span><br><span class="line">                                            push ax</span><br><span class="line"></span><br><span class="line">                                            cmp ah,0</span><br><span class="line">                                            je do1</span><br><span class="line">                                            cmp ah,1</span><br><span class="line">                                            je do2</span><br><span class="line">                                            cmp ah,2</span><br><span class="line">                                            je do3</span><br><span class="line">                                            cmp ah,3</span><br><span class="line">                                            je do4  </span><br><span class="line">                                            jmp sret</span><br><span class="line"></span><br><span class="line">                                        do1:</span><br><span class="line">                                            call sub1</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do2:</span><br><span class="line">                                            call sub2</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do3:</span><br><span class="line">                                            call sub3</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do4:</span><br><span class="line">                                            call sub4</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        sret:</span><br><span class="line"></span><br><span class="line">                                            pop ax</span><br><span class="line">                                            ret </span><br><span class="line"></span><br><span class="line">                                        sub1:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line"></span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line">                                            mov bx,0</span><br><span class="line">                                            mov cx,2000</span><br><span class="line">                                        subls:</span><br><span class="line">                                            mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">                                            mov byte ptr es:[bx+1],0</span><br><span class="line">                                            add bx,2</span><br><span class="line"></span><br><span class="line">                                            loop subls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                        ;设置前景色-------------------</span><br><span class="line">                                        sub2:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ax</span><br><span class="line"></span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line"></span><br><span class="line">                                            mov bx,1</span><br><span class="line"></span><br><span class="line">                                            mov cx,2000</span><br><span class="line"></span><br><span class="line">                                        sub2s:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            mov al,byte ptr es:[bx]   </span><br><span class="line">                                            mov ah,al                                  </span><br><span class="line">                                            mov cl,4</span><br><span class="line"></span><br><span class="line">                                            ;头4位</span><br><span class="line">                                            shr al,cl</span><br><span class="line">                                            inc al</span><br><span class="line">                                            shl al,cl</span><br><span class="line"></span><br><span class="line">                                            shl ah,cl</span><br><span class="line">                                            shr ah,cl</span><br><span class="line"></span><br><span class="line">                                            or al,ah</span><br><span class="line"></span><br><span class="line">                                            mov byte ptr es:[bx],al</span><br><span class="line">                                            add bx,2</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub2s</span><br><span class="line"></span><br><span class="line">                                            pop ax</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                            ;设置背景色----------------------------</span><br><span class="line">                                        sub3:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ax</span><br><span class="line"></span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line"></span><br><span class="line">                                            mov bx,1</span><br><span class="line"></span><br><span class="line">                                            mov cx,2000</span><br><span class="line"></span><br><span class="line">                                        sub3s:</span><br><span class="line">                                            push cx</span><br><span class="line"></span><br><span class="line">                                            mov al,byte ptr es:[bx]</span><br><span class="line">                                            mov ah,al</span><br><span class="line"></span><br><span class="line">                                            mov cl,4</span><br><span class="line">                                            ;后4位</span><br><span class="line">                                            ;我是u怎么发现问题的????</span><br><span class="line">                                            ;还是对位运算不理解呀....</span><br><span class="line">                                            shl al,cl</span><br><span class="line">                                            shr al,cl                                          </span><br><span class="line">                                            inc al</span><br><span class="line">                                            </span><br><span class="line">                                            shr ah,cl</span><br><span class="line">                                            shl ah,cl</span><br><span class="line"></span><br><span class="line">                                            or al,ah</span><br><span class="line">                                            ;mov al,11001010b;我是怎么发现问题的?????对里面的参数去做修改,然后看发生了什么变化</span><br><span class="line">                                            mov byte ptr es:[bx],al</span><br><span class="line">                                            add bx,2</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub3s</span><br><span class="line"></span><br><span class="line">                                            pop ax</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                        sub4:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push si</span><br><span class="line">                                            push di</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ds</span><br><span class="line">                                            </span><br><span class="line">                                            mov si,0b800h</span><br><span class="line">                                            mov es,si</span><br><span class="line">                                            mov ds,si</span><br><span class="line">                                            mov si,160;指向[1]第二行</span><br><span class="line">                                            mov di,0;指向[0]第一行</span><br><span class="line">                                            cld</span><br><span class="line">                                            mov cx,24;指向[24]最后一行</span><br><span class="line"></span><br><span class="line">                                            ;处理1行来上移</span><br><span class="line">                                        sub4s:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            mov cx,160</span><br><span class="line">                                            rep movsb</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub4s</span><br><span class="line">                                            mov cx,80</span><br><span class="line">                                            mov si,0</span><br><span class="line">                                            ;最后一行置空</span><br><span class="line">                                        sub4s1:</span><br><span class="line">                                            mov byte ptr [160*24+si],&#x27;?&#x27;</span><br><span class="line">                                            mov byte ptr [160*24+si+1],0</span><br><span class="line">                                            add si,2</span><br><span class="line">                                            loop sub4s1</span><br><span class="line"></span><br><span class="line">                                            pop ds</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop di</span><br><span class="line">                                            pop si</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            ret                                              </span><br><span class="line">                            copy_end:       nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>如何让做到inc每个配置??????????????</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 32 dup(&#x27;S&#x27;)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 32 dup(&#x27;D&#x27;)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:                                     </span><br><span class="line">                                        mov ax,stack</span><br><span class="line">                                        mov ss,ax</span><br><span class="line"></span><br><span class="line">                                        call init_int9</span><br><span class="line"></span><br><span class="line">                                        mov ax,4c00h</span><br><span class="line">                                        int 21h    </span><br><span class="line"></span><br><span class="line">                                init_int9:</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov ds,ax</span><br><span class="line"></span><br><span class="line">                                        push ds:[4*9+0]</span><br><span class="line">                                        pop  ds:[200h]</span><br><span class="line">                                        push ds:[4*9+2]</span><br><span class="line">                                        pop  ds:[202h]</span><br><span class="line"></span><br><span class="line">										;错误②</span><br><span class="line">                                        cli</span><br><span class="line">                                        mov word ptr ds:[4*9+0],200h </span><br><span class="line">                                        mov word ptr ds:[4*9+2],0</span><br><span class="line">                                        sti</span><br><span class="line">                                        </span><br><span class="line">                                        ;源地址</span><br><span class="line">                                        push cs</span><br><span class="line">                                        pop ds</span><br><span class="line">                                        mov si,offset copy_start</span><br><span class="line">										;目的地址</span><br><span class="line">                                        mov ax,0</span><br><span class="line">                                        mov es,ax</span><br><span class="line">                                        mov di,204h</span><br><span class="line">										;循环次数</span><br><span class="line">                                        mov cx,offset copy_end - offset copy_start</span><br><span class="line"></span><br><span class="line">                                        cld</span><br><span class="line">                                        rep movsb                                     </span><br><span class="line">                                        ret</span><br><span class="line">                                </span><br><span class="line">                                copy_start:</span><br><span class="line">                                			;担心害怕就把所有的寄存器给备份</span><br><span class="line">                                			pushf</span><br><span class="line">                                            push ax</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push dx</span><br><span class="line">                                            push ds</span><br><span class="line">                                            push si</span><br><span class="line">                                            push es</span><br><span class="line">                                            push di</span><br><span class="line">											;获取扫描码</span><br><span class="line">                                            in al,60h</span><br><span class="line">                                            pushf</span><br><span class="line">                                            call dword ptr cs:[200h]</span><br><span class="line"></span><br><span class="line">                                            cmp al,2;把扫描码与通码比较</span><br><span class="line">                                            je  set0</span><br><span class="line"></span><br><span class="line">                                            cmp al,3;</span><br><span class="line">                                            je  set1</span><br><span class="line"></span><br><span class="line">                                            cmp al,4;2</span><br><span class="line">                                            je  set2</span><br><span class="line"></span><br><span class="line">                                            cmp al,5;3</span><br><span class="line">                                            je  set3</span><br><span class="line"></span><br><span class="line">                                            jmp real_ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    set0:   mov ah,0</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set1:   mov ah,1</span><br><span class="line">                                            ;mov al,00000010b</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set2:   mov ah,2</span><br><span class="line">                                            ;mov al,10100000b</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line">                                    set3:   mov ah,2</span><br><span class="line">                                            jmp do9_ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    do9_ret:</span><br><span class="line">                                            call setscreen</span><br><span class="line">                                    real_ret:</span><br><span class="line">                    </span><br><span class="line">                                            pop di</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop si</span><br><span class="line">                                            pop ds</span><br><span class="line">                                            pop dx</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            pop ax</span><br><span class="line">                                            popf</span><br><span class="line"></span><br><span class="line">                                            iret</span><br><span class="line"></span><br><span class="line">                                        ;做一个屏幕的清理 ------------------ </span><br><span class="line">                                        ;初始会配置</span><br><span class="line">                                        setscreen:</span><br><span class="line">                                            cmp ah,0</span><br><span class="line">                                            je do1</span><br><span class="line">                                            cmp ah,1</span><br><span class="line">                                            je do2</span><br><span class="line">                                            cmp ah,2</span><br><span class="line">                                            je do3</span><br><span class="line">                                            cmp ah,3</span><br><span class="line">                                            je do4  </span><br><span class="line">                                            jmp sret</span><br><span class="line"></span><br><span class="line">                                        do1:</span><br><span class="line">                                            call sub1</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do2:</span><br><span class="line">                                            call sub2</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do3:</span><br><span class="line">                                            call sub3</span><br><span class="line">                                            jmp short sret</span><br><span class="line">                                        do4:</span><br><span class="line">                                            call sub4</span><br><span class="line">                                        sret:</span><br><span class="line">                                            ret </span><br><span class="line"></span><br><span class="line">                                        sub1:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line">                                            mov bx,0</span><br><span class="line">                                            mov cx,2000</span><br><span class="line">                                        subls:</span><br><span class="line">                                            mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">                                            or  byte ptr es:[bx+1],0</span><br><span class="line">                                            add bx,2</span><br><span class="line"></span><br><span class="line">                                            loop subls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                        ;设置前景色-------------------</span><br><span class="line">                                        sub2:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ax</span><br><span class="line"></span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line">                                            mov bx,1</span><br><span class="line">                                            mov cx,2000</span><br><span class="line">                                        sub2s:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            mov al,byte ptr es:[bx]   </span><br><span class="line">                                            mov ah,al                                  </span><br><span class="line">                                            mov cl,4</span><br><span class="line"></span><br><span class="line">                                            ;头4位</span><br><span class="line">                                            shr al,cl</span><br><span class="line">                                            inc al</span><br><span class="line">                                            shl al,cl</span><br><span class="line"></span><br><span class="line">                                            shl ah,cl</span><br><span class="line">                                            shr ah,cl</span><br><span class="line"></span><br><span class="line">                                            or al,ah</span><br><span class="line"></span><br><span class="line">                                            mov byte ptr es:[bx],al</span><br><span class="line">                                            add bx,2</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub2s</span><br><span class="line"></span><br><span class="line">                                            pop ax</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                            ;设置背景色----------------------------</span><br><span class="line">                                        sub3:</span><br><span class="line">                                            push bx</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ax</span><br><span class="line"></span><br><span class="line">                                            mov bx,0b800h</span><br><span class="line">                                            mov es,bx</span><br><span class="line">                                            mov bx,1</span><br><span class="line">                                            mov cx,2000</span><br><span class="line"></span><br><span class="line">                                        sub3s:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            mov al,byte ptr es:[bx]</span><br><span class="line">                                            mov ah,al</span><br><span class="line">                                            mov cl,4</span><br><span class="line">                                            ;后4位</span><br><span class="line">                                            shl al,cl</span><br><span class="line">                                            inc al</span><br><span class="line">                                            shr al,cl</span><br><span class="line"></span><br><span class="line">                                            shr ah,cl</span><br><span class="line">                                            shl ah,cl</span><br><span class="line"></span><br><span class="line">                                            or al,ah</span><br><span class="line"></span><br><span class="line">                                            mov byte ptr es:[bx],al</span><br><span class="line">                                            add bx,2</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub3s</span><br><span class="line"></span><br><span class="line">                                            pop ax</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            pop bx</span><br><span class="line">                                            ret </span><br><span class="line">                                        sub4:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            push si</span><br><span class="line">                                            push di</span><br><span class="line">                                            push es</span><br><span class="line">                                            push ds</span><br><span class="line">                                            </span><br><span class="line">                                            mov si,0b800h</span><br><span class="line">                                            mov es,si</span><br><span class="line">                                            mov ds,si</span><br><span class="line">                                            mov si,160;指向[1]第二行</span><br><span class="line">                                            mov di,0;指向[0]第一行</span><br><span class="line">                                            cld</span><br><span class="line">                                            mov cx,24;指向[24]最后一行</span><br><span class="line"></span><br><span class="line">                                            ;处理1行来上移</span><br><span class="line">                                        sub4s:</span><br><span class="line">                                            push cx</span><br><span class="line">                                            mov cx,160</span><br><span class="line">                                            rep movsb</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            loop sub4s</span><br><span class="line">                                            mov cx,80</span><br><span class="line">                                            mov si,0</span><br><span class="line">                                            ;最后一行置空</span><br><span class="line">                                        sub4s1:</span><br><span class="line">                                            mov byte ptr [160*24+si],&#x27;?&#x27;</span><br><span class="line">                                            mov byte ptr [160*24+si+1],0</span><br><span class="line">                                            add si,2</span><br><span class="line">                                            loop sub4s1</span><br><span class="line"></span><br><span class="line">                                            pop ds</span><br><span class="line">                                            pop es</span><br><span class="line">                                            pop di</span><br><span class="line">                                            pop si</span><br><span class="line">                                            pop cx</span><br><span class="line">                                            ret       </span><br><span class="line"></span><br><span class="line">                                        </span><br><span class="line">                            copy_end: nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h3 id="8086CPU-gt-div的Interger-over-flow解决方案"><a href="#8086CPU-gt-div的Interger-over-flow解决方案" class="headerlink" title="8086CPU-&gt;div的Interger_over_flow解决方案"></a>8086CPU-&gt;div的Interger_over_flow解决方案</h3><p>这里系统自动把结果的低16位给了ax</p>
<p>我们人为的把结果的高16位给了dx</p>
<p>人为的把余数放在cx中</p>
<p>使得溢出的数据不再丢失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">     dd 1234567 ;87 D6 12 00</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">    call div_number   </span><br><span class="line"></span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">div_number:</span><br><span class="line">    ;87 D6 12 00  0x0012D687</span><br><span class="line">    mov ax,ds:[0]   ;0xD687 </span><br><span class="line">    mov dx,ds:[2]   ;0x0012</span><br><span class="line"></span><br><span class="line">    mov cx,10        </span><br><span class="line">    push ax         ;push 0xD687</span><br><span class="line">    mov bp,sp</span><br><span class="line">    ;取bp,自动向下获取数据</span><br><span class="line"></span><br><span class="line">    call long_div</span><br><span class="line">    add sp,2</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">long_div:</span><br><span class="line">    mov ax,dx       ;ax=高8位</span><br><span class="line">    mov dx,0        ;dx=0,避免干扰</span><br><span class="line">    div cx          ;</span><br><span class="line">    push ax         ;把高位的数据保存一下,余数作为低位除法的高位</span><br><span class="line">    </span><br><span class="line">    mov ax,ss:[bp]  ;bp记录了低8位原始数据的地址,ax=低8位</span><br><span class="line">    div cx          ;</span><br><span class="line">    mov cx,dx       ;我们自定义把最后的余数给了cx</span><br><span class="line">    pop dx          ;把溢出的数据给了dx</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>例子就是</p>
<p> <img src="/re4mile/../../../../Img/Asm-%E5%AE%9E%E8%B7%B5/image-20221025005544886.png" alt="image-20221025005544886"></p>
<p>自我尝试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;=======================================================</span><br><span class="line">assume cs:code , ds:data, ss:stack</span><br><span class="line">;=======================================================</span><br><span class="line">;数据源S</span><br><span class="line">data segment</span><br><span class="line">     dd 1234567</span><br><span class="line">data ends  </span><br><span class="line"> ;=======================================================</span><br><span class="line">;栈段</span><br><span class="line">stack segment stack</span><br><span class="line">     db 128 dup(&#x27;y&#x27;)</span><br><span class="line">stack ends</span><br><span class="line">;=======================================================</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"> ;main code  </span><br><span class="line"> ;=======================================================</span><br><span class="line">    ;数据源S</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,0</span><br><span class="line">        </span><br><span class="line">    ;数据地D</span><br><span class="line">    mov ax,7e00h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">        </span><br><span class="line">    ;栈</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">               </span><br><span class="line">;=======================================================       </span><br><span class="line">    mov ax,ds:[0]</span><br><span class="line">    mov dx,ds:[2]</span><br><span class="line">    mov cx,10</span><br><span class="line"></span><br><span class="line">    push ax</span><br><span class="line">    mov bp,sp</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,0</span><br><span class="line">    div cx</span><br><span class="line"></span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,ss:[bp]</span><br><span class="line">    div cx</span><br><span class="line">    </span><br><span class="line">    mov cx,dx</span><br><span class="line">    pop dx</span><br><span class="line"></span><br><span class="line">    add sp,2;堆栈的平衡</span><br><span class="line">over:    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;=======================================================         </span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">           </span><br><span class="line">;=======================================================  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;=======================================================</span><br></pre></td></tr></table></figure>

<p>它背后的思想是什么?</p>
<p>把数据大数化小,然后一句不变的性质取解除答案</p>
<p>再次书写出现的问题</p>
<p>1.老是忘记mov dx,0</p>
<p>2.add sp,2没有加对位置</p>
<p>3.对于ASCII的打印还不是很理解</p>
<h2 id="x86-课堂代码"><a href="#x86-课堂代码" class="headerlink" title="x86 课堂代码"></a>x86 课堂代码</h2><h3 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h3><p>我的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Dqx_Gh0st</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD	</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	arr1		db  &quot;hello,I am dqx_Gh0st&quot;,0</span><br><span class="line">	arr2		db   sizeof arr1 dup(0)</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">						xor eax,eax                                                                                                                                                                                        </span><br><span class="line">						mov ecx ,sizeof arr1</span><br><span class="line">						mov esi , offset arr1</span><br><span class="line">						mov edi, offset arr2</span><br><span class="line">add_num:</span><br><span class="line">						mov al,[esi]</span><br><span class="line">						mov  [edi],al</span><br><span class="line">						inc	esi</span><br><span class="line">						inc	edi</span><br><span class="line">						loop add_num</span><br><span class="line">			</span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<p>书上的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">						xor eax,eax                                                                                                                                                                                        </span><br><span class="line">						mov ecx ,sizeof arr1</span><br><span class="line">						mov esi , 0</span><br><span class="line">add_num:</span><br><span class="line">						mov al,arr1[esi]</span><br><span class="line">						mov  arr2[esi],al</span><br><span class="line">						inc	esi</span><br><span class="line">						loop add_num</span><br></pre></td></tr></table></figure>





<h3 id="逆序字符串-IDA无法调试-xdebug可以"><a href="#逆序字符串-IDA无法调试-xdebug可以" class="headerlink" title="逆序字符串,IDA无法调试,xdebug可以"></a>逆序字符串,IDA无法调试,xdebug可以</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Dqx_Gh0st</span><br><span class="line"></span><br><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD	</span><br><span class="line">.stack 128</span><br><span class="line">.data</span><br><span class="line">	arr1	BYTE  &quot;I am Dqx_Gh0st!&quot;,0</span><br><span class="line">	len=($-arr1)-1</span><br><span class="line">	arr2  db   len dup (0)</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">						xor eax,eax                                                                                                                                                                                        </span><br><span class="line">						mov ecx,len</span><br><span class="line">						mov esi,offset arr1</span><br><span class="line">		push_str:</span><br><span class="line">						mov al,byte ptr [esi]</span><br><span class="line">						push ax</span><br><span class="line">						inc esi</span><br><span class="line">						loop push_str</span><br><span class="line"></span><br><span class="line">						mov ecx,len</span><br><span class="line">						mov edi,offset arr2</span><br><span class="line">		pop_str:</span><br><span class="line">						pop ax</span><br><span class="line">						mov byte ptr [edi],al</span><br><span class="line">						inc edi</span><br><span class="line">						loop pop_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		INVOKE	ExitProcess,0</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>





<h3 id="strcmp-汇编版-无高级调用"><a href="#strcmp-汇编版-无高级调用" class="headerlink" title="strcmp 汇编版-无高级调用"></a>strcmp 汇编版-无高级调用</h3><p>2个比较的字符串数据长度不一致</p>
<p>1️⃣.结果肯定是不相等</p>
<p>2️⃣.我们还是在小的范围里面比较一下</p>
<p>比较情况</p>
<p>1️⃣.数据尺度一致,一直比较到字符串不相等的地方</p>
<p>2️⃣.数据尺度不一致</p>
<p>在前面长度内,他们的数据都一样,导致ZF一直为1,如果你通过检测到0而采取退出的话,最后的ZF就还是1,而逻辑上的ZF&#x3D;0,毕竟他们不相等</p>
<p>因此,就算我们检测到0,也还是要比较一下,除非2个字符串都检测到0,说明前面都相等,后面也就0,0自然也相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;abcdABCD&quot;,0</span><br><span class="line">B1	db	&quot;abcdabcd&quot;,0</span><br><span class="line">len	dd	lengthof A1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">strcmp proto :ptr byte,:ptr byte</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	strcmp,addr A1,addr B1</span><br><span class="line">over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">;--------------------------------------</span><br><span class="line">strcmp proc uses eax edx esi edi,str1:ptr byte,str2:ptr byte</span><br><span class="line">		mov esi, str1</span><br><span class="line">		mov edi, str2</span><br><span class="line">check_continue: </span><br><span class="line">		mov al, [esi]</span><br><span class="line">		mov dl, [edi]</span><br><span class="line">		cmp al, 0            </span><br><span class="line">		jne check             </span><br><span class="line">		cmp dl, 0           </span><br><span class="line">		jne check </span><br><span class="line">        ;上面2个cmp操作</span><br><span class="line">        ;当最后字符串末尾都是0就不再检查</span><br><span class="line">        ;如果其中一个是0,另外一个不是0,那么cmp一下,肯定不相等</span><br><span class="line">		jmp no_check             </span><br><span class="line">check:              </span><br><span class="line">		cmp al,dl</span><br><span class="line">		pushfd</span><br><span class="line">		inc esi              </span><br><span class="line">		inc edi </span><br><span class="line">		popfd</span><br><span class="line">		je  check_continue</span><br><span class="line">no_check: </span><br><span class="line">		ret                 </span><br><span class="line">strcmp endp</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>inc会影响ZF寄存器,woc</p>
<h3 id="strlen-汇编版-无高级调用"><a href="#strlen-汇编版-无高级调用" class="headerlink" title="strlen 汇编版-无高级调用"></a>strlen 汇编版-无高级调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;abcd&quot;,0</span><br><span class="line">B1	db	&quot;abcdabcd&quot;,0</span><br><span class="line">len	dd	lengthof A1</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">strlen proto :ptr byte</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	strlen,addr A1</span><br><span class="line">over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line"></span><br><span class="line">;--------------------------------------</span><br><span class="line">strlen proc uses edi,pStr:ptr byte   </span><br><span class="line"></span><br><span class="line">		mov edi, pStr       </span><br><span class="line">		mov eax, 0            </span><br><span class="line">check_continue:	</span><br><span class="line">		cmp byte ptr [edi],0</span><br><span class="line">		je  check_end                 </span><br><span class="line">		inc edi                </span><br><span class="line">		inc eax                </span><br><span class="line">		jmp  check_continue</span><br><span class="line">check_end: </span><br><span class="line">		ret</span><br><span class="line">strlen endp</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="有输入的strlen"><a href="#有输入的strlen" class="headerlink" title="有输入的strlen"></a>有输入的strlen</h3><p>值得注意的是,scanf遇到输入空格就会停止,所以你在键入的时候,就不要输入空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include Dqx.inc</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data			</span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">arr	db	128 dup(0)</span><br><span class="line">in_fmt	db	&quot;%s&quot;,0</span><br><span class="line">out_fmt db	&quot;%d&quot;,0</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code </span><br><span class="line">start:</span><br><span class="line">		</span><br><span class="line">		invoke scanf,offset in_fmt, offset arr</span><br><span class="line"></span><br><span class="line">		mov al,0</span><br><span class="line">		lea edi,arr</span><br><span class="line">		mov ecx,10</span><br><span class="line">		cld</span><br><span class="line">		repne scasb</span><br><span class="line">		dec edi</span><br><span class="line"></span><br><span class="line">		lea eax,arr</span><br><span class="line">		sub edi,eax</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		invoke	printf,addr out_fmt,edi</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="strcpy-汇编版-无高级调用"><a href="#strcpy-汇编版-无高级调用" class="headerlink" title="strcpy 汇编版-无高级调用"></a>strcpy 汇编版-无高级调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;Dqx&quot;,0</span><br><span class="line">len	=	lengthof A1</span><br><span class="line">B1	db	len dup (0)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">Strcopy proto source:PTR BYTE,  target:PTR BYTE  </span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	Strcopy ,addr A1,addr B1</span><br><span class="line">over:</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line">;--------------------------------------</span><br><span class="line">;--------------------------------------</span><br><span class="line">Strcopy PROC USES eax ecx esi edi,</span><br><span class="line">    source:PTR BYTE,       ; source string</span><br><span class="line">    target:PTR BYTE        ; target string</span><br><span class="line">;将字符串从源串复制到目的串。</span><br><span class="line">;要求：目标串必须有足够空间容纳从源复制来的串。</span><br><span class="line">;--------------------------------------</span><br><span class="line">    mov		ecx,len             </span><br><span class="line">    mov		esi, source</span><br><span class="line">    mov		edi, target</span><br><span class="line">    cld                            ;</span><br><span class="line">    rep		movsb                  </span><br><span class="line">    ret</span><br><span class="line">Strcopy ENDP</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="strtrim-删除末尾特定的字符"><a href="#strtrim-删除末尾特定的字符" class="headerlink" title="strtrim 删除末尾特定的字符"></a>strtrim 删除末尾特定的字符</h3><p>就一个字符串,假设末尾有字符”#”,然后我们就把它删除</p>
<p>这个函数的巧妙之处就是它是从后面开始遍历的,而不是从头开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;Dqx##&quot;,0</span><br><span class="line">len	=	lengthof A1</span><br><span class="line">B1	db	len dup (0)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">Strtrim proto source:PTR BYTE, : BYTE  </span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	Strtrim ,addr A1,&quot;#&quot;</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line">;--------------------------------------</span><br><span class="line">;Str_trim</span><br><span class="line">;从字符串末尾删除所有与给定分隔符匹配的字符。</span><br><span class="line">;返回：无</span><br><span class="line">;-------------------------------------</span><br><span class="line">Strtrim PROC USES eax ecx edi,</span><br><span class="line">	pStr:PTR BYTE,                </span><br><span class="line">	char: BYTE                       </span><br><span class="line">	mov edi,pStr                  </span><br><span class="line">	mov eax,len-1   ;我们用len计算的长度是+上了最后一个字节了的        </span><br><span class="line">	cmp eax,0        ;长度为0,就结束这里的bug就是长度为0,0-1=无符号的大数                </span><br><span class="line">	je	over                      </span><br><span class="line">	mov ecx, eax                     </span><br><span class="line">	dec eax	</span><br><span class="line">	add edi,eax	;让inde指向最后一个                    </span><br><span class="line">check_continue:</span><br><span class="line">	mov al, [edi]                 </span><br><span class="line">	cmp al,char                </span><br><span class="line">	jne get_it                        </span><br><span class="line">	dec edi                       </span><br><span class="line">	loop check_continue                  </span><br><span class="line">get_it: </span><br><span class="line">	mov BYTE PTR [edi+1 ],0         </span><br><span class="line">over:</span><br><span class="line">	ret</span><br><span class="line">Strtrim ENDP</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>





<h3 id="toupper-字符串大写话"><a href="#toupper-字符串大写话" class="headerlink" title="toupper 字符串大写话"></a>toupper 字符串大写话</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I_am_Dqx_Gh0st&quot;,0</span><br><span class="line">len	=	lengthof A1</span><br><span class="line">B1	db	len dup (0)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">toupper proto source:PTR BYTE</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	toupper ,addr A1</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line">;--------------------------------------</span><br><span class="line">;Str_trim</span><br><span class="line">;从字符串末尾删除所有与给定分隔符匹配的字符。</span><br><span class="line">;返回：无</span><br><span class="line">;-------------------------------------</span><br><span class="line">;---------------------------------</span><br><span class="line">;Str_ucase</span><br><span class="line">;将空字节结束的字符串转换为大写字母。</span><br><span class="line">;返回：无</span><br><span class="line">;---------------------------------</span><br><span class="line">toupper proc uses eax esi,</span><br><span class="line">	pStr:PTR BYTE</span><br><span class="line">	mov esi,pStr</span><br><span class="line">work:</span><br><span class="line">	mov al, [esi]           ;取字符</span><br><span class="line">	cmp al, 0               ;字符串是否结束？</span><br><span class="line">	je over                   ;是：退出</span><br><span class="line">	cmp al, &#x27;a&#x27;             ;小于&quot;a&quot; ？</span><br><span class="line">	jb next</span><br><span class="line">	cmp al, &#x27;z&#x27;             ;大于&quot;z&quot; ？</span><br><span class="line">	ja next</span><br><span class="line">	and byte ptr [esi], 11011111b ;转换字符</span><br><span class="line">next:	</span><br><span class="line">	inc esi                 ;下一个字符</span><br><span class="line">	jmp work</span><br><span class="line">over:	ret</span><br><span class="line">toupper endp</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="tolower-字符串小写化"><a href="#tolower-字符串小写化" class="headerlink" title="tolower 字符串小写化"></a>tolower 字符串小写化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include		Dqx.inc</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data</span><br><span class="line">;--------------------------------------------------------		</span><br><span class="line">A1	db	&quot;I_am_Dqx_Gh0st&quot;,0</span><br><span class="line">len	=	lengthof A1</span><br><span class="line">B1	db	len dup (0)</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		;function</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">toupper proto source:PTR BYTE</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">		.code</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	invoke	toupper ,addr A1</span><br><span class="line">	invoke	ExitProcess,NULL</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">;function</span><br><span class="line">;--------------------------------------</span><br><span class="line">;Str_trim</span><br><span class="line">;从字符串末尾删除所有与给定分隔符匹配的字符。</span><br><span class="line">;返回：无</span><br><span class="line">;-------------------------------------</span><br><span class="line">;---------------------------------</span><br><span class="line">;Str_ucase</span><br><span class="line">;将空字节结束的字符串转换为大写字母。</span><br><span class="line">;返回：无</span><br><span class="line">;---------------------------------</span><br><span class="line">toupper proc uses eax esi,</span><br><span class="line">	pStr:PTR BYTE</span><br><span class="line">	mov esi,pStr</span><br><span class="line">work:</span><br><span class="line">	mov al, [esi]           ;取字符</span><br><span class="line">	cmp al, 0               ;字符串是否结束？</span><br><span class="line">	je over                   ;是：退出</span><br><span class="line">	cmp al, &#x27;A&#x27;             ;小于&quot;a&quot; ？</span><br><span class="line">	jb next</span><br><span class="line">	cmp al, &#x27;Z&#x27;             ;大于&quot;z&quot; ？</span><br><span class="line">	ja next</span><br><span class="line">	or byte ptr [esi], 00100000b ;转换字符</span><br><span class="line">next:	</span><br><span class="line">	inc esi                 ;下一个字符</span><br><span class="line">	jmp work</span><br><span class="line">over:	ret</span><br><span class="line">toupper endp</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">end	start</span><br><span class="line">;--------------------------------------------------------</span><br></pre></td></tr></table></figure>



<h3 id="asm-两数相加"><a href="#asm-两数相加" class="headerlink" title="__asm 两数相加"></a>__asm 两数相加</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax,x</span><br><span class="line">		add eax,y</span><br><span class="line">		mov z,eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,z);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的相加</p>
<h3 id="asm-数组求和"><a href="#asm-数组求和" class="headerlink" title="__asm 数组求和"></a>__asm 数组求和</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len=<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wecome to my world\n&quot;</span>);</span><br><span class="line">	sum=func(arr,len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov esi,arr</span><br><span class="line">		mov ecx,len</span><br><span class="line">		mov ebx,<span class="number">0</span></span><br><span class="line">		mov eax,<span class="number">0</span></span><br><span class="line">		flag:</span><br><span class="line">			add eax,[esi+ebx*<span class="number">4</span>]</span><br><span class="line">			inc ebx</span><br><span class="line">		loop flag</span><br><span class="line">		mov sum,eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别看你在func函数里面只写了几句汇编,其实你的func函数还是有很多的东西的</p>
<p>好比寄存器的入栈,函数栈的开辟</p>
<h3 id="asm-10进制value-gt-2进制字符串"><a href="#asm-10进制value-gt-2进制字符串" class="headerlink" title="__asm 10进制value-&gt;2进制字符串"></a>__asm 10进制value-&gt;2进制字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wecome to my world\n&quot;</span>);</span><br><span class="line">	func(<span class="number">52</span>,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Dec %d= Bin %s\n&quot;</span>,<span class="number">52</span>,str);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> value,<span class="type">char</span> *<span class="built_in">string</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov esi,<span class="built_in">string</span></span><br><span class="line">		mov eax,value</span><br><span class="line">		mov byte ptr [esi],<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="comment">//数值最高位是0,字符串最低位是0</span></span><br><span class="line">		bsr ecx,value</span><br><span class="line">		jz over</span><br><span class="line">		mov byte ptr[esi],<span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="comment">//数值最高位是1,字符串最低位是1</span></span><br><span class="line">		</span><br><span class="line">		flag:</span><br><span class="line">			bt value,<span class="number">0</span></span><br><span class="line">			adc byte ptr[esi+ecx],<span class="string">&#x27;0&#x27;</span></span><br><span class="line">            <span class="comment">//把字符串从最高位往最低位初始化</span></span><br><span class="line">            <span class="comment">//数值从最低位到最高位读取</span></span><br><span class="line">			shr value,<span class="number">1</span></span><br><span class="line">		loop flag</span><br><span class="line">		over:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于bsr指令和bt指令,见目录寻找</p>
<h3 id="取余运算-难看"><a href="#取余运算-难看" class="headerlink" title="取余运算,难看"></a>取余运算,难看</h3><p>C码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((c+1) % 8 == 0) </span><br><span class="line">    printf(&quot; &quot;);</span><br></pre></td></tr></table></figure>

<p>IDA码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add     rax, 1</span><br><span class="line">and     eax, 7          ; 这是一个取模的运输</span><br><span class="line">test    rax, rax        ; rax=0,ZF=1</span><br><span class="line">jnz     short loc_401384</span><br></pre></td></tr></table></figure>



<p>7的二进制00000111</p>
<p>当一个数是0,&amp;7才会是0,其他情况都是非0</p>
<p>所以从0到111,就是一个循环</p>
<h3 id="处理-输入-x2F-输出-溢出"><a href="#处理-输入-x2F-输出-溢出" class="headerlink" title="处理 输入&#x2F;输出 溢出"></a>处理 输入&#x2F;输出 溢出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; console2.asm</span><br><span class="line"></span><br><span class="line">section .data							</span><br><span class="line">	msg1	    db    	&quot;Hello, World!&quot;,10,0			</span><br><span class="line">   	msg2  	    db   	&quot;Your turn (only a-z): &quot;,0</span><br><span class="line">  	msg3  	    db    	&quot;You answered: &quot;,0</span><br><span class="line">  	inputlen    equ 	10			;inputbuffer</span><br><span class="line">	NL		    db		0xa					</span><br><span class="line">	</span><br><span class="line">section .bss							</span><br><span class="line">  	input       resb    inputlen+1 		;provide space for ending 0</span><br><span class="line">section .text							</span><br><span class="line">	global main						</span><br><span class="line">main:</span><br><span class="line">    push	rbp </span><br><span class="line">    mov 	rbp,rsp</span><br><span class="line">	mov 	rdi, msg1     	; print first string </span><br><span class="line">	call 	prints   </span><br><span class="line">	 </span><br><span class="line">	mov 	rdi, msg2	; print second string, no NL </span><br><span class="line">	call 	prints</span><br><span class="line">	</span><br><span class="line">	mov 	rdi, input    	; address of inputbuffer</span><br><span class="line">	mov 	rsi, inputlen	; length of inputbuffer </span><br><span class="line">	call 	reads			; wait for input </span><br><span class="line">	</span><br><span class="line">	mov 	rdi, msg3    	; print third string and add the input string</span><br><span class="line">	call 	prints</span><br><span class="line">	</span><br><span class="line">	mov 	rdi, input    	; print the inputbuffer</span><br><span class="line">	call 	prints</span><br><span class="line">	</span><br><span class="line">  	mov 	rdi,NL 			; print NL</span><br><span class="line">	call 	prints     </span><br><span class="line">	</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">;----------------------------------------------------------</span><br><span class="line">prints:</span><br><span class="line">push	rbp</span><br><span class="line">mov		rbp, rsp</span><br><span class="line">push	r12					; callee saved</span><br><span class="line"></span><br><span class="line">; Count characters </span><br><span class="line">    	xor 	rdx, rdx 	; length in rdx</span><br><span class="line">    	mov 	r12, rdi   </span><br><span class="line">.lengthloop:</span><br><span class="line">    	cmp 	byte [r12], 0</span><br><span class="line">    	je 		.lengthfound</span><br><span class="line">    	inc 	rdx</span><br><span class="line">    	inc 	r12</span><br><span class="line">    	jmp 	.lengthloop</span><br><span class="line">.lengthfound:		; print the string, length in rdx</span><br><span class="line">    	cmp 	rdx, 0     	; no string (0 length)</span><br><span class="line">    	je 		.done</span><br><span class="line">    	mov 	rsi,rdi		; rdi contains address of string</span><br><span class="line">    	mov 	rax, 1  	; 1 = write</span><br><span class="line">    	mov 	rdi, 1		; 1 = stdout</span><br><span class="line">    	syscall</span><br><span class="line">.done:</span><br><span class="line">pop r12</span><br><span class="line">leave </span><br><span class="line">ret</span><br><span class="line">;----------------------------------------------------------</span><br><span class="line">reads:</span><br><span class="line">section .data</span><br><span class="line">section .bss</span><br><span class="line">    	.inputchar 	resb 	1  </span><br><span class="line">section .text</span><br><span class="line">push	rbp</span><br><span class="line">mov	rbp, rsp</span><br><span class="line">	    push	r12			; callee saved</span><br><span class="line">	    push	r13			; callee saved</span><br><span class="line">	    push	r14			; callee saved</span><br><span class="line">	    mov 	r12, rdi	; address of stringbuffer</span><br><span class="line">        mov 	r13, rsi   	; max length in r13</span><br><span class="line">       	xor 	r14, r14  	; character counter</span><br><span class="line">.readc: </span><br><span class="line">    	mov 	rax, 0   		; read</span><br><span class="line">    	mov 	rdi, 1      	; stdin</span><br><span class="line">    	lea 	rsi, [.inputchar] 	; address of input</span><br><span class="line">    	mov 	rdx, 1      	; # of characters to read</span><br><span class="line">    	syscall</span><br><span class="line">    	mov 	al, [.inputchar]  	; char is NL?</span><br><span class="line">    	cmp 	al, byte[NL]</span><br><span class="line">    	je 		.done			; NL end</span><br><span class="line">		cmp		al, 97			; lower than a?</span><br><span class="line">		jl		.readc			; ignore it</span><br><span class="line">		cmp		al, 122			; higher than z?</span><br><span class="line">		jg		.readc			; ignore it</span><br><span class="line">    	inc 	r14				; inc counter</span><br><span class="line">    	cmp 	r14, r13</span><br><span class="line">    	ja 		.readc       	; buffer max reached, ignore</span><br><span class="line">    	mov 	byte [r12], al 	; safe the char in the buffer</span><br><span class="line">    	inc 	r12           	; point to next char in buffer</span><br><span class="line">    	jmp 	.readc </span><br><span class="line">.done:</span><br><span class="line">    	inc 	r12</span><br><span class="line">    	mov 	byte [r12],0   	; add end 0 to stringbuffer</span><br><span class="line">	    pop 	r14			; callee saved</span><br><span class="line">	    pop		r13			; callee saved</span><br><span class="line">	    pop		r12			; callee saved</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>



<p>他的思路</p>
<p>它使用了一些寄存器来保存参数</p>
<p>用r12,r13来捕捉缓冲区的字符串长度,缓冲区的字符串地址</p>
<p>用r14来做字符串缓冲区的指针,满足条件就移动r14来填入输入的数据</p>
<p>关于输入,他把你的输入作为单个字符,传入一个char buff&#x3D;0的缓冲区,然后检buff</p>
<p>如果buff是换行符就读取结束</p>
<p>如果读取是不满足条件的字符就读取下一个数据,字符串缓冲区的指针不发生变化,继续读取下一个字符</p>
<p>如果满足对应的字符,查看输入的字符串长度是否超过了,如果超过了,不移动指针,继续读取下一个字符</p>
<p>如果没有超过,就移动指针,往字符串地址里面天厨char 的buff</p>
<p>就是这样一个解决读取溢出的</p>
<p>读取是读取到一个一旦长度的buff区域</p>
<p>,读取溢出解决,输出就解决了</p>
<h2 id="win32"><a href="#win32" class="headerlink" title="win32"></a>win32</h2><h3 id="helloword"><a href="#helloword" class="headerlink" title="helloword"></a>helloword</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Hello.asm</span><br><span class="line">; Link /subsystem:windows Hello.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">c</span><br><span class="line">;对于上面的lib,inc还不是很理解</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">A_Title			db	&#x27;My_First_Box !&#x27;,0</span><br><span class="line">A_Text			db	&#x27;Hello, Dqx_Ghost !&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	</span><br><span class="line">start:</span><br><span class="line">		invoke	MessageBox, NULL, offset A_Text, offset A_Title, MB_OK</span><br><span class="line">		;传递了4个参数,NULL,标题,内容,MB_OK</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>





<p>IDA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">push    0               ; 参数1</span><br><span class="line">push    offset Caption  ; 参数2,标题&quot;My_First_Box !&quot;</span><br><span class="line">push    offset Text     ; 参数3,内容&quot;Hello, Dqx_Ghost !&quot;</span><br><span class="line">push    0               ; 参数4,hwnd????</span><br><span class="line">call    MessageBoxA</span><br><span class="line">push    0               ; uExitCode</span><br><span class="line">call    ExitProcess</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>





<h3 id="第一个窗口"><a href="#第一个窗口" class="headerlink" title="第一个窗口"></a>第一个窗口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;</span><br><span class="line">; by 罗云彬, http://www.win32asm.com.cn</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; FirstWindow.asm</span><br><span class="line">; 窗口程序的模板代码</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff FirstWindow.asm</span><br><span class="line">; Link /subsystem:windows FirstWindow.obj</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include		windows.inc</span><br><span class="line">include		gdi32.inc</span><br><span class="line">includelib	gdi32.lib</span><br><span class="line">include		user32.inc</span><br><span class="line">includelib	user32.lib</span><br><span class="line">include		kernel32.inc</span><br><span class="line">includelib	kernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.data?</span><br><span class="line">hInstance	dd		?	;用来接收资源模块的地址</span><br><span class="line">hWinMain	dd		?	;hWinMain会接受一个窗口的地址</span><br><span class="line"></span><br><span class="line">		.const</span><br><span class="line">szClassName	db	&#x27;MyClass&#x27;,0</span><br><span class="line">szCaptionMain	db	&#x27;My first Window !&#x27;,0</span><br><span class="line">szText		db	&#x27;Win32 Assembly, Simple and powerful !&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 窗口过程</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_ProcWinMain	proc	uses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">		local	@stPs:PAINTSTRUCT</span><br><span class="line">		local	@stRect:RECT</span><br><span class="line">		local	@hDc</span><br><span class="line"></span><br><span class="line">		mov	eax,uMsg</span><br><span class="line">;********************************************************************</span><br><span class="line">		.if	eax ==	WM_PAINT</span><br><span class="line">			invoke	BeginPaint,hWnd,addr @stPs</span><br><span class="line">			mov	@hDc,eax</span><br><span class="line"></span><br><span class="line">			invoke	GetClientRect,hWnd,addr @stRect</span><br><span class="line">			invoke	DrawText,@hDc,addr szText,-1,\</span><br><span class="line">				addr @stRect,\</span><br><span class="line">				DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line"></span><br><span class="line">			invoke	EndPaint,hWnd,addr @stPs</span><br><span class="line">;********************************************************************</span><br><span class="line">		.elseif	eax ==	WM_CLOSE</span><br><span class="line">			invoke	DestroyWindow,hWinMain</span><br><span class="line">			invoke	PostQuitMessage,NULL</span><br><span class="line">;********************************************************************</span><br><span class="line">		.else</span><br><span class="line">			invoke	DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">			ret</span><br><span class="line">		.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">		xor	eax,eax</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">_ProcWinMain	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_WinMain	proc</span><br><span class="line">		local	@stWndClass:WNDCLASSEX</span><br><span class="line">		local	@stMsg:MSG</span><br><span class="line">		</span><br><span class="line">		;参数0,代表0号模块</span><br><span class="line">		invoke	GetModuleHandle,NULL</span><br><span class="line">		mov	hInstance,eax</span><br><span class="line"></span><br><span class="line">		;参数</span><br><span class="line">		;结构体起始地址</span><br><span class="line">		;sizeof(结构体)</span><br><span class="line">		;功能初始化结构体为0</span><br><span class="line">		invoke	RtlZeroMemory,addr @stWndClass,sizeof @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 注册窗口类</span><br><span class="line">;重要的参数</span><br><span class="line">;hInstance</span><br><span class="line">;@stWndClass.lpfnWndProc</span><br><span class="line">;@stWndClass.lpszClassName</span><br><span class="line">;********************************************************************</span><br><span class="line">		invoke	LoadCursor,0,IDC_ARROW</span><br><span class="line">		mov	@stWndClass.hCursor,eax</span><br><span class="line">		push	hInstance</span><br><span class="line">		pop	@stWndClass.hInstance</span><br><span class="line">		mov	@stWndClass.cbSize,sizeof WNDCLASSEX</span><br><span class="line">		mov	@stWndClass.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">		mov	@stWndClass.lpfnWndProc,offset _ProcWinMain</span><br><span class="line">		mov	@stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br><span class="line">		mov	@stWndClass.lpszClassName,offset szClassName</span><br><span class="line"></span><br><span class="line">		;参数</span><br><span class="line">		;一个已经初始化好的结构体</span><br><span class="line">		;功能:把已经准备好的结构体信息给zhuche3函数</span><br><span class="line">		invoke	RegisterClassEx,addr @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;重要参数</span><br><span class="line">;szClassName 这个参数好像不怎么重要,就是一个名字,或者是一个指针的名字</span><br><span class="line">;hInstance</span><br><span class="line">;********************************************************************</span><br><span class="line">		invoke	CreateWindowEx,WS_EX_CLIENTEDGE,offset szClassName,offset szCaptionMain,\</span><br><span class="line">			WS_OVERLAPPEDWINDOW,\</span><br><span class="line">			100,100,600,400,\</span><br><span class="line">			NULL,NULL,hInstance,NULL</span><br><span class="line">		mov	hWinMain,eax</span><br><span class="line">		;重要的参数是hWinMain</span><br><span class="line">		;参数是窗口的地址</span><br><span class="line">		invoke	ShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">		invoke	UpdateWindow,hWinMain</span><br><span class="line">;********************************************************************</span><br><span class="line">; 消息循环</span><br><span class="line">;********************************************************************</span><br><span class="line">		.while	TRUE</span><br><span class="line">			;参数	@stMsg,</span><br><span class="line">			;函数的功能获取信息然后初始化@stMsg</span><br><span class="line">			invoke	GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">			.break	.if eax	== 0</span><br><span class="line">			invoke	TranslateMessage,addr @stMsg</span><br><span class="line">			invoke	DispatchMessage,addr @stMsg</span><br><span class="line">		.endw</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">_WinMain	endp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">start:</span><br><span class="line">		call	_WinMain</span><br><span class="line">		invoke	ExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">		end	start</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="第二个窗口"><a href="#第二个窗口" class="headerlink" title="第二个窗口"></a>第二个窗口</h3><p>修改IP的方法?</p>
<p>call	一个位置</p>
<p>然后	jmp到一个位置</p>
<p>最后	ret xx</p>
<p>这就让ip发生了鬼鬼祟祟的变化</p>
<p>这就是回调函数?</p>
<h2 id="asm-gt-avx"><a href="#asm-gt-avx" class="headerlink" title="asm-&gt;avx"></a>asm-&gt;avx</h2><h2 id="打印16进制"><a href="#打印16进制" class="headerlink" title="打印16进制"></a>打印16进制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000040137C print_xmm       proc near               ; CODE XREF: apply_mxcsr+50↑p</span><br><span class="line">.text:000000000040137C                 push    rbp</span><br><span class="line">.text:000000000040137D                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401380                 mov     rdi, offset hex ; &quot;0x&quot;</span><br><span class="line">.text:000000000040138A                 call    _printf</span><br><span class="line">.text:000000000040138F                 mov     ecx, 8			;它只会打印8字节,默认的</span><br><span class="line">.text:0000000000401394</span><br><span class="line">.text:0000000000401394 print_xmm_loop:                         ; CODE XREF: print_xmm+29↓j</span><br><span class="line">.text:0000000000401394                 xor     rdi, rdi</span><br><span class="line">.text:0000000000401397                 mov     dil, [rcx+404143h]</span><br><span class="line">.text:000000000040139E                 push    rcx</span><br><span class="line">.text:000000000040139F                 call    print_hex	;一个字节字节的打印</span><br><span class="line">.text:00000000004013A4                 pop     rcx</span><br><span class="line">.text:00000000004013A5                 loop    print_xmm_loop</span><br><span class="line">.text:00000000004013A7                 leave</span><br><span class="line">.text:00000000004013A8                 retn</span><br><span class="line">.text:00000000004013A8 print_xmm       endp</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000040142B print_hex       proc near               ; CODE XREF: print_xmm+23↑p</span><br><span class="line">.text:000000000040142B</span><br><span class="line">.text:000000000040142B var_4           = byte ptr -4</span><br><span class="line">.text:000000000040142B</span><br><span class="line">.text:000000000040142B ; __unwind &#123;</span><br><span class="line">.text:000000000040142B                 endbr64</span><br><span class="line">.text:000000000040142F                 push    rbp</span><br><span class="line">.text:0000000000401430                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401433                 sub     rsp, 10h</span><br><span class="line"></span><br><span class="line">.text:0000000000401437                 mov     eax, edi</span><br><span class="line">.text:0000000000401439                 mov     [rbp+var_4], al</span><br><span class="line">.text:000000000040143C                 cmp     [rbp+var_4], 15</span><br><span class="line">.text:0000000000401440                 ja      short loc_40144C</span><br><span class="line">.text:0000000000401442                 mov     edi, 30h ; &#x27;0&#x27;  ; c</span><br><span class="line">.text:0000000000401447                 call    _putchar</span><br><span class="line">.text:000000000040144C</span><br><span class="line">.text:000000000040144C loc_40144C:                             ; CODE XREF: print_hex+15↑j</span><br><span class="line">.text:000000000040144C                 movzx   eax, [rbp+var_4]</span><br><span class="line">.text:0000000000401450                 mov     esi, eax</span><br><span class="line">.text:0000000000401452                 lea     rdi, format     ; &quot;%x&quot;</span><br><span class="line">.text:0000000000401459                 mov     eax, 0</span><br><span class="line">.text:000000000040145E                 call    _printf</span><br><span class="line">.text:0000000000401463                 nop</span><br><span class="line">.text:0000000000401464                 leave</span><br><span class="line">.text:0000000000401465                 retn</span><br><span class="line">.text:0000000000401465 ; &#125; // starts at 40142B</span><br><span class="line">.text:0000000000401465 print_hex       endp</span><br></pre></td></tr></table></figure>

<h2 id="打印二进制"><a href="#打印二进制" class="headerlink" title="打印二进制"></a>打印二进制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004013A9 print_mxcsr     proc near               ; CODE XREF: apply_mxcsr+6C↑p</span><br><span class="line">.text:00000000004013A9                                         ; apply_mxcsr+88↑p</span><br><span class="line">.text:00000000004013A9</span><br><span class="line">.text:00000000004013A9 var_18          = qword ptr -18h</span><br><span class="line">.text:00000000004013A9 var_10          = qword ptr -10h</span><br><span class="line">.text:00000000004013A9 var_8           = qword ptr -8</span><br><span class="line">.text:00000000004013A9</span><br><span class="line">.text:00000000004013A9 ; __unwind &#123;</span><br><span class="line">.text:00000000004013A9                 endbr64</span><br><span class="line">.text:00000000004013AD                 push    rbp</span><br><span class="line">.text:00000000004013AE                 mov     rbp, rsp</span><br><span class="line">.text:00000000004013B1                 sub     rsp, 20h</span><br><span class="line">.text:00000000004013B5                 mov     [rbp+var_18], rdi</span><br><span class="line">.text:00000000004013B9                 mov     [rbp+var_10], 0Fh</span><br><span class="line">.text:00000000004013C1                 jmp     short loc_401417</span><br><span class="line">.text:00000000004013C3 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004013C3</span><br><span class="line">.text:00000000004013C3 loc_4013C3:                             ; CODE XREF: print_mxcsr+73↓j</span><br><span class="line">.text:00000000004013C3                 mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000004013C7                 mov     edx, eax</span><br><span class="line">.text:00000000004013C9                 mov     rax, [rbp+var_18]</span><br><span class="line">.text:00000000004013CD                 mov     ecx, edx</span><br><span class="line">										;用于判断空格输出</span><br><span class="line">.text:00000000004013CF                 sar     rax, cl </span><br><span class="line">.text:00000000004013D2                 mov     [rbp+var_8], rax</span><br><span class="line">.text:00000000004013D6                 mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000004013DA                 add     rax, 1</span><br><span class="line">.text:00000000004013DE                 and     eax, 3</span><br><span class="line">.text:00000000004013E1                 test    rax, rax</span><br><span class="line">.text:00000000004013E4                 jnz     short loc_4013F0</span><br><span class="line">.text:00000000004013E6                 mov     edi, 20h ; &#x27; &#x27;  ; c</span><br><span class="line">.text:00000000004013EB                 call    _putchar</span><br><span class="line">.text:00000000004013F0</span><br><span class="line">.text:00000000004013F0 loc_4013F0:                             ; CODE XREF: print_mxcsr+3B↑j</span><br><span class="line">.text:00000000004013F0                 mov     rax, [rbp+var_8]</span><br><span class="line">.text:00000000004013F4                 and     eax, 1</span><br><span class="line">.text:00000000004013F7                 test    rax, rax</span><br><span class="line">.text:00000000004013FA                 jz      short loc_401408</span><br><span class="line">.text:00000000004013FC                 mov     edi, 31h ; &#x27;1&#x27;  ; c</span><br><span class="line">.text:0000000000401401                 call    _putchar</span><br><span class="line">.text:0000000000401406                 jmp     short loc_401412</span><br><span class="line">.text:0000000000401408 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401408</span><br><span class="line">.text:0000000000401408 loc_401408:                             ; CODE XREF: print_mxcsr+51↑j</span><br><span class="line">.text:0000000000401408                 mov     edi, 30h ; &#x27;0&#x27;  ; c</span><br><span class="line">.text:000000000040140D                 call    _putchar</span><br><span class="line">.text:0000000000401412</span><br><span class="line">.text:0000000000401412 loc_401412:                             ; CODE XREF: print_mxcsr+5D↑j</span><br><span class="line">.text:0000000000401412                 sub     [rbp+var_10], 1</span><br><span class="line">.text:0000000000401417</span><br><span class="line">.text:0000000000401417 loc_401417:                             ; CODE XREF: print_mxcsr+18↑j</span><br><span class="line">.text:0000000000401417                 cmp     [rbp+var_10], 0</span><br><span class="line">.text:000000000040141C                 jns     short loc_4013C3</span><br><span class="line">.text:000000000040141E                 mov     edi, 0Ah        ; 换行</span><br><span class="line">.text:0000000000401423                 call    _putchar</span><br><span class="line">.text:0000000000401428                 nop</span><br><span class="line">.text:0000000000401429                 leave</span><br><span class="line">.text:000000000040142A                 retn</span><br><span class="line">.text:000000000040142A ; &#125; // starts at 4013A9</span><br><span class="line">.text:000000000040142A print_mxcsr     endp</span><br></pre></td></tr></table></figure>







<h1 id="实验的收获"><a href="#实验的收获" class="headerlink" title="实验的收获"></a>实验的收获</h1><p>对于重复的代码,尽量少些,多去调用</p>
<h2 id="循环遍历的方法"><a href="#循环遍历的方法" class="headerlink" title="循环遍历的方法"></a>循环遍历的方法</h2><h3 id="jcxz-jmp"><a href="#jcxz-jmp" class="headerlink" title="jcxz+jmp"></a>jcxz+jmp</h3><p>假设字符串 最后以0来结尾</p>
<p>可能适用于你不知道字符串的长度,然后用0来表示标志位的结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    push  si</span><br><span class="line">    push di</span><br><span class="line">flag:</span><br><span class="line">	mov cx,ds:[si]</span><br><span class="line">	mov es:[di],cx</span><br><span class="line">	jcxz over</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">over:</span><br><span class="line">	pop di</span><br><span class="line">	pop si</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="loop与cx"><a href="#loop与cx" class="headerlink" title="loop与cx"></a>loop与cx</h3><p>可能适用于你知道cx的长度,然后去遍历它的字符串长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    push si</span><br><span class="line">    push di</span><br><span class="line">    mov cx,16</span><br><span class="line">flag:</span><br><span class="line">	mov ax,ds:[si]</span><br><span class="line">	mov es:[di],ax</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	loop flag</span><br><span class="line">over:</span><br><span class="line">	pop di</span><br><span class="line">	pop si</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h2 id="数据获取string-dup-0"><a href="#数据获取string-dup-0" class="headerlink" title="数据获取string dup (0)"></a>数据获取string dup (0)</h2><p>对于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后填入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000002222222</span><br></pre></td></tr></table></figure>

<p>获取数据时,我们常常jcxz一下</p>
<p>于是获取完毕</p>
<p>但是下一次获取的时候</p>
<p>数据89</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000022222289</span><br></pre></td></tr></table></figure>

<p>前面的(上一次的)数影响了</p>
<p>于是怎么办?</p>
<p>就每次填入数据的时候,就是初始化数据的时候,就多写一个标志0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000022222222</span><br></pre></td></tr></table></figure>

<p>第二次初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000022222089</span><br></pre></td></tr></table></figure>

<p>在89前面就有一个0作为标志位</p>
<h2 id="程序死机的原因"><a href="#程序死机的原因" class="headerlink" title="程序死机的原因"></a>程序死机的原因</h2><p>你没有写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="type">int</span> <span class="number">21</span>h</span><br></pre></td></tr></table></figure>





<p>关于该数据要用多少位的寄存器存放?</p>
<p>一个无符号的bit位,假设n位,其最大值就是<code>2^n-1</code></p>
<p>一个有符号的bit位,假设n位,其最大值就是<code>2^(n-1)-1</code></p>
<p>遗留的问题(浮点数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	double 	x=3.1415926;</span><br><span class="line">	char	z=&#x27;I&#x27;;</span><br><span class="line">	int		y=(int)x;</span><br><span class="line">	char	ascii1=&#x27;O&#x27;;</span><br><span class="line">	puts(&quot;Good!&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include Dqx.inc	</span><br><span class="line">printf proto C :ptr sbyte,:vararg</span><br><span class="line">scanf  proto C :ptr sbyte,:vararg</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	n_input		byte &quot;%d %d&quot;,0</span><br><span class="line">	n_output	byte &quot;%d+%d=%d&quot;,10,0</span><br><span class="line">	s_output	BYTE &quot;%s&quot;,10,0</span><br><span class="line"></span><br><span class="line">	str1		byte &quot;welcome to my world&quot;,10</span><br><span class="line">			byte &quot;please input 2 NUm&quot;,0</span><br><span class="line"></span><br><span class="line">	a		dd	0</span><br><span class="line">	b		dd	0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">	invoke	printf,addr s_output,addr str1</span><br><span class="line">	invoke	scanf,addr n_input,addr a,addr b</span><br><span class="line">	mov	eax,0</span><br><span class="line">	add	eax,a</span><br><span class="line">	add	eax,b</span><br><span class="line">	invoke	printf,addr n_output,a,b,eax</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	INVOKE	ExitProcess,0;调用结束的函数,</span><br><span class="line">;--------------------------------------------------------------------------- </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>输入2个数字,然后相加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">welcome to my world</span><br><span class="line">please input 2 NUm</span><br><span class="line">10 20</span><br><span class="line">10+20=30</span><br></pre></td></tr></table></figure>



<h1 id="windows下-C-x2F-C-学习-调试"><a href="#windows下-C-x2F-C-学习-调试" class="headerlink" title="windows下 C&#x2F;C++学习-调试"></a>windows下 C&#x2F;C++学习-调试</h1><h2 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a>x86</h2><h3 id="count-3-x3D-x3D-0-吐了"><a href="#count-3-x3D-x3D-0-吐了" class="headerlink" title="count++ % 3 &#x3D;&#x3D; 0 吐了"></a>count++ % 3 &#x3D;&#x3D; 0 吐了</h3><p>汇编翻译吐了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* count.c -- using standard I/O */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(in)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//int版本</span><br><span class="line">mov     ecx, [esp+1Ch]</span><br><span class="line">lea     eax, [ecx+1]</span><br><span class="line">mov     [esp+28], eax</span><br><span class="line">mov     edx, 55555556h</span><br><span class="line">mov     eax, ecx</span><br><span class="line">imul    edx</span><br><span class="line">mov     eax, ecx</span><br><span class="line">sar     eax, 31</span><br><span class="line">sub     edx, eax</span><br><span class="line">mov     eax, edx</span><br><span class="line">mov     edx, eax</span><br><span class="line">add     edx, edx</span><br><span class="line">add     edx, eax</span><br><span class="line">mov     eax, ecx</span><br><span class="line">sub     eax, edx</span><br><span class="line">test    eax, eax</span><br><span class="line">jnz     short loc_4015A9</span><br><span class="line">//byte版本</span><br><span class="line">movzx   ecx, byte ptr [esp+31]</span><br><span class="line">mov     eax, ecx</span><br><span class="line">add     eax, 1</span><br><span class="line">mov     [esp+31], al</span><br><span class="line">movsx   ax, cl</span><br><span class="line">imul    eax, 86</span><br><span class="line">shr     ax, 8</span><br><span class="line">mov     edx, eax</span><br><span class="line">mov     eax, ecx</span><br><span class="line">sar     al, 7</span><br><span class="line">sub     edx, eax</span><br><span class="line">mov     eax, edx</span><br><span class="line">mov     edx, eax</span><br><span class="line">add     edx, edx</span><br><span class="line">add     edx, eax</span><br><span class="line">mov     eax, ecx</span><br><span class="line">sub     eax, edx</span><br><span class="line">test    al, al</span><br><span class="line">jnz     short loc_4015AD</span><br></pre></td></tr></table></figure>

<p>它的意思是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//byte版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">int</span> result=<span class="number">0</span>;<span class="comment">//eax</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">6</span>;<span class="comment">//ecx, byte ptr [esp+31]</span></span><br><span class="line">   	result=count<span class="number">-3</span>*((count*<span class="number">86</span>)&gt;&gt;<span class="number">8</span>-(count&gt;&gt;<span class="number">7</span>));</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int版本</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    int result=0;</span></span><br><span class="line"><span class="comment">    int count=10;</span></span><br><span class="line"><span class="comment">   	result-=count-3*(count*0x55555556&gt;&gt;32-count&gt;&gt;31);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我还是看不懂</p>
<h3 id="ds-iob-func"><a href="#ds-iob-func" class="headerlink" title="ds:__iob_func"></a>ds:__iob_func</h3><p><code>__iob_func()</code>返回一个指向<code>FILE</code>描述符数组的指针，</p>
<p>该数组包含<code>stdin</code>、<code>stdout</code>和通过 C 运行时库打开的<code>stderr</code>任何对象。</p>
<h3 id="RTC-CheckEsp"><a href="#RTC-CheckEsp" class="headerlink" title="RTC_CheckEsp"></a>RTC_CheckEsp</h3><p>参数 ZF寄存器</p>
<p>它主要分布在一些函数调用之间,</p>
<p>也就是函数前mov esi,ebp</p>
<p>函数结束后就cmp esi,ebp</p>
<p>验证<code>esp</code>, stack, register 正确性的调用。调用它以确保<code>esp</code>在函数调用中保存 的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0044</span>EE35  mov         esi,esp</span><br><span class="line">    .....一些操作</span><br><span class="line">	......</span><br><span class="line"><span class="number">0044</span>EE4D  cmp         esi,esp </span><br><span class="line"><span class="number">0044</span>EE4F  call        @ILT+<span class="number">6745</span>(__RTC_CheckEsp) (<span class="number">42B</span>A5Eh) </span><br></pre></td></tr></table></figure>

<p>在那一顿操作过后,他就检测栈是否还原</p>
<p>就是比较esi与esp</p>
<h3 id="关于函数-RTC-CheckEsp"><a href="#关于函数-RTC-CheckEsp" class="headerlink" title="关于函数__RTC_CheckEsp"></a>关于函数__RTC_CheckEsp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_RTC_CheckEsp:</span><br><span class="line"><span class="number">00475</span><span class="function">A60  jne         <span class="title">esperror</span> <span class="params">(<span class="number">475</span>A63h)</span> </span></span><br><span class="line"><span class="function">00475A62  ret         <span class="comment">//如果相等就返回</span></span></span><br><span class="line"><span class="function">    				 <span class="comment">//不相等就死了</span></span></span><br><span class="line"><span class="function">esperror:</span></span><br><span class="line"><span class="function"><span class="number">00475</span>A63  push        ebp  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A64  mov         ebp,esp </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A66  sub         esp,<span class="number">0</span> </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A69  push        eax  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A6A  push        edx  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A6B  push        ebx  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A6C  push        esi  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A6D  push        edi  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A6E  mov         eax,dword ptr [ebp+<span class="number">4</span>] </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A71  push        <span class="number">0</span>    </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A73  push        eax  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A74  call        _RTC_Failure (<span class="number">42</span>C34Bh) </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A79  add         esp,<span class="number">8</span> </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A7C  pop         edi  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A7D  pop         esi  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A7E  pop         ebx  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A7F  pop         edx  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A80  pop         eax  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A81  mov         esp,ebp </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A83  pop         ebp  </span></span><br><span class="line"><span class="function"><span class="number">00475</span>A84  ret </span></span><br></pre></td></tr></table></figure>



<h3 id="security-check-cookie"><a href="#security-check-cookie" class="headerlink" title="@__security_check_cookie"></a>@__security_check_cookie</h3><p>基于Cookie的缓冲区溢出安全检查！</p>
<p>这个Cookie的变量位于函数体内的局部变量和EBP的存放地址之间，具体表示就是：[EBP-4]。</p>
<p>__security_init_cookie()这个函数对__security_cookie变量再次初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取cooike变量</span></span><br><span class="line"><span class="comment">//每个函数的ebp保持不变且不同,于是coike与ebp异或</span></span><br><span class="line"><span class="comment">//把cooike压入ebp-4</span></span><br><span class="line">mov eax,dword ptr [___security_cookie (<span class="number">4B</span>7A74h)]</span><br><span class="line"><span class="keyword">xor</span> eax,ebp</span><br><span class="line">mov dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure>



<p>关于cooike在栈中的位置</p>
<p>就是最开始压入EBP后ESP的值，</p>
<p>ebp减4就刚好挨着一进函数时压入的EBP的地址减4。好了！Cookie变量已经在栈帧中了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00991010</span> push    ebp					<span class="comment">//这里是ebp位置</span></span><br><span class="line">.text:<span class="number">00991011</span> mov     ebp, esp			</span><br><span class="line">.text:<span class="number">00991013</span> sub     esp, <span class="number">13</span>Ch			<span class="comment">//esp的开辟</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">00F</span>5FBA0  <span class="number">66</span>DDC4AD  							<span class="comment">//cooike</span></span><br><span class="line"><span class="number">00F</span>5FBA4  <span class="number">00F</span>5FBF4  Stack[<span class="number">000022</span>C4]:<span class="number">00F</span>5FBF4	<span class="comment">//ebp</span></span><br><span class="line"><span class="number">00F</span>5FBA8  <span class="number">0099170F</span>  ___tmainCRTStartup+<span class="number">1B</span>F</span><br></pre></td></tr></table></figure>



<p>与EBP异或当然有好处。</p>
<ol>
<li><p>可以增加随机性，尽可能使不同函数的安全Cookie都不同。</p>
</li>
<li><p>可以检查EBP是否被破坏，因为在函数结束检查Cookie时，还会将Cookie变量值再次与EBP异或，如果EBP的值没有变化，那么就能恢  复成原来的___security_cookie值。</p>
</li>
</ol>
<p>一系列过程允许后又回到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出cokkie变量</span></span><br><span class="line"><span class="comment">//还原cookie变量</span></span><br><span class="line"><span class="comment">//检查是否和原来一样</span></span><br><span class="line">mov         ecx,dword ptr [ebp<span class="number">-4</span>]</span><br><span class="line"><span class="keyword">xor</span>         ecx,ebp</span><br><span class="line">call        @ILT+<span class="number">920</span>(@__security_check_cookie@<span class="number">4</span>) (<span class="number">43739</span>Dh)</span><br></pre></td></tr></table></figure>



<p>好像函数@__security_check_cookie@4采用了某个调用约定,所以的话ecx是第一个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00991220</span> ; <span class="type">void</span> __fastcall __security_check_cookie(<span class="type">uintptr_t</span> StackCookie)	<span class="comment">//某个调用约定</span></span><br><span class="line">.text:<span class="number">00991220</span> @__security_check_cookie@<span class="number">4</span> proc near    ; CODE XREF: _main_0+<span class="number">153</span>↑p</span><br><span class="line">.text:<span class="number">00991220</span>                                         ; <span class="built_in">failwithmessage</span>(<span class="type">void</span> *,<span class="type">int</span>,<span class="type">int</span>,<span class="type">char</span> <span class="type">const</span> *)+<span class="number">208</span>↓p ...</span><br><span class="line">.text:<span class="number">00991220</span> cmp     ecx, ___security_cookie		<span class="comment">//把参数于原始的cooike做一个比较</span></span><br><span class="line">.text:<span class="number">00991226</span> jnz     <span class="type">short</span> $failure$<span class="number">26820</span>			<span class="comment">//不相等就死翘翘</span></span><br><span class="line">.text:<span class="number">00991228</span> rep retn</span><br><span class="line">.text:<span class="number">0099122</span>A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0099122</span>A</span><br><span class="line">.text:<span class="number">0099122</span>A $failure$<span class="number">26820</span>:                         ; CODE XREF: __security_check_cookie(x)+<span class="number">6</span>↑j</span><br><span class="line">.text:<span class="number">0099122</span>A jmp     ___report_gsfailure			<span class="comment">//到这里来了后就处理cooike不正常的处理</span></span><br><span class="line">.text:<span class="number">0099122</span>A @__security_check_cookie@<span class="number">4</span> endp</span><br></pre></td></tr></table></figure>





<h3 id="RTC-CheckStackVar"><a href="#RTC-CheckStackVar" class="headerlink" title="@_RTC_CheckStackVar"></a>@_RTC_CheckStackVar</h3><p>顾名思义，就是用来检查局部数据是否访问越界。</p>
<p>相对来说，</p>
<p>&#x3D;&#x3D;这种检查只能起到一定的作用&#x3D;&#x3D;，并不会所有越界访问都能检查到。</p>
<p>&#x3D;&#x3D;既然是检查局部的&#x3D;&#x3D;，那么在函数内定义的static类型数组或者函数外部的全局数组并不会采用此检查，</p>
<p>&#x3D;&#x3D;既然是检查数组&#x3D;&#x3D;，那么如果函数内没有局部数组时，此检查也不会存在。</p>
<blockquote>
<p> 背景</p>
<p>在VS的debug版本下，局部变量之间并不是连续存放在栈内存里的</p>
<p>而是以4字节对齐的方式，前后都会有保护字节的。保护字节占4个字节，可能是值为0xcc，很明显这是汇编指令int 3中断的代码字节</p>
</blockquote>
<p>原始代码void  __fastcall _RTC_CheckStackVars( void *_Esp, _RTC_framedesc *_Fd );</p>
<p>参数 </p>
<p>ecx 	原来函数的ebp</p>
<p>edx	一个fd结构体指针</p>
<p>参数传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0099114B</span> mov     ecx, ebp   	<span class="comment">//参数1                     ; Esp</span></span><br><span class="line">.text:<span class="number">0099114</span>D push    eax</span><br><span class="line">.text:<span class="number">0099114</span>E lea     edx, Fd	<span class="comment">//参数2</span></span><br><span class="line">.text:<span class="number">00991154</span> call    @_RTC_CheckStackVars@<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>关于fd结构体类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTC_framedesc</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> varCount;                            <span class="comment">//  要检查的数组的个数</span></span><br><span class="line">    _RTC_vardesc *variables;        		<span class="comment">//  要检查的数组的相关信息</span></span><br><span class="line"></span><br><span class="line">&#125; _RTC_framedesc;</span><br></pre></td></tr></table></figure>



<p>关于嵌套的结构体 _RTC_vardesc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTC_vardesc</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> addr;                                   	<span class="comment">//  数组的首地址相对于EBP的偏移量</span></span><br><span class="line">    <span class="type">int</span> size;                                    <span class="comment">//  数组的大小字节数</span></span><br><span class="line">    <span class="type">char</span> *name;                             	<span class="comment">//  数组的名字</span></span><br><span class="line">&#125; _RTC_vardesc;</span><br></pre></td></tr></table></figure>

<p>起反汇编代码</p>
<p>也不是很难…..</p>
<p>瞎看C代码–基于vs2008</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTC_vardesc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125; _RTC_vardesc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTC_framedesc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> varCount;</span><br><span class="line">    _RTC_vardesc* variables;	<span class="comment">//结构体指针</span></span><br><span class="line">&#125; _RTC_framedesc;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __fastcall _RTC_CheckStackVars( <span class="type">void</span>* _Esp, _RTC_framedesc* _Fd )	<span class="comment">//ecx,edx</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( _Fd-&gt;varCount == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果数组个数是0,就不检测</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _RetAddr = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, ebp</span><br><span class="line">        add eax, <span class="number">4</span></span><br><span class="line">        mov _RetAddr, eax   <span class="comment">// 保存返回地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; _Fd-&gt;varCount ) <span class="comment">//i&lt;数组的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* pAddr = ( <span class="type">char</span>* )_Esp + _Fd-&gt;variables[i].addr - <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> ( *( <span class="type">int</span>* )pAddr != <span class="number">0xcccccccc</span> )</span><br><span class="line">            __asm <span class="type">int</span> <span class="number">3</span>  <span class="comment">// 引发中断</span></span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> ofs = _Fd-&gt;variables[i].addr + _Fd-&gt;variables[i].size;</span><br><span class="line">        pAddr = ( <span class="type">char</span>* )_Esp + ofs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( *( <span class="type">int</span>* )pAddr != <span class="number">0xcccccccc</span> )</span><br><span class="line">            __asm <span class="type">int</span> <span class="number">3</span>  <span class="comment">// 引发中断</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>vs2010的IDA伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall _RTC_CheckStackVars(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edi</span></span><br><span class="line">  _RTC_vardesc *variables; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> addr; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [esp+14h] [ebp+4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; Fd-&gt;varCount; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    variables = Fd-&gt;variables;	<span class="comment">//包含数组信息的结构体</span></span><br><span class="line">    addr = variables[v2].addr;	<span class="comment">//[index]小结构体的指针</span></span><br><span class="line">      <span class="comment">//检测对应数组2边的保护字节????0xcc</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)((<span class="type">char</span> *)Esp + addr - <span class="number">4</span>) != <span class="number">0xCCCCCCCC</span></span><br><span class="line">      || *(_DWORD *)((<span class="type">char</span> *)Esp + addr + variables[v2].size) != <span class="number">0xCCCCCCCC</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _RTC_StackFailure(retaddr, variables[v2].name);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>vs2008的汇编</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00991260</span> ; <span class="type">void</span> __fastcall _RTC_CheckStackVars(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span><br><span class="line">.text:<span class="number">00991260</span> @_RTC_CheckStackVars@<span class="number">8</span> proc near        ; CODE XREF: _main_0+<span class="number">144</span>↑p</span><br><span class="line">.text:<span class="number">00991260</span></span><br><span class="line">.text:<span class="number">00991260</span> var_4= dword ptr <span class="number">-4</span></span><br><span class="line">.text:<span class="number">00991260</span></span><br><span class="line">.text:<span class="number">00991260</span> mov     edi, edi</span><br><span class="line">    </span><br><span class="line">.text:<span class="number">00991262</span> push    ebp</span><br><span class="line">.text:<span class="number">00991263</span> mov     ebp, esp</span><br><span class="line">    </span><br><span class="line">.text:<span class="number">00991265</span> push    ecx</span><br><span class="line">.text:<span class="number">00991266</span> push    ebx</span><br><span class="line">.text:<span class="number">00991267</span> push    esi</span><br><span class="line">.text:<span class="number">00991268</span> push    edi</span><br><span class="line">    </span><br><span class="line">.text:<span class="number">00991269</span> <span class="keyword">xor</span>     edi, edi</span><br><span class="line">.text:<span class="number">0099126B</span> mov     esi, edx	<span class="comment">// 将_RTC_framedesc结构指针赋值给esi</span></span><br><span class="line">.text:<span class="number">0099126</span>D mov     ebx, ecx	<span class="comment">// 将函数的栈帧赋值给ebx</span></span><br><span class="line">.text:<span class="number">0099126F</span> mov     [ebp+var_4], edi	<span class="comment">// 这里的i应该是循环变量，后面根据数组的个数循环检测</span></span><br><span class="line">    </span><br><span class="line">.text:<span class="number">00991272</span> cmp     [esi], edi		<span class="comment">//cmp fd,0	 比较数值个数是否为0</span></span><br><span class="line">    </span><br><span class="line">.text:<span class="number">00991274</span> jle     <span class="type">short</span> loc_9912BE		<span class="comment">//没有数组,万事大吉,通过检测</span></span><br><span class="line">.text:<span class="number">00991276</span> jmp     <span class="type">short</span> loc_991280		<span class="comment">//进一步检测</span></span><br><span class="line">.text:<span class="number">00991276</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00991278</span> align <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">00991280</span></span><br><span class="line">.text:<span class="number">00991280</span> loc_991280:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+<span class="number">16</span>↑j</span><br><span class="line">.text:<span class="number">00991280</span>                                         ; _RTC_CheckStackVars(x,x)+<span class="number">5</span>C↓j</span><br><span class="line">.text:<span class="number">00991280</span> mov     eax, [esi+<span class="number">4</span>]		 <span class="comment">//  +4之后就是_RTC_framedesc.variables指针</span></span><br><span class="line">.text:<span class="number">00991283</span> mov     ecx, [eax+edi] 	<span class="comment">//  _RTC_vardesc-&gt;addr了，就是数组的首地址相对于TestVars的EBP的偏</span></span><br><span class="line">.text:<span class="number">00991286</span> cmp     dword ptr [ecx+ebx<span class="number">-4</span>], <span class="number">0</span>CCCCCCCCh  <span class="comment">//  如果不等于0xcccccccc就报错_RTC_StackFailure</span></span><br><span class="line">.text:<span class="number">0099128</span>E jnz     <span class="type">short</span> loc_99129F</span><br><span class="line">.text:<span class="number">00991290</span> mov     edx, [eax+edi+<span class="number">4</span>]</span><br><span class="line">.text:<span class="number">00991294</span> add     edx, ecx</span><br><span class="line">.text:<span class="number">00991296</span> cmp     dword ptr [edx+ebx], <span class="number">0</span>CCCCCCCCh</span><br><span class="line">.text:<span class="number">0099129</span>D jz      <span class="type">short</span> loc_9912B0</span><br><span class="line">.text:<span class="number">0099129F</span></span><br><span class="line">.text:<span class="number">0099129F</span> loc_99129F:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+<span class="number">2</span>E↑j</span><br><span class="line">.text:<span class="number">0099129F</span> mov     ecx, [eax+edi+<span class="number">8</span>]				<span class="comment">//即是_RTC_vardesc-&gt;name，用于报错提示</span></span><br><span class="line">.text:<span class="number">009912</span>A3 mov     edx, [ebp+<span class="number">4</span>]</span><br><span class="line">.text:<span class="number">009912</span>A6 push    ecx                             ; <span class="type">char</span> * <span class="comment">// 传入越界的数组名</span></span><br><span class="line">.text:<span class="number">009912</span>A7 push    edx                             ; <span class="type">void</span> * </span><br><span class="line">    <span class="comment">// 传入edx=EBP+4的地址，此地址正是_RTC_CheckStackVars的返回地址，用于定位</span></span><br><span class="line">.text:<span class="number">009912</span>A8 call    ?_RTC_StackFailure@@YAXPAXPBD@Z ; _RTC_StackFailure(<span class="type">void</span> *,<span class="type">char</span> <span class="type">const</span> *)</span><br><span class="line">     <span class="comment">// 调用此函数后，弹出异常MessageBox，提示哪个数组越界</span></span><br><span class="line">.text:<span class="number">009912</span>AD add     esp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">009912B</span>0</span><br><span class="line">.text:<span class="number">009912B</span>0 loc_9912B0:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+<span class="number">3</span>D↑j</span><br><span class="line">.text:<span class="number">009912B</span>0 mov     eax, [ebp+var_4]			  <span class="comment">// 存在多个数组需要检查时有用</span></span><br><span class="line">.text:<span class="number">009912B</span>3 inc     eax</span><br><span class="line">.text:<span class="number">009912B</span>4 add     edi, <span class="number">0</span>Ch					 <span class="comment">// 定位到下一个_RTC_vardesc结构</span></span><br><span class="line">.text:<span class="number">009912B</span>7 mov     [ebp+var_4], eax</span><br><span class="line">.text:<span class="number">009912B</span>A cmp     eax, [esi]</span><br><span class="line">.text:<span class="number">009912B</span>C jl      <span class="type">short</span> loc_991280</span><br><span class="line">.text:<span class="number">009912B</span>E</span><br><span class="line">    </span><br><span class="line">.text:<span class="number">009912B</span>E loc_9912BE:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+<span class="number">14</span>↑j</span><br><span class="line">.text:<span class="number">009912B</span>E pop     edi</span><br><span class="line">.text:<span class="number">009912B</span>F pop     esi</span><br><span class="line">.text:<span class="number">009912</span>C0 pop     ebx</span><br><span class="line">.text:<span class="number">009912</span>C1 mov     esp, ebp</span><br><span class="line">.text:<span class="number">009912</span>C3 pop     ebp</span><br><span class="line">.text:<span class="number">009912</span>C4 retn</span><br><span class="line">.text:<span class="number">009912</span>C4 @_RTC_CheckStackVars@<span class="number">8</span> endp</span><br></pre></td></tr></table></figure>



<h3 id="基于数组缓冲区溢出修改ip"><a href="#基于数组缓冲区溢出修改ip" class="headerlink" title="基于数组缓冲区溢出修改ip"></a>基于数组缓冲区溢出修改ip</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">				</span><br><span class="line"><span class="type">void</span> <span class="title function_">HelloWord</span><span class="params">()</span>			</span><br><span class="line">&#123;			</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);						</span><br><span class="line">&#125;			</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span>			</span><br><span class="line">&#123;			</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;				</span><br><span class="line">	arr[<span class="number">6</span>] = (<span class="type">int</span>)HelloWord;				</span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Fun();	</span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">//运行环境 devc++ x86 debug</span></span><br><span class="line"><span class="comment">//代码可以打印出&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>



<p>数组只有5个,强行写了6个</p>
<p>数值最后一个元素在[ebp-4]</p>
<p>强行写的arr[6],超出来2个</p>
<p>arr[5]已经超出来,arr[5]是ebp,ebp里面存放了原来的ebp</p>
<p>arr[6]已经超出来,arr[6]是ebp-4,ebp-4存放了push 进去的ip 现在ip被修改为了一个函数的地址</p>
<p>于是就可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     esp, 20h</span><br><span class="line">mov     dword ptr [ebp-20], 1</span><br><span class="line">mov     dword ptr [ebp-16], 2</span><br><span class="line">mov     dword ptr [ebp-12], 3</span><br><span class="line">mov     dword ptr [ebp-8], 4</span><br><span class="line">mov     dword ptr [ebp-4], 5</span><br><span class="line">mov     eax, offset __Z9HelloWordv ; HelloWord(void)</span><br><span class="line">mov     [ebp+4], eax</span><br><span class="line">leave</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>







<h3 id="缓冲区溢出修改其它变量"><a href="#缓冲区溢出修改其它变量" class="headerlink" title="缓冲区溢出修改其它变量"></a>缓冲区溢出修改其它变量</h3><p>用不休止的hello world</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//exe会	用不休止的hello world			</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span>					</span><br><span class="line">&#123;					</span><br><span class="line">	<span class="type">int</span> i;				</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;							</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)				</span><br><span class="line">	&#123;				</span><br><span class="line">		arr[i] = <span class="number">0</span>;			</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Hello World!...&quot;</span>);			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;					</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Fun();	</span><br><span class="line">&#125;		</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                push    ebp</span><br><span class="line">                mov     ebp, esp</span><br><span class="line">                sub     esp, 38h</span><br><span class="line">                mov     dword ptr [ebp-32], 0</span><br><span class="line">                mov     dword ptr [ebp-28], 0</span><br><span class="line">                mov     dword ptr [ebp-24], 0</span><br><span class="line">                mov     dword ptr [ebp-20], 0</span><br><span class="line">                mov     dword ptr [ebp-16], 0</span><br><span class="line">                mov     dword ptr [ebp-12], 0</span><br><span class="line">                jmp     short loc_40154D</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">loc_401532:                             ; CODE XREF: Fun(void)+51↓j</span><br><span class="line">                mov     eax, [ebp-12]</span><br><span class="line">                mov     dword ptr [ebp+eax*4-32], 0</span><br><span class="line">                mov     dword ptr [esp], offset Buffer ; &quot;Hello World!...&quot;</span><br><span class="line">                call    _puts</span><br><span class="line">                add     [ebp+i], 1</span><br><span class="line"></span><br><span class="line">loc_40154D:                             ; CODE XREF: Fun(void)+30↑j</span><br><span class="line">                cmp     [ebp+i], 5</span><br><span class="line">                jle     short loc_401532</span><br><span class="line">                leave</span><br><span class="line">                retn</span><br></pre></td></tr></table></figure>



<p>通过arr数组缓冲区溢出,修改了变量i,最后又再一次为0</p>
<h3 id="gets内存越界"><a href="#gets内存越界" class="headerlink" title="gets内存越界"></a>gets内存越界</h3><p>内存越界</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">    fgets( str,<span class="number">5</span>,<span class="built_in">stdin</span> );      </span><br><span class="line">    <span class="comment">//gets(str);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;result: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>( str );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %c \n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter a value :123456789</span><br><span class="line">result:</span><br><span class="line">1234</span><br><span class="line">a: x</span><br></pre></td></tr></table></figure>





<h3 id="确定哪个call是主要的call"><a href="#确定哪个call是主要的call" class="headerlink" title="确定哪个call是主要的call"></a>确定哪个call是主要的call</h3><p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr=(<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">1024</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>跟进函数calloc</p>
<p>然后calloc函数里面可能还会有很多的call</p>
<p>于是你就看哪个call对eax,或者ptr做了修改,那么那个call就可能是主要的call</p>
<h2 id="x64-2"><a href="#x64-2" class="headerlink" title="x64"></a>x64</h2><h3 id="printf-1"><a href="#printf-1" class="headerlink" title="printf"></a>printf</h3><p>参数1是rcx</p>
<p>参数2是rdx</p>
<p>参数3是r8f</p>
<p>参数4是r9d</p>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><p>1.分支&lt;&#x3D;3的时候，用switch没有意义，因为编译器会生成类似if..else之类的反汇编</p>
<h1 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h1><p>对于vs来说,修改一下项目属性</p>
<p>项目属性-&gt;链接器-&gt;高级-&gt;执行数据保护-&gt;取消</p>
<p>对于Dev来说,就不需要了,用gcc编译的字节码去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x89</span>, <span class="number">0xE5</span>, <span class="number">0x8B</span>, <span class="number">0x55</span>, <span class="number">0x08</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x0C</span>, <span class="number">0x01</span>, <span class="number">0xD0</span>, <span class="number">0x5D</span>,<span class="number">0xc3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> (*pfun)(<span class="type">int</span>, <span class="type">int</span>) = (<span class="type">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>))&amp;code;</span><br><span class="line">	<span class="type">int</span> sum =pfun(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>对于vs,可以用gcc的字节码</p>
<p>对于gcc,不要用vs的字节码</p>
<p>vs有很多自带的,特殊的字节码,所以在vs里面就不要去调用那些字节码</p>
<h1 id="PELAOD"><a href="#PELAOD" class="headerlink" title="PELAOD"></a>PELAOD</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"> </span><br><span class="line">include windows.inc</span><br><span class="line">include msvcrt.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line"> </span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"> </span><br><span class="line">.data</span><br><span class="line">IMAGE_SIZE equ 2000h  ;程序加载更改项</span><br><span class="line"> </span><br><span class="line">.const</span><br><span class="line">g_fileName db &quot;helloPe.exe&quot;,0 ;程序加载更改项</span><br><span class="line"> </span><br><span class="line">.code</span><br><span class="line">org IMAGE_SIZE - 1000h ;这里减1000是程序本身具有头文件可以不拷贝，直接利用</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">checkPE proc lpAddress:LPVOID</span><br><span class="line">     </span><br><span class="line">    mov esi,lpAddress</span><br><span class="line">    assume esi : ptr IMAGE_DOS_HEADER</span><br><span class="line">     </span><br><span class="line">    .if [esi].e_magic != &#x27;ZM&#x27;</span><br><span class="line">        mov eax,0</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">     </span><br><span class="line">    ;指向PE文件头</span><br><span class="line">    add esi,[esi].e_lfanew</span><br><span class="line">    assume esi : ptr IMAGE_NT_HEADERS</span><br><span class="line">    .if[esi].Signature !=&#x27;EP&#x27;</span><br><span class="line">        mov eax,0</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">     </span><br><span class="line">    ret</span><br><span class="line">checkPE endp</span><br><span class="line"> </span><br><span class="line">LoadPe proc uses esi ebx edi hMod:HMODULE</span><br><span class="line">    LOCAL @hFile:HANDLE</span><br><span class="line">    LOCAL @hMap:HANDLE</span><br><span class="line">    LOCAL @lpAddress:LPVOID</span><br><span class="line">    LOCAL @NumberOfSections:dword ;节区表数量</span><br><span class="line">    LOCAL @SizeOfOptional:dword ;可选头大小</span><br><span class="line">    LOCAL @AddrOfEntryPoint:dword;程序执行入口</span><br><span class="line">    LOCAL @SizeOfImage:dword;所有头部加节表大小</span><br><span class="line">    LOCAL @SizeOfHeaders:dword;头部占空间的大小</span><br><span class="line">    LOCAL @dwOld:dword</span><br><span class="line">    LOCAL @SectionAddr:dword</span><br><span class="line">    LOCAL @importAddr:dword</span><br><span class="line">    LOCAL @zeroIDD :IMAGE_DATA_DIRECTORY</span><br><span class="line">    LOCAL @DllhMod:HMODULE</span><br><span class="line">     </span><br><span class="line">    invoke RtlZeroMemory, addr @zeroIDD,sizeof IMAGE_DATA_DIRECTORY ;设置全0结构体检测地址是否为0</span><br><span class="line">     </span><br><span class="line">    ;读取文件</span><br><span class="line">    invoke CreateFile,offset g_fileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">    .if eax==INVALID_HANDLE_VALUE</span><br><span class="line">        jmp DISPOSE_ERROR</span><br><span class="line">    .endif </span><br><span class="line">    mov @hFile,eax</span><br><span class="line">     </span><br><span class="line">    ;创建内存位图</span><br><span class="line">    invoke CreateFileMapping,@hFile,NULL,PAGE_READONLY,0,0,NULL</span><br><span class="line">    .if eax==NULL</span><br><span class="line">        jmp DISPOSE_ERROR</span><br><span class="line">    .endif </span><br><span class="line">    mov @hMap,eax</span><br><span class="line">     </span><br><span class="line">    ;位图映射到进程,复制可执行文件的头部到PE装载器申请内存的首地址</span><br><span class="line">    invoke MapViewOfFile,@hMap,FILE_MAP_READ,0,0,0</span><br><span class="line">    .if eax==NULL</span><br><span class="line">        jmp DISPOSE_ERROR</span><br><span class="line">    .endif </span><br><span class="line">    mov @lpAddress,eax</span><br><span class="line">     </span><br><span class="line">    ;检查PE的头文件格式是否合法</span><br><span class="line">    invoke checkPE,@lpAddress</span><br><span class="line">    .if eax ==NULL</span><br><span class="line">        jmp DISPOSE_ERROR</span><br><span class="line">    .endif</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    mov esi,@lpAddress</span><br><span class="line">    assume esi : ptr IMAGE_DOS_HEADER</span><br><span class="line">     </span><br><span class="line">    ;需要拿到的属性filehead 的可选头大小，节区表数量，需要optionhead里AddressOfEntryPoint</span><br><span class="line">    ;SizeOfHeaders</span><br><span class="line">         </span><br><span class="line">    add esi,[esi].e_lfanew</span><br><span class="line">    assume esi : ptr IMAGE_NT_HEADERS</span><br><span class="line">         </span><br><span class="line">    movzx eax,[esi].FileHeader.NumberOfSections</span><br><span class="line">    mov @NumberOfSections,eax</span><br><span class="line">     </span><br><span class="line">    movzx eax,[esi].FileHeader.SizeOfOptionalHeader</span><br><span class="line">    mov @SizeOfOptional,eax</span><br><span class="line">     </span><br><span class="line">    mov eax,[esi].OptionalHeader.AddressOfEntryPoint ;拿到程序入口点地址</span><br><span class="line">    mov @AddrOfEntryPoint,eax</span><br><span class="line">    mov eax,[esi].OptionalHeader.SizeOfImage ;拿到头部+节区表的总长度</span><br><span class="line">    mov @SizeOfImage,eax</span><br><span class="line">    mov eax,[esi].OptionalHeader.SizeOfHeaders</span><br><span class="line">    mov @SizeOfHeaders,eax</span><br><span class="line">     </span><br><span class="line">    ;这里获取导入表的地址,等于导入信息表的下标1*结构体的大小</span><br><span class="line">    lea eax,[esi].OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT * sizeof IMAGE_DATA_DIRECTORY]</span><br><span class="line">    mov @importAddr,eax</span><br><span class="line">     </span><br><span class="line">    ;拷贝可执行文件的头部到当前文件的模块载入地址</span><br><span class="line">     </span><br><span class="line">    ;更改代码段的属性</span><br><span class="line">    invoke VirtualProtect,hMod,@SizeOfImage,PAGE_EXECUTE_READWRITE,addr @dwOld</span><br><span class="line"> </span><br><span class="line">    invoke crt_memcpy, hMod, @lpAddress,@SizeOfHeaders</span><br><span class="line">    .if eax==NULL</span><br><span class="line">        jmp DISPOSE_ERROR</span><br><span class="line">    .endif</span><br><span class="line">         </span><br><span class="line">    ;5 复制区块表的相关数据到PE装载器申请内存的相应地址,注意：记得加模块偏移</span><br><span class="line">    lea esi,[esi].OptionalHeader</span><br><span class="line">    add esi,@SizeOfOptional</span><br><span class="line">     </span><br><span class="line">    ;拿到了区块表的起始地址</span><br><span class="line">    mov @SectionAddr,esi</span><br><span class="line">     </span><br><span class="line">    ;转换esi地址为IMAGE_SECTION_HEADER结构体</span><br><span class="line">    mov esi,@SectionAddr</span><br><span class="line">    assume esi:ptr IMAGE_SECTION_HEADER</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">     </span><br><span class="line">    .while ecx&lt;@NumberOfSections</span><br><span class="line">        .if [esi].SizeOfRawData!=0 ;首先判断文件偏移是否为0，为0是未初始化的节区</span><br><span class="line">        mov eax,[esi].PointerToRawData ;文件的偏移加文件在内存中的基地址得到文件区块的起始位置</span><br><span class="line">        add eax,@lpAddress ;在文件中的偏移加文件的基地址</span><br><span class="line">         </span><br><span class="line">        mov edi,[esi].VirtualAddress;文件在内存中映射的位置</span><br><span class="line">        add edi,hMod ;在内存中的偏移加内存中的基地址</span><br><span class="line">         </span><br><span class="line">        invoke crt_memcpy ,edi,eax,[esi].SizeOfRawData</span><br><span class="line">        .if eax ==NULL</span><br><span class="line">            jmp DISPOSE_ERROR</span><br><span class="line">        .endif</span><br><span class="line">         </span><br><span class="line">        .endif </span><br><span class="line">        inc ecx</span><br><span class="line">        add esi,sizeof IMAGE_SECTION_HEADER</span><br><span class="line">    .endw</span><br><span class="line">     </span><br><span class="line">    ;加载导入表信息</span><br><span class="line">    mov esi,@importAddr</span><br><span class="line">    mov esi,dword ptr[esi]</span><br><span class="line">    add esi,hMod</span><br><span class="line">    assume esi:ptr IMAGE_IMPORT_DESCRIPTOR</span><br><span class="line">     </span><br><span class="line">    invoke crt_memcmp,esi,addr @zeroIDD,sizeof @zeroIDD</span><br><span class="line">    .while eax!=0</span><br><span class="line">        mov eax,[esi].FirstThunk</span><br><span class="line">        add eax ,hMod</span><br><span class="line">        .if dword ptr [eax] != 0 ;IAT表不为空</span><br><span class="line"> </span><br><span class="line">            mov ebx,[esi].OriginalFirstThunk</span><br><span class="line">            .if ebx == 0</span><br><span class="line">             mov ebx,[esi].FirstThunk</span><br><span class="line">            .endif</span><br><span class="line">             </span><br><span class="line">            add ebx,hMod ;不管是IAT表为空还是INT表为空，值都会保存在Ebx</span><br><span class="line">             </span><br><span class="line">            mov edi,[esi].FirstThunk</span><br><span class="line">            add edi,hMod ;edi得到iat的位置</span><br><span class="line">             </span><br><span class="line">            mov eax,[esi].Name1</span><br><span class="line">            add eax,hMod</span><br><span class="line">             </span><br><span class="line">            ;获取模块的名称</span><br><span class="line">            push ecx</span><br><span class="line">            invoke LoadLibrary,eax</span><br><span class="line">            pop ecx</span><br><span class="line">            mov @DllhMod,eax</span><br><span class="line">             </span><br><span class="line">            mov ecx,0</span><br><span class="line">            .while dword ptr[ebx+ecx*4] !=0</span><br><span class="line">                mov eax,[ebx+ecx*4]</span><br><span class="line">                .if eax&amp;80000000h</span><br><span class="line">                    ;序号导入</span><br><span class="line">                    and eax,0ffffh ;拿到了低4位的值</span><br><span class="line">                 </span><br><span class="line">                .else</span><br><span class="line">                    ;名称导入</span><br><span class="line">                    add eax,hMod</span><br><span class="line">                    assume eax:ptr IMAGE_IMPORT_BY_NAME</span><br><span class="line">                    lea eax,[eax].Name1</span><br><span class="line">                .endif         </span><br><span class="line">                    ;此时eax保存了序号或者函数名</span><br><span class="line">                    push ecx</span><br><span class="line">                    invoke GetProcAddress, @DllhMod,eax</span><br><span class="line">                    pop ecx</span><br><span class="line">                    mov [edi+ecx*4],eax</span><br><span class="line">                    inc ecx</span><br><span class="line">            .endw</span><br><span class="line">             </span><br><span class="line">        .endif</span><br><span class="line">         </span><br><span class="line">        add esi,sizeof IMAGE_IMPORT_DESCRIPTOR</span><br><span class="line">        invoke crt_memcmp,esi,addr @zeroIDD,sizeof @zeroIDD</span><br><span class="line">    .endw</span><br><span class="line">     </span><br><span class="line">    ;跳转到程序入口点</span><br><span class="line">    mov eax,hMod</span><br><span class="line">    add @AddrOfEntryPoint,eax</span><br><span class="line">    call @AddrOfEntryPoint</span><br><span class="line">     </span><br><span class="line">DISPOSE_ERROR:</span><br><span class="line"> </span><br><span class="line">    .if @lpAddress !=NULL</span><br><span class="line">        invoke UnmapViewOfFile,@lpAddress</span><br><span class="line">    .endif</span><br><span class="line">     </span><br><span class="line">    .if @hMap!=NULL</span><br><span class="line">        invoke CloseHandle,@hMap</span><br><span class="line">    .endif</span><br><span class="line"> </span><br><span class="line">    .if @hFile!=INVALID_HANDLE_VALUE</span><br><span class="line">        invoke CloseHandle,@hFile</span><br><span class="line">    .endif</span><br><span class="line">    ret</span><br><span class="line">LoadPe endp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">START:</span><br><span class="line">    ;获取程序载入模块的确切地址</span><br><span class="line">    invoke GetModuleHandle,NULL</span><br><span class="line">    invoke LoadPe,eax</span><br><span class="line">    invoke ExitProcess,0</span><br><span class="line">end START</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
